<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>6 Months Internship at Microsoft</title>
    <url>/post/2021-12-13-Diaries/%E5%9C%A8%E5%B8%82%E5%80%BC%E7%AC%AC%E4%B8%80%E7%9A%84%E7%A7%91%E6%8A%80%E5%B7%A8%E5%A4%B4%E5%AE%9E%E4%B9%A0%E7%9A%84%E5%85%AD%E4%B8%AA%E6%9C%88/</url>
    <content><![CDATA[<h2 id="缘起">缘起</h2>
<p>到现在我仍然会觉得这次实习的机会有些梦幻，不知是幸运女神眷顾着我，还是用我在桌游中牺牲的运气换来的(?)。</p>
<h3 id="0-种子-🪴">0. 种子 🪴</h3>
<blockquote>
<p>别误会这个标题哈</p>
</blockquote>
<p>从大一暑假（2019.7）开始，就在学校的实验时里做一些教学事务相关的系统，当时唯一接触的也就是基于 PHP 的框架 Laravel。</p>
<p>由于并没有做到前后端分离，所以整个项目的目录结构会有些混乱，而每个人的开发工作只能说是更加混乱了。小组一共算四个人，无论是后端的接口，数据库，还是前端的页面，再到部署到服务器上，配置 Nginx，几乎每个人都需要会。</p>
<p>而我所谓的「种子」也就是在那时埋下的。对于当时的我来讲，唯有写网页布局的时候最有成就感（虽然当时用的是 Bootstrap），其他调试接口，设计数据库，部署服务器的过程都显得痛苦而繁琐。</p>
<p>不过抛开这个项目，大一大二的我并没有深入后端和前端，所有的开发技能仅局限于开发使用到的东西，对于后端就是使用 PHP 实现 MySQL 的增删改查，对于前端就是用 BootStrap 把页面画出来，把数据放上去。</p>
<h3 id="1-建站">1. 建站</h3>
<p>时间快进到 2020 年，当时由于疫情影响，返校从二月份延迟到了五月份，那学期也一直保持着线上上课的状态。</p>
<blockquote>
<p>众所周知，网课就是摸鱼的圣地，听课与否并不重要，分数都是靠自学和刷题而已。</p>
</blockquote>
<p>自五月份返校后，和女朋友保持着高强度12小时以上的图书馆自习时间📖，这就给了当时的我几乎无限的自学时间，该学什么呢？很可惜，当时的我并没有意识到那已经是一个应该做出职业规划的时候了，可怜的我为了更高的 GPA 将许多时间「浪费」在了本科课程上。</p>
<p>值得庆幸的是，由于网课带来了过剩的空余时间，我在当时做的两件事在无形之中帮助了未来的自己。一是搭建自己的个人博客，二是刷 Leetcode。</p>
<p>可能我本质上是一个追求花里胡哨的人，也是一个喜欢疯狂安利自己喜欢的东西的人，所以在当时那段时间里，我第一次真正意义上接触到「博客」。在那之前，我印象中博客应该是一种已经被时代所淘汰的东西，就和「网上冲浪」，「MM还是GG」，「偷菜抢车位」这种热词一样。无非只是在过去的一段时间内火了一把，接着很快就被浇灭了热度，被技术的更迭所淘汰。而所谓的 CSDN 博客，也只是一个略胜过百度知道的知识引擎罢了。</p>
<p>有趣的是，在使用了「Clash」进行上网之后，通过 Google 我发现了现在还有不少优质的个人博客👤，他们产出的博文质量比 CSDN 高到不知道哪里去了。在某个博客的 Footer 处，我看到了有种技术叫做 Wordpress。我自己尝试着用了一下，才发现建立一个网站可以这么快捷！而且网上都有现成的样式和模版可供使用，比平日里见到的那些破网站好看多了。就像是第一次输出 <code>Hello world</code> 一样的兴奋感席卷我的大脑 🧠。</p>
<p>随着逐步深入，我发现另一款基于 PHP 的 Typecho 框架看起来更加新颖，有着更多好看的主题（这个应该是当时的痛点）。于是乎，我利用 Typecho 第一次搭建了个人博客，并且开始记录一些东西。</p>
<p>尽管 Typecho 在当时已经很好用了，但是我仍然存在了一些痛点没有被解决。</p>
<ol>
<li>Typecho 自带 Web 端后台管理系统，毕竟是一套全栈的框架，有着数据库的支撑。但是框架自带的 markdown 编辑器实在难以接受，导致我都是在本地 Typora 编辑好之后复制到网页端上点击保存。属于是非常不优雅了。</li>
<li>PHP 作者都不想维护这门语言了，更何况是基于 PHP 开发的 Typecho 和基于 Typecho 的一些主题作者呢。社区生态可以说是非常不完善了。</li>
</ol>
<blockquote>
<p>当时搬家的时候我也简单阐述了原因：<a href="https://blog.ethanloo.cn/post/2020-10-14-Diaries/%E5%8D%9A%E5%AE%A2%E6%90%AC%E5%AE%B6%E6%97%A5%E8%AE%B0/">Typecho-&gt;Hexo搬家日记 | Ethanloo’s</a></p>
</blockquote>
<p>在使用 Hexo 之后，我又花了许多时间折腾主题之类的，让自己的博客表面上「花里胡哨」。从 2020 年 6 月份建站，到 2020 年 11 月搬家完毕，抛开表面，博客内容并没有变得更加「优质」。</p>
<p>但是搭建博客的过程对我而言，就像是哥伦布的一次远航🚣‍♀️，收获可能不大，然而意义非凡。</p>
<h3 id="2-刷题">2. 刷题</h3>
<p>2020 年 9 月，当时是大三上学期开学，事实上应该是我最忙的一个学年，毕竟学分多，竞赛多，是决定保研成功与否的关键一年。一想到自己再过一个学期就要开始面试暑期实习了，我仿佛又能看到了各种大厂 Offer 正在向我招手🙋‍♂️。</p>
<p>面对 GPA，竞赛和 Offer，我选择「<strong>全都要</strong>」。在当时初步了解了一下各大厂笔试面试的内容，发现有一个公共的也是最基础的要求：「算法与数据结构」。</p>
<p>于是，Leetcode，我来了！</p>
<p>我又回到了自己大一上学期为了 Python 期末考试而每天刷题的状态。</p>
<p><img src="https://cdn.ethanloo.cn/img/202112161041536.png" alt="image-20211216103810094"></p>
<p><img src="https://cdn.ethanloo.cn/img/202112161038796.png" alt="image-20211216103829756"></p>
<blockquote>
<p>其中特别绿的日子，一般都是面试的前两天 🤣</p>
</blockquote>
<p>对我而言，刷题并不是一个非常痛苦的事情，因为我个人并不喜欢死磕难题，我关注更多的是中等题和简单题，而 pass 的成就感也能洗去做不出题的挫败感。在将刷题培养成习惯之后，每日一题显得更加轻松愉快（困难题除外）。</p>
<p>为了杜绝看题解后不动脑子的写代码行为，我也尝试将每日一题的思路和代码记录📝到了我的博客里，这所有的一切都是自己真真切切努力过的痕迹。</p>
<img src="https://cdn.ethanloo.cn/img/202112161048944.png" alt="image-20211216104845918" style="zoom:33%;" />
<h3 id="3-入门">3. 入门</h3>
<p>真正要提到入门前端，已经是 2020 年底的时候了，即使当时是期末考试时期，我仍然选择了充分利用时间去学习前端的各项技术栈。</p>
<blockquote>
<p><a href="https://blog.ethanloo.cn/post/2020-12-21-Weber/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%94%9F%E6%B4%BB/">从零开始的前端工程师生活 | Ethanloo’s</a>，2020.12.21 写了篇小小博文阐述了自己选择前端的理由，也算是立下了一个 Flag（正向的）。</p>
</blockquote>
<p>感谢当时的自己，每天都在幸苦地强迫着知识进入脑袋 🧠。</p>
<h2 id="敲门">敲门</h2>
<p>OK，花了几个月刷了题，学习了基础的 HTML + CSS + JavaScript，终于是到了要接受挑战的时候了。</p>
<h3 id="引路人">引路人</h3>
<p>在 2021 年的寒假，大概也就一二月，在学校的就业群里，有一个 15 届的学长转发了苏州微软的暑期实习推文，并说有意参加的同学准备好简历找他内推。印象里似乎他是最早开始发的，并且在这之后群里开始陆陆续续的有各个在中大厂就业的学长学姐们开始内推暑期实习。</p>
<p>当时的我是相当紧张的，毕竟自己只能算学了基础而已，简历上也只有可怜的一两个项目经历，甚至还是 PHP 写的。</p>
<p>但是我还是决定投一下试试，出于对自己英语能力的自信，「万一就过了呢」，你说是吧？</p>
<p>在跟学长简单沟通之后，他告诉我「正好」他们组就是做前端的，「正好」他们现在非常缺人，所以我就「正好」被定向内推到了他们组。</p>
<blockquote>
<p>如果不是内推我的 Johnny 学长，那之后面试我的大概率就不是前端组，那按我的算法水平估计多半凉了。</p>
</blockquote>
<h3 id="咚咚咚">咚咚咚</h3>
<p>在一月份成功投递完简历之后，根据微软推文上的日程安排，大概是在三月中旬之后逐步开始笔试和面试。</p>
<p>然而一开学（2/20+）我就收到了笔试邀请！给我吓飞了都快，原本的我准备开学之后巩固巩固算法和 JavaScript 基础，结果一上来就是王炸💥。</p>
<p>不过笔试和面试的过程甚是幸运，虽然一面大概是挂了（怪我基础太薄弱了），但是微软暑期实习给二面平行面的机会，通过之后三面的面试官也没过多为难我。</p>
<blockquote>
<p><a href="https://blog.ethanloo.cn/post/2021-02-28-Weber/%E5%BE%AE%E8%BD%AF%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/">微软暑期实习面筋 | Ethanloo’s</a>，暑期实习面了四家，过了两家，其中没过的两家的面试体验可以说是非常糟糕了。</p>
</blockquote>
<p>终面完的后一天，学长告诉我面试通过了，安心等待 offer 即可。</p>
<p>太 COOOOOOOOOOOL 了！！！</p>
<p>在一系列入职前的手续和第一次租房完成后，终于在 6.15 那天进入了微软的大门。</p>
<h2 id="Work-Life-Balance">Work Life Balance</h2>
<h3 id="Work">Work</h3>
<blockquote>
<p>不太清楚我可以通过怎样的方式来描述我的工作内容，保险起见跳过部分内容。</p>
</blockquote>
<img src="https://cdn.ethanloo.cn/img/202112181007514.jpg" alt="2021-06-18 04.14.22 1_11zon" style="height: 400px" />
<p>入职当天只有临时门卡，图片里的这个是在入职一周之后申请拿到的正式门卡。</p>
<p>关于我的工位嘛，实习了六个月，我总共呆过两个地方，可以说苏州微软的工位是非常紧缺了，都在盼着那两栋新的大楼赶快造好吧。</p>
<img src="https://cdn.ethanloo.cn/img/202112181012418.jpg" alt="IMG_20210615_180719_11zon" style="height: 400px" />
<p>第一个工位，是跟许多实习生一块儿，坐在一楼的 trainning room 里，原本应该是一间用来培训的大 room。虽说房间大，人多，单显示器，但是 32GB 的内存，10900K 的 U 以及眼前的落地窗还是给我带来了不错的体验。</p>
<p>在这个工位呆了大概三个月，到九月份的时候，有管理人员说这边马上要装修，让仅剩的四个实习生（这个时间点大部分实习生已经离职了）搬到楼上去。</p>
<img src="https://cdn.ethanloo.cn/img/202112181020998.jpg" alt="IMG_20211210_154026_11zon" style="height: 400px" />
<p>第二个工位显得就正式多了，虽然仍然不是正式员工的工位，只是在一个 focus room 里，原本是用来给电话或者面试的私人空间。拥有了两个显示器和更加舒服的凳子之后，工作体验也更上了一层楼，不过偶尔会可惜失去落地窗之后眼前的景色的单调乏味。</p>
<p>工作日程也非常的纯粹，每周大概两三次 sync up meetings 用来讨论进度，若干小时的开发和 debug 时间，若干次跟他人单独的 call 用来咨询或者被咨询。对于包括我室友在内的许多实习生，任务不多，基本没有 ddl，可以说是没什么压力了。</p>
<p>虽然这么说，但是我确实也做了不少东西。和某司 leader 描述的「去微软学不到东西」不同，单纯就前端而言，MS 的技术栈更新迭代相当之快。</p>
<p>我们组负责的项目花了将近一年的时间从主流的 React 迁移到了 Web Component，只为了那么几十毫秒的性能优化能给用户带来更好的使用体验。 之所以花了一年倒也不是重构的难度有多大，而是微软的项目 DAU 之高导致不敢将一次性地将 Web Component 架构的产品部署到线上，而需要经过将近一年的 hybrid 模式和相当一段时间的实验，在保证了不会有事故发生的情况下，才完全上线。</p>
<p>进入微软之后，也算是我第一次正式规范化协作开发流程，和之前相比学校的项目开发模式简直就是讲笑话。</p>
<p>大学前三年的开发几乎都是，把代码仓库放到 gitlab 上，修改代码之前 pull 一下 master 分支，改完代码本地调通之后，push 上去，偶尔还需要跟别人讲一下自己改了啥，反正整个仓库最多只有三个人会改动代码。要部署的时候就用 ssh 远程连接一下 linux 的服务器，cd 到对应文件夹，pull 一下代码，检查一下线上网站有没有问题。</p>
<blockquote>
<p>明眼人，或者说当时的我就已经感觉到这种流程是相当不优雅的，但是出于懒惰以及图省力的目的，我并没有选择纠正</p>
</blockquote>
<p>在微软实习的项目无论是从代码规模还是使用人数上都是远超学校事务类的系统，全球上百个程序员同时进行开发，我也有幸能在仓库中留下了不少自己的代码。</p>
<p>但仅仅是为了提交这些代码，就需要花费不少的功夫。</p>
<ol>
<li>首先就是学习 Web Component 技术栈，针对当前开发的 feature 写一个 spec，说明 feature 解决的问题，面向的用户，主要需求。</li>
<li>然后本地从 master 新建分支开发，开发完之后，将代码提交到当前分支，并且 pulish 该分支。</li>
<li>提出 Pull Request，在 PR 中说明该项代码更改的作用，每一个 PR 都会自动跑一遍 pipeline，build 一个用于测试的版本，生成对应的 test link。</li>
<li>每一个 build 都会进行至少一次的 unit test, integration test, visual parity tests。只有测试全部通过的 build，才会被允许 complete。</li>
<li>找到其他 dev 帮助进行 code review，在 PR 底下 comment 一些需要改进的地方。部分文件的代码更改会 trigger 对应的 review 的逻辑，将特定的人加入到 reviewer 中。</li>
<li>逐个解决 comments，并且将更改的代码 push 当前分支，重新生成 test link，检查当前的版本是否还有相应问题。</li>
<li>解决完 comments 之后，需要等其他 dev 给当前提出的 PR 至少两个 sign off 后才可 complete 当前 PR，所有代码会自动创建一个 merge request 进入到 master 分支。</li>
</ol>
<p>从 6.15 入职到 12.10 号离职，我提出了大概 16 个 PR，其中有 13 个合了进去，剩余 3 个交接给了同事后续进行完成。</p>
<p>虽然实习只有六个月，但我自己前后总共参与过四个项目，开发了四个 feature，虽然这四个 feature 里只有一个真正上线了，但是每个 feature 都让我学到了好多好多东西。</p>
<p><img src="https://cdn.ethanloo.cn/img/202112181405251.png" alt="image-20211218140544206"></p>
<p>唯一上线的这个就是这么一个简单的 carousel，可惜的是因为是我离职前做的 feature，没办法在下次面试的时候给面试官吹嘘自己的数据了。</p>
<p>还有一个 feature 是一个类似小彩蛋的东西，从 2021 年开始每年的圣诞月🎄大家都可以在 Edge 的新标签页上看到这个啦！</p>
<p><img src="https://cdn.ethanloo.cn/img/202112181412265.png" alt="image-20211218141238217"></p>
<p>身边的同事，我的 mentor 和 leader，都完全符合了我之前对外企程序员的期望，大家都相当善良并且给人一种相处很舒服的感觉。虽然我比较喜欢一个人吃饭，因为是每天的快乐玩手机时间（其他时间摸鱼总是没那么光明正大），但是也会和同事快乐约饭，完全不会有那种强制社交的感觉。</p>
<p>实习后半段和美国 team 的合作的过程也相当愉快，无论是美国人，中国人还是印度人，他们都真的很会鼓励人，是那种无数 great, good job, well done 的好听的 🌈 屁。</p>
<blockquote>
<p>交流的时候偶尔会觉得自己不太客气，一方面是英文词汇量不行，一方面自己还不太习惯跟不熟悉的人放 🌈 p。</p>
</blockquote>
<h3 id="Life">Life!!!</h3>
<p>终于到了分享快乐生活的时候了。</p>
<p>从食堂讲起，苏州微软的食堂被很多同事所诟病，光看价钱确实略显夸张，素菜3.5，小荤5.5，大荤10/15，有时吃一顿中饭会有物价水平直逼美利坚的错觉。</p>
<p>在这里随便贴几张几顿午餐的照片，其实味道和份量都是还可以的，样式也不少，但是食堂吃多了终究会腻。</p>
<div style="display: flex; overflow: hidden; width: 100%;">
	<img src="https://cdn.ethanloo.cn/img/202112182026764.jpg" alt="IMG_20210805_173125" style="object-fit: cover; zoom: 30%;" />
  <img src="https://cdn.ethanloo.cn/img/202112182037337.jpg" alt="IMG_20210830_082803" style="object-fit: cover; zoom: 30%;"/>
  <img src="https://cdn.ethanloo.cn/img/202112182026773.jpg" alt="IMG_20211210_153451"  style="object-fit: cover; zoom: 30%;"/>
</div>
微软也提供无限量的免费饮料和零食，每周三也有小蛋糕（暑假是雪糕，中秋是月饼）。
<div style="display: flex; overflow: hidden; height: 300px;">
	<img src="https://cdn.ethanloo.cn/img/202112182034653.jpg" alt="IMG_20210805_173125" style="object-fit: cover; zoom: 25%;" />
  <img src="https://cdn.ethanloo.cn/img/202112182034662.jpg" alt="IMG_20210830_082803" style="object-fit: cover; zoom: 25%;"/>
  <img src="https://cdn.ethanloo.cn/img/202112182034661.jpg" alt="IMG_20211210_153451"  style="object-fit: cover; zoom: 25%;"/>
    <img src="https://cdn.ethanloo.cn/img/202112182034663.jpg" alt="IMG_20211210_153451"  style="object-fit: cover; zoom: 25%;"/>
</div>
> 突然发现自己忘记拍冰箱和不需要支付的售货机了，总之就是非常的后悔。
<p>每个月还有一次 team 内部的 happy hour，虽然是自费的，但是大家竟然可以在工作时间玩桌游，吃零食！</p>
<img src="https://cdn.ethanloo.cn/img/202112182038594.jpg" alt="IMG_20210621_160629" style="zoom:50%;" />
<p>当然啦，微软也有不少的娱乐设施，包括桌面足球，台球，XBOX，我也给自己的个人账户兑换了一个年费的 Xbox Game Pass，偶尔会在摸鱼的时候开两把车。</p>
<div style="display: flex; overflow: hidden; height: 300px;">
	<img src="https://cdn.ethanloo.cn/img/202112182042351.jpg" alt="IMG_20210805_173125" style="object-fit: cover; zoom: 25%;" />
  <img src="https://cdn.ethanloo.cn/img/202112182042353.jpg" alt="IMG_20210830_082803" style="object-fit: cover; zoom: 25%;"/>
  <img src="https://cdn.ethanloo.cn/img/202112182042359.jpg" alt="IMG_20211210_153451"  style="object-fit: cover; zoom: 25%;"/>
    <img src="https://cdn.ethanloo.cn/img/202112182042358.jpg" alt="IMG_20211210_153451"  style="object-fit: cover; zoom: 25%;"/>
</div>
为了每天能心安理得的吃夜宵，下班前的健身也是必不可少的！
<img src="https://cdn.ethanloo.cn/img/202112182044381.jpg" alt="IMG_20210624_174227" style="height: 400px;" />
<p>在12.10离职前，和大家吃的最后一顿午餐，被迫坐在 C 位。</p>
<img src="https://cdn.ethanloo.cn/img/202112182051380.jpeg" alt="WechatIMG17" style="zoom:50%;" />
<h2 id="Ending">Ending</h2>
<p>时间过得真是快呀，没想到六个月实习这么快就结束了。不管是学习到的知识，还是认识到的小伙伴，工作和生活，这段经历都太棒了！</p>
<p>「First enjoy your life, then work for fun. 🤩」</p>
<p><img src="https://cdn.ethanloo.cn/img/202112182110059.png" alt="cover"></p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title>前端开发的十万个为什么（二）</title>
    <url>/post/2023-11-26-Weber/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="Rollup-Vite-Webpack-有什么联系和区别？">Rollup, Vite, Webpack 有什么联系和区别？</h2>
<ul>
<li>三者分别都是前端项目的打包和构建工具。</li>
<li>Rollup 用于构建 JavaScript 库，目标是尽可能小和快地构建，提倡使用 ESM 进行模块化开发，热门项目主要是通用性框架：React，Vue，Vuex 和 Vue-Router。</li>
<li>Webpack 通常用于复杂项目的打包，有更强的代码拆分能力，热门项目主要是组件库：Element-Plus，Mint-UI。</li>
<li>Vite 是现代化的开发服务器，特点在于开发模式下不用打包操作，提供极快的模块热更新和启动速度，生产模式的打包过程基于 rollup 实现。</li>
</ul>
<blockquote>
<p><a href="https://juejin.cn/post/7054752322269741064?searchId=20231126160834219A7F127C0B342D8F7C">rollup打包产物解析及原理（对比webpack） - 掘金 (juejin.cn)</a></p>
</blockquote>
<p>在打包的过程中，Webpack 和 Rollup 的具体差异体现在：</p>
<ol>
<li>Webpack 为了更好地兼容性注入的代码比较多，Rollup 比较干净。</li>
<li>Rollup 诞生于 ESM 标准出来后，原生不支持 CJS，所以可以做到更精准地打包。</li>
<li>Webpack 诞生地更早，所以社区开发地插件更加完善。</li>
</ol>
<h2 id="Vue-3-使用-Proxy-替换-Object-defineProperty-的好处？">Vue 3 使用 Proxy 替换 Object.defineProperty() 的好处？</h2>
<ol>
<li><code>Object.defineProperty()</code> 不能直接监听数组长度的变化和对象属性的新增或删除，Vue 2 额外提供了 <code>Vue.set</code> 和 <code>Vue.delete</code> 方法来触发这种情况下的视图的更新。而 <code>Proxy</code> 原生就可以支持，不需要额外的兼容。</li>
<li><code>Proxy</code> 可以直接拦截 <code>Map</code>, <code>Set</code> 等集合的操作，<code>Object.defineProperty</code> 则不行。</li>
<li>与 <code>Object.defineProperty()</code> 需要递归遍历对象的每个属性不同，<code>Proxy</code> 可以懒观察属性，只有在属性被访问时才将其转换为响应式。这大大减少了初始化响应式数据的时间。</li>
</ol>
<h2 id="Vue-和-React-的-Diff-算法有什么联系和区别？">Vue 和 React 的 Diff 算法有什么联系和区别？</h2>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/149972619">聊一聊Diff算法（React、Vue2.x、Vue3.x） - 知乎 (zhihu.com)</a></p>
</blockquote>
<p>最朴实的 <code>diff</code> 是 N 个节点去对比 N 个节点，复杂度是 <code>O(N^2)</code>。<br>
基于两个基本原则对 <code>diff</code> 过程进行优化：</p>
<ol>
<li>节点几乎不会跨层级移动</li>
<li>同一层级的子节点有 <code>id</code> 作为唯一标识符。</li>
</ol>
<h3 id="React-的-diff-优化">React 的 diff 优化</h3>
<ol>
<li>Tree Diff（整棵树）：只对同层级的虚拟 DOM 进行对比，跨层级的操作会删除原节点，创建新节点。</li>
<li>Component Diff（两个组件，例如 <code>&lt;MyComp /&gt;</code>）：类型相同时，优先对比 Virtual DOM 树，其次根据 <code>shouldComponentUpdate</code> 来判断。</li>
<li>Element Diff（同层级的两个节点，例如 <code>div</code>）：</li>
</ol>
<ul>
<li>通过 <code>key</code> 来遍历新旧集合，判断是否需要创建和删除</li>
<li>只在 <code>newIndex &lt; oldIndex</code> 的时候才会进行移动。</li>
</ul>
<blockquote>
<p>为什么 element diff 的时候只能前移？<br>
避免不同节点的前移和后移抵消；</p>
</blockquote>
<h3 id="Vue-2-的双端对比">Vue 2 的双端对比</h3>
<ol>
<li>初始化指针：设置 4 个指针，指向旧节点和新节点 list 的首尾。</li>
<li>循环比较：</li>
</ol>
<ul>
<li><strong>首尾比较</strong>：先比较两个 <strong>首节点</strong>，然后比较两个 <strong>尾节点</strong>。如果节点相同（<code>key</code> 相同），就直接更新节点，并移动指针。</li>
<li><strong>交叉比较</strong>：如果首尾没有找到相同节点，就进行交叉比较，比较旧列表的 <strong>首节点</strong> 和新列表的 <strong>尾节点</strong>，以及旧列表的 <strong>尾节点</strong> 和新列表的 <strong>首节点</strong>。如果相同，移动并更新节点，移动指针。</li>
<li><strong>创建新节点</strong>：如果上述都没有找到相同的节点，就在旧列表中找和新列表首节点相同的节点。如果找到了，就移动对应节点。否则就创建新的 DOM。</li>
<li>更新完节点之后，移动指针，进入下一轮。</li>
</ul>
<ol start="3">
<li>添加剩余节点：如果新列表的指针没有走完，说明后剩下的都是新增的节点。</li>
<li>移除多余节点：如果旧列表的指针还没有走完，说明多余的都是待删除的多余节点。</li>
</ol>
<h3 id="Vue-3">Vue 3</h3>
<p>Vue 3 中针对标注了 <code>key</code> 的元素，还是保留了旧版的双端对比操作。<br>
除此之外，还新增了许多额外的优化：</p>
<ol>
<li>在编译阶段标注 <code>hoist</code> 静态节点，并且将多个静态节点用 <code>innerHTML</code> 的方式进行 <code>render</code>，以此减少不必要的对比和重渲染。</li>
<li>引入 <code>Fragment</code> 和 <code>Block</code> 的概念，允许单个组件拥有多个根节点，追踪动态的节点。</li>
<li>编译过程中，对节点的类型进行标注，利用位运算标注 <code>PatchFlag</code>，限制 <code>diff</code> 过程中判断是否更新的操作。</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>面向 Vue 中 VNode 的一次 Deep Dive</title>
    <url>/post/2023-11-22-Vue/%E9%9D%A2%E5%90%91%20Vue%20%E4%B8%AD%20VNode%20%E7%9A%84%E4%B8%80%E6%AC%A1%20Deep%20Dive/</url>
    <content><![CDATA[<blockquote>
<p>从 Vue 源码出发，探索 Vue 内部针对虚拟 DOM 的各种优化操作</p>
</blockquote>
<h2 id="Vue-针对虚拟-DOM-做了什么特殊优化？">Vue 针对虚拟 DOM 做了什么特殊优化？</h2>
<blockquote>
<p><a href="https://cn.vuejs.org/guide/extras/rendering-mechanism.html">渲染机制 | Vue.js (vuejs.org)</a><br>
<a href="https://funfish.github.io/blog-sys/post/Vue3%20%E7%9A%84hoist%E4%B8%8Ediff/">Vue3 的hoist与diff (funfish.github.io)</a></p>
</blockquote>
<p>针对虚拟 DOM 而言，Vue 的优化重点放在了同时控制 <strong>编译 compile</strong> 和 <strong>运行时 runtime</strong>，通过两者的紧密耦合（互相可预见）来实现的 <strong>带编译信息的虚拟 DOM</strong>。</p>
<h2 id="静态节点提升（Static-Node-Hoisting）">静态节点提升（Static Node Hoisting）</h2>
<p>针对完全静态的元素，因为没有重新渲染或 diff 的必要，所以 Vue 会自动提升这部分的 <code>vnode</code> 创建函数到模版的渲染函数之外。<br>
在足够多连续的静态元素时，会被压缩为一个静态 vnode（字符串形式），直接通过 <code>innerHTML</code> 来挂载。</p>
<h3 id="源码分析">源码分析</h3>
<blockquote>
<p>尤大 19 年的 commit: <a href="https://github.com/vuejs/core/commit/095f5edf8dad8a44adaba6d1d1556168e8eec108">feat(compiler): hoist static trees · vuejs/core@095f5ed (github.com)</a></p>
</blockquote>
<p>编译过程：从 <code>compile-core</code> 文件夹中编写的 <code>createRoot(), genFunctionPreamble()</code> 等函数可以发现，Vue 在编译过程中会在根结点（Root Node）中维护一个 <code>hoists</code> 属性，存放静态的节点。<br>
<code>compiler.compile(..., &#123;hoistStatic: true&#125;)</code> 函数中的 <code>hoistStatic</code> 就决定了是否要在编译（模版=&gt;实际的渲染函数）当前节点的过程中启用静态节点提升。</p>
<p>针对启用了 <code>hoistStatic</code> 的组件，会在编译过程中利用 <code>walk</code> 函数遍历并标记静态节点。判定静态节点的逻辑较为复杂，其遵循的主要逻辑包括：</p>
<ol>
<li>根结点不会被 hoist，考虑到可能的 props 透传。</li>
<li>对于普通的 Element 结点，需要其本身和所有子节点没有 <code>key, ref, 绑定的 props, 指令</code> 等，才<strong>有可能</strong>上升为 static。</li>
<li>判断子节点的过程中，使用哈希表 <code>constantCache</code> 来缓存判断的结果。</li>
<li>针对没有被 hoist 的节点，其 props 在非动态变更的情况下，可以被 <code>hoist</code>。</li>
<li>单独的文本节点，可以被 <code>hoist</code>。</li>
</ol>
<p>当节点满足可 hoist，并且连续拥有至少20个静态节点或5个有 props 的节点，就会通过字符串化来存储和 <code>innerHTML</code> 来渲染节点。参考 <code>compiler-dom/src/transforms/stringifyStatic.ts</code>。<br>
虽然利用 <code>innerHTML</code> 来存储和渲染静态节点可以有效减少 Virtual DOM 的数量，但是判断和生成字符串需要遍历两次节点树，所以编译过程会更加耗费时间。</p>
<p>以这个组件为例： ^3ed9c1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; t &#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;a href=&quot;1&quot; /&gt;</span><br><span class="line">        &lt;a href=&quot;1&quot; /&gt;</span><br><span class="line">        &lt;a href=&quot;1&quot; /&gt;</span><br><span class="line">        &lt;a href=&quot;1&quot; /&gt;</span><br><span class="line">        &lt;a href=&quot;1&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">const t = 1;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编译后的渲染函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> _hoisted_1 = <span class="comment">/* @__PURE__ */</span> <span class="title function_">_createElementVNode</span>(</span><br><span class="line">  <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  <span class="literal">null</span>,</span><br><span class="line">  <span class="string">&quot;1&quot;</span>,</span><br><span class="line">  -<span class="number">1</span></span><br><span class="line">  <span class="comment">/* HOISTED */</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> _hoisted_2 = <span class="comment">/* @__PURE__ */</span> <span class="title function_">_createStaticVNode</span>(<span class="string">&#x27;&lt;div&gt;&lt;a href=&quot;1&quot;&gt;&lt;/a&gt;&lt;a href=&quot;1&quot;&gt;&lt;/a&gt;&lt;a href=&quot;1&quot;&gt;&lt;/a&gt;&lt;a href=&quot;1&quot;&gt;&lt;/a&gt;&lt;a href=&quot;1&quot;&gt;&lt;/a&gt;&lt;/div&gt;&#x27;</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_sfc_render</span>(<span class="params">_ctx, _cache, $props, $setup, $data, $options</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">_openBlock</span>(), <span class="title function_">_createElementBlock</span>(</span><br><span class="line">    _Fragment,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    [</span><br><span class="line">      _hoisted_1,</span><br><span class="line">      <span class="title function_">_createElementVNode</span>(<span class="string">&quot;div&quot;</span>, <span class="literal">null</span>, <span class="title function_">_toDisplayString</span>($setup.<span class="property">t</span>)),</span><br><span class="line">      _hoisted_2</span><br><span class="line">    ],</span><br><span class="line">    <span class="number">64</span></span><br><span class="line">    <span class="comment">/* STABLE_FRAGMENT */</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="更新类型标记（Patch-Flag）">更新类型标记（Patch Flag）</h2>
<p>在编译的过程中，会有一些标记信息（Patch Flag）存放在渲染函数中，其中 Patch 在 Vue 中的含义就是更新，同义词是 diffing。</p>
<p>假设当前的节点模版长这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div :class=&quot;&#123; active &#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div :class=&quot;&#123; active &#125;&quot; :age=&#123;dynamic&#125;&gt;&#123;&#123;dynamic&#125;&#125;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>通过 <a href="https://template-explorer.vuejs.org/#eyJzcmMiOiI8ZGl2IDpjbGFzcz1cInsgYWN0aXZlIH1cIj48L2Rpdj5cbjxkaXYgOmNsYXNzPVwieyBhY3RpdmUgfVwiIDphZ2U9e2R5bmFtaWN9Pnt7ZHluYW1pY319PC9kaXY+Iiwic3NyIjpmYWxzZSwib3B0aW9ucyI6eyJob2lzdFN0YXRpYyI6dHJ1ZX19">Vue Template Explorer (vuejs.org)</a> 查看编译后的渲染函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">createElementVNode</span>(<span class="string">&quot;div&quot;</span>, &#123; <span class="attr">class</span>: <span class="title function_">_normalizeClass</span>(&#123; <span class="attr">active</span>: _ctx.<span class="property">active</span> &#125;) &#125;, <span class="literal">null</span>, <span class="number">2</span> <span class="comment">/* CLASS */</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">_createElementBlock</span>(<span class="string">&quot;div&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">class</span>: <span class="title function_">_normalizeClass</span>(&#123; <span class="attr">active</span>: _ctx.<span class="property">active</span> &#125;),</span><br><span class="line">    <span class="attr">age</span>: &#123;<span class="attr">dynamic</span>: _ctx.<span class="property">dynamic</span>&#125;</span><br><span class="line">  &#125;, <span class="title function_">_toDisplayString</span>(_ctx.<span class="property">dynamic</span>), <span class="number">11</span> <span class="comment">/* TEXT, CLASS, PROPS */</span>, [<span class="string">&quot;age&quot;</span>])</span><br></pre></td></tr></table></figure>
<p>渲染函数中的数字 <code>2</code> 和 <code>11</code> 就是这两个节点的 Patch Flag，是通过位运算出来的。比如第一个节点只绑定了动态的 class，那么它的 Patch Flag 就是 <code>10b</code>，而第二个节点则是对应了动态的 text, class 和 props，所以对应 Flag 就是 <code>1011b</code>。<br>
运行时的渲染器就会利用这些编译时增加的 Patch Flag 信息，进行相应的更新操作。</p>
<p>这个 Patch Flag 在渲染的时候到底有什么好处呢？挂载在 vNode 上的 <code>patchFlag</code> 可以帮助快速定位需要执行的 diff 操作。在 <code>shouldUpdateComponent</code> 的生命周期内就会进行以下操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (patchFlag &gt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (patchFlag &amp; patchFlag.<span class="property">DYNAMIC_SLOTS</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line"> <span class="keyword">if</span> (patchFlag &amp; <span class="title class_">PatchFlags</span>.<span class="property">PROPS</span>) <span class="comment">// 逐个对比动态变更的 props</span></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>render</code> 的过程中，会对已经 mount 的 element 进行 patch 操作，具体函数是 <code>patchElement</code>，里面也会对 <code>patchFlag</code> 进行比对，并且具体 vNode 上最终有哪些属性被更新了。大致如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (patchFlag &gt; <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="keyword">if</span> (patchFlag &amp; patchFlag.<span class="property">FULL_PROPS</span>) <span class="title function_">patchProps</span>(...) <span class="comment">// 在 key 变动的情况下，对 props 进行全量更新</span></span><br><span class="line"> <span class="keyword">if</span> (patchFlag &amp; <span class="title class_">PatchFlags</span>.<span class="property">CLASS</span>) <span class="title function_">hostPatchProp</span>(el, <span class="string">&#x27;class&#x27;</span>, ...)</span><br><span class="line"> <span class="keyword">if</span> (patchFlag &amp; <span class="title class_">PatchFlags</span>.<span class="property">STYLE</span>) <span class="title function_">hostPatchProp</span>(el, <span class="string">&#x27;style&#x27;</span>, ...)</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上个章节对 Hoist 进行分析的时候举的 🌰 中，我们发现当前节点的 Patch Flag 设为了 <code>64</code>。这就相当于告诉运行时渲染器在更新的过程中，这些根结点的相对位置不会发生变化，因此更新（Patch）的过程中，就不会进行节点重新排序的操作。</p>
<h2 id="块（Block）的优化-树结构打平">块（Block）的优化 - 树结构打平</h2>
<p>一个内部稳定的节点在 Vue 中被称之为 <strong>区块 BLOCK</strong>，在这里稳定指的是没有用到会影响结构的指令（<code>v-if, v-for</code>）。</p>
<p>Vue 官方给出的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt; &lt;!-- root block --&gt;</span><br><span class="line">  &lt;div&gt;...&lt;/div&gt;         &lt;!-- 不会追踪 --&gt;</span><br><span class="line">  &lt;div :id=&quot;id&quot;&gt;&lt;/div&gt;   &lt;!-- 要追踪 --&gt;</span><br><span class="line">  &lt;div&gt;                  &lt;!-- 不会追踪 --&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; bar &#125;&#125;&lt;/div&gt; &lt;!-- 要追踪 --&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>这本身是一棵 DOM 树，但是 Vue 可以细分 Block 节点的整棵树上有哪些需要追踪的节点，忽略不需要追踪的节点。对于 Block 来说，他只需要追踪有可能会更新的节点，并且打平成一个数组（听起来跟 <code>[1, [2, 3]].flat()</code> 有点像）。</p>
<p>这个操作就可以让重渲染的时候减少需要遍历的节点数量，时间复杂度由原有的 O(N^3) 变成了接近 O(N)。</p>
<h1>Vue 中的 vNode 到底维护了哪些属性？</h1>
<blockquote>
<p><a href="https://juejin.cn/post/6997975922880020488?searchId=20230817112608933723CF352335E71F88">再聊 Vue.js 3.2 关于 vnode 部分的优化 - 掘金 (juejin.cn)</a></p>
</blockquote>
<p>先回顾一下 Vue 编译后的渲染函数长什么样子：<a href="https://template-explorer.vuejs.org/#eyJzcmMiOiI8ZGl2IDpjbGFzcz1cInsgYWN0aXZlIH1cIj57e2R5bmFtaWN9fTwvZGl2PlxuPENhckxpc3QgOmNhcnM9e2NhcnN9IC8+Iiwic3NyIjpmYWxzZSwib3B0aW9ucyI6eyJob2lzdFN0YXRpYyI6dHJ1ZX19">Vue Template Explorer (vuejs.org)</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div :class=&quot;&#123; active &#125;&quot;&gt;&#123;&#123;dynamic&#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;CarList :cars=&#123;cars&#125; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">// 编译后对应的渲染函数</span><br><span class="line">export function render(_ctx, _cache, $props, $setup, $data, $options) &#123;</span><br><span class="line">  const _component_CarList = _resolveComponent(&quot;CarList&quot;)</span><br><span class="line"></span><br><span class="line">  return (_openBlock(), _createElementBlock(_Fragment, null, [</span><br><span class="line">    _createElementVNode(&quot;div&quot;, &#123;</span><br><span class="line">      class: _normalizeClass(&#123; active: _ctx.active &#125;)</span><br><span class="line">    &#125;, _toDisplayString(_ctx.dynamic), 3 /* TEXT, CLASS */),</span><br><span class="line">    _createVNode(_component_CarList, &#123;</span><br><span class="line">      cars: &#123;carList: _ctx.carList&#125;</span><br><span class="line">    &#125;, null, 8 /* PROPS */, [&quot;cars&quot;])</span><br><span class="line">  ], 64 /* STABLE_FRAGMENT */))</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>不难发现，对于元素节点和组件节点，会分别使用 <code>_createElementVNode</code> 和 <code>_createVNode</code> 方法创建虚拟节点。</p>
<blockquote>
<p>事实上，在 Vue.js 3.2 之前，都是统一用 <code>createVNode</code> 方法创建 VNode 的。直到这个 <a href="https://github.com/vuejs/core/pull/3334">PR</a> 被提出并和 Vue.js 3.2 一起被发布，才对 element 和 component 的 VNode 创建进行了区分，最终带来了 element 节点渲染过程 200% 的性能提升。</p>
</blockquote>
<p><code>createVNode</code> 是一个抽象层级更高的方法，而 <code>createElementVNode</code> 也被封装在内。</p>
<p>我们先来看一看 <code>createElementVNode</code> 是怎么写的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packages/runtime-core/src/vnode.ts</span></span><br><span class="line"><span class="comment">// 对外导出的 createElementVNode 在本文件内的函数名是 createBaseVNode</span></span><br><span class="line"><span class="keyword">export</span> &#123; createBaseVNode <span class="keyword">as</span> createElementVNode &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createBaseVNode</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="comment">// 节点类型，例如 &#x27;div&#x27;, &#x27;span&#x27;, ...</span></span></span><br><span class="line"><span class="params">  <span class="keyword">type</span>: VNodeTypes | ClassComponent | <span class="keyword">typeof</span> NULL_DYNAMIC_COMPONENT,</span></span><br><span class="line"><span class="params">  <span class="comment">// 节点的所有 props</span></span></span><br><span class="line"><span class="params">  props: (Data &amp; VNodeProps) | <span class="literal">null</span> = <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  <span class="comment">// 子节点</span></span></span><br><span class="line"><span class="params">  children: <span class="built_in">unknown</span> = <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  <span class="comment">// 用于 diff 算法</span></span></span><br><span class="line"><span class="params">  patchFlag = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">  dynamicProps: <span class="built_in">string</span>[] | <span class="literal">null</span> = <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  shapeFlag = <span class="keyword">type</span> === Fragment ? <span class="number">0</span> : ShapeFlags.ELEMENT,</span></span><br><span class="line"><span class="params">  isBlockNode = <span class="literal">false</span>,</span></span><br><span class="line"><span class="params">  needFullChildrenNormalization = <span class="literal">false</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> vnode = &#123;</span><br><span class="line">    <span class="attr">__v_isVNode</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">__v_skip</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="keyword">type</span>, <span class="comment">// 节点类型</span></span><br><span class="line">    props, <span class="comment">// 节点 props</span></span><br><span class="line">    <span class="attr">key</span>: props &amp;&amp; <span class="title function_">normalizeKey</span>(props),</span><br><span class="line">    <span class="attr">ref</span>: props &amp;&amp; <span class="title function_">normalizeRef</span>(props),</span><br><span class="line">    <span class="attr">scopeId</span>: currentScopeId,</span><br><span class="line">    <span class="attr">slotScopeIds</span>: <span class="literal">null</span>,</span><br><span class="line">    children,</span><br><span class="line">    <span class="attr">component</span>: <span class="literal">null</span>, <span class="comment">// 组件实例</span></span><br><span class="line">    <span class="attr">suspense</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">ssContent</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">ssFallback</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">dirs</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">transition</span>: <span class="literal">null</span>, <span class="comment">// 过渡动画</span></span><br><span class="line">    <span class="attr">el</span>: <span class="literal">null</span>, <span class="comment">// 对应的 DOM 元素</span></span><br><span class="line">    <span class="attr">anchor</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">target</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">targetAnchor</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">staticCount</span>: <span class="number">0</span>,</span><br><span class="line">    shapeFlag,</span><br><span class="line">    patchFlag,</span><br><span class="line">    dynamicProps,</span><br><span class="line">    <span class="attr">dynamicChildren</span>: <span class="literal">null</span>,</span><br><span class="line">    <span class="attr">appContext</span>: <span class="literal">null</span>, <span class="comment">// APP 上下文</span></span><br><span class="line">    <span class="attr">ctx</span>: currentRenderingInstance <span class="comment">// 当前渲染实例的上下文</span></span><br><span class="line">  &#125; <span class="keyword">as</span> <span class="title class_">VNode</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (needFullChildrenNormalization) &#123;</span><br><span class="line">    <span class="title function_">normalizeChildren</span>(vnode, children)</span><br><span class="line">    <span class="keyword">if</span> (__FEATURE_SUSPENSE__ &amp;&amp; shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">SUSPENSE</span>) &#123;</span><br><span class="line">      ;(<span class="keyword">type</span> <span class="keyword">as</span> <span class="keyword">typeof</span> <span class="title class_">SuspenseImpl</span>).<span class="title function_">normalize</span>(vnode)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (children) &#123;</span><br><span class="line">    <span class="comment">// 根据子节点是字符串还是数组类型，更新 shapedFlag</span></span><br><span class="line">    vnode.<span class="property">shapeFlag</span> |= <span class="title function_">isString</span>(children)</span><br><span class="line">      ? <span class="title class_">ShapeFlags</span>.<span class="property">TEXT_CHILDREN</span></span><br><span class="line">      : <span class="title class_">ShapeFlags</span>.<span class="property">ARRAY_CHILDREN</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; vnode.<span class="property">key</span> !== vnode.<span class="property">key</span>) &#123;</span><br><span class="line">    <span class="title function_">warn</span>(<span class="string">`VNode created with invalid key (NaN). VNode type:`</span>, vnode.<span class="property">type</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    isBlockTreeEnabled &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">    !isBlockNode &amp;&amp;</span><br><span class="line">    currentBlock &amp;&amp;</span><br><span class="line">    (vnode.<span class="property">patchFlag</span> &gt; <span class="number">0</span> || shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">COMPONENT</span>) &amp;&amp;</span><br><span class="line">    vnode.<span class="property">patchFlag</span> !== <span class="title class_">PatchFlags</span>.<span class="property">HYDRATE_EVENTS</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    currentBlock.<span class="title function_">push</span>(vnode)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__COMPAT__) &#123;</span><br><span class="line">    <span class="title function_">convertLegacyVModelProps</span>(vnode)</span><br><span class="line">    <span class="title function_">defineLegacyVNodeProperties</span>(vnode)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来看更加完整的 <code>createVNode</code> 方法：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_createVNode</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="keyword">type</span>: VNodeTypes | ClassComponent | <span class="keyword">typeof</span> NULL_DYNAMIC_COMPONENT,</span></span><br><span class="line"><span class="params">  props: (Data &amp; VNodeProps) | <span class="literal">null</span> = <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  children: <span class="built_in">unknown</span> = <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  patchFlag: <span class="built_in">number</span> = <span class="number">0</span>,</span></span><br><span class="line"><span class="params">  dynamicProps: <span class="built_in">string</span>[] | <span class="literal">null</span> = <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  isBlockNode = <span class="literal">false</span></span></span><br><span class="line"><span class="params"></span>): <span class="title class_">VNode</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">type</span> || <span class="keyword">type</span> === <span class="variable constant_">NULL_DYNAMIC_COMPONENT</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (__DEV__ &amp;&amp; !<span class="keyword">type</span>) &#123;</span><br><span class="line">      <span class="title function_">warn</span>(<span class="string">`Invalid vnode type when creating vnode: <span class="subst">$&#123;<span class="keyword">type</span>&#125;</span>.`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">type</span> = <span class="title class_">Comment</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是 vNode，就克隆并合并 props 和 children</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isVNode</span>(<span class="keyword">type</span>)) &#123;</span><br><span class="line">    <span class="keyword">const</span> cloned = <span class="title function_">cloneVNode</span>(<span class="keyword">type</span>, props, <span class="literal">true</span> <span class="comment">/* mergeRef: true */</span>)</span><br><span class="line">    <span class="keyword">if</span> (children) &#123;</span><br><span class="line">      <span class="title function_">normalizeChildren</span>(cloned, children)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isBlockTreeEnabled &gt; <span class="number">0</span> &amp;&amp; !isBlockNode &amp;&amp; currentBlock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cloned.<span class="property">shapeFlag</span> &amp; <span class="title class_">ShapeFlags</span>.<span class="property">COMPONENT</span>) &#123;</span><br><span class="line">        currentBlock[currentBlock.<span class="title function_">indexOf</span>(<span class="keyword">type</span>)] = cloned</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentBlock.<span class="title function_">push</span>(cloned)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cloned.<span class="property">patchFlag</span> |= <span class="title class_">PatchFlags</span>.<span class="property">BAIL</span></span><br><span class="line">    <span class="keyword">return</span> cloned</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isClassComponent</span>(<span class="keyword">type</span>)) &#123;</span><br><span class="line">    <span class="keyword">type</span> = <span class="keyword">type</span>.<span class="property">__vccOpts</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__COMPAT__) &#123;</span><br><span class="line">    <span class="keyword">type</span> = <span class="title function_">convertLegacyComponent</span>(<span class="keyword">type</span>, currentRenderingInstance)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重新处理 class 和 style（可能是对象）</span></span><br><span class="line">  <span class="keyword">if</span> (props) &#123;</span><br><span class="line">    props = <span class="title function_">guardReactiveProps</span>(props)!</span><br><span class="line">    <span class="keyword">let</span> &#123; <span class="attr">class</span>: klass, style &#125; = props</span><br><span class="line">    <span class="keyword">if</span> (klass &amp;&amp; !<span class="title function_">isString</span>(klass)) &#123;</span><br><span class="line">      props.<span class="property">class</span> = <span class="title function_">normalizeClass</span>(klass)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isObject</span>(style)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="title function_">isProxy</span>(style) &amp;&amp; !<span class="title function_">isArray</span>(style)) &#123;</span><br><span class="line">        style = <span class="title function_">extend</span>(&#123;&#125;, style)</span><br><span class="line">      &#125;</span><br><span class="line">      props.<span class="property">style</span> = <span class="title function_">normalizeStyle</span>(style)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对 vnode 的 type 进行编码</span></span><br><span class="line">  <span class="keyword">const</span> shapeFlag = <span class="title function_">isString</span>(<span class="keyword">type</span>)</span><br><span class="line">    ? <span class="title class_">ShapeFlags</span>.<span class="property">ELEMENT</span></span><br><span class="line">    : __FEATURE_SUSPENSE__ &amp;&amp; <span class="title function_">isSuspense</span>(<span class="keyword">type</span>)</span><br><span class="line">    ? <span class="title class_">ShapeFlags</span>.<span class="property">SUSPENSE</span></span><br><span class="line">    : <span class="title function_">isTeleport</span>(<span class="keyword">type</span>)</span><br><span class="line">    ? <span class="title class_">ShapeFlags</span>.<span class="property">TELEPORT</span></span><br><span class="line">    : <span class="title function_">isObject</span>(<span class="keyword">type</span>)</span><br><span class="line">    ? <span class="title class_">ShapeFlags</span>.<span class="property">STATEFUL_COMPONENT</span></span><br><span class="line">    : <span class="title function_">isFunction</span>(<span class="keyword">type</span>)</span><br><span class="line">    ? <span class="title class_">ShapeFlags</span>.<span class="property">FUNCTIONAL_COMPONENT</span></span><br><span class="line">    : <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__DEV__ &amp;&amp; shapeFlag &amp; <span class="title class_">ShapeFlags</span>.<span class="property">STATEFUL_COMPONENT</span> &amp;&amp; <span class="title function_">isProxy</span>(<span class="keyword">type</span>)) &#123;</span><br><span class="line">    <span class="keyword">type</span> = <span class="title function_">toRaw</span>(<span class="keyword">type</span>)</span><br><span class="line">    <span class="title function_">warn</span>(</span><br><span class="line">      <span class="string">`Vue received a Component which was made a reactive object. This can `</span> +</span><br><span class="line">        <span class="string">`lead to unnecessary performance overhead, and should be avoided by `</span> +</span><br><span class="line">        <span class="string">`marking the component with \`markRaw\` or using \`shallowRef\` `</span> +</span><br><span class="line">        <span class="string">`instead of \`ref\`.`</span>,</span><br><span class="line">      <span class="string">`\nComponent that was made reactive: `</span>,</span><br><span class="line">      <span class="keyword">type</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createBaseVNode</span>(</span><br><span class="line">    <span class="keyword">type</span>,</span><br><span class="line">    props,</span><br><span class="line">    children,</span><br><span class="line">    patchFlag,</span><br><span class="line">    dynamicProps,</span><br><span class="line">    shapeFlag,</span><br><span class="line">    isBlockNode,</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>createVNode</code> 复用了 <code>createBaseVNode</code> 方法，并且在初始化的过程中对节点进行了额外处理。正因如此，将创建 Element 的方法独立出来，也就避免了初始化过程中许多不必要的判断和处理。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发的十万个为什么（一）</title>
    <url>/post/2023-07-24-Weber/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<blockquote>
<p>好久不见了，在研一结束一周后就匆匆忙忙开启了漫长的日常实习生活。无数次面试被挂的经验告诉我，只是简单的明白怎么用 API 是不够进入大厂的。因此，还是老方法，「用输出倒逼输入」，为了解决惰性带来的浅入浅出的问题，我依然决定拿时间换能力。这里会总结并分享一些我在实际开发过程中遇到的一些困惑和相关的探索。 感谢 ChatGPT 对本文的大力支持！🤖️</p>
</blockquote>
<blockquote>
<p>面向实习中遇到的知识点，偏 Vue</p>
</blockquote>
<h2 id="微前端到底是好还是坏？">微前端到底是好还是坏？</h2>
<p>一句话总结：让项目容易上手，适合 ToB 场景下多项目的敏捷开发，但全局的项目管理非常困难。</p>
<p>所有的微前端项目独立于各自的仓库中，每个项目可以独立的加载自己的 JS，CSS 文件。<br>
这带来的好处显而易见，如果我只需要开发其中一个项目，那么我可以单纯 clone 这个仓库，然后提对应的 PR，合进 master 分支，并单独部署。针对单个项目的开发而言，可以说是非常舒服。<br>
另一方面，这种模式也允许我们的子项目可以做到技术栈无关，针对有些 vue2 的老项目，可以不用重构，直接以子应用的方式独立的进行开发和部署。不同的子应用之间也可能应用不同的组件库，这也给我们的设计与开发带来了更加自由的选择。</p>
<p>这种架构模式之下，也会带来同样多的麻烦。</p>
<ol>
<li>微前端的状态管理是相对繁琐的，需要额外选择微前端框架（例如 Wujie、Qiankun），针对每个子应用，都需要单独且重复地配置一遍权限认证等，即使已经封装了对应hooks和packages。并且，可能还需要额外处理打包工具和这些前端框架的兼容性问题（例如 Qiankun 和 Vite）。</li>
<li>如果想要实现跨子应用的组件复用，需要单独维护一个 NPM 组件库，在库中单独管理和发布公用组件，这无疑会增加组件复用时的时间耗费。</li>
<li>如果想在本地预览子应用，可能会需要在本地启动多个项目（外层&gt;子应用&gt;子应用&gt;…)。</li>
</ol>
<h2 id="Vue，React-和-Svelte-这些在-Reactivity-上有什么区别？">Vue，React 和 Svelte 这些在 Reactivity 上有什么区别？</h2>
<blockquote>
<p>ES6 中的 Proxy 无法为原始值提供代理，包括 Boolean, Number, BigInt, String, undefined 等。<br>
而其他的非原始类型均可使用 Proxy 来实现对象代理，包括 Object, Array, Map, Set, WeakMap 等。</p>
</blockquote>
<h3 id="Vue3">Vue3</h3>
<blockquote>
<p>针对 Vue3 中的 <code>ref</code> 实现</p>
</blockquote>
<p>原始值的响应式更新：通过创建 <code>RefImpl</code> 类来实现创建 <code>ref</code> 的实例，拦截数据的 <strong>读取Get</strong> 和 <strong>设置Set</strong> 操作，在 <code>get</code> 的时候通过 <code>trackerEffects</code> 来收集 <code>value</code> 的依赖，在 <code>set</code> 的时候通过 <code>triggerEffects</code> 派发 <code>value</code> 的更新。</p>
<p>非原始值的响应式更新：根据设定的深浅响应，除了需要创建单独的 <strong>Getter</strong> 和 <strong>Setter</strong> 来捕获数据的读取和更新，还需要通过 <code>has</code> 拦截函数拦截 <code>in</code> 操作符，使用 <code>ownKeys</code> 来拦截 <code>for...in</code> 循环，以及对 <code>delete</code> 的拦截等等。</p>
<h3 id="React">React</h3>
<blockquote>
<p>针对 React 16.8 提出的 <code>useState</code></p>
</blockquote>
<p>在组件内部，通过闭包的方式创建和维护状态的数组和更新对应状态的方法，包括 setter 数组和 state 数组。使用 cursor 来维护当前的状态指针，每一次重渲染都会将 cursor 置为 0。</p>
<p>这里可以引申到「为什么hooks不能放在判断、循环中」，因为 hooks 的都只能根据调用顺序来。因为组件实例确定后，hooks 只能拿到初始值和调用次数，例如 <code>useState</code> 是拿不到状态变量的名称的。</p>
<h3 id="Svelte">Svelte</h3>
<p>独立的编译过程，不去手动维护虚拟 DOM。每个组件都是一个独立的 <code>JS类（Class）</code>，继承 <code>SvelteComponent</code>，Svelte 负责替换原生 DOM 算法来优化 DOM 更新操作。</p>
<p>对应的组件实例通过 <code>instance</code> 实例方法去创建状态和更新状态的相关方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">instance</span>(<span class="params">$$self, $$props, $$invalidate</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">click_handler</span> = (<span class="params"></span>) =&gt; $$invalidate(<span class="number">0</span>, count++, count);</span><br><span class="line">  <span class="keyword">return</span> [count, click_handler];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例化组件的时候执行 <code>init</code> 方法标注脏组件（有需要重新 render 的状态和更新方法），然后在状态变化的时候通过 <code>flush()</code> 方法去遍历更新组件。</p>
<h2 id="v-if-和-v-show-有什么区别？"><code>v-if</code> 和 <code>v-show</code> 有什么区别？</h2>
<blockquote>
<p><a href="https://vuejs.org/guide/essentials/conditional.html#v-if-vs-v-show">Conditional Rendering | Vue.js (vuejs.org)</a></p>
</blockquote>
<ul>
<li>两者本身都是控制动态渲染组件</li>
<li><code>v-if</code> 是真实的条件渲染，会在切换过程中销毁和重建块内的事件监听器和子组件。</li>
<li><code>v-if</code> 也是惰性的，如果初次渲染时为 <code>false</code>，就什么都不会做，直到为 <code>true</code> 时才会局部编译。</li>
<li><code>v-show</code> 只是单纯的 CSS 样式切换，具体来说就是 <code>display: none</code> 的开关。</li>
<li><code>v-if</code> 切换开销更高，<code>v-show</code> 的初始渲染开销更高。如果需要频繁切换，就用 <code>v-show</code>；如果运行时绑定条件很少改变，就用 <code>v-if</code>。</li>
</ul>
<h2 id="为什么-vant-组件库的-Popup-onMounted-里无法捕获到-ref？">为什么 vant 组件库的 Popup onMounted 里无法捕获到 ref？</h2>
<p>问题分析：通过查看 vant 库的文档和源码，发现这个组件默认设置了 <code>lazyRender</code>，通过监听 <code>props.show</code> 决定是否要 render 对应的 DOM 结构。我们主组件 mount 的时候，虽然也会 mount <code>Popup</code> 组件，但是这个时候 <code>Popup</code> 组件的 DOM 树是空的，在 <code>onMounted</code> 钩子里拿到对应的结点引用为 <code>undefined</code>。</p>
<p>解决方案：</p>
<ol>
<li>把 <code>lazyRender</code> 属性设置为 <code>false</code>，这个时候 <code>Popup</code> 组件在 Mount 的时候就会全部加载。理论上会对性能有轻微的影响。</li>
<li>在 <code>Popup</code> 组件内手动 <code>Watch</code> 一下 <code>show</code> 属性，在 <code>show</code> 属性发生变化的时候，对应的 <code>ref</code> 就是能正常引用的。</li>
</ol>
<h2 id="高度不定的元素该怎么设计-transition-动画？">高度不定的元素该怎么设计 transition 动画？</h2>
<p>问题分析：<code>height: auto/100%</code> 不会触发过渡动画，因为 <code>transition</code> 的过渡动画需要元素拥有确定的高度（即通过已知的起点和终点来计算逐帧的变化），例如 <code>height: 300px =&gt; height: 100px</code>。</p>
<p>解决方案：</p>
<ol>
<li>max-height：可以为高度不定的元素设定 <code>max-height</code> 值，<code>transition</code> 动画会根据这个值的变化来进行渲染过渡的动画。局限：当目标高度比 <code>max-height</code> 小的时候，实际的过渡动画持续时间会小于手动设定的 <code>transition</code> 持续时间。</li>
<li>grid：grid 布局的尺寸计算是根据最小高度来计算的，支持在 <code>0fr =&gt; 1fr</code> 的时候应用过渡动画。通过设定 grid 内容器样式的 <code>min-height</code> 设定展开前动画。</li>
</ol>
<h2 id="Vue-里的-nextTick-的触发时机？">Vue 里的 nextTick 的触发时机？</h2>
<p><code>nextTick</code> 函数用于实现在下次 DOM 更新循环结束之后延迟回调，回调时机是当前 JS 执行结束之后，在下一个 DOM 更新循环之前。在 <code>nextTick</code> 之后，可以访问更新后的 DOM，比如元素的新尺寸或者位置等。在 JS 的事件循环中，<code>nextTick</code> 属于是微任务。</p>
<p>我们在实际开发过程中，常用的几个异步函数，分别是 <code>promise(微), nextTick(宏/微), requestAnimationFrame(宏), setTimeout(宏)</code>，执行顺序是怎样的？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// promise =&gt; nextTick =&gt; requestAnimationFrame =&gt; timeout</span></span><br><span class="line"><span class="title function_">nextTick</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;timeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">requestAnimationFrame</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;requestAnimationFrame&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Vue-中的-computed-和-watch-是怎么实现的，分别适合怎样的场景？">Vue 中的 computed 和 watch 是怎么实现的，分别适合怎样的场景？</h2>
<blockquote>
<p><a href="https://github.com/vuejs/core/blob/main/packages/reactivity/src/computed.ts">core/packages/reactivity/src/computed.ts at main · vuejs/core (github.com)</a></p>
</blockquote>
<p><code>computed</code> 方法依赖于 <code>ComputedRefImpl</code> 类来创建了一个可以自定义 <code>getter</code> 和 <code>setter</code> 方法的响应式 ref。为了实现响应式的更新，<code>ComputedRefImpl</code> 类中又通过 <code>ReactiveEffect</code> 类新建了 <code>effect</code> 实例来管理 <code>value</code> 的更新。</p>
<blockquote>
<p><a href="https://github.com/vuejs/core/blob/main/packages/runtime-core/src/apiWatch.ts">core/packages/runtime-core/src/apiWatch.ts at main · vuejs/core (github.com)</a></p>
</blockquote>
<p><code>watch</code> 方法通过指定 <code>source</code> 和 <code>callback</code> 来实现更加直观的响应式更新，对于 <code>source</code> 而言，<code>watch</code> 方法会根据是 <code>ref/reactive/array/function</code> 来设置不同的 <code>getter</code>。<br>
方法内部通过 <code>EffectScheduler</code> 类的实例来管理 <code>callback</code> 的调用时机，默认是 <code>render</code> 前，但是还可以设定为同步或者 <code>render</code> 后。<br>
<code>watch</code> 方法和 <code>computed</code> 方法一样，使用 <code>ReactiveEffect</code> 类，来实现响应式更新。</p>
<p>这两个方法原理类似，使用场景稍微有些不同，<code>computed</code> 适用于比较直接的根据其他响应式数据计算结果，自带缓存。<code>watch</code> 的控制更加细粒度，通过监听数据的变化，执行特定的逻辑。</p>
<h2 id="Event-的触发顺序是怎么样的？event-prevent-event-stop-是怎么实现的，分别有什么作用？">Event 的触发顺序是怎么样的？<code>event.prevent</code> / <code>event.stop</code> 是怎么实现的，分别有什么作用？</h2>
<p>DOM 的标准事件模型中规定的事件触发顺序：捕获阶段、目标阶段和冒泡阶段。<br>
即从外到里，目标本身事件触发，从里到外。</p>
<p>在 Vue 中，事件处理函数默认是在冒泡阶段执行的。<br>
<code>prevent</code> 和 <code>stop</code> 分别是对事件进行额外的限制，分别表示 <code>阻止事件的默认行为</code> 和 <code>停止事件的冒泡</code>。<br>
实现方式就是在修饰符之后，额外调用 <code>e.preventDefault</code> 以及 <code>e.preventPropagation</code>。</p>
<h2 id="Vue-中有哪些常用的性能优化手段？">Vue 中有哪些常用的性能优化手段？</h2>
<blockquote>
<p><a href="https://cn.vuejs.org/guide/best-practices/performance.html">性能优化 | Vue.js (vuejs.org)</a></p>
</blockquote>
<ol>
<li>架构选择：根据产品的特性选择合适的架构，利用 SSR （服务端渲染）或者 SSG（静态站点生成）来渲染可能的页面，以缩短首屏加载时间。</li>
<li>Tree-shake：减小构建的包的大小，一般这种由打包工具实现（webpack、Vite）。并且，在引入依赖的时候，需要注意依赖包是否过重，尽量选择 ES 模块格式的依赖。</li>
<li>代码分割：将部分组件利用 <code>defineAsyncComponent</code> 设置为异步组件，只在必要的时刻按需加载。特别是基于 <code>Vue-Router</code>，将页面级别的组件以异步方式引入。</li>
<li>减少不必要的更新：</li>
</ol>
<ul>
<li>传给子组件的 props 应该尽量保持稳定</li>
<li>使用 <code>v-once</code> 实现只初始化一次组件</li>
<li>使用 <code>v-memo=&quot;[vA, vB]&quot;</code> 让组件只在 <code>vA</code> 或 <code>vB</code> 改变的时候才会更新</li>
</ul>
<ol start="5">
<li>对大型列表实现列表虚拟化</li>
<li>使用 <code>shallowRef</code> 和 <code>shallowReactive</code> 来避免不必要的深度响应</li>
<li>去掉不必要的组件抽象（维护虚拟 DOM 的 cost 太高）</li>
</ol>
<blockquote>
<p>Vue 框架自身利用编译和运行时的强耦合来对 Virtual DOM 进行的特殊优化：[[面向 Vue 中 VNode 的一次 Deep Dive]]</p>
</blockquote>
<h2 id="Vue-3-的生命周期对外暴露了哪些-hooks？">Vue 3 的生命周期对外暴露了哪些 hooks？</h2>
<p>Vue3 Lifecycle:</p>
<p><img src="https://cn.vuejs.org/assets/lifecycle.16e4c08e.png" alt="img"></p>
<h2 id="Vue3-中使用-reactive-或-ref-在什么时候会失去响应性？">Vue3 中使用 reactive 或 ref 在什么时候会失去响应性？</h2>
<p><code>reactive</code>：</p>
<ul>
<li>在遇到解构赋值的时候，一层的对象包裹的属性会丢失响应性。</li>
<li>在重新整个赋值对象的时候，整个对象都会失去响应性。（这种情况编辑器会报警）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;flex flex-col gap-2&quot;&gt;</span><br><span class="line">    &lt;span&gt; foo: &#123;&#123; foo &#125;&#125; &lt;/span&gt;</span><br><span class="line">    &lt;el-button @click=&quot;foo++&quot;&gt;foo++&lt;/el-button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div class=&quot;flex flex-col gap-2&quot;&gt;</span><br><span class="line">    &lt;span&gt; bar: &#123;&#123; bar &#125;&#125; &lt;/span&gt;</span><br><span class="line">    &lt;el-button @click=&quot;bar.val++&quot;&gt;bar.val++&lt;/el-button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">  &lt;div class=&quot;flex flex-col gap-2&quot;&gt;</span><br><span class="line">    &lt;span&gt; p1.age: &#123;&#123; p1.age &#125;&#125; &lt;/span&gt;</span><br><span class="line">    &lt;el-button @click=&quot;() =&gt; (p1 = &#123; age: 10 &#125;)&quot;&gt;p1.age&lt;/el-button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">import &#123; reactive &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">// 解构赋值</span><br><span class="line">const &#123; foo, bar &#125; = reactive(&#123;</span><br><span class="line">  foo: 1,</span><br><span class="line">  bar: &#123;</span><br><span class="line">    val: 2,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const p1 = reactive(&#123; name: &#x27;ethan&#x27; &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.ethanloo.cn/img/202311262103604.gif" alt=""></p>
<p><code>ref</code>：同理，将对应的 <code>.value</code> 赋给一个非响应式对象之后就不会触发更新了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;span&gt; x: &#123;&#123; x &#125;&#125; &lt;/span&gt;</span><br><span class="line">  &lt;el-button @click=&quot;x++&quot;&gt; x++ &lt;/el-button&gt;</span><br><span class="line"></span><br><span class="line">  &lt;span&gt; y: &#123;&#123; y &#125;&#125; &lt;/span&gt;</span><br><span class="line">  &lt;el-button @click=&quot;y++&quot;&gt; y++ &lt;/el-button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&quot;ts&quot; setup&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const x = ref(1)</span><br><span class="line">const y = x.value</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.ethanloo.cn/img/202311262103138.gif" alt=""></p>
<h2 id="Vue3-中提示的-Suspense-特性是啥？">Vue3 中提示的 Suspense 特性是啥？</h2>
<blockquote>
<p>Vue3 的项目经常会有一个 warning：<code>&lt;Suspense&gt;</code> is an experimental feature.</p>
</blockquote>
<p><code>&lt;Suspense&gt;</code> 用于包裹一些异步组件，使用 <code>&lt;template #fallback&gt;</code> 来定义加载时显示的内容。<br>
异步组件特指那些 <code>async setup()</code> 函数定义的组件，或者在 <code>&lt;script setup&gt;</code> 标签包裹的顶层中有 <code>await</code> 表达式的组件。</p>
<p>在异步组件的加载过程中，即 <code>await setup()</code> 执行完成之前，<code>Suspense</code> 组件会默认渲染 <code>#fallback</code> 中的内容，例如骨架屏，或者是加载动画等。</p>
<p>和之前相比，<code>Suspense</code> 的优势在于：</p>
<ul>
<li>之前我们需要手动在组件内部，定义 <code>isLoading</code> 的状态去维护当前组件的加载状态。</li>
<li>之前在加载异步组件的过程中，如果不用本地的状态去管理异步的情况，用户可能看到不完整的界面。</li>
<li>以前异步的处理逻辑分布在各个组件内部，现在更加集中。</li>
</ul>
<h2 id="Vue3-什么场景下会用到-shallowRef-shallowReactive？">Vue3 什么场景下会用到 <code>shallowRef/shallowReactive</code>？</h2>
<p><code>shallowRef</code> 最大的特性在于只在整个引用发生变化的时候才会触发重渲染，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> v = <span class="title function_">shallowRef</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;ethan&#x27;</span>, <span class="attr">age</span>: <span class="number">24</span> &#125;)</span><br><span class="line">v.<span class="property">value</span>.<span class="property">name</span> = <span class="string">&#x27;ethanloo&#x27;</span> <span class="comment">// 不触发 rerender</span></span><br><span class="line">v.<span class="property">value</span> = &#123; <span class="attr">name</span>: <span class="string">&#x27;ethanloo&#x27;</span>, <span class="attr">age</span>: <span class="number">25</span> &#125; <span class="comment">// 触发 rerender</span></span><br></pre></td></tr></table></figure>
<p><code>shallowReactive</code> 也是类似，只在浅层的属性变更时触发重渲染：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> v = <span class="title function_">shallowReactive</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">1</span> &#125; &#125;)</span><br><span class="line">v.<span class="property">a</span> = <span class="number">2</span> <span class="comment">// 触发 rerender</span></span><br><span class="line">v.<span class="property">b</span>.<span class="property">c</span> = <span class="number">3</span> <span class="comment">// 不触发 rerender</span></span><br></pre></td></tr></table></figure>
<p>在特定的场景下，<code>shallowRef/shallowReactive</code> 可以起到性能优化的作用：</p>
<ol>
<li>当维护一个大型数组/对象的时候，避免深层监听的多重递归导致的性能下降。</li>
<li>一些简单的状态管理场景，只关心对象什么时候被替换，不关心对象内部某个属性的变化。</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>NSDI22 - YuZu：Neural-Enhanced Volumetric Video Streaming</title>
    <url>/post/2022-11-24-Paper/YuZu%20-%20Neural-Enhanced%20Volumetric%20Video%20Streaming/</url>
    <content><![CDATA[<blockquote>
<p>找了 NSDI22 上的一篇关于视频传输的论文来应付课程报告，主要是针对容积视频（Volumetric Video）的传输优化。<br>
Zhang A, Wang C, Han B, et al. {YuZu}:{Neural-Enhanced} Volumetric Video Streaming[C]//19th USENIX Symposium on Networked Systems Design and Implementation (NSDI 22). 2022: 137-154.</p>
</blockquote>
<h2 id="背景介绍">背景介绍</h2>
<p>随着硬件设备的发展和网络设施的进一步完善，人们对于观看视频的需求也在持续地提升。在十年前，或许 1080P 视频在我们的认知中已经属于高清视频了，但是站在今天的角度来看，可能 4K 或者更高分辨率的视频才能满足很多人对于画质的追求。随着「元宇宙」概念的热度增加，3D 的容积视频（Volumetric Video）也受到了公众的关注。<br>
容积视频和传统的 2D 视频和 360 度视频的不同之处在于，每一帧视频都包含了一个完整的 3D 场景，一般通过点云或者多边形网格进行渲染。3D 的容积视频允许观众进行 6 个自由度（Six Degree-of-Freedom，6DoF）的移动，不仅可以通过 Yaw/Pitch/Roll 来改变观看视角的，还可以通过移动改变观看的位置，这种观看体验可以说是身临其境了。观看这种容积视频的方式有很多种，可以使用支持 VR/MR（虚拟现实/混合现实）的穿戴设备，当然也可以像玩 3D 游戏一样直接通过 PC 进行观看。<br>
想要实现流畅地观看容积视频，如何通过 Internet 进行容积视频流传输是一个主要的待解决问题。容积视频比传统的 2D 视频和全景视频对于网络带宽的需求更高，一般需要上百甚至千兆网才能实现高画质的容积视频传输。因此，这篇文章着眼于在有限带宽的限制下提高用户的观看容积视频的体验（Quality of Experience，QoE）。</p>
<h2 id="难点阐述">难点阐述</h2>
<p>已经有不少的研究关注到了容积视频传输高带宽占用的问题，部分文章尝试使用了视口自适应串流，可以简单的理解为通过预测用户观看的视角和位置来减少需要实时传输的内容。本论文直接指出了这些研究存在的不足和缺陷，这些视口的预测都需要对 6 个 DoF 进行预测，而如果用户的视角或者位置移动的速度比较快，那么预测结果也往往会不准确。而其他的研究尝试了远程渲染的方式，通过让边缘结点将 3D 场景渲染为 2D 的常规帧画面来降低实时传输的带宽，这种转码的方案由于设备的限制往往是难以扩展的。<br>
作者关注到了过去在传输 2D 视频时候为了节省带宽使用的一种技术手段：超分辨率（Super Resolution，SR）。借助 CV 的快速发展，超分辨率实现了将画质较低的图片或者帧，在接近无损的情况下放大为更高分辨率的画面。近年来，专注于 CV 领域的研究人员也尝试了使用神经网络实现了 3D 点云的超分辨率模型。借助训练完的 3D 点云超分辨率模型，服务器只需要将低分辨率的帧和这个 SR 模型传输给用户，即可实现在用户端播放高分辨率的画面。<br>
作者一开始直接使用了 PU-GAN 网络来尝试实现对容积视频的帧进行超分辨率。这个 PU-GAN 模型可以实现 4 倍的 SR，比如原来的点云是 25K 的点，就可以超分到 100K 个点。作者使用一张 2080Ti 训练了这样一个 SR 模型，在保证良好的上采样准确率的前提下，确实节省了接近 74% 的带宽。但是直接使用这样一个现成的模型也存在了很多问题：</p>
<ol>
<li>缺少了一种针对容积视频的 QoE 模型，没办法衡量超分完的视频 QoE 受到了什么程度的影响。</li>
<li>在 SR 的过程中，速度非常慢，平均 10s 才能对一帧进行 SR，这显然不能满足流畅观看的要求。同时，运行 PU-GAN 会占用 7GB 的显存，对硬件要求过高。</li>
<li>PU-GAN 仅仅只是对点云进行 SR，没有处理颜色的信息。</li>
</ol>
<h2 id="模型分析">模型分析</h2>
<p>本文针对 3D 容积视频流传输的高带宽需求问题，创新地提出了一种基于 SR 的立体视频传输系统 Yuzu。Yuzu 的整体架构如下图所示，接下来我将就自己的理解对各个模块进行讲解和分析。<br>
<img src="https://cdn.ethanloo.cn/img/202211081520946.png" alt=""></p>
<h3 id="QoE-模型建立">QoE 模型建立</h3>
<p>首先看到最右侧的 QoE 模型，为了衡量 SR 后的容积视频质量，作者使用用户调研的方式来制定了 QoE 模型。考虑到 2D 视频的各种因素被证明对 QoE 的影响成线性，本篇论文也假设了容积 QoE 的计算也是一种线性的格式。<br>
本文为了确认点云密度、观察距离和超分辨率比例对 QoE 的影响，本文的研究团队 40 个国家的 1446 个参与者来对 4 个不同的人像容积视频进行评价。最终确定完各项系数之后的 QoE 预测模型误差中位数为 12.49%，可以认为对于人像类的容积视频具有适用性。</p>
<h3 id="SR-模型">SR 模型</h3>
<p>本文由于本质上还是基于 PU-GAN 来实现的对容积视频内点云进行 SR，所以主要目标实际上就是加速 SR 的过程。在超分辨率过程的优化方面，本文主要做了两类的工作：帧内 SR 优化和帧间 SR 优化。<br>
帧内 SR 优化针对的是单帧 SR，上文提到容积视频的超分辨率的对象是对每一帧的点云。考虑到直接 4xSR 的时间开销较大，本文首先对这个倍数进行了优化。点云实际上就是非结构化的点集合，本文发现 3DSR 后输出的点的位置会和原来点的位置发生变化，基于这个关键发现，作者将原本的 4xSR 转换为了 3xSR 加原低分辨率的 1xSR，以此来间接放大四倍。这个方法属于是非常直观且容易理解，显著节省了 35% 的时间，同时实验也证明了这种操作不会降低直接 SR 的准确性。<br>
除此之外，本文的 YuZu 也对 PU-GAN 的 DNN 结构进行了分析，发现所经历的特征提取、特征扩展和点集生成三个阶段中的特征提取阶段时间占比最长，达到了 78.3%。为了加速卷积的过程，YuZu 借鉴最新研究 PointNet++，使用 SKF 核函数来取代了原来的特征提取。文章里也简单阐释了 SKF 加速特征提取过程的可能原因，SKF 的核不对称性有利于学习点云所特有的几何细节。 YuZu 的 SR 模型也删除了特征提取的最后两个密集层核特征扩展阶段的几个大型卷积层，在尽可能不影响上采样精度的前提下减少了扩展特征，以减少 GPU 的内存占用并加速卷积过程。<br>
帧间 SR 优化的思路则关注的是利用时间和空间上接近的 SR 来对当前某个区域 SR 行为的加速。作者强调了每个 patch（视频里的块结构）的 SR 行为进行缓存，利用动态规划来减少不必要上采样的 patch。</p>
<h3 id="网络-计算模型">网络/计算模型</h3>
<p>YuZu 在传输容积视频的时候，不仅会像传统的比特率自适应算法一样会根据网络波动调整传输决策，还建立了特定的计算资源模型来适应可用的计算资源。利用之前建立的 QoE 模型，YuZu 巧妙地根据网络传输和计算资源决定是下载高分辨率还是低分辨率+SR。概括地讲，YuZu 每次基于后面的 $m$ 个 chunk（包含 $f$ 个帧）通过穷举质量和SR比例，最大化 QoE。因为直接穷举会消耗过多的时间，所以对于决策只进行了粗粒度的判断。在计算 SR 比例之前，YuZu 使用了模拟退火算法来查找全局的最优解，为了加速模拟退火的速度，把范围控制在相邻的两帧（前一帧+当前帧）。</p>
<h3 id="上色模型">上色模型</h3>
<p>因为现有的 3D SR 算法都没有考虑过上色的问题，这篇文章采取了一种相对直接的上色算法。每个帧内的点云实际上就是若干个点，每个点都在三维空间内有它对应的坐标，SR 后的点都去找到原帧内的最接近（欧氏距离）的点的颜色。</p>
<h2 id="实验结果">实验结果</h2>
<p>本文为了证明 YuZu 对容积视频的传输优化做了比较多的实验，除了服务端的一台机器，为了模拟不同的场景也准备了三台配置不同的客户端机器。为了模拟观看容积视频时候用户视口发生的变化过程，作者也收集了 32 个用户的 6DoF 移动轨迹。<br>
实验结果包括了三个方面，这边做一个简单的概括：</p>
<ol>
<li>SR 性能：在进行了上述的优化之后，在保证画质没有降低的同时，用同样的 2080Ti 进行 SR 的速率提升了 307 倍，因此 FPS 也从原来的 0.1 升到了 30+，显存的占用也减少了 87%。</li>
<li>QoE 改善：对于测试用的 4个容积视频，相比较不进行超分的原视频，SR 后的视频提升了至多 150% 的 QoE。</li>
<li>端到端性能：YuZu 整体的 QoE 提升达到了 83%，仅使用缓存进行优化也能提升 63% 的 QoE。除此以外，YuZu 降低了传输内容体积的 49%，仅使用缓存则可以节省 40% 的数据使用量。</li>
</ol>
<h2 id="思维延伸">思维延伸</h2>
<p>本章的内容主要是我个人在阅读完整篇论文之后的一些收获和拙见。</p>
<p>YuZu 这篇论文的亮点我认为可以归纳为以下几点：</p>
<ul>
<li>我们都知道想在新兴领域想 idea 本身不难的，但是想找到合适的解决方案往往是非常困难的。探究了一个相对新的领域：容积视频。这个领域内的相关研究内容是比较少的，作者很巧妙地利用其他领域（CV）的研究成果来解决了这个新的问题。</li>
<li>整篇论文想要解决的问题虽然表面上是优化容积视频的网络传输，但是最后实现的是从 0 到 1 的提升，原本的 0.1FPS 被提升到了 30+FPS。</li>
<li>作者对于 SR 的优化是一步一步进行的，对于每一步的实际操作也解释得相当清楚，最后的实验里也证明了每一步优化都是有意义的。</li>
<li>因为 idea 相对冷门，所以很多研究是不够充分的，比如说「容积视频」的 QoE 模型和 3D SR 后的视频效果等。面对这些问题，作者相对巧妙地引入了群众的主观意见来避免过于硬核的研究延伸。</li>
</ul>
<p>面对这篇文章，我自己的一些胡思乱想：</p>
<ul>
<li>在 3D 着色的部分有些略显随意，只是寻找原点云内最近的点进行着色显然不是 SR 后点云着色的最优解。</li>
<li>因为很多数据是基于参与者的主观想法，有些对比我不确定是作者故意省略的还是我自己忽略了。比如原画质的容积视频和缩小后重新 SR 的视频在画面质量是否存在差距。</li>
<li>用于 3DSR 的 PU-GAN 模型实际上是针对每个视频都需要单独训练的，现在的每个视频都是几分钟，如果处理时间更长的容积视频会不会导致 SR 模型本身更大或者效果变差呢。</li>
</ul>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>视频传输</tag>
        <tag>容积视频</tag>
      </tags>
  </entry>
  <entry>
    <title>TMC21 - Collaborative Service Placement for Edge Computing in Dense Small Cell Networks</title>
    <url>/post/2022-11-10-Paper/Collaborative%20Service%20Placement%20for%20Edge%20Computing%20in%20Dense%20Small%20Cell%20Networks/</url>
    <content><![CDATA[<blockquote>
<p>一篇来自 TMC21 的关于边缘计算环境下服务放置的论文，第一次在组会做的报告。<br>
L. Chen, C. Shen, P. Zhou and J. Xu, “Collaborative Service Placement for Edge Computing in Dense Small Cell Networks,” in IEEE Transactions on Mobile Computing, vol. 20, no. 2, pp. 377-390, 1 Feb. 2021, doi: 10.1109/TMC.2019.2945956.</p>
</blockquote>
<h2 id="Abstract">Abstract</h2>
<p>MEC 将计算的任务从集中的云端扩散到了几乎是数据源处，因此大幅度降低了提供服务的延迟并且节省了网络的带宽。MEC 的计算卸载任务被研究了很多，但是服务放置任务作为一个相当重要的设计却没有得到关注。服务放置指的是设置服务平台，并且将相关的库和数据库存放到边缘服务器。例如配置了MEC的基站（BS），允许执行相关的计算任务。由于有限的计算资源，边缘服务器通常只能提供较少数量的服务，因此具体提供什么服务需要进行正确的决策才能最大化系统的性能。<br>
本篇论文探究了一种面向启用MEC的密集小型基地台网络的联合式的服务放置（Service Placement）。我们提出了一种有效的分布式算法，简称为 CSP（Collaborative Service Placement），在小型的基地台网络内，基站对服务放置的决策进行联合式的优化，以解决MEC系统中的一些挑战，包括服务的异构性、空间上需求的耦合性、分散式的协作。<br>
CSP 算法基于并行的吉布斯采样，通过利用小型蜂窝网络上的图形着色而开发。和传统的吉布斯采样相比，该算法大大提高了时间效率，同时也保证了可证明的收敛性和最优性。CSP 被进一步扩展到了自私型基站的研究，在这种情况下基站是可以选择合作和不合作。我们采用了合作博弈理论来研究BS的策略并且设计了组建合作计划来使用合并和分裂规则来建立稳定的基站合作。实验结果表明，CSP可以有效降低边缘系统的操作成本，无论是对于合作还是自私的基站。</p>
<h2 id="Questions">Questions</h2>
<p>在小型基地台网络内提供服务的例子？</p>
<ol>
<li>在博物馆内，通过在 BS 处部署 AR 服务，来为当前区域提供实时的服务。</li>
<li>对于在家晚上玩手机游戏的用户，开发商可以在特定时间内提供这种游戏所需要的服务。</li>
</ol>
<p>为什么要建立这个模型？</p>
<ol>
<li>部署在 BS 的计算资源是有限的，边缘服务器通常由于执行任务的异构性和时间的变化，而导致服务频繁的配置和删除。导致加重了网络了负担，额外的计算延迟，最终使得用户的体验恶化。</li>
<li>小型基地台的概念最近被提出，可以实现无缝的覆盖，增加吞吐量并且节省蜂窝网络的能量消耗。在当前以及未来高密度的基站覆盖下，一个移动的设备可能会被很多个基站覆盖，这为共同提供计算资源、共享配置的服务、协同提供计算服务。</li>
</ol>
<p>进行 service placement 决策的困难：</p>
<ol>
<li>需要同时基站<strong>的考虑无线接入和计算服务</strong>，因此需要一个新的模型来整体地考虑系统的各个方面。BS 之间不仅可以在服务平台上进行协作，还可以在任务的物理传输上协作。</li>
<li>尽管小型基地台之间的网络的部分重叠为 BS 协作创造了可能，但是这也导致了复杂的多网格交互下的服务需求和计算资源的高度耦合，因此最终的合作式服务放置成为了<strong>一个相当复杂的联合优化</strong>问题。本身分布式 MEC 使得这个问题更加棘手。</li>
<li>因为小型基地台的基站通常是由个人用户部署的，例如企业用户，所以如果没有一定的好处，那么他们不一定愿意参与到这套合作式的系统来。因此需要设计一个<strong>激励的机制</strong>来鼓励服务放置的合作工作。</li>
</ol>
<p>这篇论文的工作：</p>
<ol>
<li>将在密集小型基地台网络下的协作式服务放置任务表述为一个最大化可用性问题。</li>
<li>开发了 CSP 算法来解决一个困难的组合优化问题。CSP 算法的特点之一是分布式的处理原则，适用于在地理位置上分散的边缘节点。基于吉布斯采样实现，一个马尔可夫链蒙特卡洛算法。创新点在于使用图上色理论来允许并行地进行吉布斯采样，加速了算法的收敛。</li>
<li>采取了合作博弈理论来探索在合作式服务配置时自私的战略行为。为了推广协作服务放置，使用了激励机制。开发了一种分布式的同盟建立算法，并证明是帕累托最优的稳定合作。</li>
</ol>
<p>以前研究的缺陷：</p>
<ol>
<li>传统的在云服务器上部署 VM 时研究的服务共享无法直接应用到 MEC，因为移动的网络更加不稳定，最优解往往是空间耦合并且暂时的。</li>
<li>先有的集中式的解决方案将问题描述为一个整数线性规划问题，并且利用集中式的方式进行计算。</li>
<li>原有的联合优化问题下假设了边缘节点支持范围没有重叠覆盖的区域。</li>
</ol>
<h2 id="建模">建模</h2>
<h3 id="网络建模">网络建模</h3>
<p>BS，或者说边缘服务器，从 $1$ 编号到 $N$。<br>
对于每个 $BS_n$ 来说，都被一组用户设备（UE）订阅了，这个集合 $\mathcal M_n$ ，这些设备被允许该 $BS_n$ 访问信号和计算资源。<br>
每一个 $UE$ 实际上都是被一个服务计划（商业的 BS）或者拥有者（自有的 BS）决定的。<br>
对于 $\mathcal M_n$ 中的每个 UE 而言，$BS_n$ 被成为他们的 $home BS$。<br>
例如在一个有很多层的大楼内，每个房间都部署了一个 a small cell BS（可能是 Femtocell，家庭基站），而 UE 可能是移动设备，传感器或者其他的需要联网和计算服务的智能设备。<br>
由于 small-cell BS 的密集部署，一个 UE 可能在多个其他 BS 的覆盖范围内。对于每个 BS 来说，它们可以开启 OSG（open subscriber group）模式，允许服务其他订阅的 UE。一开始我们假设所有的 BS 都处于 OSG 模式。<br>
对于 $UE_m$，我们用 $\mathcal N_m$ 表示可以通信的 BS 集合。<br>
对于 $BS_i$ 和 $BS_j$ 来说，如果存在一个 $UE_m$ 使得 $i,j\in\mathcal N_m$ ，我们就它们两个是邻居，换句话说它们两个是可以合作地服务于至少一个 UE。<br>
通过以上定义，我们可以把网络抽象为一个无向图 $G=\langle \mathcal N, \mathcal \varepsilon \rangle$，在这里 $\varepsilon$ 指代边的集合。当两个 BS 为邻居时，两者之间有边。<br>
我们使用 $\Omega_{i,1}$ 和 $\Omega_{i,2}$ 来分别表示 $BS_i$ 在一跳和两跳范围内的邻居。</p>
<h3 id="边缘服务建模">边缘服务建模</h3>
<p>边缘服务器都是用虚拟化的技术来提供执行的环境，通常来说时 VM 和 Docker 的容器提供的服务放置。如果一项服务应用需要被放置在 BS 处，那么就需要由操作员来根据对应的资源需求来进行设置。服务的资源需求通常是由服务提供者预先决定好的。<br>
考虑到服务的异构性，我们假设这里有 K 种服务，$\mathcal K = {1,2,…,K}$。<br>
由于一台边缘服务资源的限制，不可能同时部署所有种类的服务，我们假设处理器的能力是资源分配的主要限制。设定 $p_k$ 表示服务 $k$ 的处理器需求，$P_n$ 表示 $BS_n$ 能提供的处理器能力。<br>
对于一个服务放置决定 $a_n \subseteq \mathcal K$ 对于 $BS_n$ 来说是可实现的，只有在 $\sum_{k\in a_n} p_k \le P_n$ 为真，即部署在该 BS 上的所有服务的处理器需求总和要小于这个 BS 所拥有的处理器能力。</p>
<p>假设 $a_n \in \mathcal F_n$ 是当前 $BS_n$ 的服务放置决策，那么对于当前系统而言，服务放置状态可以表示为 $a = {a_1,…,a_N}$</p>
<h3 id="计算卸载建模">计算卸载建模</h3>
<p>主要分为两种 user-to-edge 的卸载和 edge-to-cloud 的卸载。</p>
<h4 id="Edge-offloading">Edge offloading</h4>
<p>采用了一种简单的卸载策略，每个 UE 接受服务放置和合作决策作为输入，目标是最大化 QoS。</p>
<p>$d_{m,k}$ 表示 $UE_m$ 在当前情况下对服务 $k$ 的需求。<br>
$d_m={d_{m,1},d_{m,2},…d_{m,K}}$ 表示 $UE_m$ 对所有服务的需求情况。</p>
<p>BS 可以轻松获得这个 d，要么在决策前提前询问每个 UE，要么通过预测算法直接进行预测。</p>
<p>根据系统的服务放置状态 $a$，我们用 $B_{m,k}(a)\subseteq\mathcal N_m$ 表示 $UE_m$ 想要获取服务 $k$ 的可访问的 BS。<br>
$d_{m,k}$ 被卸载至 $B_{m,k}(a)$ 中拥有最佳的上行通道的 BS，我们表示为 $argmax_{n\in\mathcal B_{m,k}(a)}H_{m,n}$ ，这个式子中的 $H_{m,n}$ 表示 ${UE_m}$ 和 $BS_n$ 之间的信道质量。</p>
<p>$\mathcal B_{m,k}(a) = \emptyset$ 表示 $UE_m$ 无法获取它想要的服务 $k$。这种情况下，$d_{m,k}$ 将会通过 $UE_m$ 的 home BS 被卸载到云端。<br>
$v_{m,k}(a)\in\mathcal N_m$ 用来表述 $UE_m$ 为了获取服务 $k$ 需求最终请求的 BS。<br>
${n_m}$ 表 $UE_m$ 的 Home BS。</p>
<p>给定卸载决策，我们可以将 $BS_n$ 收到的关于服务 $k$ 的请求表示为：<br>
$\hat{\phi}<em>{n,k}(a)=\sum</em>{m\in\mathcal M}d_{m,k}·1{v_{m,k}(a) = n}$<br>
这里的 $1{·}$ 是一个指示函数（真为1，假为0）。</p>
<h4 id="Cloud-offloading">Cloud offloading</h4>
<p>同样使用了现有的云卸载决方案。<br>
$\bar\phi_{n,k}$ 表示 $BS_n$ 的最大负载限制，即 $BS_n$ 对服务 $k$ 能处理的最大需求数量。<br>
综合以上两个变量，总结出 $BS_n$ 处理的服务 $k$ 的请求：<br>
$\phi_{n,k}(a)=\left{ \begin{aligned} min(\hat{\phi}<em>{n,k}(a),\bar\phi</em>{n,k}),if k \in a_n \ 0, if k\notin a_n\end{aligned}\right.$</p>
<p>$BS_n$ 收到但是卸载到云端进行的对服务 $k$ 的请求 $\psi_{n,k}(a) = \bar\phi_{n,k}(a) - \phi_{n,k}(a)$</p>
<h3 id="Utility-model">Utility model</h3>
<p>BS 在提供更加优质的服务时，我们可以认为 BS 应该获得更好的回报，服务的质量的关键因素是延迟。对于服务 $k$ 可以获得收益定义为 $\mu_k(y_k)=u_k-w_Y\cdot y_k$。<br>
$u_k$ 是完成任务 $k$ 的收益常量，$y_k$ 是提供服务的延迟，$w_Y$ 是延迟的比重。这个延迟包含了传播时延和计算延迟。</p>
<p>$UE_m$ 和 $BS_n$ 之间的传输速率可以计算：<br>
$r_{m,n} = W \log_2(1+\frac{P_m^{tx}H_{m,n}}{N_0+I_{multi-user}+I_{Inter-cell}})$<br>
$W$ 是信道带宽，$P_m^{tx}$ 是传输功率，$H_{m,n}$ 是 $UE_m$ 和 $BS_n$ 之间信道的传输能力，$N_0$ 是噪声功率，$I_{multi-user}$ 和 $I_{Inter-cell}$ 分别是多用户和多基站的干扰。这两个变量通常可以用先进的干扰抑制技术减轻。</p>
<p>假设$BS_n$ 都是固定的传输速率 $r_n$，传输任务 $k$ 的延迟可以表示为 $y_{Ex,n,k}=\lambda_k/r_n$，$\lambda_k$ 是传输的任务的数据量。</p>
<p>从 BS 卸载至云端的额外传播延迟表示为 $y_{C_x,k}=\lambda_k/r_b$，$r_b$ 表示预期的主干网的传输速率。我们假设结果数据量非常小，下载的传播延时可以忽略不计。在边缘服务器上，服务 $k$ 的计算延迟主要是通过 CPU 进行计算所花费的开销，表示为 $y_{E_m,k}=\gamma_k/p_k$，$\gamma_k$ 表示完成这项任务需要的 CPU 周期，$p_k$ 是边缘服务器分配给服务 $k$ 的处理器频率。<br>
云服务器的计算资源较为丰富，忽视云服务器上的阻塞延迟。云服务器上的计算延迟表示为 $y_{C_m,k}=\gamma_k/p_{c,k}$ ，这里的 $p_{c,k}$ 表示的是云服务器分配给服务 $k$ 的处理器频率。<br>
最终我们可以分别计算出服务 $k$ 在边缘和云端处理的延迟 $y_{E,n,k}$ 和 $y_{C,n,k}$<br>
在边缘服务器上，就是边缘的传播延迟+边缘的处理延迟。<br>
在云服务器上，就是边缘的传播延迟+云的传播延迟+云的处理延迟。</p>
<p>对于 $BS_n$ 来说，它最终做出的贡献相当于提供的所有服务的收益之和 $R_n(a)$。</p>
<p>BS 的开销主要包含两个方面：边缘服务器的能源消耗和使用云服务器的支出。<br>
$BS_n$ 在处理任务 $k$ 的时候消耗的能量：$E_{n,k}=\mathcal k_n\gamma_k(p_k)^2$，$\mathcal k$ 是由边缘服务器架构决定的能源系数。<br>
$BS_n$ 的总能源消耗表示为 $C_{E,n}(a)=\sum_{k=1}^{K}E_{n,k}\cdot \phi_k(a)$<br>
同理将 $h$ 定义为在云服务器上的一个工作单位的价格，可以同样计算出云服务器上的开销。</p>
<p>对于 $BS_n$，它的效益 $U_n$ 就是通过总的收益减掉边缘服务器的能源消耗和云服务器的支出。</p>
<h3 id="非协作式服务放置">非协作式服务放置</h3>
<p>对于每个 BS 来说最终的优化目标方程总结为：<br>
<img src="https://cdn.ethanloo.cn/img/202209231414432.png" alt=""></p>
<p>12a 表示最大化 K 个服务所能产生的最大效益，这个效益是由服务提供数量，延迟，卸载决策，能源消耗一起决定的。</p>
<p>12b 表示在提供某个服务的时候，要低于请求数和能接受的请求上限。</p>
<p>12c 表示只有 Home Server 为 UE 提供服务。</p>
<p>12d 表示确保当前的服务放置策略是可行的。</p>
<h2 id="协作式服务放置模型">协作式服务放置模型</h2>
<p>通过一系列推倒，我们可以将最终的优化目标总结为下式。<br>
<img src="https://cdn.ethanloo.cn/img/202209260935958.png" alt=""><br>
我们希望，通过尝试不同的服务放置组合，即穷举服务放置矩阵 $a$ 来尽可能减少整个系统总的开销。但是穷举的方式时间复杂度太高了，本论文尝试使用并行的吉布斯采样算法进行优化。</p>
<h3 id="涂色-吉布斯采样">涂色+吉布斯采样</h3>
<p>吉布斯采样是用来生成网络服务放置矩阵 $a$ 的概率分布，通过逐个扫描每个 BS，从概率分布中进行采样确定它的服务放置决策，保证其余的 BS 的服务放置决策固定不变。</p>
<p>吉布斯采样获取的概率分布一定是和 $e^{-\sum_n{C_n(a)/\tau}}$ 成正比的，可以简单的理解为，越低的系统开销应该会有越高的概率被选择。这里的 $\tau$</p>
<p>单纯的使用吉布斯采样的缺陷：</p>
<ul>
<li>因为每次只能计算一个的概率分布，所以如果 BS 数量较多，就会需要花很多时间进行循环</li>
<li>这个算法的前提是每个 BS 知道整个系统的情况，但实际上在论文假定的密集小型基地网络环境下是基本不可行的。<br>
之所以没办法直接进行并行的吉布斯采样的原因是没办法保证收敛至吉布斯分布。</li>
</ul>
<p>因此，论文基于 MRF 理论和图上色理论，来为 BS 进行分组，在不影响最终目标的情况下尽可能的实现并行计算。<br>
Markov Blanket，中文翻译为马尔可夫毯，每一个 BS 都有一个马尔可夫毯，马尔可夫毯是一个 BS 集合，在这个集合外的所有 BS 的服务决策分配将不会对该 BS 的概率分布产生影响。<br>
论文提出，在这个马尔可夫随机场内，每个 BS 的马尔可夫毯就是 2 跳以内的所有相邻 BS 的子集。因此，计算某个 BS 的概率分布的时候，所有不相邻的 BS 都不会影响他的最终决策。</p>
<p>因此，根据网络拓扑图，我们可以将所有的 BS 分成若干组，保证每个组内的 BS 进行决策时互不干扰。并且，为了让并行性更高，我们肯定是希望分的组数越少越好（每个组内的 BS 尽可能多一些）。<br>
纯粹的着色问题求解难度是 NP-hard，但是 BS 网络拓扑结构通常每个节点的度都比较小，每个 BS 的邻居比较少，因此可以使用现有的图着色算法进行求解。本文使用了 sequential coloring algorithm 来生成图的着色情况。</p>
<p><img src="https://cdn.ethanloo.cn/img/202209261155274.png" alt=""><br>
在上一次迭代的最后，绿色的 1 和 4 号在更新完自己的服务放置决策之后，把自己的最新决策告诉给了 2-hop 以内的 BS。<br>
本次迭代更新蓝色的 2 和 5 号，已知 2-hop 内所有 BS 的当前决策的总 cost，即可计算本 BS 的服务放置决策概率分布，根据概率分布进行采样（概率越大越容易被选中，只有能让总cost减小的决策才会有更大的概率）。<br>
更新完成后，在本次迭代结束前，将自己的最新决策告诉 2-hop 以内的其他 BS，以便于在下一次迭代过程中计算他们的概率分布。</p>
<h2 id="自私基站模型">自私基站模型</h2>
<p>每个联盟的 value function 定义为，当合作只发生在联盟内部时所能获取的最大效益。<br>
想要计算这个效益，可以通过上文的 CPGS 算法，把这个联盟看作一个系统，计算最优服务放置方案来获得最大效益。</p>
<p>这篇文章定义了两种合作模式：</p>
<ol>
<li>纯合作，通过完成的任务和开销之差直接计算效益。合作相对较弱，因为没有额外收益。</li>
<li>激励式合作，通过激励方案，将系统所能收获的最大效益分配给系统内的 BS。根据 proportional fairness division 来决定分配的效益，将通过合作额外获得的系统效益按比例分配给 BS。</li>
</ol>
<p>每个参与到合作里来的 BS，都会获取更多的效益，这个效益按照下面这个公式计算：<br>
<img src="https://cdn.ethanloo.cn/img/202209261257840.png" alt=""><br>
前面这个系数代表了自己的贡献比例，每个联盟里的系数和为 1，一般来说，自己贡献越多，则获取的比例越大。</p>
<p>Stable Coalition：一个稳定的联盟，联盟内的基站不会因为激励措施而离开当前的联盟去成立一个新联盟。让联盟内的所有基站都获得更高的效益，对于稳定来说是必要不充分条件。</p>
]]></content>
      <categories>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>服务放置</tag>
        <tag>边缘计算</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次DIY装机小结</title>
    <url>/post/2022-06-03-Diaries/%E7%AC%AC%E4%B8%80%E6%AC%A1DIY%E8%A3%85%E6%9C%BA/</url>
    <content><![CDATA[<p>又一次好久不见，先汇报一下近况。<br>
五月底又重新开始在 MS 打工了，趁今年答辩完到开始读研期间找点事情做。<br>
几乎同一时间学校也通知了返校，目前正在和 npy 体验最后一个月的校园生活（封校限定）。</p>
<h2 id="配件挑选">配件挑选</h2>
<p>先贴一张最后下单的配置清单吧。</p>
<p><img src="https://cdn.ethanloo.cn/img/202206042226248.png" alt=""></p>
<p>简单概括从零到购买的几个任务：</p>
<ol>
<li>总结自己的需求。</li>
<li>通过 B 站视频/知乎/博文的方式了解主流配置单和相关配件的性能。</li>
<li>浏览 JD，PDD，TB 各个店铺，通过比价软件确认此时的价格情况。</li>
<li>利用 Excel 或者其他表格软件整理几套自己心仪的配置清单。</li>
<li>重新确认自己的需求，最后选择配件下单。</li>
</ol>
<h3 id="确认需求">确认需求</h3>
<p>回到第一步，确认<strong>需求</strong>。作为软件工程的学生，「需求」这个词可以说已经刻入骨髓了。作为一种相当主观的东西，需求<strong>大概率</strong>会在你后续挑选配件的过程中发生变化，你了解得越多，你的选择越多，自然而然，原本没有的需求也会被创造出来。因此，前期一个大致的需求描述就够用了。<br>
对我而言，需求可以简单总结为「高性价比，低颜值，相对便携」。</p>
<h3 id="了解主流">了解主流</h3>
<p>作为一个计算机专业的学生，我对硬件的接触可以说是相当少了。即使初三暑假购买并更换过一张显卡，高一的时候参加过拆机课（究极古董机），高二的时候给教室的主机更换了一张固态，大二的时候学习了计算机硬件基础。我也没有对电脑主机有过任何完整或者系统的了解。<br>
通过看视频，读博文，大概清楚了装机需要的基本配件：主板、CPU、内存条、硬盘、电源、散热器、机箱、显卡（可选）。</p>
<blockquote>
<p>这里推荐一个 B 站 UP 主 <a href="https://space.bilibili.com/10485312">ZoveyChen的个人空间_哔哩哔哩_bilibili</a>，日常更新硬件比价视频，也有主流的配置单推荐。</p>
</blockquote>
<p>具体内容可以去观看各种视频了解，我这边了提几个值得注意小 tips。</p>
<ul>
<li>主板和 CPU 通常会一起买，不仅是因为会有一些小优惠，还因为不同的主板支持不同的 CPU，例如 B550 主板支持 AMD 家的 CPU，B660 只支持 Intel 家的 CPU。</li>
<li>不玩游戏可以暂时不买显卡，矿潮刚过，价格仍过高。</li>
<li>不同级别的 CPU 和显卡需要的电源功率也不一样。</li>
<li>如果准备像我一样购买小尺寸的机箱，需要注意对应机箱支持的显卡/散热器/电源的尺寸。</li>
</ul>
<h3 id="比价下单">比价下单</h3>
<p>在比价的过程中发现了一个很神奇的事情，虽然时代在进步，硬件性能在提升，但是实际上几乎所有的配件的价格都或多或少比以前便宜 📉（DDR5 内存条和矿潮下的显卡除外）。至少在考虑通胀的情况下，想要组装一台当前主流的配置的花销，是比以往显著要少的。<br>
例如，在我印象中，固态硬盘是很奢侈的，一般来讲 1GB 的容量等价于 1 RMB。然而这次我买的铠侠 RC20 1TB 的国产固态硬盘，竟然只需要500+。<br>
这里要说明的是，虽然看了好几天的 B 站 zovey 的比价视频和其他 up 主的评测，但是本人没什么耐心并且返校时间较紧张，在确定配件的选择后便匆匆下单了，导致配件的价格和史低还是有差距。<br>
其中内存条「酷兽 金甲 3200 16G * 2」我在 jd 旗舰店下单了两条总共是 618 元，然而六月一号，pdd 旗舰店两条同样配置的内存条竟然只要530+。不过也并不需要后悔，毕竟我也有一半是生产力需求，早买早享受。</p>
<blockquote>
<p>这里吐槽一下 BJMS 给远程的实习生发的电脑，竟然是 2014 年的 thinkpad x1，2核CPU，2G 内存！别说 local dev 了，无线网卡都能时常断连。</p>
</blockquote>
<h2 id="装机">装机</h2>
<p>装机也还算顺利，攒快递，拆快递，跟着 B 站的装机视频，装 CPU，涂硅脂，装散热，连电源，塞进机箱，盖上机箱盖子，插电，按开机键。</p>
<p><img src="https://cdn.ethanloo.cn/img/202206051946227.webp" alt=""></p>
<p>所有配件塞进机箱的样子：</p>
<p><img src="https://cdn.ethanloo.cn/img/202206051950241.webp" alt=""></p>
<p>唯一卡住我的竟然是最后的装系统，由于手边没有合适的 U 盘，我直接拿我的 500G 固态硬盘进行了一波装机。一开始图快，用的第三方 U 盘媒介创建工具，结果电脑点不亮。通过查看主板上的故障指示灯，发现是 Boost 灯亮，说明是 U 盘问题，最终换了个微软官方的工具初始化了 U 盘，终于是把电脑给点亮了。<br>
因为不太喜欢光污染没有购买额外的 RBG 配件，所以机箱里唯一会亮的只有主板上的一个小绿灯。</p>
<p><img src="https://cdn.ethanloo.cn/img/202206051951448.webp" alt=""></p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title>最后的本科时光</title>
    <url>/post/2022-03-28-Diaries/%E6%9C%80%E5%90%8E%E7%9A%84%E6%9C%AC%E7%A7%91%E6%97%B6%E5%85%89/</url>
    <content><![CDATA[<h2 id="近况">近况</h2>
<p>哎呀，一不小心三个月没更新了，疫情在家的时光过得飞快。</p>
<p>从去年十二月初从微软离职，我本以为就过上了轻松愉快的本科养老生活，和npy一块快乐学习和玩耍的时间至少可以持续到毕业🥳。没想到，开学前的一波疫情直接导致快乐生活被终结。由于疫情的时间太巧直接线上开学，我们甚至连被封在学校里的机会都没有。虽然我们俩同处一个大市，但是40公里的距离和疫情导致的大巴停运也让我们寒假期间两次的相聚显得尤为珍贵。</p>
<p>既然没办法一起去学校，那就一起出去玩。我投了几个想去玩的城市的实习，包括重庆、成都和广州等等，准备抓紧时间实习和旅游两不误。结果嘞，由于本人学术不精，唯一给我面试机会的广州字节没通过，被迫变身家里蹲😤。</p>
<p>所以到头来，从今年一月到今天三月二十八，我做了些啥呢？虽然本质上宅在家，但是我还是强迫自己做了一些项目，顺便当了几个礼拜的网瘾少年（Switch限定版）。</p>
<h2 id="程序员生活">程序员生活</h2>
<p>不得不感叹一下，在寒假前把显示器从学校带回了家里的我简直是个天才🥹。有了27寸4K显示器，写代码都带劲了很多。</p>
<blockquote>
<p>当然，用大屏幕看电影和玩游戏也很带劲。</p>
</blockquote>
<p>在去年年底，我就开始为我的毕设做一些简单的技术选型，由于未来我仍然准备从事前端相关的开发工作，所以我选用了一些比较新的技术栈去开展和完成了自己的项目，一个前端基于 Svelte 实现的碎片信息聚合平台。</p>
<p>大致的技术栈说明：</p>
<ul>
<li>前端：Svelte3 + Vite + TypeScript + Tailwind + Vercel</li>
<li>后端：Express.js + MongoDB</li>
<li>爬虫：Python</li>
</ul>
<p>Github: <a href="https://github.com/EthanLuu/soo-share-svelte">EthanLuu/soo-share-svelte (github.com)</a></p>
<p>Online Demo: <a href="https://share.ethanloo.cn">https://share.ethanloo.cn</a></p>
<p><img src="https://cdn.ethanloo.cn/img/202203282312629.png" alt="image-20220328231240596"></p>
<p>由于开发过程中并没有做详细的笔记，所以大概率不会单独为这个项目写一篇博文了，不过我的毕业论文大体已经完成了（虽然有水论文的嫌疑），我应该会在毕业之后把论文分享在博客里。</p>
<p>近期我也在完成一个五金电器店铺网站的开发，主要是学习一下 Next.js 的使用，顺便帮我的舅舅开发一个面向搜索引擎的店铺网站。</p>
<h2 id="宅男生活">宅男生活</h2>
<p>除了碎片式的学习时间，宅在家更多的时间其实是游戏+动漫+电影。</p>
<p>由于身边只有一台 MacBook，我并没有办法去体验老头环，只能以云玩家的形式观看老菊的老头环实况。平常只能用那台大学入学买的 Mi Pro 笔记本去和同学打打 LOL。</p>
<p>还好身边有台 Swtich 可以让我能沉浸式体验更多游戏，先后入手了塞尔达传说、马里奥奥德赛、马里奥3D世界、宝可梦阿尔宙斯、异度之刃2，虽然游戏小贵，但架不住确实好玩。</p>
<p><img src="https://cdn.ethanloo.cn/img/202203290854737.jpeg" alt="2021040123173500-57B4628D2267231D57E0FC1078C0596D"></p>
<p>追番情况的话就比较纯粹，一月番只追了巨人最终季和鬼灭之刃，由于这两部质量实在太高，导致无法接受其他番剧了🫣。</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title>毕业论文选题之前端技术栈探索</title>
    <url>/post/2021-12-10-Weber/%E5%89%8D%E7%AB%AF%E6%96%B0%E5%9E%8B%E6%8A%80%E6%9C%AF%E6%A0%88%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>随着实习的告一段落，即将迎来本科阶段的最后一个学期。</p>
<p>在这之前，还有一项非常重要的工作要做：<strong>毕业设计选题</strong>。稍加思索，虽然未来研究生阶段会进行边缘计算方面的学习，但是最终还是选择了将自己的毕业设计定题在前端的领域，来为我本科阶段画一个句号。🛫</p>
<blockquote>
<p>在这里非常感谢 Mirone 大佬为我引出前端如此新颖的技术栈和无限多的可能性，在这里也给大佬的 Github 项目做个小推广，一年不到就收割了 5k star 的在线 markdown 编辑器：<a href="https://github.com/Saul-Mirone/milkdown">Saul-Mirone/milkdown: 🍼 Plugin driven WYSIWYG markdown editor framework. (github.com)</a></p>
</blockquote>
<p>作为一次简单的初探，本文会借鉴包括官方文档在内的许多线上资源，会依次放入最后的参考文档列表中。</p>
<h2 id="Svelte">Svelte</h2>
<p><a href="https://svelte.dev/">Svelte • Cybernetically enhanced web apps</a></p>
<p>官网的首页就写着这个框架最自豪的三大特点（感觉是故意地在针对市场主流的那两个框架一样</p>
<ol>
<li>write less code</li>
<li>no virtual dom</li>
<li>truly reactive</li>
</ol>
<p>在描述自己的时候，Svelte 甚至也强调了自己不像 React 和 Vue 那样的「传统框架」一样将大量的工作让浏览器去完成，而是在编译阶段处理。</p>
<blockquote>
<p>听起来有点像 Web Component？</p>
</blockquote>
<p>作者分别针对他所自豪的三大特点写了三篇博文来进行具体的阐述。</p>
<h3 id="更少的代码">更少的代码</h3>
<p>更少的代码量意味着什么？作者给出了他的答案：<strong>更少的 BUG 和更少的项目开发时间</strong>。</p>
<p>确实，为了能实现同样的功能，如果代码能写的更简洁，在一屏高度以内的组件代码可读性也会更加的高。</p>
<p>为了证明能比 Raect 和 Vue 用更短的代码实现同样的功能，最有力的方法当然是写个例子。</p>
<p>作者用那个经典「计数器」来证明了这一点。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">let</span> a = <span class="number">1</span>;</span></span><br><span class="line"><span class="language-javascript">	<span class="keyword">let</span> b = <span class="number">2</span>;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">bind:value</span>=<span class="string">&#123;a&#125;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">bind:value</span>=<span class="string">&#123;b&#125;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;a&#125; + &#123;b&#125; = &#123;a + b&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这里就不贴 React 和 Vue 版本的计数器了，博文里统计了三个版本计数器所需要的字符数。</p>
<ul>
<li>React: 442</li>
<li>Vue: 263</li>
<li>Svelte: 145</li>
</ul>
<blockquote>
<p>绝了，看到这里我就心动了，简直是偷懒神器了</p>
</blockquote>
<p>除了这个经典样例以外，作者也通过痛点分析（竞品？）的方式指出了 React 和 Vue 存在的几个问题：</p>
<ol>
<li>对于 React 和 Vue 而言，他们只允许有一个顶层元素，即使有着 <code>&lt;&gt;&lt;/&gt;</code> 和 <code>&lt;template&gt;</code> 来去包裹多个元素，这种解决方式也是冗余且不优雅的。</li>
<li>在 binding 上，React 必须要手动处理包括 input 在内的许多事件，把 <code>value=&#123;a&#125;</code> 和 <code>setA(a + 1)</code> 这两个逻辑相关的代码存放在两个相距很远的地方。Vue 则需要标注成 <code>v-model.number</code> 来确保变量是以数值的形式保存的。</li>
<li>状态管理方面，React 使用 useState，对于每一个状态而言都要用一个变量和另一个保存状态的函数去进行更新操作。Vue 则需要导出一个 data 函数。</li>
<li>再见👋模板文件，告别了 React 的 <code>useMemo</code>, <code>useCallback</code> 和 <code>useEffect</code>。Svelte 作为一个编译器，可以在很多方面脱离 JavaScript 的限制，开发时候更多的使用变量，而不是 proxies 和 hooks。</li>
</ol>
<h3 id="告别-Virtual-DOM">告别 Virtual DOM</h3>
<p><a href="https://svelte.dev/blog/virtual-dom-is-pure-overhead">Virtual DOM is pure overhead (svelte.dev)</a></p>
<p>在阅读这篇文章之前，我确实觉得 Virtual DOM 就是未来的趋势了，不过作者非常明确地告诉我们，Virtual DOM 并不是必须的，相反，操作 Real DOM 也可以带来同样甚至更高的 Performance。</p>
<p>在 2013 年的一个演讲中，React 的开发者之一 Pete Hunt 提出，直接操作 DOM 会有许多 performance 上的工作，非常的缓慢。自此之后，就掀起了对 Virtual DOM 的狂热 (meme) 之中。</p>
<blockquote>
<p>This is actually extremely fast, primarily because most DOM operations tend to be slow. There’s been a lot of performance work on the DOM, but most DOM operations tend to drop frames.</p>
</blockquote>
<p>但是 Svelte 的作者指出，这种性能上的提升仅仅只能和过去的框架或者说是跟稻草人 (a straw man) 在做比较。因为以前的框架意味着每次子状态的更新，都会 rerender 整个 app。</p>
<p>Pete 也在那次发布会之后澄清说，React 不是魔法，只是让你开发的时候不需要考虑性能的问题，并且在默认状态下就够快。</p>
<p>作者尝试分析了对于一个 DOM 树来说，什么才是经常性开支 (overhead)。</p>
<blockquote>
<p><a href="https://twitter.com/pcwalton/status/1015694528857047040">diffing isn’t free</a>.</p>
</blockquote>
<p>意思是，在更新一个结点时候，要判断更新的部分的筛选工作是非常昂贵的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function HelloMessage(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;greeting&quot;&gt;</span><br><span class="line">      Hello &#123;props.name&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于上面这个组件来说，如果我们更新 <code>props.name = &quot;world&quot;</code>，那么需要执行以下三步：</p>
<ol>
<li>新旧的两个 snapshots (快照) 都包含了 <code>&lt;div&gt;</code>，所以更新的时候要保留 DOM 结点。</li>
<li>遍历新旧的所有属性，发现两者的 <code>className</code> 都等于 <code>greeting</code>。</li>
<li>深入到结点的内层，发现结点的 text 改变了，所以更新 real DOM。</li>
</ol>
<p>在这三步中，只有第三步才是真正有价值的，有没有办法只进行第三步而不需要前两步呢？如果我们能在变更 <code>props.name</code> 的时候，直接去进行第三步。</p>
<p>作者指出，Svelte 是这么做的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (changed.<span class="property">name</span>) &#123;</span><br><span class="line">  text.<span class="property">data</span> = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了在 diff 上有优化以外，React 还有一点是让人不满意的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function MoreRealisticComponent(props) &#123;</span><br><span class="line">  const [selected, setSelected] = useState(null);</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;Selected &#123;selected ? selected.name : &#x27;nothing&#x27;&#125;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;props.items.map(item =&gt;</span><br><span class="line">          &lt;li&gt;</span><br><span class="line">            &lt;button onClick=&#123;() =&gt; setSelected(item)&#125;&gt;</span><br><span class="line">              &#123;item.name&#125;</span><br><span class="line">            &lt;/button&gt;</span><br><span class="line">          &lt;/li&gt;</span><br><span class="line">        )&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，这个父组件会通过遍历 <code>props.items</code> 生成了许多子 virtual DOM。这就导致在更新父组件的状态的时候，无论 <code>props.items</code> 变化与否，最终都会重新生成一次子列表。只有对性能要求极高的人才会发现或者愿意去进行优化。</p>
<blockquote>
<p><a href="https://reactjs.org/docs/hooks-intro.html">React Hooks</a> doubles down on defaulting to doing unnecessary work, with <a href="https://twitter.com/thekitze/status/1078582382201131008">predictable results</a>.</p>
</blockquote>
<p>Svelte 也在这点上做出了优化，避免开发者陷入这种境况。</p>
<h3 id="重新思考-Reactivity">重新思考 Reactivity</h3>
<p><a href="https://svelte.dev/blog/svelte-3-rethinking-reactivity">Svelte 3: Rethinking reactivity</a></p>
<p>强烈推荐 Svelte 作者在 2019 年推出 Svelte 3 的时候的这期讲座：<a href="https://www.youtube.com/watch?v=AdNJ3fydeao">Rich Harris - Rethinking reactivity - YouTube</a>，FANTASTIC!!🤩</p>
<p>Reactivity 该怎么翻译呢，反应能力？反应程度？</p>
<p>Anyway，我简单的理解就是，当一个变量发生变化的时候，其产生的化合作用同步使整个程序发生变化的能力。</p>
<p>例如在 React 中，我们使用 useState 钩子函数来进行状态管理，已实现状态和结点显示的内容能同步发生变化。</p>
<p>在 Svelte3 中，完全可以跳过这样的钩子函数，用不到 proxy 和 accessory，直接通过一行代码实现。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">count += <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>会被编译成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">count += <span class="number">1</span>; $$invalidate(<span class="string">&#x27;count&#x27;</span>, count);</span><br></pre></td></tr></table></figure>
<h2 id="RXJS">RXJS</h2>
<blockquote>
<p>说实话，比较难理解，适用范围可能也相对不那么广。</p>
</blockquote>
<p><a href="https://rxjs.dev/guide/overview">RxJS - Introduction</a>，一开始是 Microsoft 发布的一款开源库，后来由社区维护。</p>
<p>这是一个 JavaScript 的库，用来处理一些「异步」和「基于事件」的编程。结合了「观察者模式」、「迭代器模式」和「使用集合的函数式编程」。</p>
<p>在这个库里有几个基础的概念，我这边就直接复制粘贴中文站的翻译：</p>
<ul>
<li><strong>Observable (可观察对象):</strong> 表示一个概念，这个概念是一个可调用的未来值或事件的集合。</li>
<li><strong>Observer (观察者):</strong> 一个回调函数的集合，它知道如何去监听由 Observable 提供的值。</li>
<li><strong>Subscription (订阅):</strong> 表示 Observable 的执行，主要用于取消 Observable 的执行。</li>
<li><strong>Operators (操作符):</strong> 采用函数式编程风格的纯函数 (pure function)，使用像 <code>map</code>、<code>filter</code>、<code>concat</code>、<code>flatMap</code> 等这样的操作符来处理集合。</li>
<li><strong>Subject (主体):</strong> 相当于 EventEmitter，并且是将值或事件多路推送给多个 Observer 的唯一方式。</li>
<li><strong>Schedulers (调度器):</strong> 用来控制并发并且是中央集权的调度员，允许我们在发生计算时进行协调，例如 <code>setTimeout</code> 或 <code>requestAnimationFrame</code> 或其他。</li>
</ul>
<p>从官网的例子大概能看出来它的主要作用，就是将许多功能包装好，让开发人员可以自由添加到事件处理中去，包括点击的时候更新数组，节流，去重等等。</p>
<h2 id="ReasonML">ReasonML</h2>
<p><a href="https://www.imaginarycloud.com/blog/reasonml-react-as-first-intended/">ReasonML - React as first intended (imaginarycloud.com)</a>，Facebook 用来开发 React 的一项技术。</p>
<p>一开始，Facebook 在开发 React 原型的时候，用的是一个叫做 Stand ML 的编程语言，后来由于语言的小众性，在开发完原型后使用 JavaScript 进行开发。</p>
<p>在一段时间内，一款叫做 BuckleScript 的编译器被发明了出来，可以将原始的 Ocaml 快速地编译成 JavaScript。</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">(* A Factorial implementation in BuckleScript / O&#x27;Caml *)</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> factorial n =</span><br><span class="line">  <span class="keyword">if</span> n &lt;= <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    n * fact(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>鉴于 React 的热度，Facebook 的开发团队决定将 OCaml 的语义，JavaScipt 的语法和 BuckleScript 的后端编译功能结合起来，创建了一个新的编译器，一种新的编程语言 ReasonML。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A FizzBuzz implementation in ReasonML</span></span><br><span class="line"><span class="keyword">let</span> fizzbuzz = (i) =&gt;</span><br><span class="line">  <span class="keyword">switch</span> ([i <span class="keyword">mod</span> <span class="number">3</span>, i <span class="keyword">mod</span> <span class="number">5</span>]) &#123;</span><br><span class="line">    | [<span class="number">0</span>, <span class="number">0</span>] =&gt; <span class="string">&quot;FizzBuzz&quot;</span></span><br><span class="line">    | [<span class="number">0</span>, _] =&gt; <span class="string">&quot;Fizz&quot;</span></span><br><span class="line">    | [_, <span class="number">0</span>] =&gt; <span class="string">&quot;Buzz&quot;</span></span><br><span class="line">    | _    =&gt; string_of_int(i)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> <span class="keyword">to</span> <span class="number">100</span>) &#123;</span><br><span class="line">  print_endline(fizzbuzz(i));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这门语言是和 JS 如此的相似，以至于某些代码可以写的完全相同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Both valid ReasonML and Javascript code</span></span><br><span class="line"><span class="keyword">let</span> <span class="title function_">add</span> = (<span class="params">a, b</span>) =&gt; a + b;</span><br><span class="line"><span class="title function_">add</span>(<span class="number">4</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<p>除此之外，React 的开发团队也制作了一款包装器，叫做 React Reason，可以在一个 React 应用或者 Reason 应用中将 JS 的组件和 Reason 的组件结合起来。</p>
<p>Redux 作为一款热门的状态管理库，在 ReactReason 中也不被需要了，因为 ReactReason 的无状态组件自带了 reducer。</p>
<p><img src="https://cdn.ethanloo.cn/img/202112182308968.png" alt="cover (1)"></p>
<h2 id="参考文档">参考文档</h2>
<p><a href="https://svelte.dev/">Svelte • Cybernetically enhanced web apps</a></p>
<p><a href="https://svelte.dev/blog/virtual-dom-is-pure-overhead">Virtual DOM is pure overhead (svelte.dev)</a></p>
<p><a href="https://svelte.dev/blog/svelte-3-rethinking-reactivity">Svelte 3: Rethinking reactivity</a></p>
<p><a href="https://rxjs.dev/guide/overview">RxJS - Introduction</a></p>
<p><a href="https://reasonml.github.io/docs/en/what-and-why">What &amp; Why · Reason (reasonml.github.io)</a></p>
<p><a href="https://www.imaginarycloud.com/blog/reasonml-react-as-first-intended/">ReasonML - React as first intended (imaginarycloud.com)</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>南大CS硕 || 浙大SE硕 || 微软SWE</title>
    <url>/post/2021-10-31-Diaries/%E4%BA%BA%E7%94%9F%E6%8A%89%E6%8B%A9/</url>
    <content><![CDATA[<h2 id="Microsoft">Microsoft</h2>
<p>人生第一次面试就是 Dream Company，然后顺利通过了三面拿到实习名额，又在实习三个月后通过转正面试并且收到意向书，真的可以说是意外之喜了。</p>
<p>本应该在九月份结束的实习，我又往后续了三个月，所以到目前为止一共实习了四个月十六天。</p>
<p>在这里简单谈谈自己的实习经历吧。</p>
<p>Onboard 的第一天，就正好遇到我的 mentor 休假了，于是我们组的 leader 来接了我，带我首先认识了一下 team 里的其他同事。第一个星期基本上就是各种配置环境，申请权限，熟悉框架等等。</p>
<p>不得不说，作为一个只在学校实验室和两三个成员合作过小型项目的人，第一次发现开发流程可以做到如此完善又不冗余。感到惊讶的同时我又有一次担心，害怕自己会没办法融入到组内，也害怕自己会写出一些丑陋的代码而不被同事认可。</p>
<p>不过，让人感到安心的是，程序员或许有着某种奇怪的共性。Team 里的各位或活泼，或安静，但是又能感受到每个人都有着包容的理性和感性态度。Anyway，我担心的事情都没有发生，大家都很和善，我的 mentor 也对我的代码风格和质量起到了巨大的帮助作用。</p>
<p>让我印象最深刻的是我 mentor 的一句话：包括软件工程师在内，所有工程师的任务本质上只有一件事：<strong>解决问题</strong>。很纯粹也很易懂的一句话，但是正是这句话给我指明了未来工作的方向和意义。</p>
<p>其他经历就等我十二月份 checkout 之后续写吧。</p>
<h2 id="保研经历">保研经历</h2>
<p>很滑稽的一点是，在大一上学期期末成绩出来之后，我直接被逐出保研人的队列，原因是我思修拿了 D（69分），而我院当时的政策规定拿到 D 或挂科的学生没有保研资格，同时不承认重修成绩。</p>
<p>“得，佛了。” 当时我直接把保研从自己的人生规划划掉了。</p>
<p>2019年底，我准备出国读研，因此报了一个新东方班级准备考托福。原定在2020年3月份的托福考试也疫情泡了汤，好在我并没有把读研看得这么重要，因此我也并没有多着急。</p>
<p>谁知，在2020年中，大二下学期，辅导员又跟我说，我院承认重修成绩，搞得我一时间不知所措，保研，出国读研，就业，成了我当时未来的三个选项。</p>
<p>2020年10月份考了托福，首考出分104，还算满意。</p>
<p>咋办呢，到底走哪路呢？这个问题真的是让一个选择困难症纠结到死。但是本着不想浪费机会的心态（贪），我准备逐个尝试。</p>
<p>首先是就业，</p>
<ul>
<li>
<p>从2020年12月份开始自学前端</p>
</li>
<li>
<p>2021年2月完成了苏州微软暑期实习生的面试</p>
</li>
<li>
<p>并且在3月份正式收到了offer。内推我的学长跟我说，只要不打架就能转正。</p>
</li>
<li>
<p>2021年9月，收到转正意向书。</p>
</li>
<li>
<p>2021年10月30日，HR 来电说明薪资。</p>
<blockquote>
<p>事实证明本科211学历还是不够用的，拿到组内的 strongly recommended 的评价最终也只拿到了白菜价。</p>
</blockquote>
</li>
</ul>
<p>保研这件事严格意义上应该是从大学第一次期中考试就算开始了，因为决定保研与否的重要因素之一就是 GPA。</p>
<p>我并不认为所有的竞争称为卷，因为卷 != 激烈的竞争，卷 == 浪费时间的竞争。</p>
<p>保研整体分两步，第一步需要拿到院内的保研名额，第二步需要拿到外校的保研名额。</p>
<p>从大一到大三，我的 GPA 能稳定在班级前 10%，多亏了 npy 每天拉我在图书馆和通宵自习室从早上八点待到晚上十二点。</p>
<p>除了 GPA 之外，我也在大二和大三分别争取过各种比赛，大创，软件著作权等等。</p>
<p>在有了或多或少省奖国奖，大创项目和软件著作权之后，我们班的其他大佬甚至手中都握有了若干篇论文，并且是会刊而不是一些杂牌的水刊。</p>
<p>不过我并没有多愁自己的院内保研名额，因为班里 79 个人，给 9 个名额，GPA 甚至还是四舍五入，入到 3.9 之后大家都是第一了。</p>
<p>原先我也没有愁外校的名额，我以为浙大南大软院都是点击就送，毕竟是软件，没那么卷。谁能想到我竟然等到系统开放前一天才拿到了南大计院的名额。</p>
<p>图片里是我夏令营报的几所学校的材料：</p>
<img src="https://cdn.ethanloo.cn/img/202110311624961.png" alt="image-20211031162424910" style="zoom:50%;" />
<p>其中武大，同济，上交，清深我都没有入营。南大我报了计院和软院，结果软院没过初审，计院过了初审但是第一次笔试直接把我刷了。华师大入营，没有拿到优营。只有东南软院（苏州）拿到了优营。</p>
<p>2021年暑假边实习边参加夏令营，结果只捞到了一个offer，也有些小郁闷。但是我还是没有慌，毕竟自己可以把微软当作保底。</p>
<p>接着就是九推，我报了南大，浙大，复旦，对于这三所学校，我想去的程度的排序为：复&gt;南&gt;浙。毕竟 npy 在上海，而且上海的实习机会显然比南京多得多。至于南大和浙大的比较，见仁见智。</p>
<p>对于南大，我其实更想去软院读专硕（2年），但是软院又一次把我给拒了，计院给了我面试资格。</p>
<blockquote>
<p>后来我听说，即使填志愿的时候第一志愿写软院，第二志愿写计院，但其实是计院先筛人，软院后捞人。</p>
</blockquote>
<p>参加九推的结果也并不如人意，复旦和南大拿到的候补，浙大拿到了保研资格（虽然是拿到资格里的倒数第四）。</p>
<p>在保研系统开放前一天，南大来电说我候补到了。</p>
<p>保研系统开放当天，还发生了一个非常打击人的乌龙。</p>
<p>系统里需要每个学生和学校的三次握手来完成录取，过程如下：</p>
<ol>
<li>学生填报三所学校</li>
<li>学校给学生发送复试邀请</li>
<li>学生接受复试邀请</li>
<li>学校给学生发送待录取邀请</li>
<li>学生接受待录取</li>
</ol>
<p>一般学校，都只给拿到名额的学生发送复试邀请，然后学生接受复试之后直接发送待录取。</p>
<p>因此，在惊喜地收到复旦的复试邀请以后，我立刻接受了复试邀请，结果等了两个小时，一点待录取的消息都没有。我当时慌了起来，又是给复旦的研招办打电话，又是联系之前负责复试的志愿者同学。研招办回答，复试邀请不等于候补到了，具体还要问负责这个方向的老师。</p>
<p>听到这个回答我简直绝望了，发现自己成了经典半场开香槟结果翻车的典型。通过邮件咨询了我申报方向的老师才得知自己候补不上复旦了，可惜无缘与npy在一个城市读研。</p>
<p>最后的最后，接受了南大的复试邀请，并接受了待录取。未来还很长，微软再见，你好南大。</p>
<img src="https://cdn.ethanloo.cn/img/202110311649175.jpg" alt="mmexport1635670103018" style="zoom:50%;" />
<p><img src="https://cdn.ethanloo.cn/img/202112182310837.png" alt="cover (2)"></p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title>M1 MacBook Pro 20天初体验</title>
    <url>/post/2021-09-23-Diaries/MacBook%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="购买前">购买前</h2>
<p>从七月份开始，由于原来那台小米笔记本偶尔会出现蓝屏的情况，就已经开始犹豫要不要换笔记本了。但是，本质上我开发使用的是公司配的台式机，所以并没有什么紧迫感，只略微增加了一点平常浏览电子产品测评的视频的时间。</p>
<p>最终，随着八月份蓝屏的频率越来越高，还是咬咬牙买了2020款的M1 MBP。</p>
<p>花了两天时间纠结购买途径和配置，逛遍了知乎、B 站，根据自己的需求：</p>
<ul>
<li>中轻度的前端开发</li>
<li>需要使用虚拟机</li>
<li>基本用不到视频剪辑</li>
</ul>
<p>确定了要买 16 GB + 256 GB。</p>
<h2 id="购买时">购买时</h2>
<p>第一次自己购买贵重的电子产品，本来以为可以第一次体验一下花呗分期的快乐（毕竟当时自己才拿了一个半月的工资，还付了房租）。结果发现，我的额度只有2k多，完全没办法用来分期买电脑 👐，无奈之下还是靠爸妈打钱买下了电脑。</p>
<blockquote>
<p>十月份补充，已经把我爸给我打的 8k 全部还给他了。</p>
</blockquote>
<img src="https://cdn.ethanloo.cn/img/image-20210923000350329.png" alt="image-20210923000350329" style="zoom:50%;" />
<blockquote>
<p>虽然下单了，但是还是要感叹一句太贵了吧！！！</p>
</blockquote>
<h2 id="购买后">购买后</h2>
<p>两个字，满意。</p>
<p>高素质的屏幕，接近 12H 的电池续航，简单纯粹的系统体验，B 格拉满的 Macgic Bar，丝滑流畅的触摸板……</p>
<p>这是目前装的一些常用软件，以后有机会挑几个好用的详细介绍一下。</p>
<p><img src="https://cdn.ethanloo.cn/img/image-20210923132952610.png" alt="image-20210923132952610"></p>
<p>抛开优点，这里展开讲讲使用体验上给我感觉有些糟糕的地方。</p>
<h3 id="Finder">Finder</h3>
<p>绝了，我第一次发现 Windows 资源管理器是这么好用。在 Finder 里找个类似我的电脑的东西都找了老半天。</p>
<p><img src="https://cdn.ethanloo.cn/img/image-20210923133251350.png" alt="image-20210923133251350"></p>
<h3 id="快捷键">快捷键</h3>
<p>这个或许不是 MacOS 本身的问题，而是 Windows 用户在适应 MacOS 过程中必然遇到的一个难于跨越的鸿沟。</p>
<p>没有 Ctrl 就算了，我可以用 Command，但是谁能告诉我为啥有的时候是用 Command 替代，有的时候又变成了 Option 来替代 Ctrl？？？</p>
<h3 id="App-Store">App Store</h3>
<p>第一次登录 App Store 失败，我以为是网络问题没有深究，毕竟软件可以通过官网下载 dmg 安装包。</p>
<p>第二次公司网登录失败，仍然继续忽略。</p>
<p>接着又是 N 次登录失败，直到有一次我需要下载 Microsoft Remote Desktop 必须要访问 App Store 时，我才去尝试解决这个问题。</p>
<p>参考网上的解决方案，更换热点，连接代理，更换节点，终端输入命令……都没能成功解决问题，最终我重新登录了一次 Apple ID 才成功进入了 App Store。</p>
<h2 id="20-天初次体验后的建议">20 天初次体验后的建议</h2>
<ol>
<li>M1 Macbook Pro 基本没有不兼容问题。</li>
<li>适合不喜欢带充电器的人群。</li>
<li>笔记本自带 2 个雷电接口，如果对接口有更高需求，建议入手雷电 3 拓展坞。</li>
<li>早买早享受，晚买有折扣。</li>
</ol>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
  </entry>
  <entry>
    <title>面试后的亡羊补牢</title>
    <url>/post/2021-07-31-Weber/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/</url>
    <content><![CDATA[<blockquote>
<p>微软实习了一个半月了，参与秋招并不是觉得自己不能转正，更多的是希望能把自己带入到应届生的身份中去，掂量掂量自己几斤几两。</p>
<p>也是一个好机会，通过面试去查漏补缺，看看自己的提升方向，在这儿整理一下自己回答的不好或者觉得有价值的问题。</p>
<p>虽说是提起批，但仍然问了相当多的八股文，很多问题我在开发中并没有关注，值得考究。</p>
</blockquote>
<h3 id="React-中-key-的作用是什么？具体渲染的时候是如何提升性能的？">React 中 key 的作用是什么？具体渲染的时候是如何提升性能的？</h3>
<p>key 是 React 中用来对组件进行标记的唯一标识（这里的唯一是指局部唯一）。简单来说 key 帮助 React 识别哪些元素被改变了，例如添加或删除。</p>
<p><a href="https://zh-hans.reactjs.org/docs/reconciliation.html#recursing-on-children">React 官方的例子</a>很好地解释了 key 能提升性能的原因。</p>
<p>在更改列表的时候，例如我希望往列表尾部插入一个新的元素：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>first<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>second<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>first<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>second<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>third<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么此时 React 自然知道只需要往后增加一个元素即可，不需要动前两个元素，这棵树实际上只多了一个 node。</p>
<p>但是，如果需要往列表头增加一个元素：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Duke<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Villanova<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Connecticut<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Duke<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>Villanova<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这棵树上原来两个 nodes 的位置也变了，所以 React 进行的操作不只是添加，而是变更了 1 + 2 个结点。</p>
<p>但是如果当使用了 key 之后，React 可以使用 key 去匹配树上的每个结点：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2015&quot;</span>&gt;</span>Duke<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2016&quot;</span>&gt;</span>Villanova<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2014&quot;</span>&gt;</span>Connecticut<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2015&quot;</span>&gt;</span>Duke<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&quot;2016&quot;</span>&gt;</span>Villanova<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样子，React 就知道，只有 <code>key = &quot;2014&quot;</code> 的元素需要被更改。</p>
<h3 id="useMemo-和-useCallback-分别是用来做什么的？具体怎么使用？">useMemo 和 useCallback 分别是用来做什么的？具体怎么使用？</h3>
<p><code>useMemo</code> 接收两个参数，第一个参数是个函数，返回值是需要保存的值，第二个参数是一个数组，作为依赖项，变化的时候会执行第一个函数，产生新的值。</p>
<p>应用场景：</p>
<ol>
<li>
<p>缓存，减少运算量。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 大量运算</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">number</span>;</span><br><span class="line">&#125;, [props.<span class="property">n</span>]) <span class="comment">// 只有 props.n 变化，才会重新计算 number</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>减少 <code>dom</code> 循环</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保证只有在 selectList 的变化的时候，才会重新执行这个循环</span></span><br><span class="line">&#123;<span class="title function_">useMemo</span>(<span class="function">() =&gt;</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;</span></span><br><span class="line"><span class="language-xml">            selectList.map((i, v) =&gt; (</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">span</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">className</span>=<span class="string">&#123;style.listSpan&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">key</span>=<span class="string">&#123;v&#125;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">                    &#123;i.patentName&#125; </span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            ))&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">), [selectList])&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>减少子组件渲染</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 只有当 props.list 列表改变的时候，子组件才渲染 */</span></span><br><span class="line"><span class="keyword">const</span>  goodListChild = <span class="title function_">useMemo</span>(<span class="function">()=&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">GoodList</span> <span class="attr">list</span>=<span class="string">&#123;</span> <span class="attr">props.list</span> &#125; /&gt;</span></span> ,[ props.<span class="property">list</span> ])</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>useCallback</code> 接受的参数和 <code>useMemo</code> 类似，区别在于返回的是函数本身，而不是函数的运行结果。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">DemoUseCallback</span>=(<span class="params">&#123; id &#125;</span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> [number, setNumber] = <span class="title function_">useState</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">/* 此时usecallback的第一参数 (sonName)=&gt;&#123; console.log(sonName) &#125;</span></span><br><span class="line"><span class="comment">     经过处理赋值给 getInfo */</span></span><br><span class="line">    <span class="keyword">const</span> getInfo  = <span class="title function_">useCallback</span>(<span class="function">(<span class="params">sonName</span>)=&gt;</span>&#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(sonName)</span><br><span class="line">    &#125;,[id])</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;/* 点击按钮触发父组件更新 ，但是子组件没有更新 */&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;</span> ()=&gt;</span>setNumber(number+1) &#125; &gt;增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">DemoChildren</span> <span class="attr">getInfo</span>=<span class="string">&#123;getInfo&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类组件和函数组件有什么区别？">类组件和函数组件有什么区别？</h3>
<p>标准答案：<strong>函数式组件捕获了渲染所用的值。（Function components capture the rendered values.）</strong></p>
<p>React 的 contributor 之一 Dan Abramov 的例子非常的清晰易懂。</p>
<p>假设有两个组件，一个是函数组件，一个是类组件，两个都通过 <code>props.user</code> 从父组件那边获取了一个值 <code>user</code>，并且执行了一个异步的操作（使用 setTimeout 延迟了 3 秒输出 <code>user</code>）。</p>
<p>对于类组件，通过 <code>this.props.user</code> 来获取当前的 <code>user</code> 信息，而函数组件通过 <code>props.user</code>。</p>
<p>两者很大的差别就是有没有用 <code>this</code>，对于使用 <code>this</code> 的类组件，他们拿到的永远都是实例上最新的值，因为类组件是跟实例绑定的。</p>
<p>所以，在延迟 3 秒的期间，如果我们改变了 <code>user</code> 的值，那么，类组件最后输出的就是最新的 <code>user</code> 值。</p>
<p>但是，对于函数组件而言，即时等待期间改变 <code>user</code> 的值，最后输出的也是原 <code>user</code> 的值，因为函数式组件是和一个特定的渲染绑定在了一起。</p>
<p>在 React 中，props 是不可变的，而 this 是可变的。</p>
<h3 id="React-的新旧版生命周期">React 的新旧版生命周期</h3>
<h4 id="old-lifecycle">old lifecycle</h4>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e12b2e35c8444f19b795b27e38f4c149~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p>
<h4 id="new-lifecycle">new lifecycle</h4>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a7d8676f379d4d96bbf0ebd9a8528594~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p>
<h3 id="HTTPS-是怎么做到加密的">HTTPS 是怎么做到加密的</h3>
<ol>
<li>浏览器向服务器发送<code>client_random</code>和加密方法列表。</li>
<li>服务器接收到，返回<code>server_random</code>、加密方法以及公钥。</li>
<li>浏览器接收，接着生成另一个随机数<code>pre_random</code>, 并且用公钥加密，传给服务器。(敲黑板！重点操作！)</li>
<li>服务器用私钥解密这个被加密后的<code>pre_random</code>。</li>
</ol>
<p>现在浏览器和服务器有三样相同的凭证:<code>client_random</code>、<code>server_random</code>和<code>pre_random</code>。然后两者用相同的加密方法混合这三个随机数，生成最终的<code>密钥</code>。</p>
<p>然后浏览器和服务器尽管用一样的密钥进行通信，即使用<code>对称加密</code>。</p>
<p>这个最终的密钥是很难被中间人拿到的，为什么呢? 因为中间人没有私钥，从而<strong>拿不到pre_random</strong>，也就无法生成最终的密钥了。</p>
<h3 id="常见的-HTTP-Headers">常见的 HTTP Headers</h3>
<ul>
<li>Accept: text/html, image/png</li>
<li>Authorization</li>
<li>Host: <a href="http://shopapi.ethanloo.cn">shopapi.ethanloo.cn</a></li>
<li>Connection: keep-alive</li>
<li>User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.110 Safari/537.36 Edg/96.0.1054.57</li>
<li>Origin: <a href="https://mooc.ethanloo.cn">https://mooc.ethanloo.cn</a></li>
<li>Allow: GET</li>
<li>Content-type: application/json; charset=utf-8</li>
</ul>
<h3 id="参考资料">参考资料</h3>
<p><a href="https://juejin.cn/post/6950063294270930980">「React进阶」 React全部api解读+基础实践大全(夯实基础2万字总结) (juejin.cn)</a></p>
<p><a href="https://overreacted.io/zh-hans/how-are-function-components-different-from-classes/">函数式组件与类组件有何不同？ — Overreacted</a></p>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>秋招</tag>
      </tags>
  </entry>
  <entry>
    <title>好物分享 - 终端 | 封面 | 快捷方式</title>
    <url>/post/2021-06-07-Share/%E5%A5%BD%E7%94%A8%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<blockquote>
<p>好久没来分享黑科技了，趁今天晚上课设写累了，分享一些自己最近搜刮到的好东西。</p>
<p>先声明，文章中推荐的软件只是我用了一段时间之后觉得很好用，不保证适合你。</p>
</blockquote>
<h2 id="Windows-Terminal：好看的终端不只是皮囊">Windows Terminal：好看的终端不只是皮囊</h2>
<p>还在用古老的黑乎乎命令行窗口？改用 Windows PowerShell 了？</p>
<p>看看新版的 Windows 命令行界面吧。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210607230211.png" alt="image-20210607225953955"></p>
<p>毛玻璃，自定义字体，透明度，自定义配色…光这些表面功夫就已经够吸引人了。让自己写代码的时候保持心情愉悦何尝不是提升效率呢？</p>
<p>你甚至还可以直接在里面配置不同的命令行窗口，包括一些 Ubuntu 子系统等。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210607230557.png" alt="image-20210607230557242"></p>
<p>Win10 应用商店自行安装完之后通过搜索引擎找一下美化方案吧！</p>
<h2 id="Figma：设计封面？抄作业就完事儿了！">Figma：设计封面？抄作业就完事儿了！</h2>
<p>在前端技术相当成熟的今天，已经有不少的 Web 应用相当好用，在舍弃繁琐的安装步骤之后，显得更加强大。</p>
<p>在接触到 Figma 之前，我一直在 <a href="https://www.fotor.com/design/">fotor</a> 上制作我的封面，正如下图所示，这是我之前做过的一些图。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210607231212.png" alt="image-20210607231211153"></p>
<p>虽说这个网站已经足够方便制作封面了，只需要改改模板上的文字就是一张完整的封面图。</p>
<p>奈何人总是贪婪（吝啬？）的，这个网站的大多数模板都是收费的（VIP），免费的模板少的可怜。</p>
<blockquote>
<p>网站甚至不提供 「只显示免费」的选项</p>
</blockquote>
<p>于是，我便找到了一个新的宠儿，让我们有请 <a href="https://www.figma.com/">FIGMA</a> ！这是我的仓库，其中有一些最近的封面。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210607231538.png" alt="image-20210607231537945"></p>
<p>严格意义上来讲，这个应用面向的群体并不是简单的封面图需求者，而是真正意义设计师。</p>
<p>不过，我作为一个没啥美术造诣的人，虽不会创作，但是抄作业总还是会的。</p>
<p>进入<a href="https://www.figma.com/community">社区</a>，可以看到很多设计师分享的设计作品，根据他们的作品和自己的需求，我凭借自己还 OK 的审美，勉强能做个简洁舒服的封面。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210607231800.png" alt="image-20210607231759766"></p>
<blockquote>
<p>最近因为一些众所周知的原因，很多网站被墙了，包括 Figma 😓</p>
</blockquote>
<h2 id="uTools：强迫症福音-程序员之友">uTools：强迫症福音 程序员之友</h2>
<p>先分享一下我的桌面：</p>
<p><img src="https://cdn.ethanloo.cn/img/20210607233537.png" alt="image-20210607233535692"></p>
<p>在桌面上我只放了我使用频率最高的东西，包括底下的菜单栏。</p>
<p>你很好奇我是怎么打开其他软件的对不对？（不对）</p>
<p>有的时候，我用 Win10 的菜单栏，其实挺好看的，就是找东西有点费眼睛。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210607233719.png" alt="image-20210607233717124"></p>
<p>不过最近用过 <a href="https://u.tools/">uTools</a> 后，我已经准备慢慢淘汰这种方法了。</p>
<p>给你看下这个软件的使用截图，你就知道我为什么把他叫做程序员之友了。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210607234135.png" alt="image-20210607234134511"></p>
<p>看起来是不是有点像什么东西？对！就是命令行。</p>
<p>这就是我使用频率最高的功能，在任意界面通过 『Alt + 空格』呼出命令行，输入关键字或者首字母，快速打开软件。</p>
<p>当然，它也提供了不少的扩展功能。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210607234447.png" alt="img"></p>
<blockquote>
<p>下次见</p>
</blockquote>
]]></content>
      <categories>
        <category>黑科技</category>
      </categories>
      <tags>
        <tag>美化</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年6月刷题日志</title>
    <url>/post/2021-06-02-Algorithm/2021%E5%B9%B46%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p><strong>6.19</strong></p>
<p>MS 实习了四天，放假回来刷题啦！</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1239-串联字符串的最大长度"><a href="https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/">1239. 串联字符串的最大长度</a></h4>
<p>难度中等</p>
<p>给定一个字符串数组 <code>arr</code>，字符串 <code>s</code> 是将 <code>arr</code> 某一子序列字符串连接所得的字符串，如果 <code>s</code> 中的每一个字符都只出现过一次，那么它就是一个可行解。</p>
<p>请返回所有可行解 <code>s</code> 中最长长度。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;]</span><br><span class="line">输出：4</span><br><span class="line">解释：所有可能的串联组合是 &quot;&quot;,&quot;un&quot;,&quot;iq&quot;,&quot;ue&quot;,&quot;uniq&quot; 和 &quot;ique&quot;，最大长度为 4。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [&quot;cha&quot;,&quot;r&quot;,&quot;act&quot;,&quot;ers&quot;]</span><br><span class="line">输出：6</span><br><span class="line">解释：可能的解答有 &quot;chaers&quot; 和 &quot;acters&quot;。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [&quot;abcdefghijklmnopqrstuvwxyz&quot;]</span><br><span class="line">输出：26</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 16</code></li>
<li><code>1 &lt;= arr[i].length &lt;= 26</code></li>
<li><code>arr[i]</code> 中只含有小写英文字母</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>深搜 + 剪枝</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> maxL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxLength</span><span class="params">(List&lt;String&gt; arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String str : arr) &#123;</span><br><span class="line">            total += str.length();</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, arr, total);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.maxL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> idx, String cur, List&lt;String&gt; arr, <span class="type">int</span> total)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.length() + total &lt;= maxL || !isLegal(cur))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (idx == arr.size()) &#123;</span><br><span class="line">            <span class="built_in">this</span>.maxL = Math.max(cur.length(), <span class="built_in">this</span>.maxL);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        total -= arr.get(idx).length();</span><br><span class="line">        dfs(idx + <span class="number">1</span>, cur + arr.get(idx), arr, total);</span><br><span class="line">        dfs(idx + <span class="number">1</span>, cur, arr, total);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLegal</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &gt; <span class="number">26</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            cnt[idx]++;</span><br><span class="line">            <span class="keyword">if</span> (cnt[idx] &gt;= <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>6.14</strong></p>
<p>端午节简单题！🐉！</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="374-猜数字大小"><a href="https://leetcode-cn.com/problems/guess-number-higher-or-lower/">374. 猜数字大小</a></h4>
<p>难度简单</p>
<p>猜数字游戏的规则如下：</p>
<ul>
<li>每轮游戏，我都会从 <strong>1</strong> 到 <em><strong>n</strong></em> 随机选择一个数字。 请你猜选出的是哪个数字。</li>
<li>如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。</li>
</ul>
<p>你可以通过调用一个预先定义好的接口 <code>int guess(int num)</code> 来获取猜测结果，返回值一共有 3 种可能的情况（<code>-1</code>，<code>1</code> 或 <code>0</code>）：</p>
<ul>
<li>-1：我选出的数字比你猜的数字小 <code>pick &lt; num</code></li>
<li>1：我选出的数字比你猜的数字大 <code>pick &gt; num</code></li>
<li>0：我选出的数字和你猜的数字一样。恭喜！你猜对了！<code>pick == num</code></li>
</ul>
<p>返回我选出的数字。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 10, pick = 6</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>又是二分模板题，和昨天的区别有两点：</p>
<ol>
<li>昨天的是找边界，今天的是找点</li>
<li>昨天的点有两种值，今天的点可能有三种值。</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Forward declaration of guess API.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  num   your guess</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 	     -1 if num is lower than the guess number</span></span><br><span class="line"><span class="comment"> *			      1 if num is higher than the guess number</span></span><br><span class="line"><span class="comment"> *               otherwise return 0</span></span><br><span class="line"><span class="comment"> * int guess(int num);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">GuessGame</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">guessNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (guess(mid) == <span class="number">1</span>) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (guess(mid) == -<span class="number">1</span>) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>6.13</strong></p>
<p>昨天因为一些个人原因刷了题没写题解。</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="278-第一个错误的版本"><a href="https://leetcode-cn.com/problems/first-bad-version/">278. 第一个错误的版本</a></h4>
<p>难度简单</p>
<p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 <code>n</code> 个版本 <code>[1, 2, ..., n]</code>，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 <code>version</code> 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定 n = 5，并且 version = 4 是第一个错误的版本。</span><br><span class="line"></span><br><span class="line">调用 isBadVersion(3) -&gt; false</span><br><span class="line">调用 isBadVersion(5) -&gt; true</span><br><span class="line">调用 isBadVersion(4) -&gt; true</span><br><span class="line"></span><br><span class="line">所以，4 是第一个错误的版本。 </span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>要从一个<code>[f, f, f, t, t]</code> 找到第一个 <code>f</code> 的位置，还是比较好看出来是二分的。</p>
<blockquote>
<p>tip: 在计算 <code>mid</code> 的时候要记得使用 <code>left + (right - left) / 2</code>，而不是 <code>(left + right)/2</code>，因为后一种会溢出。</p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The isBadVersion API is defined in the parent class VersionControl.</span></span><br><span class="line"><span class="comment">      boolean isBadVersion(int version); */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">VersionControl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (isBadVersion(mid)) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>6.11</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="279-完全平方数"><a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></h4>
<p>难度中等</p>
<p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p>
<p>给你一个整数 <code>n</code> ，返回和为 <code>n</code> 的完全平方数的 <strong>最少数量</strong> 。</p>
<p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 = 4 + 4 + 4</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 13</span><br><span class="line">输出：2</span><br><span class="line">解释：13 = 4 + 9</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>动，都可以动</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// dp[i] 表示用小于等于 largest 的自然数的平方数组成 i 所需要的最少个数</span></span><br><span class="line">        Arrays.fill(dp, <span class="number">0x3f3f3f</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - j * j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>6.10</strong></p>
<p>完全背包问题简单版 ⭕</p>
<blockquote>
<p>昨天蓝桥杯出成绩了，国二 👶</p>
</blockquote>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="518-零钱兑换-II"><a href="https://leetcode-cn.com/problems/coin-change-2/">518. 零钱兑换 II</a></h4>
<p>难度中等</p>
<p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: amount = 5, coins = [1, 2, 5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 有四种方式可以凑成总金额:</span><br><span class="line">5=5</span><br><span class="line">5=2+2+1</span><br><span class="line">5=2+1+1+1</span><br><span class="line">5=1+1+1+1+1</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>起初我想的方法是用 <code>dp[i][j]</code> 去表示 <code>用前 j 种硬币，凑出 i 元的方案数</code>。</p>
<p>要计算这个，必定需要令 <code>i = 0...amount</code> 一层循环，<code>j = 1...coins.length</code> 一层循环。</p>
<p>但是需要计算出 <code>dp[i][j]</code> 的值，还需要去计算不用第 <code>j</code> 个硬币的凑出 <code>i - 用过的硬币的价值</code> 的方案数，也就是说需要再套一层循环 <code>k = 0...j-1</code>，因此我写出来的代码长这个样子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> coins.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// dp[i][j] 表示凑出 i 元的可能方案，且只能用前 j 种硬币。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; j; k++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">coin</span> <span class="operator">=</span> coins[k];</span><br><span class="line">                    <span class="keyword">if</span> (i &gt;= coin) &#123;</span><br><span class="line">                        dp[i][j] += dp[i - coin][k + <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一提交发现击败 5% 😰 于是我去题解区寻找了优化方案，想办法优化掉最内存的循环。</p>
<p>答案肯定是可以的，其实要确定 <code>dp[i][j]</code> 并不需要逐个遍历用过的硬币面值去找，假设只需要通过 <code>dp[i][j - 1]</code> 和 <code>dp[i - coin(当前的面值)][j]</code> 就可以算出来。可以理解为两种情况：</p>
<ol>
<li>不用当前的硬币，只用前 <code>j - 1</code> 种硬币凑出来 <code>i</code> 元。</li>
<li>用当前的硬币 <code>coin</code>，并且前 <code>j - 1</code> 种硬币凑出 <code>i - coin</code> 元。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> coins.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// dp[i][j] 表示凑出 i 元的可能方案，且只能用前 j 种硬币。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">coin</span> <span class="operator">=</span> coins[j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (coin &lt;= i) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - coin][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一提交发现击败 10% 💢 见鬼了，继续优化 ！</p>
<img src="https://cdn.ethanloo.cn/img/20210610133439.png" alt="image-20210610133439506" style="zoom:67%;" />
<p>二维的动态规划耗时长，无非优化成一维的嘛！那就把原来的 <code>dp[i][j]</code> 的 <code>j</code> 给优化掉，直接遍历硬币数组。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> coins.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// dp[i] 表示凑出 i 元的可能方案</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> coin: coins) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> coin; i &lt;= amount; i++) &#123;</span><br><span class="line">                dp[i] += dp[i - coin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们求的是组合数，所以在外层遍历硬币，内层遍历金额。反过来会变成排列。</p>
<img src="https://cdn.ethanloo.cn/img/20210610134048.png" alt="image-20210610134048553" style="zoom:67%;" />
<p>舒服了</p>
<p><strong>6.9</strong></p>
<p>背包问题困难版 ❌</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="879-盈利计划"><a href="https://leetcode-cn.com/problems/profitable-schemes/">879. 盈利计划</a></h4>
<p>难度困难</p>
<p>集团里有 <code>n</code> 名员工，他们可以完成各种各样的工作创造利润。</p>
<p>第 <code>i</code> 种工作会产生 <code>profit[i]</code> 的利润，它要求 <code>group[i]</code> 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。</p>
<p>工作的任何至少产生 <code>minProfit</code> 利润的子集称为 <strong>盈利计划</strong> 。并且工作的成员总数最多为 <code>n</code> 。</p>
<p>有多少种计划可以选择？因为答案很大，所以 <strong>返回结果模</strong> <code>10^9 + 7</code> <strong>的值</strong>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 5, minProfit = 3, group = [2,2], profit = [2,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。</span><br><span class="line">总的来说，有两种计划。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>虽然看出来是用动规，但是却没看出来是三维的数组（因为有两种限制，工作和人数）</p>
<p>开辟一个三维数组记录状态，<code>dp[i][j][k]</code> 表示的是前 <code>i</code> 项工作，派 <code>j</code> 个人，获得利润大于等于 <code>k</code> 的可能计划数。</p>
<p>进行一个三重的遍历，每次根据人数去更新计划数。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">profitableSchemes</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> minProfit, <span class="type">int</span>[] group, <span class="type">int</span>[] profit)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>, MOD = (<span class="type">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> group.length;</span><br><span class="line">        <span class="comment">// dp[i][j][k] 表示前 i 项工作，派 j 个人，获得的利润大于等于 k 的计划数</span></span><br><span class="line">        <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>][n + <span class="number">1</span>][minProfit + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">members</span> <span class="operator">=</span> group[i - <span class="number">1</span>], money = profit[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt;= minProfit; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j &lt; members) &#123;</span><br><span class="line">                        dp[i][j][k] = dp[i - <span class="number">1</span>][j][k] % MOD;</span><br><span class="line">                    &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j][k] = (dp[i - <span class="number">1</span>][j][k] + dp[i - <span class="number">1</span>][j - members][Math.max(<span class="number">0</span>, k - money)]) % MOD;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            sum = (sum + dp[len][j][minProfit]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>6.8</strong></p>
<p>又是背包问题 🤦‍♂️ 人傻了</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1049-最后一块石头的重量-II"><a href="https://leetcode-cn.com/problems/last-stone-weight-ii/">1049. 最后一块石头的重量 II</a></h4>
<p>难度中等</p>
<p>有一堆石头，用整数数组 <code>stones</code> 表示。其中 <code>stones[i]</code> 表示第 <code>i</code> 块石头的重量。</p>
<p>每一回合，从中选出<strong>任意两块石头</strong>，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>
<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li>
</ul>
<p>最后，<strong>最多只会剩下一块</strong> 石头。返回此石头 <strong>最小的可能重量</strong> 。如果没有石头剩下，就返回 <code>0</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：stones = [2,7,4,1,8,1]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，</span><br><span class="line">组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，</span><br><span class="line">组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，</span><br><span class="line">组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>可以看作是需要把一堆石头分成两堆，一堆用来加，一堆用来减。</p>
<p>我们的目标就是让其中一堆的质量尽可能靠近总质量的一半。</p>
<p>利用动态规划，令 <code>dp[i][j]</code> 表示前 <code>i</code> 块石头能否粉碎成重量等于 <code>j</code> 的石头。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> stones.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> stone: stones) &#123;</span><br><span class="line">            sum += stone;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sum / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j] 表示前 i 块石头能否粉碎成重量等于 j 的石头</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>]; </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">stone</span> <span class="operator">=</span> stones[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= stone) &#123;</span><br><span class="line">                    dp[i][j] |= dp[i - <span class="number">1</span>][j - stone];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[n][j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> sum - <span class="number">2</span> * j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>6.7</strong></p>
<p>软测期末考试 + 选修课交论文 + 疫苗 + 理发结束，下午三点多终于有空刷题了。</p>
<p>今天高考作文出来了，之前看了木鱼的11p觉醒年代讲解，感觉光引用台词就能写完作文，「觉醒年代」YYDS！</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="494-目标和"><a href="https://leetcode-cn.com/problems/target-sum/">494. 目标和</a></h4>
<p>难度中等</p>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>target</code> 。</p>
<p>向数组中的每个整数前添加 <code>'+'</code> 或 <code>'-'</code> ，然后串联起所有整数，可以构造一个 <strong>表达式</strong> ：</p>
<ul>
<li>例如，<code>nums = [2, 1]</code> ，可以在 <code>2</code> 之前添加 <code>'+'</code> ，在 <code>1</code> 之前添加 <code>'-'</code> ，然后串联起来得到表达式 <code>&quot;+2-1&quot;</code> 。</li>
</ul>
<p>返回可以通过上述方法构造的、运算结果等于 <code>target</code> 的不同 <strong>表达式</strong> 的数目。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1,1,1], target = 3</span><br><span class="line">输出：5</span><br><span class="line">解释：一共有 5 种方法让最终目标和为 3 。</span><br><span class="line">-1 + 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 = 3</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>表面中等题，实际简单题。</p>
<p>哈希表迭代即可求出可能和的种类和个数。</p>
<p>权当学习一下 Java 语法。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">var</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        m.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="type">var</span> <span class="variable">nxt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> key : m.keySet()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">plus</span> <span class="operator">=</span> nxt.containsKey(key + num) ? nxt.get(key + num) : <span class="number">0</span>;</span><br><span class="line">                nxt.put(key + num, plus + m.get(key));</span><br><span class="line">                <span class="type">int</span> <span class="variable">minus</span> <span class="operator">=</span> nxt.containsKey(key - num) ? nxt.get(key - num) : <span class="number">0</span>;</span><br><span class="line">                nxt.put(key - num, minus + m.get(key));</span><br><span class="line">            &#125;</span><br><span class="line">            m = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m.containsKey(target)? m.get(target): <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>6.6</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="474-一和零"><a href="https://leetcode-cn.com/problems/ones-and-zeroes/">474. 一和零</a></h4>
<p>难度中等</p>
<p>给你一个二进制字符串数组 <code>strs</code> 和两个整数 <code>m</code> 和 <code>n</code> 。</p>
<p>请你找出并返回 <code>strs</code> 的最大子集的大小，该子集中 <strong>最多</strong> 有 <code>m</code> 个 <code>0</code> 和 <code>n</code> 个 <code>1</code> 。</p>
<p>如果 <code>x</code> 的所有元素也是 <code>y</code> 的元素，集合 <code>x</code> 是集合 <code>y</code> 的 <strong>子集</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：strs = [&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;], m = 5, n = 3</span><br><span class="line">输出：4</span><br><span class="line">解释：最多有 5 个 0 和 3 个 1 的最大子集是 &#123;&quot;10&quot;,&quot;0001&quot;,&quot;1&quot;,&quot;0&quot;&#125; ，因此答案是 4 。</span><br><span class="line">其他满足题意但较小的子集包括 &#123;&quot;0001&quot;,&quot;1&quot;&#125; 和 &#123;&quot;10&quot;,&quot;1&quot;,&quot;0&quot;&#125; 。&#123;&quot;111001&quot;&#125; 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：strs = [&quot;10&quot;, &quot;0&quot;, &quot;1&quot;], m = 1, n = 1</span><br><span class="line">输出：2</span><br><span class="line">解释：最大的子集是 &#123;&quot;0&quot;, &quot;1&quot;&#125; ，所以答案是 2 。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>又是动态规划，做不出来真苦恼 😕</p>
<p>背包问题的变形。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">      	<span class="comment">// 空间优化版本</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (String str: strs) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">zero</span> <span class="operator">=</span> <span class="number">0</span>, one = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c: str.toCharArray()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>) zero++;</span><br><span class="line">                <span class="keyword">else</span> one++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m; i &gt;= zero; i--) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n; j &gt;= one; j--) &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i-zero][j-one] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>6.5</strong></p>
<p>上午蓝桥杯国赛，一言难尽，真就写的都是嗯解。</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="203-移除链表元素"><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">203. 移除链表元素</a></h4>
<p>难度简单</p>
<p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [], val = 1</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>小技巧，在头节点前新建一个伪结点，便于需要删除头节点的情况。</p>
<p>然后就是很普通的遍历和删结点，因为是链表，所以只要让指针跳过需要删的结点即可，不需要真的删。</p>
<p><strong>代码</strong></p>
<blockquote>
<p>为了迎接接下来的夏令营，我又要开始用 Java 刷题了 😪</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.val == val) &#123;</span><br><span class="line">                pre.next = node.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = node;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>6.4</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="160-相交链表"><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h4>
<p>难度简单</p>
<p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p>
<p>图示两个链表在节点 <code>c1</code> 开始相交**：**</p>
<p><a href="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png" alt="img"></a></p>
<p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p>
<p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><a href="https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png"><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png" alt="img"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</span><br><span class="line">输出：Intersected at &#x27;8&#x27;</span><br><span class="line">解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。</span><br><span class="line">从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。</span><br><span class="line">在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<ol>
<li>先遍历一遍 A 链表，用哈希表记录遍历过的结点值。再遍历一遍 B 链表，同时查找当前结点是否在 A 链表中出现过。</li>
<li>第一次先遍历 A 和 B 链表，确认两者长度，第二次，让长的那个链表先前进若干步，保证两者能最终同时到尾结点。一边前进，一边确认是否当前结点相同。</li>
<li>交叉遍历，<a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/xiang-jiao-lian-biao-by-leetcode-solutio-a8jn/">官方题解</a> YYDS，感觉有种<strong>殊途同归</strong>的含义。</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解法2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        nodeA, nodeB = headA, headB</span><br><span class="line">        lenA = lenB = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> nodeA:</span><br><span class="line">            nodeA = nodeA.<span class="built_in">next</span></span><br><span class="line">            lenA += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> nodeB:</span><br><span class="line">            nodeB = nodeB.<span class="built_in">next</span></span><br><span class="line">            lenB += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> lenA &gt; lenB:</span><br><span class="line">            <span class="comment"># 确保 A 短 B 长</span></span><br><span class="line">            headA, headB = headB, headA</span><br><span class="line">            lenA, lenB = lenB, lenA</span><br><span class="line">        nodeA, nodeB = headA, headB</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(lenB - lenA):</span><br><span class="line">            nodeB = nodeB.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> nodeA <span class="keyword">and</span> nodeB <span class="keyword">and</span> nodeA != nodeB:</span><br><span class="line">            nodeA = nodeA.<span class="built_in">next</span></span><br><span class="line">            nodeB = nodeB.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> nodeA <span class="keyword">if</span> nodeA == nodeB <span class="keyword">else</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解法3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getIntersectionNode</span>(<span class="params">self, headA: ListNode, headB: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        nodeA, nodeB = headA, headB</span><br><span class="line">        <span class="keyword">while</span> nodeA != nodeB:</span><br><span class="line">            nodeA = nodeA.<span class="built_in">next</span> <span class="keyword">if</span> nodeA <span class="keyword">else</span> headB</span><br><span class="line">            nodeB = nodeB.<span class="built_in">next</span> <span class="keyword">if</span> nodeB <span class="keyword">else</span> headA</span><br><span class="line">        <span class="keyword">return</span> nodeA</span><br></pre></td></tr></table></figure>
<p><strong>6.3</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="525-连续数组"><a href="https://leetcode-cn.com/problems/contiguous-array/">525. 连续数组</a></h4>
<p>难度中等</p>
<p>给定一个二进制数组 <code>nums</code> , 找到含有相同数量的 <code>0</code> 和 <code>1</code> 的最长连续子数组，并返回该子数组的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0,1]</span><br><span class="line">输出: 2</span><br><span class="line">说明: [0, 1] 是具有相同数量0和1的最长连续子数组。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0,1,0]</span><br><span class="line">输出: 2</span><br><span class="line">说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>和昨天的题目类似，都是利用前缀和的思路快速求得某段子数组中 0 的个数和 1 的个数。</p>
<p>利用哈希表记录前面出现过的子数组的 0 和 1 的出现次数之差。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxLength</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dic = <span class="built_in">dict</span>() <span class="comment"># cnt0 - cnt1 -&gt; idx</span></span><br><span class="line">        dic[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        cnts = [<span class="number">0</span>, <span class="number">0</span>] <span class="comment"># 记录0,1的个数</span></span><br><span class="line">        <span class="keyword">for</span> idx, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            cnts[num] += <span class="number">1</span></span><br><span class="line">            diff = cnts[<span class="number">0</span>] - cnts[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> diff <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                dic[diff] = idx</span><br><span class="line">            <span class="keyword">if</span> diff:</span><br><span class="line">                res = <span class="built_in">max</span>(res, idx - dic[diff])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res = idx + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>6.2</strong></p>
<p>周六就要去蓝桥杯国赛了，紧张</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="523-连续的子数组和"><a href="https://leetcode-cn.com/problems/continuous-subarray-sum/">523. 连续的子数组和</a></h4>
<p>难度中等</p>
<p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：</p>
<ul>
<li>子数组大小 <strong>至少为 2</strong> ，且</li>
<li>子数组元素总和为 <code>k</code> 的倍数。</li>
</ul>
<p>如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>如果存在一个整数 <code>n</code> ，令整数 <code>x</code> 符合 <code>x = n * k</code> ，则称 <code>x</code> 是 <code>k</code> 的一个倍数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [23,2,4,6,7], k = 6</span><br><span class="line">输出：true</span><br><span class="line">解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [23,2,6,4,7], k = 6</span><br><span class="line">输出：true</span><br><span class="line">解释：[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 </span><br><span class="line">42 是 6 的倍数，因为 42 = 7 * 6 且 7 是一个整数。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<ol>
<li>
<p>为了快速计算 <code>nums</code> 数组中某段区间和，需要用到前缀和的思想。</p>
</li>
<li>
<p>假设子数组 <code>nums[left: right]</code> 和为 <code>k</code> 的倍数，只需要保证 <code>nums[0: left]</code> 和 <code>nums[0: right]</code> ➗ <code>k</code> 的余数都相同就行了。</p>
</li>
<li>
<p>以上两个操作，可以在一次遍历中使用哈希表完成。</p>
</li>
</ol>
<img src="https://cdn.ethanloo.cn/img/20210602151436.png" alt="image-20210602151436198" style="zoom:50%;" />
<blockquote>
<p>根据官方题解和其他人提交的代码不断优化。</p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkSubarraySum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        visited = <span class="built_in">dict</span>() <span class="comment"># sum -&gt; idx</span></span><br><span class="line">        visited[<span class="number">0</span>] = -<span class="number">1</span></span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> idx, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            cur = (cur + num) % k</span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                visited[cur] = idx</span><br><span class="line">            <span class="keyword">if</span> idx - visited[cur] &gt;= <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span> </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题日志</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>后端开发 | SooMooc 直播平台</title>
    <url>/post/2021-05-31-SooMooc/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%20-%20SooMooc%20%E7%9B%B4%E6%92%AD%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<blockquote>
<p>前端所有代码已经同步到 GitHub Repo: <a href="https://github.com/EthanLuu/soomooc">EthanLuu/soomooc: React + TypeScript 实践，在线教学直播平台。 (github.com)</a><br>
一直用 json-server 来 mock 数据显然是不够的，要想实现聊天室和其他的功能，还是需要简单开发一下后端接口的。</p>
</blockquote>
<p>直接跳过对 <a href="https://docs.nestjs.cn/7/introduction">nest.js</a> 的详细介绍，安装过程可以直接参考官网，这里就记录一下纯粹的 CRUD 接口的完整开发过程。</p>
<h2 id="创建-Module">创建 Module</h2>
<p>Nest.js 要实现一个数据结构的 CRUD，主要需要三个东西：<code>Controller, Service, Module</code>，<code>Module</code> 起到的作用是连接 <code>Service</code> 和 <code>Controller</code>。</p>
<p>新建一个组件只需要在项目的根目录下直接用命令行输入对应的命令即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nest g service menu server</span><br></pre></td></tr></table></figure>
<p>这是框架为我们自动创建的文件。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210531180138.png" alt="image-20210531180138237"></p>
<h2 id="创建-Service">创建 Service</h2>
<p>其中的 <code>Service</code> 存放的具体的增删改查的逻辑和操作。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210531180218.png" alt="image-20210531180218180"></p>
<p>只需要对 <code>menu.service.ts</code> 进行修改，以下是刚新建完的样子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Injectable</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">MenuService</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建-Controller">创建 Controller</h2>
<p><code>Controller</code> 在整个项目中负责的是根据请求的<strong>方法</strong>和<strong>参数</strong>去调用 <code>Service</code> 中的方法。</p>
<p>一样是使用命令行直接创建文件即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nest g controller menu server</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.ethanloo.cn/img/20210531180203.png" alt="image-20210531180203679"></p>
<p>初始化的 <code>controller</code> 长这个样子：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Controller</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">&#x27;menu&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">MenuController</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CRUD">CRUD</h2>
<p>终于要开始增删改查了，激不激动！</p>
<p>不过先等等，为了连接 MongoDB，需要确保安装了 <code>mongoose</code>  依赖和进行了相关的配置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add mongoose @nestjs/mongoose</span><br><span class="line">yarn add @types/mongoose -D			# ts支持</span><br></pre></td></tr></table></figure>
<p>在根模块 <code>app.module.ts</code> 中要引入该依赖。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Module</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">AppController</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./app.controller&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">AppService</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./app.service&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">UserModule</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./server/user/user.module&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">MongooseModule</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/mongoose&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CourseModule</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./server/course/course.module&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">MenuModule</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./server/menu/menu.module&#x27;</span>;</span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [</span><br><span class="line">    <span class="title class_">MongooseModule</span>.<span class="title function_">forRoot</span>(<span class="string">&#x27;mongodb://admin:xxxx@121.xxx.xxx.xxx:27017&#x27;</span>),		<span class="comment">// 服务器上的 MongoDB 的连接地址</span></span><br><span class="line">    <span class="title class_">UserModule</span>,				<span class="comment">// 创建完 module 后自动引入的</span></span><br><span class="line">    <span class="title class_">CourseModule</span>,</span><br><span class="line">    <span class="title class_">MenuModule</span>,</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">controllers</span>: [<span class="title class_">AppController</span>],</span><br><span class="line">  <span class="attr">providers</span>: [<span class="title class_">AppService</span>],</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">AppModule</span> &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在我们写的 <code>menu</code> 的模块中也需要对数据库进行配置。</p>
<p>首先需要数据结构进行定义，每一个菜单项包括『方向』和『子类别（数组）』。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/server/menu/menu.interface.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Document</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;mongoose&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Menu</span> <span class="keyword">extends</span> <span class="title class_">Document</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">_id</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">direction</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">types</span>: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其次，还需要新建一个 <code>src/server/menu/menu.schema.ts</code> 描述我们数据库。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Schema</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;mongoose&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> menuScheme = <span class="keyword">new</span> <span class="title class_">Schema</span>(&#123;</span><br><span class="line">  <span class="attr">direction</span>: &#123; <span class="attr">type</span>: <span class="title class_">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  <span class="attr">types</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="title class_">Array</span>,</span><br><span class="line">    <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">items</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再去对应的 <code>module</code> 中引入类型的定义和 <code>mongoose</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/server/menu/menu.module.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; menuScheme &#125; <span class="keyword">from</span> <span class="string">&#x27;./menu.schema&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Module</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">MongooseModule</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/mongoose&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">MenuController</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./menu.controller&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">MenuService</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./menu.service&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Module</span>(&#123;</span><br><span class="line">  <span class="attr">imports</span>: [</span><br><span class="line">    <span class="title class_">MongooseModule</span>.<span class="title function_">forFeature</span>([&#123; <span class="attr">name</span>: <span class="string">&#x27;Menus&#x27;</span>, <span class="attr">schema</span>: menuScheme &#125;]),</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">controllers</span>: [<span class="title class_">MenuController</span>],</span><br><span class="line">  <span class="attr">providers</span>: [<span class="title class_">MenuService</span>]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">MenuModule</span> &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>OK，接下去在 <code>service</code> 中修改一下获取菜单信息的逻辑。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Injectable</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">InjectModel</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/mongoose&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Model</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;mongoose&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Menu</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./menu.interface&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Injectable</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">MenuService</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="meta">@InjectModel</span>(<span class="string">&#x27;Menus&#x27;</span>) <span class="keyword">private</span> <span class="keyword">readonly</span> menuModel: Model&lt;Menu&gt;</span>) &#123;&#125;	<span class="comment">// 绑定模型</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">findAll</span>(): <span class="title class_">Promise</span>&lt;<span class="title class_">Menu</span>[]&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> menus = <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">menuModel</span>.<span class="title function_">find</span>();</span><br><span class="line">    <span class="keyword">return</span> menus;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>定义完了这个逻辑之后，为了调用这个方法，我们需要在 <code>controller</code> 中绑定路由。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">MenuService</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./menu.service&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Controller</span>, <span class="title class_">Get</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Menu</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./menu.interface&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">MenuResponse</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="attr">code</span>: <span class="built_in">number</span>;</span><br><span class="line">  data?: T;</span><br><span class="line">  <span class="attr">message</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">&#x27;menu&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">MenuController</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> <span class="keyword">readonly</span> menuService: MenuService</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Get</span>(<span class="string">&#x27;menus&#x27;</span>)</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">findAll</span>(): <span class="title class_">Promise</span>&lt;<span class="title class_">MenuResponse</span>&lt;<span class="title class_">Menu</span>[]&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">code</span>: <span class="number">200</span>,</span><br><span class="line">      <span class="attr">data</span>: <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">menuService</span>.<span class="title function_">findAll</span>(),</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;Success.&#x27;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在这里我们只有一个 Get 方法，用于查询数据库中的所有菜单。</p>
<p>我们用 Postman 测试一下。</p>
<blockquote>
<p>老样子，要记得在命令行运行 <code>yarn start:dev</code> 打开服务器，我设置的端口是 3333</p>
</blockquote>
<p>GET 请求地址 <code>http://localhost:3333/menu/menus</code>，成功返回一个包括 <code>code, data, message</code> 在内的代码。</p>
<img src="https://cdn.ethanloo.cn/img/20210531191446.png" alt="image-20210531191446258" style="zoom: 80%;" />
<p>因为数据库里是空的，所以自然返回的是空数组。</p>
<p>接下去写一个用 POST 请求添加菜单的方法，首先定义一下请求的 BODY 格式，新建 <code>src/server/menu/menu.dto.ts</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">CreateMenuDTO</span> &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">_id</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">direction</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">types</span>: <span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的 DTO 指的是数据传输对象 Data Transfer Object</p>
</blockquote>
<p>然后往 <code>Service</code> 和 <code>Controller</code> 里添加方法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/server/menu/menu.service.ts</span></span><br><span class="line"><span class="comment">// 添加单个菜单</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">addOne</span>(<span class="attr">body</span>: <span class="title class_">CreateMenuDTO</span>): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">menuModel</span>.<span class="title function_">create</span>(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/server/menu/menu.controller.ts</span></span><br><span class="line"><span class="comment">// POST /menu</span></span><br><span class="line"><span class="meta">@Post</span>()</span><br><span class="line"><span class="keyword">async</span> <span class="title function_">addOne</span>(<span class="meta">@Body</span>() <span class="attr">body</span>: <span class="title class_">CreateMenuDTO</span>): <span class="title class_">Promise</span>&lt;<span class="title class_">MenuResponse</span>&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="variable language_">this</span>.<span class="property">menuService</span>.<span class="title function_">addOne</span>(body);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">code</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;Success.&#x27;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这之后，通过 POST 请求将原来的 mock 数据写入到数据库中。</p>
<blockquote>
<p>当前写的几个接口和原来的 mock 方式都有一些出入，包括返回的数据格式等等。这些调整需要手动在 React 项目中进行。</p>
</blockquote>
<p><img src="https://cdn.ethanloo.cn/img/20210531202933.webp" alt="Thumbnail (2)"></p>
]]></content>
      <categories>
        <category>后端开发</category>
      </categories>
      <tags>
        <tag>直播平台</tag>
        <tag>Nest.js</tag>
      </tags>
  </entry>
  <entry>
    <title>注册登陆 | SooMooc 直播平台</title>
    <url>/post/2021-05-27-SooMooc/%E7%99%BB%E9%99%86%E6%B3%A8%E5%86%8C%20-%20SooMooc%20%E7%9B%B4%E6%92%AD%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<blockquote>
<p>一晃已经 2 周过去了，更新慢的原因既有生活忙碌，比赛事务繁忙，也有开发遇到的困难。不过好歹是凭借着 Google 技巧和 CV 能力实现了用户登陆状态的全局管理。为了对 CV 内容有自己的理解，也为了下次能够减少开发类似功能所需要的时间，我对这次的功能实现做一个总结。</p>
<p>前端所有代码已经同步到 GitHub Repo: <a href="https://github.com/EthanLuu/soomooc">EthanLuu/soomooc: React + TypeScript 实践，在线教学直播平台。 (github.com)</a></p>
</blockquote>
<h2 id="一、需求分析">一、需求分析</h2>
<h3 id="1-1-系统界面状态分析">1.1 系统界面状态分析</h3>
<p>就目前开发情况而言，整个网站包括以下几个界面：</p>
<ul>
<li>首页</li>
<li>课程列表界面</li>
<li>课程详情界面</li>
<li>登陆/注册界面</li>
</ul>
<p>虽然以上这些都应该面向游客，而对于在线教学直播平台来说，『用户』仍然是非常必要的，具体针对以下界面/功能：</p>
<ul>
<li>
<p>订阅课程</p>
</li>
<li>
<p>观看直播</p>
</li>
<li>
<p>直聊天发言</p>
</li>
<li>
<p>课程作业</p>
</li>
<li>
<p>…</p>
</li>
</ul>
<h3 id="1-2-登陆注册需求整理">1.2 登陆注册需求整理</h3>
<p>再整理一下我们的需求：</p>
<ul>
<li>未登录时
<ul>
<li>页头组件上应该显示 <code>登陆</code> 和 <code>注册</code> 两个按钮，点击进入对应页面。</li>
<li>登陆界面
<ul>
<li>用户可以通过已经注册用户名和密码进行登陆。</li>
<li>如果用户名或密码错误，则提示用户登陆错误。</li>
<li>登陆成功则跳转至主页。</li>
</ul>
</li>
<li>注册界面
<ul>
<li>需要用户输入用户名，密码，并且需要重复输入一次密码进行确认。</li>
<li>如果两次输入密码不一致，提示用户错误。</li>
<li>注册成功则跳转至主页。</li>
</ul>
</li>
</ul>
</li>
<li>已登录后
<ul>
<li>页头组件显示 <code>Hi, xxx</code>，其中 <code>xxx</code> 为登录用户的用户名。</li>
<li>鼠标移到 <code>Hi, xxx</code> 时显示悬浮菜单，悬浮菜单包含一个登出按钮。</li>
<li>点击登出按钮，用户退出登陆状态，页头组件恢复为未登录时状态。</li>
</ul>
</li>
</ul>
<h2 id="二、系统设计">二、系统设计</h2>
<h3 id="2-1-全局状态">2.1 全局状态</h3>
<p>众所周知，React 比较有名的也是比较经典的全局状态管理插件是 Redux，作为一款成熟的状态管理库，Redux 可以很好地对全局状态进行统一管理。</p>
<p>但是，Redux 作为一款状态机，其使用和配置实在是有些复杂，就目前需求而言，并用不到。</p>
<p>而恰巧，React 16.8 添加的 React Hooks 中的 <code>useContext()</code> 就能够满足我们实现跨组件通信的需求。</p>
<blockquote>
<p>不过要注意 <code>useContext()</code> 和 Redux 并不是一样的，前者是可以实现跨组件传值，而后者是对全局状态的统一管理。</p>
</blockquote>
<h3 id="2-2-初识-useContext">2.2 初识 useContext</h3>
<p>还是从经典的计数器来尝试理解这个 API。</p>
<h4 id="第一步：创建上下文">第一步：创建上下文</h4>
<p>为了实现全局的数据共享，我们需要一个对象，来存放需要共享的数据，这个对象在这里就叫做 <code>context(上下文)</code>  。</p>
<p>我们应该把当前的次数作为上下文，以 <code>undefined</code> 为初始值创建上下文对象：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> context = createContext&lt;<span class="built_in">number</span> | <span class="literal">undefined</span>&gt;(<span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure>
<h4 id="第二部：创建父组件">第二部：创建父组件</h4>
<p>对于计数的组件而言，<code>次数</code> 应该是存放在状态中，并且能够通过点击按钮更新状态。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">CountContext</span> = createContext&lt;number | <span class="literal">undefined</span>&gt;(<span class="literal">undefined</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Counter</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>父组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;`当前的点击次数为$&#123;count&#125;`&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>子组件👇<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">SubCounter</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目前为止，我们的点击次数 <code>count</code> 只在当前组件用到了，上下文对象也没有用到。</p>
<h4 id="第三步：创建子组件">第三步：创建子组件</h4>
<p>接下来，我们写子组件 <code>SubCounter</code>，用来接收它的父组件的 <code>count</code> 状态。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">SubCounter</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;1&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span> <span class="comment">// 这里的 1 需要接收 count 的值的位置 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般来说，我们当然可以直接使用 <code>prop</code> 实现父子组件的传值，但是在这里我们就强行使用一下 <code>useContext</code> 来实现。</p>
<h4 id="第四步：钩取上下文">第四步：钩取上下文</h4>
<p>利用这个钩子函数，获取这个上下文当前的值。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里需要 import &#123;CountContext&#125; from 父组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">SubCounter</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="title function_">useContext</span>(<span class="title class_">CountContext</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第五步：Provider-提供数据共享功能">第五步：Provider 提供数据共享功能</h4>
<p>但是，仅仅想要钩到数据是不够的，我们需要有一个 <code>Provider</code> 来包裹需要获取上下文的范围，并且设定上下文的 <code>value</code>。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Counter</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">CountContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;count&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>父组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;`当前的点击次数为$&#123;count&#125;`&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>子组件👇<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">SubCounter</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">CountContext.Provider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于我们需要共享的是次数，所以 <code>value</code> 的值设定为了 <code>count</code> 这个状态。</p>
<h4 id="效果展示">效果展示</h4>
<p>效果如下：</p>
<img src="https://cdn.ethanloo.cn/img/20210527230752.gif" alt="动画 (1)" style="zoom:50%;" />
<p>可以看到，子组件通过钩子函数获取的上下文对象的值跟父组件的完全同步。</p>
<p>爷孙组件，兄弟组件以及其他更复杂的远方亲戚组件只要被包裹在一个 <code>XXXXContext.Provider</code> 里，就能很好地实现数据的共享。</p>
<h2 id="三、具体实现">三、具体实现</h2>
<p>通过以上的 <code>useContext</code> 体验，大概就能了解整套实现不同组件之间数据共享的方法了。</p>
<p>现在，我们需要加入一点点细节，来实现用户登陆状态的共享。</p>
<h3 id="3-1-创建上下文对象">3.1 创建上下文对象</h3>
<p>创建 <code>src/context</code> 文件夹用于存放和上下文相关的组件，新建 <code>auth-context.tsx</code> 组件存放上下文对象。</p>
<p>和登陆注册相关的 API 有哪些？</p>
<ul>
<li>当前登陆的用户信息</li>
<li>注册操作</li>
<li>登陆操作</li>
<li>登出操作</li>
</ul>
<p>为了能随时随地使用这些 API，所有的这些都需要放到上下文对象中，因此可以如下初始化上下文对象：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/context/auth-context.tsx</span></span><br><span class="line"><span class="comment">// 定义登陆/注册表单的数据格式</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AuthForm</span> &#123;</span><br><span class="line">  <span class="attr">username</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">password</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建上下文对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AuthContext</span> =</span><br><span class="line">  createContext&lt;</span><br><span class="line">    | &#123;</span><br><span class="line">        <span class="attr">user</span>: <span class="title class_">User</span> | <span class="literal">null</span>	<span class="comment">// 存放登陆的用户，null 表示未登录</span></span><br><span class="line">        <span class="attr">register</span>: <span class="function">(<span class="params">form: AuthForm</span>) =&gt;</span> <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt;	<span class="comment">// 注册操作</span></span><br><span class="line">        <span class="attr">login</span>: <span class="function">(<span class="params">form: AuthForm</span>) =&gt;</span> <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt;		<span class="comment">// 登陆操作</span></span><br><span class="line">        <span class="attr">logout</span>: <span class="function">() =&gt;</span> <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt;									<span class="comment">// 登出操作</span></span><br><span class="line">      &#125;</span><br><span class="line">    | <span class="literal">undefined</span></span><br><span class="line">  &gt;(<span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure>
<p>之后会解释每个方法具体是怎么定义的。</p>
<h3 id="3-2-方法定义">3.2 方法定义</h3>
<p>所有登陆相关的方法统一定义在 <code>src/auth-provider.ts</code> 文件中。</p>
<blockquote>
<p>一般项目使用第三方框架的话这个组件不需要手写，这里我们自己定义一下每个方法。</p>
</blockquote>
<p>首先要明确，用户的登陆状态是怎么记录的。为了区分用户是否登陆，也为了区分当前登陆的用户的身份，我们需要在当前域名的 <code>localStorage</code> 中存储一个 <code>token(令牌)</code>。</p>
<blockquote>
<p><code>localStorage</code> 是一个对象，它和 <code>origin(源)</code> 绑定（具体参考『跨源』的定义），存储的数据会被保存在浏览器会话中。<code>localStorage</code> 的数据可以长期保留，页面关闭并不会导致其被清除。</p>
</blockquote>
<p>在这里我们可以简单理解为通过存储 <code>token</code> 值，用户的登陆状态可以持久地被存储在本地。</p>
<p>通常来讲，这个 <code>token</code> 值是在用户登陆时后端自动生成的，经过特定时间过期。但是由于我们这里使用的是 <code>json-server</code> 来伪造数据接口，所以如果要实现定时过期 <code>token</code>，要么废除 <code>json-server</code> 手动开发后端接口，要么在 <code>json-server</code> 中安装插件对登录和注册接口进行包装。</p>
<p>而我，则选择令 <code>token</code> 值在用户注册的时候直接写死到用户属性中，先暂时忽略 <code>token</code> 会过期的特性，将精力集中到状态的保持上。</p>
<p>用户数据的类型定义如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/type/user.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">username</span>: <span class="built_in">string</span>	<span class="comment">// 用户名</span></span><br><span class="line">  <span class="attr">password</span>: <span class="built_in">string</span>	<span class="comment">// 密码(明文)</span></span><br><span class="line">  <span class="attr">token</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们需要把 <code>token</code> 存储到 <code>localStorage</code> 中，其存储格式为键值对形式。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/auth-provider.ts</span></span><br><span class="line"><span class="comment">// 用于实现用户认证的 token 的键名</span></span><br><span class="line"><span class="keyword">const</span> localStorageKey = <span class="string">&#x27;__auth_provider_token__&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 token 的方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getToken</span> = (<span class="params"></span>) =&gt; <span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">getItem</span>(localStorageKey)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">handleUserResponse</span> = (<span class="params">user: User</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 用来处理登陆和注册的回调函数</span></span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">setItem</span>(localStorageKey, user.<span class="property">token</span> || <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> user</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来先写 <code>login</code> 方法，根据之前的定义 <code>login: (form: AuthForm) =&gt; Promise&lt;void&gt;</code>已知获取的表单信息包括 <code>username, password</code>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">login</span> = (<span class="params">data: &#123; username: <span class="built_in">string</span>; password: <span class="built_in">string</span> &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fetch</span>(<span class="string">`<span class="subst">$&#123;apiUrl&#125;</span>/users?username=<span class="subst">$&#123;data.username&#125;</span>`</span>, &#123;</span><br><span class="line">    <span class="comment">// 根据用户名查询用户对象</span></span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="keyword">async</span> (response) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> response.<span class="title function_">json</span>()</span><br><span class="line">    <span class="keyword">const</span> user = res?.[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> (!user || data.<span class="property">password</span> !== user.<span class="property">password</span>) &#123;</span><br><span class="line">      <span class="comment">// 根据用户名无法检索到用户 || 用户输入密码错误，我们都直接提示用户名或密码错误。</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="string">&#x27;用户名或密码错误❌&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response.<span class="property">ok</span> &amp;&amp; data.<span class="property">password</span> === user.<span class="property">password</span>) &#123;</span><br><span class="line">      <span class="comment">// 当用户密码正确，进行登陆成功的回调，存储 token。</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">handleUserResponse</span>(user)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 其余错误直接返回。</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>register</code> 方法也类似，唯一区别是会注册时随机生成一个 6 位的 <code>token</code> 和用户绑定。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">register</span> = (<span class="params">data: &#123; username: <span class="built_in">string</span>; password: <span class="built_in">string</span> &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> user = &#123; ...data, <span class="attr">token</span>: <span class="title class_">Math</span>.<span class="title function_">random</span>().<span class="title function_">toString</span>(<span class="number">36</span>).<span class="title function_">slice</span>(-<span class="number">6</span>) &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fetch</span>(<span class="string">`<span class="subst">$&#123;apiUrl&#125;</span>/users`</span>, &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">body</span>: <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(user),</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="keyword">async</span> (response) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (response.<span class="property">ok</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">handleUserResponse</span>(<span class="keyword">await</span> response.<span class="title function_">json</span>())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">await</span> response.<span class="title function_">json</span>())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>logout</code> 登出方法就简单的多了，直接清除 <code>localStorage</code> 中存储的 <code>token</code> 即可。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">logout</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">removeItem</span>(localStorageKey)</span><br></pre></td></tr></table></figure>
<h3 id="3-3-Provider-定义">3.3 Provider 定义</h3>
<p>在这里，我们把原本的 <code>XXXContext.Provider</code> 抽象成了一个组件 <code>XXXProvider</code>，既能提高组件的聚合性，也方便了多个 <code>Provider</code> 的组合（之后再谈）。</p>
<p>先记得安装一个 hooks 的库 <code>ahooks</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yarn add ahooks</span><br></pre></td></tr></table></figure>
<p>让我们回到 <code>src/context/auth-context.tsx</code> 来继续开发用于组件提供共享数据的供应商 <code>AuthProvider</code>。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> auth <span class="keyword">from</span> <span class="string">&#x27;auth-provider&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; http &#125; <span class="keyword">from</span> <span class="string">&#x27;utils/http&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useMount, useRequest &#125; <span class="keyword">from</span> <span class="string">&#x27;ahooks&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该异步函数用于检测用户是否已经登陆，逻辑是根据 token 获取 user 信息</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">bootstrapUser</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> user = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">const</span> token = auth.<span class="title function_">getToken</span>()</span><br><span class="line">  <span class="keyword">if</span> (token) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">http</span>(<span class="string">`users`</span>, &#123; token &#125;)</span><br><span class="line">    user = data?.[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> user</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里的参数是 &#123;children&#125;，因为我们需要包裹指定范围内的所有组件。</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">AuthProvider</span> = (<span class="params">&#123; children &#125;: &#123; children: ReactNode &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 利用 ahooks 中封装好的 useRequest 来执行异步函数</span></span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="attr">data</span>: user,</span><br><span class="line">    error,</span><br><span class="line">    loading,</span><br><span class="line">    mutate,</span><br><span class="line">  &#125; = useRequest&lt;<span class="title class_">User</span> | <span class="literal">null</span>&gt;(bootstrapUser)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义登陆，注册，登出三个方法</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">login</span> = (<span class="params">form: AuthForm</span>) =&gt; auth.<span class="title function_">login</span>(form).<span class="title function_">then</span>(mutate)</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">register</span> = (<span class="params">form: AuthForm</span>) =&gt; auth.<span class="title function_">register</span>(form).<span class="title function_">then</span>(mutate)</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">logout</span> = (<span class="params"></span>) =&gt; auth.<span class="title function_">logout</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">mutate</span>(<span class="literal">null</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据加载和报错情况，返回对应全局组件</span></span><br><span class="line">  <span class="keyword">if</span> (loading) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">FullPageLoading</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">FullPageErrorFallback</span> <span class="attr">error</span>=<span class="string">&#123;error&#125;</span> /&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个可以共享上下文的组件，并且保留了范围内的子组件</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">AuthContext.Provider</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">children</span>=<span class="string">&#123;children&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">value</span>=<span class="string">&#123;&#123;</span> <span class="attr">user</span>, <span class="attr">login</span>, <span class="attr">register</span>, <span class="attr">logout</span> &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    /&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>谈谈重点，在这里我们先定义了一个异步函数 <code>bootstrapUser</code>，用来加载已经登陆的用户。它的逻辑也比较简单，就是根据本地的 <code>localStorage</code> 中存储的 <code>token</code> 去请求用户数据。</p>
<p>在定义 <code>AuthProvider</code> 的时候，使用了 <code>ahooks</code> 库中提供的 <code>useRequest</code> 函数，该函数是专门封装好用来运行异步函数的钩子函数，它会返回一个对象，里面包含各种常用 API。</p>
<ul>
<li>
<p><code>data</code> 是执行完异步函数的返回值，将其自定义命名为 <code>user</code>。</p>
</li>
<li>
<p><code>error, loading</code> ，可以快速判断异步函数是否报错以及是否在加载中。</p>
</li>
<li>
<p><code>mutate</code> 突变函数，用来修改 <code>data</code> 的值，即在登陆，注册，登出的时候我们需要将修改用户的状态。</p>
</li>
</ul>
<h3 id="3-4-包裹组件">3.4 包裹组件</h3>
<p>为了能够在之后快速兼容各种其他的 <code>Provider</code>，我们需要在 <code>AuthProvider</code> 的外面包裹一层  <code>AppProvider</code>。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/context/index.tsx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ReactNode</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">AuthProvider</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;context/auth-context&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">AppProviders</span> = (<span class="params">&#123; children &#125;: &#123; children: ReactNode &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">AuthProvider</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">AuthProvider</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后将这个 <code>AppProvider</code> 包裹到 <code>App</code> 的外面。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/index.tsx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOM</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">AppProviders</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;context&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">AppProviders</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">AppProviders</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">React.StrictMode</span>&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="3-5-自定义-Hook">3.5 自定义 Hook</h3>
<p>为了能够在各个组件之中更加方便地调用上下文，我们需要自定义一个 hook。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/context/auth-context.tsx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useAuth</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> context = <span class="title class_">React</span>.<span class="title function_">useContext</span>(<span class="title class_">AuthContext</span>)</span><br><span class="line">  <span class="keyword">if</span> (!context) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;useAuth必须在AuthProvider中使用&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> context</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、界面组件">四、界面组件</h2>
<h3 id="4-1-登陆界面">4.1 登陆界面</h3>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/screens/unauthenticated-app/login.tsx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; useAuth &#125; <span class="keyword">from</span> <span class="string">&#x27;context/auth-context&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Button</span>, <span class="title class_">Form</span>, <span class="title class_">Input</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useJumpTo &#125; <span class="keyword">from</span> <span class="string">&#x27;utils&#x27;</span></span><br><span class="line"><span class="keyword">import</span> useRequest <span class="keyword">from</span> <span class="string">&#x27;@ahooksjs/use-request&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">LoginScreen</span> = (<span class="params">&#123;</span></span><br><span class="line"><span class="params">  onError,</span></span><br><span class="line"><span class="params">&#125;: &#123;</span></span><br><span class="line"><span class="params">  onError: (error: string) =&gt; <span class="keyword">void</span></span></span><br><span class="line"><span class="params">&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; login &#125; = <span class="title function_">useAuth</span>()	<span class="comment">// 获取 login 方法</span></span><br><span class="line">  <span class="keyword">const</span> &#123; run, loading &#125; = <span class="title function_">useRequest</span>(login, &#123;</span><br><span class="line">    <span class="attr">manual</span>: <span class="literal">true</span>,					<span class="comment">// 手动操作登陆异步函数</span></span><br><span class="line">    <span class="attr">throwOnError</span>: <span class="literal">true</span>,		<span class="comment">// 允许抛出异常</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> backHome = <span class="title function_">useJumpTo</span>(<span class="string">&#x27;/&#x27;</span>)		<span class="comment">// 使用自定义跳转 hook，用于返回主页</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理提交表单的操作</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleSubmit</span> = (<span class="params">values: &#123; username: string; password: string &#125;</span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">run</span>(values)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">backHome</span>())</span><br><span class="line">      .<span class="title function_">catch</span>(onError)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回登陆表单</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Form</span> <span class="attr">onFinish</span>=<span class="string">&#123;handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Form.Item</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">name</span>=<span class="string">&#123;</span>&#x27;<span class="attr">username</span>&#x27;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">rules</span>=<span class="string">&#123;[&#123;</span> <span class="attr">required:</span> <span class="attr">true</span>, <span class="attr">message:</span> &#x27;<span class="attr">请输入用户名</span>&#x27; &#125;]&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Input</span> <span class="attr">placeholder</span>=<span class="string">&#123;</span>&#x27;<span class="attr">用户名</span>&#x27;&#125; <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&#123;</span>&#x27;<span class="attr">username</span>&#x27;&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Form.Item</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">name</span>=<span class="string">&#123;</span>&#x27;<span class="attr">password</span>&#x27;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">rules</span>=<span class="string">&#123;[&#123;</span> <span class="attr">required:</span> <span class="attr">true</span>, <span class="attr">message:</span> &#x27;<span class="attr">请输入密码</span>&#x27; &#125;]&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Input</span> <span class="attr">placeholder</span>=<span class="string">&#123;</span>&#x27;<span class="attr">密码</span>&#x27;&#125; <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&#123;</span>&#x27;<span class="attr">password</span>&#x27;&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">loading</span>=<span class="string">&#123;loading&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width:</span> &#x27;<span class="attr">100</span>%&#x27; &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">htmlType</span>=<span class="string">&#123;</span>&#x27;<span class="attr">submit</span>&#x27;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">type</span>=<span class="string">&#123;</span>&#x27;<span class="attr">primary</span>&#x27;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &gt;</span></span></span><br><span class="line"><span class="language-xml">          登录</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Form</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-2-注册界面">4.2 注册界面</h3>
<p>注册和登陆两个组件大同小异，调整表单结构增加『确认密码』的输入框，并且在注册时候需要保证两个密码框的值相同。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/screens/unauthenticated-app/register.tsx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; useAuth &#125; <span class="keyword">from</span> <span class="string">&#x27;context/auth-context&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Button</span>, <span class="title class_">Form</span>, <span class="title class_">Input</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useJumpTo &#125; <span class="keyword">from</span> <span class="string">&#x27;utils&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useRequest &#125; <span class="keyword">from</span> <span class="string">&#x27;ahooks&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">RegisterScreen</span> = (<span class="params">&#123;</span></span><br><span class="line"><span class="params">  onError,</span></span><br><span class="line"><span class="params">&#125;: &#123;</span></span><br><span class="line"><span class="params">  onError: (error: string) =&gt; <span class="keyword">void</span></span></span><br><span class="line"><span class="params">&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; register &#125; = <span class="title function_">useAuth</span>()</span><br><span class="line">  <span class="keyword">const</span> &#123; run, loading &#125; = <span class="title function_">useRequest</span>(register, &#123;</span><br><span class="line">    <span class="attr">manual</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">throwOnError</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> backHome = <span class="title function_">useJumpTo</span>(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleSubmit</span> = (<span class="params">&#123;</span></span><br><span class="line"><span class="params">    cpassword,</span></span><br><span class="line"><span class="params">    ...values</span></span><br><span class="line"><span class="params">  &#125;: &#123;</span></span><br><span class="line"><span class="params">    username: string</span></span><br><span class="line"><span class="params">    password: string</span></span><br><span class="line"><span class="params">    cpassword: string</span></span><br><span class="line"><span class="params">  &#125;</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (cpassword !== values.<span class="property">password</span>) &#123;</span><br><span class="line">      <span class="title function_">onError</span>(<span class="string">&#x27;请确认两次输入的密码相同&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">run</span>(values)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function">() =&gt;</span> <span class="title function_">backHome</span>())</span><br><span class="line">      .<span class="title function_">catch</span>(onError)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Form</span> <span class="attr">onFinish</span>=<span class="string">&#123;handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Form.Item</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">name</span>=<span class="string">&#123;</span>&#x27;<span class="attr">username</span>&#x27;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">rules</span>=<span class="string">&#123;[&#123;</span> <span class="attr">required:</span> <span class="attr">true</span>, <span class="attr">message:</span> &#x27;<span class="attr">请输入用户名</span>&#x27; &#125;]&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Input</span> <span class="attr">placeholder</span>=<span class="string">&#123;</span>&#x27;<span class="attr">用户名</span>&#x27;&#125; <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&#123;</span>&#x27;<span class="attr">username</span>&#x27;&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Form.Item</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">name</span>=<span class="string">&#123;</span>&#x27;<span class="attr">password</span>&#x27;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">rules</span>=<span class="string">&#123;[&#123;</span> <span class="attr">required:</span> <span class="attr">true</span>, <span class="attr">message:</span> &#x27;<span class="attr">请输入密码</span>&#x27; &#125;]&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Input</span> <span class="attr">placeholder</span>=<span class="string">&#123;</span>&#x27;<span class="attr">密码</span>&#x27;&#125; <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&#123;</span>&#x27;<span class="attr">password</span>&#x27;&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Form.Item</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">name</span>=<span class="string">&#123;</span>&#x27;<span class="attr">cpassword</span>&#x27;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">rules</span>=<span class="string">&#123;[&#123;</span> <span class="attr">required:</span> <span class="attr">true</span>, <span class="attr">message:</span> &#x27;<span class="attr">请确认密码</span>&#x27; &#125;]&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Input</span> <span class="attr">placeholder</span>=<span class="string">&#123;</span>&#x27;<span class="attr">确认密码</span>&#x27;&#125; <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&#123;</span>&#x27;<span class="attr">cpassword</span>&#x27;&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width:</span> &#x27;<span class="attr">100</span>%&#x27; &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">loading</span>=<span class="string">&#123;loading&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">htmlType</span>=<span class="string">&#123;</span>&#x27;<span class="attr">submit</span>&#x27;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">type</span>=<span class="string">&#123;</span>&#x27;<span class="attr">primary</span>&#x27;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &gt;</span></span></span><br><span class="line"><span class="language-xml">          注册</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Form</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-界面集成">4.3 界面集成</h3>
<p>为了让注册和登陆界面没那么单调，我们在其外面再包裹一层 <code>UnauthenticatedApp</code> 组件，用于渲染一些其他的装饰。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/screens/unauthenticated-app/index.tsx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&#x27;@emotion/styled&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Typography</span>, notification &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useLocation &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">LoginScreen</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./login&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RegisterScreen</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./register&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">LogoSvg</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;components/lib&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">UnauthenticatedApp</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> url = <span class="title function_">useLocation</span>()		<span class="comment">// 获取当前 URL，用于判断是注册界面还是登陆界面</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">showError</span> = (<span class="params">error: string</span>) =&gt; &#123;	<span class="comment">// 利用 antd 的提示窗口进行错误提示</span></span><br><span class="line">    notification.<span class="title function_">open</span>(&#123;</span><br><span class="line">      <span class="attr">key</span>: error,	<span class="comment">// 设定 key 可以避免显示重复错误</span></span><br><span class="line">      <span class="attr">message</span>: error,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Container</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Typography.Text</span> <span class="attr">strong</span>&gt;</span>SooMooc<span class="tag">&lt;/<span class="name">Typography.Text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">LogoSvg</span> <span class="attr">size</span>=<span class="string">&#123;</span>&#x27;<span class="attr">7rem</span>&#x27;&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>你的不二之选<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">FromContainer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;url.pathname === &#x27;/login&#x27; ? (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">LoginScreen</span> <span class="attr">onError</span>=<span class="string">&#123;showError&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        ) : (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">RegisterScreen</span> <span class="attr">onError</span>=<span class="string">&#123;showError&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        )&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">FromContainer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Container</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">Container</span> = styled.<span class="property">div</span><span class="string">`</span></span><br><span class="line"><span class="string">  display: flex;</span></span><br><span class="line"><span class="string">  justify-content: center;</span></span><br><span class="line"><span class="string">  align-items: center;</span></span><br><span class="line"><span class="string">  flex: 1;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Title</span> = styled.<span class="property">div</span><span class="string">`</span></span><br><span class="line"><span class="string">  font-size: 5rem;</span></span><br><span class="line"><span class="string">  margin-right: 15%;</span></span><br><span class="line"><span class="string">  p &#123;</span></span><br><span class="line"><span class="string">    white-space: nowrap;</span></span><br><span class="line"><span class="string">    margin-bottom: 0;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">FromContainer</span> = styled.<span class="property">div</span><span class="string">`</span></span><br><span class="line"><span class="string">  border-radius: 8px;</span></span><br><span class="line"><span class="string">  box-shadow: 0 2px 4px rgb(0 0 0 / 10%), 0 8px 16px rgb(0 0 0 / 10%);</span></span><br><span class="line"><span class="string">  border: none;</span></span><br><span class="line"><span class="string">  padding: 2rem 1rem 0 1rem;</span></span><br><span class="line"><span class="string">  background-color: #fff;</span></span><br><span class="line"><span class="string">  min-width: 30rem;</span></span><br><span class="line"><span class="string">  input,</span></span><br><span class="line"><span class="string">  button &#123;</span></span><br><span class="line"><span class="string">    font-size: 2rem;</span></span><br><span class="line"><span class="string">    height: 4rem;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  position: relative;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当然，还需要把这个组件包裹到 <code>App.tsx</code> 路由中。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> exact path=&#123;<span class="string">&#x27;/login&#x27;</span>&#125; component=&#123;<span class="title class_">UnauthenticatedApp</span>&#125; /&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">register</span>&#x27;&#125; <span class="attr">component</span>=<span class="string">&#123;UnauthenticatedApp&#125;</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="五、成果展示">五、成果展示</h2>
<p>终于开发完了，来看看效果吧。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210529124031.gif" alt="动画 (1)"></p>
<p><img src="https://cdn.ethanloo.cn/img/20210528092750.webp" alt="Thumbnail (1)"></p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>直播平台</tag>
        <tag>Ant Design</tag>
      </tags>
  </entry>
  <entry>
    <title>路由配置 | SooMooc 直播平台</title>
    <url>/post/2021-05-15-SooMooc/%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE%20-%20SooMooc%20%E7%9B%B4%E6%92%AD%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<blockquote>
<p>前端所有代码已经同步到 GitHub Repo: <a href="https://github.com/EthanLuu/soomooc">EthanLuu/soomooc: React + TypeScript 实践，在线教学直播平台。 (github.com)</a></p>
</blockquote>
<p>作为一款 SPA 应用，我们通过路由对页面显示的内容进行动态调整。</p>
<h2 id="react-router安装">react-router安装</h2>
<p>由于我们是在 Web 中进行开发，所以安装的是 <code>react-router-dom</code> 库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装 react-router-dom</span></span><br><span class="line">yarn add react-router-dom</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">适配 TypeScript</span></span><br><span class="line">yarn add @types/react-router-dom -D</span><br></pre></td></tr></table></figure>
<h2 id="组件调整">组件调整</h2>
<p>在上一次写主页的时候，我们把主页的组件组成直接写在了 <code>App.tsx</code> 中，显然这个方式并不好。</p>
<p>我们希望以路由的方式对页面显示的内容进行控制。</p>
<img src="https://cdn.ethanloo.cn/img/20210515210852.png" alt="code" style="zoom: 50%;" />
<p>原来的 <code>Content</code> 这个命名也不够标准，我们将其名字从 <code>Content.tsx</code> 改成 <code>index.tsx</code>，表示主页的界面。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210515213755.png" alt="image-20210515213754966"></p>
<p>同时，将其导出的组件名称修改为 <code>HomePage</code>，同时把原来外面那个 <code>Container</code> 组件去掉，我们将其作为公共组件直接写到 <code>App.tsx</code> 中去。</p>
<img src="https://cdn.ethanloo.cn/img/20210515224052.png" alt="code" style="zoom:50%;" />
<h2 id="基础路由配置">基础路由配置</h2>
<p>现在就可以根据我们当前已经写的界面来修改根组件啦！</p>
<p>整理下我们现在有的几个界面：</p>
<ul>
<li>首页界面，<code>&lt;HomePage /&gt;</code> 组件</li>
<li>写一个注册界面 <code>&lt;LoginScreen /&gt;</code>，直接返回一个 H1 标题。</li>
<li>写一个登陆界面 <code>&lt;RegisterScreen /&gt;</code>，直接返回一个 H1 标题。</li>
<li>写一个 <code>NotFoundPage</code> 组件，作为 404 界面，当输入的路由无法匹配时显示该界面。</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Result</span>, <span class="title class_">Button</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Link</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">NotFoundPage</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Result</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">status</span>=<span class="string">&quot;404&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">title</span>=<span class="string">&quot;404&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">subTitle</span>=<span class="string">&quot;未知资源&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">extra</span>=<span class="string">&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &lt;<span class="attr">Button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>&#x27;/&#x27;&#125;&gt;</span>返回首页<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#125;</span></span><br><span class="line"><span class="language-xml">    /&gt;</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引入 <code>BrowserRouter</code> 包裹页面，并且新建路由项 <code>Route</code>，将其指向根目录并且将需要显示的组件设定为 <code>HomePage</code> 组件。</p>
<blockquote>
<p>似乎给 <code>BrowserRouter</code> 起个别名 <code>Router</code> 已经成了传统，那我们就干脆继承过来吧。</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./App.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ErrorBoundary</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;components/error-boundary&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">FullPageErrorFallback</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;components/lib&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BrowserRouter</span> <span class="keyword">as</span> <span class="title class_">Router</span>, <span class="title class_">Route</span>, <span class="title class_">Switch</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">HomePage</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;screens/home&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Header</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;components/header&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Footer</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;components/footer&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">NotFoundPage</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;screens/404&#x27;</span></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&#x27;@emotion/styled&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">LoginPage</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;screens/login&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RegisterPage</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;screens/register&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ErrorBoundary</span> <span class="attr">fallbackRender</span>=<span class="string">&#123;FullPageErrorFallback&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Main</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&#123;</span>&#x27;/&#x27;&#125; <span class="attr">component</span>=<span class="string">&#123;HomePage&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">login</span>&#x27;&#125; <span class="attr">component</span>=<span class="string">&#123;LoginPage&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">register</span>&#x27;&#125; <span class="attr">component</span>=<span class="string">&#123;RegisterPage&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#123;</span>&#x27;*&#x27;&#125; <span class="attr">component</span>=<span class="string">&#123;NotFoundPage&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">Main</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Footer</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Main</span> = styled.<span class="property">div</span><span class="string">`</span></span><br><span class="line"><span class="string">  padding: 3rem 10rem;</span></span><br><span class="line"><span class="string">  flex: 1;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有几个小 tips。</p>
<ol>
<li>这边我把 <code>Header</code> 和 <code>Footer</code> 放置在 <code>Route</code> 的外侧作为两个固定渲染的组件，因为就目前需求而言，这两个组件每个页面都会用到。</li>
<li>在写路由的时候在外侧包裹 <code>Switch</code> 的原因保证只会渲染一个路由，加上 <code>exact</code> 关键字是为了实现精确匹配（避免 <code>/login</code> 匹配到 <code>/</code>）。</li>
<li>把 404 组件的路由项放到最后一个，保证只有在无法匹配到已有路由时才会显示该界面。</li>
</ol>
<p>404 界面效果图：</p>
<p><img src="https://cdn.ethanloo.cn/img/20210515224336.png" alt="image-20210515224335670"></p>
<h2 id="课程列表组件">课程列表组件</h2>
<p>为了更加能够通过更加真实的体验去了解路由配置的过程，我决定先把课程相关的界面大致写出来。</p>
<p>在 <code>src/screens</code> 下新建两个文件夹，<code>course</code> 文件夹中存放课程详情界面的组件，<code>course-list</code> 文件夹中存放课程列表的组件。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210517161729.png" alt="image-20210517161721967"></p>
<p>先把复杂的课程列表写完，包含三个组件 <code>card.tsx</code> 用来以卡片格式展示某个课程的信息，<code>index.tsx</code> 用来渲染整个课程列表界面，<code>list.tsx</code> 用来组织课程列表。</p>
<img src="https://cdn.ethanloo.cn/img/20210517162656.png" alt="无标题" style="zoom:50%;" />
<p>在定义 <code>Course(课程类)</code> 的数据结构时，由于课程应该是公用，所以我将其提取到 <code>src/type/course.ts</code> 中（新建）。</p>
<img src="https://cdn.ethanloo.cn/img/20210517162051.png" alt="code" style="zoom:50%;" />
<p>接下去编写最外层的框架 <code>index.tsx</code>，写一个组件 <code>CourseListScreen</code> 。</p>
<p>该组件需要完成的功能很简单，展示页面的标题，获取所有的课程信息，并且渲染 <code>course-list.tsx</code> 中的 <code>CourseList</code> 组件。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Course</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;type/course&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useHttp &#125; <span class="keyword">from</span> <span class="string">&#x27;utils/http&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CourseList</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./list&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Divider</span>, <span class="title class_">Row</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">CourseListScreen</span>: <span class="title class_">React</span>.<span class="property">FC</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> client = <span class="title function_">useHttp</span>()</span><br><span class="line">  <span class="keyword">const</span> [courses, setCourses] = useState&lt;<span class="title class_">Course</span>[]&gt;([])</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">client</span>(<span class="string">&#x27;course&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">courses</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCourses</span>(courses)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [client])</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Row</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">justifyContent:</span> &#x27;<span class="attr">center</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>全部课程<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Row</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Divider</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">CourseList</span> <span class="attr">courses</span>=<span class="string">&#123;courses&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">CourseList</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>course-list.tsx</code> 中，新建 <code>CourseList</code> 组件，利用 <code>grid</code> 布局，每行放最多 4 个课程的卡片。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Col</span>, <span class="title class_">Row</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Course</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;type/course&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CourseCard</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./card&#x27;</span></span><br><span class="line"></span><br><span class="line">interface <span class="title class_">ListProps</span> &#123;</span><br><span class="line">  <span class="attr">courses</span>: <span class="title class_">Course</span>[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">CourseList</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">ListProps</span>&gt; = <span class="function">(<span class="params">&#123; courses &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Row</span> <span class="attr">gutter</span>=<span class="string">&#123;24&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;courses?.map((course) =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">          return (</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Col</span> <span class="attr">span</span>=<span class="string">&#123;6&#125;</span> <span class="attr">key</span>=<span class="string">&#123;course.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">CourseCard</span> <span class="attr">course</span>=<span class="string">&#123;course&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">CourseCard</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Col</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          )</span></span><br><span class="line"><span class="language-xml">        &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Row</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>参考慕课网的课程列表展示方式，我利用 <code>&lt;Card /&gt;</code> 组件来展示课程信息。</p>
<p>课程信息卡片组件收到的 <code>props</code> 应该包含一个课程对象，这个课程对象包含了 <code>课程id，课程标题，封面，方向，类别，学生人数</code>。</p>
<p>正常来说，点击课程的卡片就会进入课程的详情页面，所以我们在卡片外部包裹跳转链接。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&#x27;@emotion/styled&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Card</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Course</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;type/course&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Link</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">CourseCard</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;&#123; <span class="attr">course</span>: <span class="title class_">Course</span> &#125;&gt; = <span class="function">(<span class="params">&#123; course &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; id, title, cover, direction, type, numberOfStudents &#125; = course</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>`<span class="attr">course</span>/<span class="attr">detail</span>/$&#123;<span class="attr">id</span>&#125;`&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Card</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">hoverable</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">borderRadius:</span> <span class="attr">10</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">marginBottom:</span> <span class="attr">20</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">cover</span>=<span class="string">&#123;</span>&lt;<span class="attr">Cover</span> <span class="attr">src</span>=<span class="string">&#123;cover&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Cover</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">      &gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Card.Meta</span> <span class="attr">title</span>=<span class="string">&#123;title&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Description</span>&gt;</span>&#123;`$&#123;direction&#125; | $&#123;type&#125; | $&#123;numberOfStudents&#125;人报名`&#125;<span class="tag">&lt;/<span class="name">Description</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Card</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Cover</span> = styled.<span class="property">img</span><span class="string">`</span></span><br><span class="line"><span class="string">  height: 15rem;</span></span><br><span class="line"><span class="string">  border-radius: 10px 10px 0 0 !important;</span></span><br><span class="line"><span class="string">  object-fit: cover;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Description</span> = styled.<span class="property">div</span><span class="string">`</span></span><br><span class="line"><span class="string">  margin-top: 10px;</span></span><br><span class="line"><span class="string">  color: #999;</span></span><br><span class="line"><span class="string">  white-space: nowrap;</span></span><br><span class="line"><span class="string">  overflow: hidden;</span></span><br><span class="line"><span class="string">  text-overflow: ellipsis;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再往 <code>db.json</code> 文件中加入我们需要的 mock data（拷贝于慕课网）。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;course&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2小时极速入门 TypeScript&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cover&quot;</span><span class="punctuation">:</span> <span class="string">&quot;//img3.mukewang.com/607fc1a4097d454805400304.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;direction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;前端&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TypeScript&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfStudents&quot;</span><span class="punctuation">:</span> <span class="number">2569</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vue3.0实现todolist&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cover&quot;</span><span class="punctuation">:</span> <span class="string">&quot;//img4.mukewang.com/600ebd8b08a2013605400304.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;direction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;前端&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Vue&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfStudents&quot;</span><span class="punctuation">:</span> <span class="number">4873</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;当React遇上TypeScript开发Antd组件&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cover&quot;</span><span class="punctuation">:</span> <span class="string">&quot;//img2.mukewang.com/5fe4430e0001057c05400304.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;direction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;前端&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;React&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfStudents&quot;</span><span class="punctuation">:</span> <span class="number">5699</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;趣味 C++ 入门&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cover&quot;</span><span class="punctuation">:</span> <span class="string">&quot;//img2.mukewang.com/606c41a60914530f05400304.png&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;direction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;后端&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C++&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfStudents&quot;</span><span class="punctuation">:</span> <span class="number">2285</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Python3 进阶教程 2020全新版&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cover&quot;</span><span class="punctuation">:</span> <span class="string">&quot;//img2.mukewang.com/5fe4430f0001cbe605400304.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;direction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;后端&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Python&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfStudents&quot;</span><span class="punctuation">:</span> <span class="number">20341</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">6</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Javascript实现二叉树算法&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cover&quot;</span><span class="punctuation">:</span> <span class="string">&quot;//img2.mukewang.com/5fe442fd00018a1405400304.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;direction&quot;</span><span class="punctuation">:</span> <span class="string">&quot;计算机基础&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;JavaScript&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;numberOfStudents&quot;</span><span class="punctuation">:</span> <span class="number">44848</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>写完这三个组件后，我们将 <code>CourseListScreen</code> 组件写入 <code>App.tsx</code> 的路由中。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> exact path=&#123;<span class="string">&#x27;/course&#x27;</span>&#125; component=&#123;<span class="title class_">CourseListScreen</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>适当修改一下页头中的菜单项。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Menu</span></span><br><span class="line">  theme=<span class="string">&quot;light&quot;</span></span><br><span class="line">  mode=<span class="string">&quot;horizontal&quot;</span></span><br><span class="line">  selectedKeys=&#123;[pathname]&#125;</span><br><span class="line">  style=&#123;&#123; <span class="attr">flex</span>: <span class="number">1</span> &#125;&#125;</span><br><span class="line">  &gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Menu.Item</span> <span class="attr">key</span>=<span class="string">&#123;</span>&#x27;/&#x27;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>&#x27;/&#x27;&#125;&gt;</span>首页<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Menu.Item</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Menu.Item</span> <span class="attr">key</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">course</span>&#x27;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">course</span>&#x27;&#125;&gt;</span>课程列表<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Menu.Item</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Menu</span>&gt;</span><br></pre></td></tr></table></figure>
<p>效果图如下：</p>
<p><img src="https://cdn.ethanloo.cn/img/20210517190836.png" alt="image-20210517190835754"></p>
<blockquote>
<p>记得要运行 <code>json-server</code> 服务器哦</p>
</blockquote>
<h2 id="课程详情组件">课程详情组件</h2>
<p>接着继续写课程详情界面。</p>
<p>课程详情信息的接口如下：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">CourseProps</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">  <span class="attr">title</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">cover</span>: <span class="built_in">string</span> <span class="comment">// 封面图片地址</span></span><br><span class="line">  <span class="attr">direction</span>: <span class="built_in">string</span> <span class="comment">// 方向：前端，后端...</span></span><br><span class="line">  <span class="attr">type</span>: <span class="built_in">string</span> <span class="comment">// 类别：Vue，React</span></span><br><span class="line">  <span class="attr">numberOfStudents</span>: <span class="built_in">number</span> <span class="comment">// 学生人数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">CourseDetailProps</span> <span class="keyword">extends</span> <span class="title class_">CourseProps</span> &#123;</span><br><span class="line">  <span class="attr">courseId</span>: <span class="built_in">number</span> <span class="comment">// 对应的课程id</span></span><br><span class="line">  <span class="attr">info</span>: <span class="built_in">string</span> <span class="comment">// 课程的详细介绍</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>先写个大概，之后根据具体设计修改。</p>
</blockquote>
<p>设置 <code>courseId</code> 的原因是因为需要将 <code>Course</code>和 <code>CourseDetail</code> 通过外键关联起来，另一方面 <code>json-server</code> 自带非常好用的外键功能。</p>
<p>通过 <code>/course/1/detail</code>，我就能查找到 id 为 1 的 <code>course</code> 对应的 <code>detail</code>。</p>
<p>伪造数据如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;detail&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;courseId&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="string">&quot;让你通过2小时，实现 TypeScript 的从入门到精通&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;courseId&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;info&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Vue 入门第一步：TodoList&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>在之前定义路由的时候，我们设计的是通过链接 <code>course/detail/courseId</code> 来访问课程的详情界面。</p>
<p>先在 <code>App.tsx</code> 中加入对应的路由信息。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">Switch</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&#123;</span>&#x27;/&#x27;&#125; <span class="attr">component</span>=<span class="string">&#123;HomePage&#125;</span> /&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">course</span>&#x27;&#125; <span class="attr">component</span>=<span class="string">&#123;CourseListScreen&#125;</span> /&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">exact</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">path</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">course</span>/<span class="attr">detail</span>/<span class="attr">:courseId</span>&#x27;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">component</span>=<span class="string">&#123;CourseDetailScreen&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    /&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">login</span>&#x27;&#125; <span class="attr">component</span>=<span class="string">&#123;LoginScreen&#125;</span> /&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&#123;</span>&#x27;/<span class="attr">register</span>&#x27;&#125; <span class="attr">component</span>=<span class="string">&#123;RegisterScreen&#125;</span> /&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#123;</span>&#x27;*&#x27;&#125; <span class="attr">component</span>=<span class="string">&#123;NotFoundPage&#125;</span> /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Switch</span>&gt;</span><br></pre></td></tr></table></figure>
<p>在 <code>src/screens/course/index.tsx</code> 下写出大概的组件样式，并且打印出路由相关属性研究一下。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Divider</span>, <span class="title class_">Row</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RouteComponentProps</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">CourseDetail</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">RouteComponentProps</span>&gt; = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="property">history</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="property">location</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(props.<span class="property">match</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Row</span> <span class="attr">justify</span>=<span class="string">&#123;</span>&#x27;<span class="attr">center</span>&#x27;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Row</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Row</span> <span class="attr">justify</span>=<span class="string">&#123;</span>&#x27;<span class="attr">center</span>&#x27;&#125;&gt;</span>&#123;`direction | type | numberOfStudents`&#125;<span class="tag">&lt;/<span class="name">Row</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Divider</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Row</span> <span class="attr">justify</span>=<span class="string">&#123;</span>&#x27;<span class="attr">center</span>&#x27;&#125;&gt;</span>&#123;`info`&#125;<span class="tag">&lt;/<span class="name">Row</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用 <code>ReactComponentProps</code> 来声明 <code>props</code> 的类型包含了路由信息。</p>
<p>我们通过访问任意一个课程详情界面来分别研究一下这三个对象：</p>
<ol>
<li>
<p><code>history</code>：类型为 <code>History</code>，存储了历史记录相关的信息，包括历史记录长度和<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History">其他 H5 规范中的 API</a></p>
<img src="https://cdn.ethanloo.cn/img/20210517203629.png" alt="image-20210517203629577" style="zoom:67%;" />
</li>
<li>
<p><code>location</code>：类型为 <code>Location</code>，包含了 URL 相关信息。</p>
<img src="https://cdn.ethanloo.cn/img/20210517204011.png" alt="image-20210517204011525" style="zoom: 67%;" />
</li>
<li>
<p><code>match</code>：一个对象，存储了路由相关信息。</p>
<img src="https://cdn.ethanloo.cn/img/20210517204316.png" alt="image-20210517204316443" style="zoom: 67%;" />
</li>
</ol>
<p>打印出来之后用哪个来定位 <code>courseId</code> 应该也很清楚了，显然是 <code>match.params.courseId</code>。</p>
<p>在写组件的时候遇到了一个很尬尴的问题，这是我本来写的代码。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> courseId = props.<span class="property">match</span>.<span class="property">params</span>.<span class="property">courseId</span></span><br><span class="line"><span class="keyword">const</span> client = <span class="title function_">useHttp</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [courseDetail, setCourseDetail] =</span><br><span class="line">      useState&lt;<span class="title class_">CourseDetailProps</span> | <span class="literal">null</span>&gt;(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">fetchData</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">course</span>: <span class="title class_">CourseProps</span> = <span class="keyword">await</span> <span class="title function_">client</span>(<span class="string">`course/<span class="subst">$&#123;courseId&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">detail</span>: <span class="title class_">CourseDetailProps</span>[] = <span class="keyword">await</span> <span class="title function_">client</span>(</span><br><span class="line">      <span class="string">`course/<span class="subst">$&#123;courseId&#125;</span>/detail`</span></span><br><span class="line">    )</span><br><span class="line">    <span class="title function_">setCourseDetail</span>(&#123; ...courseDetail, ...detail?.[<span class="number">0</span>], ...course &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">fetchData</span>()</span><br><span class="line">&#125;, [client, courseId])</span><br></pre></td></tr></table></figure>
<p>组件的逻辑是这样的：</p>
<ul>
<li>将课程详情定义为一个状态，并且初始化为 <code>null</code></li>
<li>在 <code>useEffect</code> 函数中，通过异步函数获取课程详情信息。</li>
<li>通过 <code>SetState</code> 函数，设置当前的课程详情。</li>
</ul>
<p>可以看到我写了一行代码：<code>setCourseDetail(&#123; ...courseDetail, ...detail?.[0], ...course &#125;)</code>，当时我写的时候的心里想法是：</p>
<blockquote>
<p>通过异步获取课程详细信息 =&gt; 解构原状态并且更新状态</p>
</blockquote>
<p>但是这样写 <code>eslint</code> 会报警告 ⚠</p>
<img src="https://cdn.ethanloo.cn/img/20210524203228.png" alt="image-20210524203221152" style="zoom:67%;" />
<p>大致含义就是因为在 <code>useEffect</code> 里用到了外部定义的变量 <code>courseDetail</code> ，提示你应该将其放到依赖项中。但是因为我们在这个 <code>useEffect</code> 中会更新 <code>courseDetail</code>，所以放到依赖项中的结果就是组件会无限重新加载。</p>
<p>于是我便开始在网上搜索解决办法，直到我找到了<a href="https://www.seangroff.dev/useeffect-state-trap/">这篇文章</a>，才发现事实上 <code>eslint</code>  已经提示了解决办法。</p>
<blockquote>
<p>有一说一，考虑到 React 的生态还是直接用英文在谷歌上搜索比较好。</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setCourseDetail</span>(<span class="function"><span class="params">c</span> =&gt;</span> (&#123; ...c,...detail?.[<span class="number">0</span>], ...course &#125;))</span><br></pre></td></tr></table></figure>
<p>以回调形式的函数作为参数，避免了直接传入原状态，因此得以去掉警告。</p>
<p>但是话又说回来了，为什么我一定要原状态呢？该组件的逻辑难道不是只需要根据路由获取课程 <code>id</code>，然后异步获取课程详情并且加载吗？本质上组件只会随着页面的加载而加载，状态也只需要在加载页面的时候获取一次。这个函数完全可以不用调用原状态，写成以下样子就行了：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">fetchData</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">course</span>: <span class="title class_">CourseProps</span> = <span class="keyword">await</span> <span class="title function_">client</span>(<span class="string">`course/<span class="subst">$&#123;courseId&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">detail</span>: <span class="title class_">CourseDetailProps</span>[] = <span class="keyword">await</span> <span class="title function_">client</span>(</span><br><span class="line">      <span class="string">`course/<span class="subst">$&#123;courseId&#125;</span>/detail`</span></span><br><span class="line">    )</span><br><span class="line">    <span class="title function_">setCourseDetail</span>(&#123; ...detail?.[<span class="number">0</span>], ...course &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">fetchData</span>()</span><br><span class="line">&#125;, [client, courseId])</span><br></pre></td></tr></table></figure>
<p>🙄 好家伙直接白忙活。</p>
<p><code>course/index.tsx</code> 组件如下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CourseBanner</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./banner&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Row</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">FullPageLoading</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;components/lib&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RouteComponentProps</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CourseDetailProps</span>, <span class="title class_">CourseProps</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;type/course&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useHttp &#125; <span class="keyword">from</span> <span class="string">&#x27;utils/http&#x27;</span></span><br><span class="line"></span><br><span class="line">interface <span class="title class_">MatchParams</span> &#123;</span><br><span class="line">  <span class="attr">courseId</span>: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">CourseDetailScreen</span>: <span class="title class_">React</span>.<span class="property">FC</span>&lt;<span class="title class_">RouteComponentProps</span>&lt;<span class="title class_">MatchParams</span>&gt;&gt; = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  props</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> courseId = props.<span class="property">match</span>.<span class="property">params</span>.<span class="property">courseId</span></span><br><span class="line">  <span class="keyword">const</span> client = <span class="title function_">useHttp</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [courseDetail, setCourseDetail] =</span><br><span class="line">    useState&lt;<span class="title class_">CourseDetailProps</span> | <span class="literal">null</span>&gt;(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">fetchData</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">course</span>: <span class="title class_">CourseProps</span> = <span class="keyword">await</span> <span class="title function_">client</span>(<span class="string">`course/<span class="subst">$&#123;courseId&#125;</span>`</span>)</span><br><span class="line">      <span class="keyword">const</span> <span class="attr">detail</span>: <span class="title class_">CourseDetailProps</span>[] = <span class="keyword">await</span> <span class="title function_">client</span>(</span><br><span class="line">        <span class="string">`course/<span class="subst">$&#123;courseId&#125;</span>/detail`</span></span><br><span class="line">      )</span><br><span class="line">      <span class="title function_">setCourseDetail</span>(&#123; ...detail?.[<span class="number">0</span>], ...course &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fetchData</span>()</span><br><span class="line">  &#125;, [client, courseId])</span><br><span class="line">  <span class="keyword">return</span> !courseDetail ? (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">FullPageLoading</span> /&gt;</span></span></span><br><span class="line">  ) : (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">CourseBanner</span> <span class="attr">courseDetail</span>=<span class="string">&#123;courseDetail&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Row</span> <span class="attr">justify</span>=<span class="string">&#123;</span>&#x27;<span class="attr">center</span>&#x27;&#125;&gt;</span>&#123;`$&#123;courseDetail?.info&#125;`&#125;<span class="tag">&lt;/<span class="name">Row</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>course/banner.tsx</code> 组件用于展示课程详细信息界面的头图：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&#x27;@emotion/styled&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CourseDetailProps</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;type/course&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">CourseBanner</span> = (<span class="params">&#123;</span></span><br><span class="line"><span class="params">  courseDetail,</span></span><br><span class="line"><span class="params">&#125;: &#123;</span></span><br><span class="line"><span class="params">  courseDetail: CourseDetailProps</span></span><br><span class="line"><span class="params">&#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">TitleContainer</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">backgroundImage:</span> `<span class="attr">url</span>($&#123;<span class="attr">courseDetail.cover</span>&#125;)` &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">fontSize:</span> &#x27;<span class="attr">3.5rem</span>&#x27;, <span class="attr">fontWeight:</span> <span class="attr">600</span> &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &gt;</span>&#123;`$&#123;courseDetail?.title&#125;`&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">fontSize:</span> &#x27;<span class="attr">1.5rem</span>&#x27; &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &gt;</span>&#123;`$&#123;courseDetail?.direction&#125; | $&#123;courseDetail?.type&#125; | $&#123;courseDetail?.numberOfStudents&#125; 人正在学习`&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">TitleContainer</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TitleContainer</span> = styled.<span class="property">div</span><span class="string">`</span></span><br><span class="line"><span class="string">  display: flex;</span></span><br><span class="line"><span class="string">  height: 20rem;</span></span><br><span class="line"><span class="string">  overflow: hidden;</span></span><br><span class="line"><span class="string">  background-size: cover;</span></span><br><span class="line"><span class="string">  background-repeat: no-repeat;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Title</span> = styled.<span class="property">div</span><span class="string">`</span></span><br><span class="line"><span class="string">  display: flex;</span></span><br><span class="line"><span class="string">  flex: auto;</span></span><br><span class="line"><span class="string">  flex-direction: column;</span></span><br><span class="line"><span class="string">  align-items: center;</span></span><br><span class="line"><span class="string">  justify-content: space-around;</span></span><br><span class="line"><span class="string">  color: #fff;</span></span><br><span class="line"><span class="string">  padding: 3rem 0;</span></span><br><span class="line"><span class="string">  background-color: rgba(0, 0, 0, 0.4);</span></span><br><span class="line"><span class="string">  backdrop-filter: blur(20px);</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当前效果如下：</p>
<p><img src="https://cdn.ethanloo.cn/img/20210524215917.gif" alt="动画 (1)"></p>
<p><img src="https://cdn.ethanloo.cn/img/20210515223925.webp" alt="Thumbnail (3)-tuya"></p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>直播平台</tag>
        <tag>Ant Design</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建门面 | SooMooc 直播平台</title>
    <url>/post/2021-05-12-SooMooc/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA%20-%20SooMooc%20%E7%9B%B4%E6%92%AD%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<blockquote>
<p>前端所有代码已经同步到 GitHub Repo: <a href="https://github.com/EthanLuu/soomooc">EthanLuu/soomooc: React + TypeScript 实践，在线教学直播平台。 (github.com)</a></p>
<p>项目的界面只是初步设计，后续还会随着功能的变更而更改界面</p>
</blockquote>
<h2 id="Header">Header</h2>
<p>先去 <a href="https://www.iconfont.cn/">iconfont-阿里巴巴矢量图标库</a> 上挑选一个合适的图标作为网站的 LOGO。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210511210929.svg" alt="icon"></p>
<p>下载之后放到 <code>assets</code> 文件夹中。</p>
<p>新建 <code>/components/header.tsx</code> 组件，用来存放我们网站的公共页头。</p>
<p>简单写一点样式，用上 antd 提供的布局组件和按钮组件等。</p>
<p>我这边写了很多行内样式，后续考虑如果需要复用的话会抽象成组件。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&#x27;@emotion/styled&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Button</span>, <span class="title class_">Layout</span>, <span class="title class_">Menu</span>, <span class="title class_">Row</span>, <span class="title class_">Typography</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ButtonGroup</span> <span class="keyword">from</span> <span class="string">&#x27;antd/lib/button/button-group&#x27;</span></span><br><span class="line"><span class="keyword">import</span> logo <span class="keyword">from</span> <span class="string">&#x27;assets/logo.svg&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Search</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;components/search&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Header</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Layout.Header</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">background:</span> &#x27;<span class="attr">white</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">boxSizing:</span> &#x27;<span class="attr">border-box</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">boxShadow:</span> &#x27;<span class="attr">0</span> <span class="attr">2px</span> <span class="attr">8px</span> #<span class="attr">f0f1f2</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    &gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Row</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">height:</span> &#x27;<span class="attr">6.4rem</span>&#x27;, <span class="attr">alignItems:</span> &#x27;<span class="attr">center</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#123;</span>&#x27;/&#x27;&#125; <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width:</span> &#x27;<span class="attr">20rem</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Logo</span> <span class="attr">src</span>=<span class="string">&#123;logo&#125;</span> <span class="attr">alt</span>=<span class="string">&quot;logo&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Typography.Title</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">level</span>=<span class="string">&#123;3&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">lineHeight:</span> &#x27;<span class="attr">6.4rem</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">marginBottom:</span> <span class="attr">0</span>,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">              <span class="attr">marginLeft:</span> &#x27;<span class="attr">6rem</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          &gt;</span></span></span><br><span class="line"><span class="language-xml">            SooMooc</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">Typography.Title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Menu</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">theme</span>=<span class="string">&quot;light&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">mode</span>=<span class="string">&quot;horizontal&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">defaultSelectedKeys</span>=<span class="string">&#123;[</span>&#x27;<span class="attr">1</span>&#x27;]&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">background:</span> &#x27;<span class="attr">white</span>&#x27;, <span class="attr">border:</span> &#x27;<span class="attr">none</span>&#x27;, <span class="attr">flex:</span> &#x27;<span class="attr">auto</span>&#x27; &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Menu.Item</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">Menu.Item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Menu.Item</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>课程<span class="tag">&lt;/<span class="name">Menu.Item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Menu</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Search</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ButtonGroup</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">alignItems:</span> &#x27;<span class="attr">center</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Button</span> <span class="attr">type</span>=<span class="string">&quot;link&quot;</span>&gt;</span>注册<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Button</span> <span class="attr">type</span>=<span class="string">&quot;link&quot;</span>&gt;</span>登陆<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ButtonGroup</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Row</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Layout.Header</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Logo</span> = styled.<span class="property">img</span><span class="string">`</span></span><br><span class="line"><span class="string">  height: 5rem;</span></span><br><span class="line"><span class="string">  width: 5rem;</span></span><br><span class="line"><span class="string">  float: left;</span></span><br><span class="line"><span class="string">  margin: 0.7rem 0;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>单独写的一个搜索框的组件 <code>/components/search.tsx</code></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Input</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Search</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleSearch</span> = (<span class="params"></span>) =&gt; &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Input.Search</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">placeholder</span>=<span class="string">&#123;</span>&quot;<span class="attr">搜索课程</span>&quot;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width:</span> <span class="attr">300</span>, <span class="attr">paddingRight:</span> &#x27;<span class="attr">5rem</span>&#x27; &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      <span class="attr">onSearch</span>=<span class="string">&#123;handleSearch&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    /&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>效果图，还不错。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210511225100.png" alt="image-20210511225100310"></p>
<h2 id="Footer">Footer</h2>
<p>我直接用 antd 的组件写了一个很简单的页脚。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Layout</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Footer</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Layout.Footer</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">textAlign:</span> &#x27;<span class="attr">center</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      SooMooc ©2021 Created by EthanLoo</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Layout.Footer</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.ethanloo.cn/img/20210513210253.png" alt="image-20210513210253874"></p>
<h2 id="Content">Content</h2>
<p>先把首页的大致样子做了一下。</p>
<p>参考的网站为<a href="https://www.imooc.com/">慕课网</a>。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210513205625.png" alt="image-20210513205625398"></p>
<p>包括两个最主要的组件。</p>
<ol>
<li>SideMenu，左边的可扩展菜单。</li>
<li>Carousel，右边的轮播图（走马灯）。</li>
</ol>
<p>在写组件前，首先把需要的数据，存到 <code>__json_server_mock__/db.json</code> 文件中去。</p>
<p>首先是菜单的内容，每个菜单可以包括子菜单。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;sideMenuList&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;前端开发： HTML5 / Vue.js / Node.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;subMenu&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;HTML5&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Vue.js&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">10</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Node.js&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>然后我去网上随便找了几张图，并且使用 <code>PicGo</code> 上传到了自己的图床上。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210513212032.png" alt="image-20210513212032028"></p>
<p>再把对应的图片的地址存到 <code>db.json</code> 文件中，需要保证通过接口可以获取对应地址。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;carousel&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;carousel-1&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://cdn.ethanloo.cn/img/20210513154859.webp&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;carousel-2&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://cdn.ethanloo.cn/img/20210513154902.webp&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;carousel-3&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://cdn.ethanloo.cn/img/20210513154901.webp&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;carousel-4&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://cdn.ethanloo.cn/img/20210513154900.webp&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<p>然后开始写主页相关的组件，都放在 <code>src/screens/home</code> 文件夹下。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210513212401.png" alt="image-20210513212401221"></p>
<p>主页内容框架组件 <code>content.tsx</code>，将 <code>Carousel</code> 和 <code>SideMenu</code> 整合到一起，在这儿使用 antd 提供的 Grid 布局，让左边的菜单占总宽度的 1/4，右边的轮播图占总宽度的 3/4。</p>
<p>为了让网站更美观，我还给这个 <code>SideMnu</code> 和 <code>Carousel</code> 组合起来的外边界加了个阴影。</p>
<p>使用的是这个<a href="https://shadows.brumm.af/">工具</a>，可以直接通过可视化界面写出阴影的 CSS 代码。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&#x27;@emotion/styled&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Row</span>, <span class="title class_">Col</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Carousel</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;screens/home/carousel&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">SideMenu</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./side-menu&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Content</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Container</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Banner</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Col</span> <span class="attr">span</span>=<span class="string">&#123;6&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">SideMenu</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Col</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Col</span> <span class="attr">span</span>=<span class="string">&#123;18&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Carousel</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Col</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Banner</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Container</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Container</span> = styled.<span class="property">div</span><span class="string">`</span></span><br><span class="line"><span class="string">  padding: 3rem 10rem;</span></span><br><span class="line"><span class="string">  margin: 0 auto;</span></span><br><span class="line"><span class="string">  min-height: calc(100vh - 134px);</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Banner</span> = <span class="title function_">styled</span>(<span class="title class_">Row</span>)<span class="string">`</span></span><br><span class="line"><span class="string">  border-radius: 1rem;</span></span><br><span class="line"><span class="string">  overflow: hidden;</span></span><br><span class="line"><span class="string">  box-shadow: 0 1.9px 4px rgba(0, 0, 0, 0.044),</span></span><br><span class="line"><span class="string">    0 4.6px 13.4px rgba(0, 0, 0, 0.066), 0 26px 60px rgba(0, 0, 0, 0.11);</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>
<p>接下去继续写 <code>SideMenu.tsx</code>，这是一个比较经典的流程（就我目前理解而言）。</p>
<ul>
<li>利用 <code>MenuItemProp</code> 接口来定义每个菜单项的数据格式。</li>
<li>利用 <code>useState</code> 将菜单的数据存储在状态中。</li>
<li>使用 <code>useEffect</code> 在首次加载该页面的时候，通过 API 获取所有菜单的数据，并且更新状态。</li>
<li>使用状态中的数据生成组件并返回。</li>
</ul>
<p>这个 <code>SideMenu</code> 组件唯一特殊的点就是我把菜单的数据结构定义为了统一的，也就是说无论是否有父菜单还是子菜单，都使用一样的数据结构。在渲染菜单的时候，通过利用函数的递归，来渲染父菜单和子菜单项。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&#x27;@emotion/styled&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Menu</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; http &#125; <span class="keyword">from</span> <span class="string">&#x27;utils/http&#x27;</span></span><br><span class="line"></span><br><span class="line">interface <span class="title class_">MenuItemProp</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: number</span><br><span class="line">  <span class="attr">title</span>: string</span><br><span class="line">  subMenu?: <span class="title class_">MenuItemProp</span>[]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">SideMenu</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="title class_">SubMenu</span> &#125; = <span class="title class_">Menu</span></span><br><span class="line">  <span class="keyword">const</span> [menuItems, setMenuItems] = useState&lt;<span class="title class_">MenuItemProp</span>[]&gt;([])</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">http</span>(<span class="string">&#x27;sideMenuList&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">MenuItems: MenuItemProp[]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setMenuItems</span>(<span class="title class_">MenuItems</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">renderMenu</span> = (<span class="params">items: MenuItemProp[]</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> items.<span class="title function_">map</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (item.<span class="property">subMenu</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">          <span class="language-xml"><span class="tag">&lt;<span class="name">SubMenu</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span> <span class="attr">title</span>=<span class="string">&#123;item.title&#125;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">flex:</span> &#x27;<span class="attr">auto</span>&#x27; &#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;renderMenu(item.subMenu)&#125;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">SubMenu</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Menu.Item</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">Menu.Item</span>&gt;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">MenuContainer</span> <span class="attr">mode</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span>&#123;renderMenu(menuItems)&#125;<span class="tag">&lt;/<span class="name">MenuContainer</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MenuContainer</span> = <span class="title function_">styled</span>(<span class="title class_">Menu</span>)<span class="string">`</span></span><br><span class="line"><span class="string">  display: flex;</span></span><br><span class="line"><span class="string">  flex-direction: column;</span></span><br><span class="line"><span class="string">  justify-items: space-around;</span></span><br><span class="line"><span class="string">  height: 100%;</span></span><br><span class="line"><span class="string">  padding: 1rem 0 0.5rem 1rem;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>Carousel.tsx</code>走马灯组件相比而言更简单一些，利用 antd 提供的 <code>Carousel</code> 组件可以很容易写出。</p>
<p>定义数据结构和调取接口的流程和上一个菜单组件一样。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&#x27;@emotion/styled&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Image</span>, <span class="title class_">Carousel</span> <span class="keyword">as</span> <span class="title class_">AntCarousel</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; http &#125; <span class="keyword">from</span> <span class="string">&#x27;utils/http&#x27;</span></span><br><span class="line"></span><br><span class="line">interface <span class="title class_">CarouselImageProp</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: number</span><br><span class="line">  <span class="attr">title</span>: string</span><br><span class="line">  <span class="attr">url</span>: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Carousel</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [imageUrls, setImageUrls] = useState&lt;<span class="title class_">CarouselImageProp</span>[]&gt;([])</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">http</span>(<span class="string">&#x27;carousel&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">urls: CarouselImageProp[]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setImageUrls</span>(urls)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">CarouselContainer</span> <span class="attr">autoplay</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;console.log(imageUrls)&#125;</span></span><br><span class="line"><span class="language-xml">      &#123;imageUrls.map((image) =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Image</span> <span class="attr">src</span>=<span class="string">&#123;image.url&#125;</span> <span class="attr">key</span>=<span class="string">&#123;image.id&#125;</span> <span class="attr">object-fit</span>=<span class="string">&#123;</span>&#x27;<span class="attr">cover</span>&#x27;&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">      ))&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">CarouselContainer</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CarouselContainer</span> = <span class="title function_">styled</span>(<span class="title class_">AntCarousel</span>)<span class="string">`</span></span><br><span class="line"><span class="string">  text-align: center;</span></span><br><span class="line"><span class="string">  height: 40rem;</span></span><br><span class="line"><span class="string">  line-height: 40rem;</span></span><br><span class="line"><span class="string">  overflow: hidden;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>OK，组件写完了，再把 <code>Content</code> 组件放到 <code>App.tsx</code> 中去吧。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./App.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">ErrorBoundary</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;components/error-boundary&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">FullPageErrorFallback</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;components/lib&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Header</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;components/header&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Footer</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;components/footer&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Content</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;screens/home/content&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ErrorBoundary</span> <span class="attr">fallbackRender</span>=<span class="string">&#123;FullPageErrorFallback&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Content</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Footer</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">ErrorBoundary</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>有没有发现多了一个 <code>ErrorBoundary</code> 组件？这是一个专门用来捕获和展示错误的组件。就不细讲了，有兴趣可以直接看源码。</p>
</blockquote>
<p>赶快运行一下看看吧。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 json-server</span></span><br><span class="line">yarn mock</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 React</span></span><br><span class="line">yarn start</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这两个需要放在两个命令行窗口运行</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.ethanloo.cn/img/20210513220657.gif" alt="动画"></p>
<p><img src="https://cdn.ethanloo.cn/img/20210512134742.webp" alt="Thumbnail (1)-tuya"></p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>直播平台</tag>
        <tag>Ant Design</tag>
      </tags>
  </entry>
  <entry>
    <title>Mock 数据 | SooMooc 直播平台</title>
    <url>/post/2021-05-11-SooMooc/%E4%BC%AA%E9%80%A0%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3%20-%20SooMooc%20%E7%9B%B4%E6%92%AD%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<blockquote>
<p>前端所有代码已经同步到 GitHub Repo: <a href="https://github.com/EthanLuu/soomooc">EthanLuu/soomooc: React + TypeScript 实践，在线教学直播平台。 (github.com)</a></p>
</blockquote>
<h2 id="Mock-说明">Mock 说明</h2>
<p>在当前这个前后端开发分离的时代，作为前端开发人员，自然是需要调用后端开发人员的写的接口来获取数据。例如为了获取一个课程的信息，在前端的项目中就需要如下操作：</p>
 <figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fetchData</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.soomooc.com/course/1&#x27;</span>) <span class="comment">// 虚构的api</span></span><br><span class="line">  <span class="keyword">const</span> courseData = <span class="keyword">await</span> response.<span class="title function_">json</span>()</span><br><span class="line">  <span class="keyword">return</span> courseData</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是问题就出现在这个接口上，我们并不能保证在需要获取课程数据的时候，后端的兄弟就已经写好了对应的 API。</p>
<p>因此，伟大的 Mock 便诞生了。Mock 字面意思是 「虚假」，因此 Mock 数据可以解释为「虚假的数据」。</p>
<p>其本质就是在前端开发的时候，我们通过一些手段来模拟数据的获取。既保证了开发的效率，又方便了产品的演示。</p>
<h2 id="Mock-方式">Mock 方式</h2>
<h3 id="代码侵入">代码侵入</h3>
<p>把所有的数据写死在代码中，或者把所有数据存放在本地的 JSON 文件中，需要的时候调用。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fetchData</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(&#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">      <span class="attr">courseName</span>: <span class="string">&#x27;软件工程&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，这种最初级的方式效果很不好，上线的时候需要手动修改很多地方。</p>
<h3 id="请求拦截">请求拦截</h3>
<p>通过如 <a href="http://mockjs.com/">Mock.js</a> 等插件，来根据模板和规则生成假数据。</p>
<p>以获取访客的接口为例，我们在服务器端通过 <code>mock</code> 方法可以返回对应伪造的访客数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Mock</span>.<span class="title function_">mock</span>(<span class="regexp">/\\/</span>api\\/visitor\\/list/, <span class="string">&#x27;get&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">code</span>: <span class="number">2000</span>,</span><br><span class="line">  <span class="attr">msg</span>: <span class="string">&#x27;ok&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;data|10&#x27;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&#x27;id|+1&#x27;</span>: <span class="number">6</span>,</span><br><span class="line">      <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;@csentence(5)&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;@age(1, 100),</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure>
<p>这个方法的缺点也很明显，那就是只能生成随机的假数据，不能真正地增删改查（是不是听起来像杠精发言）。另一个缺点就没这么明显，那就是这个数据接口不能通过 fetch 调用。</p>
<h3 id="接口管理工具">接口管理工具</h3>
<p>利用 <a href="https://github.com/thx/RAP">rap</a>, <a href="https://swagger.io/">swagger</a>, <a href="https://github.com/dreamhead/moco">moco</a>, <a href="https://github.com/YMFE/yapi">yapi</a> 等工具直接管理接口。</p>
<p>更像是后端在直接帮我们先造临时接口，在前端开发缺少后端接口开发相关知识或者团队规模较小的时候就显得有些繁琐了。</p>
<h3 id="本地-node-服务器">本地 node 服务器</h3>
<p>利用 <a href="https://github.com/typicode/json-server">json-server</a>，在使用 JSON 存储数据的基础上，实现真实的增删改查。</p>
<p>并且 <code>json-server</code> 无需设计接口的地址，所有接口均可以 REST API 格式进行直接调用。</p>
<p>虽然也有缺点，就是这个 API 也会在前端写死，无法动态调整。</p>
<p>接下来我们就用这种方法来配置 SooMooc 吧。</p>
<h2 id="json-server-配置">json-server 配置</h2>
<p>首先在本地安装包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add json-server -D</span><br></pre></td></tr></table></figure>
<p>在项目根目录建立一个文件夹 <code>__json_server_mock__</code>，用于存放 mock 数据。</p>
<p>在文件夹中新建一个 <code>db.json</code> 文件，随便写点数据。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210510220539.png" alt="image-20210510220538952"></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;users&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">&#123;</span> <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span> <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ethan&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123456&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>为了便捷地打开 <code>json-server</code> 服务器，我们将启动命令写进 <code>package.json</code> 中。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210510220958.png" alt="code"></p>
<p>在命令行输入：<code>yarn mock</code>，看到如下提示就说明新建好啦！</p>
<img src="https://cdn.ethanloo.cn/img/20210510221143.png" alt="image-20210510221142934" style="zoom:67%;" />
<p>这个时候，我们可以直接使用浏览器或者一些 API 测试工具试用一下。</p>
<blockquote>
<p>我这边用的是 Postman</p>
</blockquote>
<p>用 GET 方法，请求 <code>localhost:3001/users</code>，我们发现成功返回了刚刚手动输入的信息。</p>
<img src="https://cdn.ethanloo.cn/img/20210510221418.png" alt="image-20210510221418268" style="zoom:67%;" />
<p>这还只是 <strong>查</strong>，试试 <strong>增</strong> 呢？</p>
<p>用 POST 方法，请求 <code>localhost:3001/users</code>，同时把需要新增的数据以 <code>json</code> 的格式放到 body 里。</p>
<img src="https://cdn.ethanloo.cn/img/20210510221614.png" alt="image-20210510221614450" style="zoom:67%;" />
<p>返回的信息显示添加成功了！并且服务器还自动帮我们加上了 id。此时，我们惊喜地发现项目本地的 <code>db.json</code> 文件中也插入了这条信息。</p>
<img src="https://cdn.ethanloo.cn/img/20210510222347.png" alt="image-20210510222347500" style="zoom:67%;" />
<p>但是有没有发现，我们并没有自己写插入用户的方法，为啥 POST 一下就能新增数据呢？</p>
<p>这就是 json-server 的神奇之处了，正如我上文所说，他利用 REST API 的形式，提供了一套增删改查的接口，完全自动配置。</p>
<p>这意味着：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET			/users				# 获取所有的用户信息</span><br><span class="line">GET			/users/?id=1	# 查询id=1的用户信息</span><br><span class="line">POST		/users				# 通过在body里写需要新增的用户信息即可插入一条新数据</span><br><span class="line">DELETE	/users/1			# 删除id=1的用户信息</span><br><span class="line">PUT			/users/2			# 和POST类似在body里附加信息，即可实现用户信息更新				</span><br></pre></td></tr></table></figure>
<p>一套完整 API，超短时间配置，同时支持利用接口访问和本地文件访问，就问你香不香？</p>
<blockquote>
<p>或许会有更优秀的 mock 数据方式出现，不过目前而言对于本项目而言，json-server 方式足矣。</p>
</blockquote>
<h2 id="项目结合">项目结合</h2>
<p>为了方便未来从开发到上线过程中 API 的修改，我们在项目根目录新建两个文件用于配置路由。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210510223605.png" alt="image-20210510223605342"></p>
<p>在 <code>.env</code> 文件中，写入未来真实线上的 API 地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REACT_APP_API_URL=http://api.ethanloo.cn</span><br></pre></td></tr></table></figure>
<p>在 <code>.env.development</code> 文件中，写入我们 json-server 的地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REACT_APP_API_URL=http://localhost:3001</span><br></pre></td></tr></table></figure>
<p>添加一个便于 URL 查询的库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">queryString</span></span><br><span class="line">yarn add qs</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">适配TS</span></span><br><span class="line">yarn add @types/qs -D </span><br></pre></td></tr></table></figure>
<p>编写一个用于 <code>http</code> 请求的函数，存放在 <code>src/utils/http.ts</code> 文件中</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">&#x27;qs&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Config</span> <span class="keyword">extends</span> <span class="title class_">RequestInit</span> &#123;</span><br><span class="line">  data?: <span class="built_in">object</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> apiUrl = process.<span class="property">env</span>.<span class="property">REACT_APP_API_URL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">http</span> = <span class="keyword">async</span> (<span class="params"></span></span><br><span class="line"><span class="params">  endpoint: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  &#123; data, headers, ...customConfig &#125;: Config = &#123;&#125;</span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> config = &#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: data ? <span class="string">&#x27;application/json&#x27;</span> : <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    ...customConfig,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (config.<span class="property">method</span>.<span class="title function_">toUpperCase</span>() === <span class="string">&#x27;GET&#x27;</span>) &#123;</span><br><span class="line">    endpoint += <span class="string">`?<span class="subst">$&#123;qs.stringify(data)&#125;</span>`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    config.<span class="property">body</span> = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data || &#123;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">window</span></span><br><span class="line">    .<span class="title function_">fetch</span>(<span class="string">`<span class="subst">$&#123;apiUrl&#125;</span>/<span class="subst">$&#123;endpoint&#125;</span>`</span>, config)</span><br><span class="line">    .<span class="title function_">then</span>(<span class="keyword">async</span> (response) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> data = <span class="keyword">await</span> response.<span class="title function_">json</span>()</span><br><span class="line">      <span class="keyword">if</span> (response.<span class="property">ok</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(data)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>再编写一个用户列表界面用来测试增删改查。</p>
<blockquote>
<p>我这边标注成 jsx 是因为网页的代码高亮还不支持 tsx，实际的文件后缀名是 tsx</p>
<p>这个组件还有很多问题，比如：</p>
<ul>
<li>每次增或删之后会重新调取接口获取所有用户信息，然后渲染（正式项目中可以考虑使用乐观更新）</li>
<li>因为不太会 TS，所以很不好地写了一个 <code>users: any</code></li>
</ul>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Button</span>, <span class="title class_">Card</span>, <span class="title class_">Input</span>, <span class="title class_">Form</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; useEffect, useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&#x27;@emotion/styled&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; http &#125; <span class="keyword">from</span> <span class="string">&#x27;utils/http&#x27;</span></span><br><span class="line"></span><br><span class="line">interface <span class="title class_">UserProps</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: number</span><br><span class="line">  <span class="attr">username</span>: <span class="string">&#x27;string&#x27;</span></span><br><span class="line">  <span class="attr">password</span>: <span class="string">&#x27;string&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">UsersList</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [users, setUsers] = <span class="title function_">useState</span>([])</span><br><span class="line">  <span class="keyword">const</span> [form] = <span class="title class_">Form</span>.<span class="title function_">useForm</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">renderUsers</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">http</span>(<span class="string">&#x27;users&#x27;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">users: any</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setUsers</span>(users)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初次加载时渲染users</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">renderUsers</span>()</span><br><span class="line">  &#125;, [])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">deleteUser</span> = <span class="keyword">async</span> (<span class="params">id: number</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> config = &#123;</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;DELETE&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">http</span>(<span class="string">`users/<span class="subst">$&#123;id&#125;</span>`</span>, config).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      form.<span class="title function_">resetFields</span>()</span><br><span class="line">      <span class="title function_">renderUsers</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">addUser</span> = <span class="keyword">async</span> (<span class="params">values: &#123; username: string; password: string &#125;</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> config = &#123;</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">      <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">data</span>: values,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">http</span>(<span class="string">&#x27;users&#x27;</span>, config).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      form.<span class="title function_">resetFields</span>()</span><br><span class="line">      <span class="title function_">renderUsers</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Container</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">UsersContainer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;users.map((user: UserProps) =&gt; (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Card</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">title</span>=<span class="string">&#123;</span>`<span class="attr">id:</span>$&#123;<span class="attr">user.id</span>&#125;`&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">key</span>=<span class="string">&#123;user.id&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">width:</span> <span class="attr">200</span>, <span class="attr">margin:</span> <span class="attr">30</span> &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">            <span class="attr">extra</span>=<span class="string">&#123;</span>&lt;<span class="attr">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> deleteUser(user.id)&#125;&gt;x<span class="tag">&lt;/<span class="name">Button</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">          &gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>username: &#123;user.username&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>password: &#123;user.password&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">Card</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        ))&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">UsersContainer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Form</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onFinish</span>=<span class="string">&#123;addUser&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">form</span>=<span class="string">&#123;form&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">style</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">textAlign:</span> &#x27;<span class="attr">center</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">padding:</span> &#x27;<span class="attr">10px</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">border:</span> &#x27;<span class="attr">1px</span> <span class="attr">solid</span> #<span class="attr">ccc</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">boxShadow:</span> &#x27;<span class="attr">3px</span> <span class="attr">3px</span> <span class="attr">3px</span> #<span class="attr">ccc</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">borderRadius:</span> &#x27;<span class="attr">5px</span>&#x27;,</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        &#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      &gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Form.Item</span> <span class="attr">name</span>=<span class="string">&#123;</span>&#x27;<span class="attr">username</span>&#x27;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Input</span> <span class="attr">placeholder</span>=<span class="string">&#123;</span>&#x27;<span class="attr">用户名</span>&#x27;&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Form.Item</span> <span class="attr">name</span>=<span class="string">&#123;</span>&#x27;<span class="attr">password</span>&#x27;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Input</span> <span class="attr">placeholder</span>=<span class="string">&#123;</span>&#x27;<span class="attr">密码</span>&#x27;&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Button</span> <span class="attr">htmlType</span>=<span class="string">&#123;</span>&#x27;<span class="attr">submit</span>&#x27;&#125; <span class="attr">type</span>=<span class="string">&#123;</span>&#x27;<span class="attr">primary</span>&#x27;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">            注册</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Form.Item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Form</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Container</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">UsersContainer</span> = styled.<span class="property">div</span><span class="string">`</span></span><br><span class="line"><span class="string">  font-size: 2rem;</span></span><br><span class="line"><span class="string">  height: 30vh;</span></span><br><span class="line"><span class="string">  width: 80%;</span></span><br><span class="line"><span class="string">  display: flex;</span></span><br><span class="line"><span class="string">  border: 1px solid #ccc;</span></span><br><span class="line"><span class="string">  box-shadow: 3px 3px 3px #ccc;</span></span><br><span class="line"><span class="string">  border-radius: 5px;</span></span><br><span class="line"><span class="string">  margin: 30px;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Container</span> = styled.<span class="property">div</span><span class="string">`</span></span><br><span class="line"><span class="string">  display: flex;</span></span><br><span class="line"><span class="string">  flex-direction: column;</span></span><br><span class="line"><span class="string">  align-items: center;</span></span><br><span class="line"><span class="string">  min-height: 100vh;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><img src="https://cdn.ethanloo.cn/img/20210511102505.gif" alt="动画 (1)"></p>
<p><img src="https://cdn.ethanloo.cn/img/20210510194604.webp" alt="Thumbnail (1)-tuya"></p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>直播平台</tag>
        <tag>Ant Design</tag>
      </tags>
  </entry>
  <entry>
    <title>项目启动 | SooMooc 直播平台</title>
    <url>/post/2021-05-09-SooMooc/%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8%20-%20SooMooc%20%E7%9B%B4%E6%92%AD%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<blockquote>
<p>前端所有代码已经同步到 GitHub Repo: <a href="https://github.com/EthanLuu/soomooc">EthanLuu/soomooc: React + TypeScript 实践，在线教学直播平台。 (github.com)</a></p>
<p>迫于课程实践要做一个在线教学直播平台，就拿 React 练练手吧。</p>
<p>既然是一个教学直播平台，就先起名叫做 SooMooc 了 🎉</p>
</blockquote>
<h2 id="技术栈说明">技术栈说明</h2>
<ul>
<li>React：前端框架</li>
<li>React Ant Design：组件库</li>
<li>OBS：直播推流工具</li>
<li>livego：直播服务器</li>
<li>flv.js：网页视频播放器</li>
</ul>
<h2 id="初始化项目">初始化项目</h2>
<p>因为之前有看过一个 React + TypeScript 的实战视频，这次干脆也试着用 TS 写咯。</p>
<p>先在命令行创建项目。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g create-react-app</span><br><span class="line">npx create-react-app soomooc  --template typescript</span><br></pre></td></tr></table></figure>
<p>修改一下 <code>tsconfig.json</code> 里的 <code>compilerOptions</code>，修改一下 <code>baseUrl</code>，便于以后的 <code>import</code> 操作。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./src&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<img src="https://cdn.ethanloo.cn/img/20210510192603.png" alt="code" style="zoom:50%;" />
<h3 id="antd">antd</h3>
<p>安装 <code>antd</code> 样式库。</p>
<blockquote>
<p><a href="https://ant.design/docs/react/use-in-typescript-cn">在 TypeScript 中使用 - Ant Design</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add antd</span><br></pre></td></tr></table></figure>
<p>修改 <code>src/App.css</code>，在文件顶部引入 <code>antd</code> 的样式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&#x27;~antd/dist/antd.css&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="craco">craco</h3>
<p>为了实现主题的自定义和模块化的 CSS 书写方式，我们需要安装 craco 插件，注意这里有两个包。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自定义主题</span></span><br><span class="line">yarn add @craco/craco craco-less</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">模块化书写 CSS</span></span><br><span class="line">yarn add @emotion/styled</span><br></pre></td></tr></table></figure>
<p>安装完之后在根目录新建一个文件 <code>craco.config.js</code>，可以在这里自定义主题配色、字体等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CracoLessPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;craco-less&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">plugin</span>: <span class="title class_">CracoLessPlugin</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">lessLoaderOptions</span>: &#123;</span><br><span class="line">          <span class="attr">lessOptions</span>: &#123;</span><br><span class="line">            <span class="attr">modifyVars</span>: &#123;</span><br><span class="line">              <span class="comment">// &#x27;@primary-color&#x27;: &#x27;rgb(0, 82, 204)&#x27;,</span></span><br><span class="line">              <span class="string">&#x27;@font-size-base&#x27;</span>: <span class="string">&#x27;16px&#x27;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">javascriptEnabled</span>: <span class="literal">true</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里把字体大小设置成 16px，是为了方便后续可以设置成 <code>font-size: 62.5%</code> ，最终实现<code>1rem = 10px</code></p>
</blockquote>
<p>修改一下 <code>App.css</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">62.5%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">html</span> <span class="selector-tag">body</span> <span class="selector-id">#root</span> <span class="selector-class">.App</span> &#123;</span><br><span class="line">  <span class="attribute">min-height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>顺便改一下 <code>package.json</code> 里面的命令脚本。</p>
<img src="https://cdn.ethanloo.cn/img/20210510192643.png" alt="code" style="zoom:50%;" />
<h3 id="commitlint">commitlint</h3>
<p>安装 <code>commitlint</code>，用于规范 git 提交格式。</p>
<blockquote>
<p><a href="https://github.com/conventional-changelog/commitlint">conventional-changelog/commitlint: 📓 Lint commit messages (github.com)</a></p>
</blockquote>
<ol>
<li>
<p>安装库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add @commitlint/config-conventional @commitlint/cli -D</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在项目根目录新建文件 <code>commitlint.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;<span class="attr">extends</span>: [<span class="string">&#x27;@commitlint/config-conventional&#x27;</span>]&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>安装并配置 <code>husky</code>，用于在 <code>git commit</code> 前进行格式检查。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Install Husky v6</span></span><br><span class="line">yarn add husky --dev</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Activate hooks</span></span><br><span class="line">yarn husky install</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Add hook</span></span><br><span class="line">npx husky add .husky/commit-msg &#x27;npx --no-install commitlint --edit &quot;$1&quot;&#x27;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>提交格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git commit -m &lt;type&gt;[optional scope]: &lt;description&gt;</span><br></pre></td></tr></table></figure>
<p>常用 type：</p>
<ul>
<li>build：主要目的是修改项目构建系统(例如 glup，webpack，rollup 的配置等)的提交</li>
<li>ci：主要目的是修改项目继续集成流程(例如 Travis，Jenkins，GitLab CI，Circle等)的提交</li>
<li>docs：文档更新</li>
<li>feat：新增功能</li>
<li>fix：bug 修复</li>
<li>perf：性能优化</li>
<li>refactor：重构代码(既没有新增功能，也没有修复 bug)</li>
<li>style：不影响程序逻辑的代码修改(修改空白字符，补全缺失的分号等)</li>
<li>test：新增测试用例或是更新现有测试</li>
<li>revert：回滚某个更早之前的提交</li>
<li>chore：不属于以上类型的其他类型(日常事务)</li>
</ul>
<h2 id="直播组件-demo">直播组件 demo</h2>
<blockquote>
<p>参考 <a href="https://github.com/gwuhaolin/reflv">gwuhaolin/reflv: react component wrap flv.js (github.com)</a></p>
</blockquote>
<p>先写一个播放器的 demo，熟悉一下推拉流所需要的技术栈。</p>
<p>新建 <code>src/components</code> 文件夹，存放通用组件。</p>
<p>新建 <code>src/screens</code> 文件夹，存放页面相关组件。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210508204130.png" alt="image-20210508204130604"></p>
<h3 id="live-player-tsx">live-player.tsx</h3>
<p><code>live-player.tsx</code> 组件是对 <code>flv.js</code> 的封装。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> flvjs <span class="keyword">from</span> <span class="string">&#x27;flv.js&#x27;</span></span><br><span class="line"></span><br><span class="line">interface <span class="title class_">LivePlayerProps</span> &#123;</span><br><span class="line">  type?: string</span><br><span class="line">  <span class="attr">url</span>: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">LivePlayer</span> = (<span class="params">props: LivePlayerProps</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> flvRef = useRef&lt;flvjs.<span class="property">Player</span>&gt;()</span><br><span class="line">  <span class="keyword">const</span> videoRef = useRef&lt;<span class="title class_">HTMLVideoElement</span>&gt;(<span class="literal">null</span>)</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (flvjs.<span class="title function_">isSupported</span>()) &#123;</span><br><span class="line">      flvRef.<span class="property">current</span> = flvjs.<span class="title function_">createPlayer</span>(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;flv&#x27;</span>,</span><br><span class="line">        <span class="attr">isLive</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">cors</span>: <span class="literal">true</span>,</span><br><span class="line">        ...props,</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">if</span> (videoRef.<span class="property">current</span>) &#123;</span><br><span class="line">        flvRef.<span class="property">current</span>.<span class="title function_">attachMediaElement</span>(videoRef.<span class="property">current</span>)</span><br><span class="line">        flvRef.<span class="property">current</span>.<span class="title function_">load</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [props])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>&#x27;<span class="attr">video-container</span>&#x27;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">video</span> <span class="attr">ref</span>=<span class="string">&#123;videoRef&#125;</span> <span class="attr">className</span>=<span class="string">&#123;</span>&#x27;<span class="attr">video</span>&#x27;&#125; <span class="attr">width</span>=<span class="string">&quot;80%&quot;</span> <span class="attr">controls</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;`Your browser is too old which doesn&#x27;t support HTML5 video.`&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="demo-tsx">demo.tsx</h3>
<p><code>demo.tsx</code> 界面组件用于展示播放器。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* @jsxImportSource @emotion/react */</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">LivePlayer</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;components/live-player&#x27;</span></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&#x27;@emotion/styled&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">Demo</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">PlayerContainer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span> <span class="attr">css</span>=<span class="string">&#123;&#123;</span> &#x27;<span class="attr">font-size</span>&#x27;<span class="attr">:</span> &#x27;<span class="attr">3rem</span>&#x27; &#125;&#125;&gt;</span>SooMooc Demo<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">LivePlayer</span> <span class="attr">url</span>=<span class="string">&quot;http://localhost:7001/live/demo.flv&quot;</span> <span class="attr">type</span>=<span class="string">&quot;flv&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">PlayerContainer</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">PlayerContainer</span> = styled.<span class="property">div</span><span class="string">`</span></span><br><span class="line"><span class="string">  text-align: center;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>
<h3 id="App-tsx">App.tsx</h3>
<p>将 demo 界面组件包到 <code>App</code> 里。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./App.css&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Demo</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;screens/demo&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Demo</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span></span><br></pre></td></tr></table></figure>
<h2 id="直播流程">直播流程</h2>
<p>在本地试用一下这个播放界面。</p>
<p>在开始推流之前，要先知道推流的地址，本项目使用 livego 作为推拉流的中介服务器。</p>
<p>在 GitHub 的 <a href="https://github.com/gwuhaolin/livego">livego</a> 上直接下载最新版 <code>release</code> 安装即可，我这边是 windows 版。</p>
<blockquote>
<p>当然你也可以按照说明里下载源码自己进行编译</p>
</blockquote>
<p>安装完成后直接在本地打开 <code>livego.exe</code> 运行服务器即可。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210508212204.png" alt="image-20210508212204659"></p>
<p>可以看到这边的 RTMP 的接口是 1935，由于我们的服务器架在本地，所以推流的服务器地址应该是 <code>rtmp://localhost:1935</code></p>
<p>主播需要安装并打开 OBS，对需要分享的屏幕进行自定义，点击左下角 ➕ 可以添加文字、图片、摄像头等。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210508210844.png" alt="image-20210508210837652"></p>
<p>点击右下角<strong>设置</strong>，在推流界面填写我们刚刚知道的服务器地址和密钥。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210508213903.png" alt="image-20210508213903915"></p>
<p>在 OBS 界面点击开始推流，此时 OBS 右下角会显示推流的速度和时间等信息。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210508214024.png" alt="image-20210508214024788"></p>
<p>回到项目根目录，确认一下 <code>demo.tsx</code> 中的拉流地址是否一致。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;<span class="title class_">LivePlayer</span> url=<span class="string">&quot;http://localhost:7001/live/demo.flv&quot;</span> type=<span class="string">&quot;flv&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>运行 React 项目。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn start</span><br></pre></td></tr></table></figure>
<p>打开浏览器即可看到</p>
<p><img src="https://cdn.ethanloo.cn/img/20210508221140.png" alt="image-20210508221140389"></p>
<p>本地推拉流延迟大约2-3s，第一步大功告成。<img src="https://cdn.ethanloo.cn/img/20210509193435.png" alt="image-20210509193426944"></p>
]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>直播平台</tag>
        <tag>Ant Design</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年5月刷题日志</title>
    <url>/post/2021-05-05-Algorithm/2021%E5%B9%B45%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p><strong>5.31</strong></p>
<p>这么快就五月最后一天啦。</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="342-4的幂"><a href="https://leetcode-cn.com/problems/power-of-four/">342. 4的幂</a></h4>
<p>难度简单</p>
<p>给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
</blockquote>
<p><strong>思路</strong></p>
<p>没高兴动脑子，就和昨天一样的解法。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPowerOfFour</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">4</span> != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            n //= <span class="number">4</span></span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>5.30</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="231-2-的幂"><a href="https://leetcode-cn.com/problems/power-of-two/">231. 2 的幂</a></h4>
<p>难度简单</p>
<p>给你一个整数 <code>n</code>，请你判断该整数是否是 2 的幂次方。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>如果存在一个整数 <code>x</code> 使得 <code>n == 2x</code> ，则认为 <code>n</code> 是 2 的幂次方。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：20 = 1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 16</span><br><span class="line">输出：true</span><br><span class="line">解释：24 = 16</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 4</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 5</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>-2^31 &lt;= n &lt;= 2^31 - 1</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>循环</li>
<li><code>log</code> 函数</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 循环</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPowerOfTwo</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">while</span> n &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">1</span>: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            n //= <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> n == <span class="number">1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPowerOfTwo</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> <span class="keyword">and</span> <span class="number">2</span> ** <span class="built_in">int</span>(math.log(n, <span class="number">2</span>)) == n</span><br></pre></td></tr></table></figure>
<p><strong>5.29</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1074-元素和为目标值的子矩阵数量"><a href="https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/">1074. 元素和为目标值的子矩阵数量</a></h4>
<p>难度困难</p>
<p>给出矩阵 <code>matrix</code> 和目标值 <code>target</code>，返回元素总和等于目标值的非空子矩阵的数量。</p>
<p>子矩阵 <code>x1, y1, x2, y2</code> 是满足 <code>x1 &lt;= x &lt;= x2</code> 且 <code>y1 &lt;= y &lt;= y2</code> 的所有单元 <code>matrix[x][y]</code> 的集合。</p>
<p>如果 <code>(x1, y1, x2, y2)</code> 和 <code>(x1', y1', x2', y2')</code> 两个子矩阵中部分坐标不同（如：<code>x1 != x1'</code>），那么这两个子矩阵也不同。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/02/mate1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0</span><br><span class="line">输出：4</span><br><span class="line">解释：四个只含 0 的 1x1 子矩阵。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,-1],[-1,1]], target = 0</span><br><span class="line">输出：5</span><br><span class="line">解释：两个 1x2 子矩阵，加上两个 2x1 子矩阵，再加上一个 2x2 子矩阵。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[904]], target = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><em><strong>*提示：*</strong></em></p>
<ul>
<li><code>1 &lt;= matrix.length &lt;= 100</code></li>
<li><code>1 &lt;= matrix[0].length &lt;= 100</code></li>
<li><code>-1000 &lt;= matrix[i] &lt;= 1000</code></li>
<li><code>-10^8 &lt;= target &lt;= 10^8</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>首先需要进行一波预处理，生成二维前缀和数组，用来快速计算子矩阵和。</p>
<p>然后从朴素的角度出发，需要枚举所有的子矩阵，但是这边可以使用一个巧妙的优化方法。</p>
<ul>
<li>进行纵向扫描👇，枚举子矩阵可能的所有首行和末行的位置。</li>
<li>对于确定的首行和末行，新建一个哈希表用来记录子列和的出现次数，并且初始化 <code>dic[0] = 1</code>。
<ul>
<li>进行横向的扫描👉，即每次计算某一列的和。</li>
<li>如果发现 <code>当前的子列和 - target</code> 在哈希表中出现过，说明有子矩阵可以满足和为 <code>target</code>，更新 <code>res</code>。</li>
<li>根据当前的子列和更新哈希表。</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numSubmatrixSumTarget</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 二维前缀和</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        sums = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                sums[i + <span class="number">1</span>][j + <span class="number">1</span>] = sums[i][j + <span class="number">1</span>] + sums[i + <span class="number">1</span>][j] + matrix[i][j] - sums[i][j]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 枚举子矩阵</span></span><br><span class="line">        <span class="keyword">for</span> r1 <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>):                 <span class="comment"># 枚举矩阵首行</span></span><br><span class="line">            <span class="keyword">for</span> r2 <span class="keyword">in</span> <span class="built_in">range</span>(r1 + <span class="number">1</span>, m + <span class="number">1</span>):     <span class="comment"># 枚举矩阵末行</span></span><br><span class="line">                dic = defaultdict(<span class="built_in">int</span>)          <span class="comment"># 用来记录子列和的出现次数</span></span><br><span class="line">                dic[<span class="number">0</span>] = <span class="number">1</span>                      <span class="comment"># 初始化</span></span><br><span class="line">                <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                    cur_sum = sums[r2][c] - sums[r1][c]</span><br><span class="line">                    <span class="keyword">if</span> cur_sum - target <span class="keyword">in</span> dic:</span><br><span class="line">                        res += dic[cur_sum - target]</span><br><span class="line">                    dic[cur_sum] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>5.28</strong></p>
<p>收到 MS 的 onboard 通知啦，交完最后一份材料就等着过两周实习去咯。</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="477-汉明距离总和"><a href="https://leetcode-cn.com/problems/total-hamming-distance/">477. 汉明距离总和</a></h4>
<p>难度中等</p>
<p>两个整数的 <a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/475174?fr=aladdin">汉明距离</a> 指的是这两个数字的二进制数对应位不同的数量。</p>
<p>计算一个数组中，任意两个数之间汉明距离的总和。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 4, 14, 2</span><br><span class="line"></span><br><span class="line">输出: 6</span><br><span class="line"></span><br><span class="line">解释: 在二进制表示中，4表示为0100，14表示为1110，2表示为0010。（这样表示是为了体现后四位之间关系）</span><br><span class="line">所以答案为：</span><br><span class="line">HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6.</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ol>
<li>数组中元素的范围为从 <code>0</code>到 <code>10^9</code>。</li>
<li>数组的长度不超过 <code>10^4</code>。</li>
</ol>
</blockquote>
<p><strong>思路</strong></p>
<p>呜呜呜，中等题我竟然也要看题解。</p>
<p>因为需要计算任意两个数的汉明距离的总和，所以本质上是一个全排列。</p>
<p>但是直接计算全排列中每一对数的异或后 1 的个数时间复杂度太高，因此可以巧妙地转换成按位来计算 1 的个数。</p>
<ul>
<li>先遍历一遍数组，统计每个位置的 <code>1</code> 的个数，比如 <code>1, 2, 5</code>，就会统计得到 <code>dic[0] = 2, dic[1] = 1, dic[2] = 1</code>。</li>
<li>因为是全排列，所以每个位置都会进行 $n \times n$ 次对比，其中 $n$ 表示数组长度。最后计算得到的汉明距离只包括 <code>0 和 1</code> 对，因此就是 $n \times (n - cnt)$，其中 <code>cnt</code> 是该位置上 <code>1</code> 的出现次数。</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">totalHammingDistance</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 统计每个位置的1的个数</span></span><br><span class="line">        dic = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="comment"># 从第30位枚举到第1位</span></span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">29</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                bit = (num &gt;&gt; k) &amp; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> bit == <span class="number">1</span>:</span><br><span class="line">                    dic[k] += <span class="number">1</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 每个位置的和为 dic[i] * (n - dic[i])</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):</span><br><span class="line">            res += dic[i] * (n - dic[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>5.27</strong></p>
<p>回归简单的快乐。</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="461-汉明距离"><a href="https://leetcode-cn.com/problems/hamming-distance/">461. 汉明距离</a></h4>
<p>难度简单</p>
<p>两个整数之间的<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给出两个整数 <code>x</code> 和 <code>y</code>，计算它们之间的汉明距离。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: x = 1, y = 4</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line"></span><br><span class="line">上面的箭头指出了对应二进制位不同的位置。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>统计 <code>x </code> 和 <code>y</code> 异或出来的结果的二进制 <code>1</code> 个数。</p>
<ol>
<li>通过函数转换成二进制字符串之后统计 <code>1</code> 的个数。</li>
<li>通过 <code>&amp;</code> 和 <code>&lt;&lt;</code> 每次计算结果的最后一位是否为 <code>1</code> 同时右移一位。</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 转换二进制字符串并计数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingDistance</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bin</span>(x ^ y).count(<span class="string">&#x27;1&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2. 位运算计数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hammingDistance</span>(<span class="params">self, x: <span class="built_in">int</span>, y: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        k =  x ^ y</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> k:</span><br><span class="line">            cnt += k &amp; <span class="number">1</span></span><br><span class="line">            k &gt;&gt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
<p><strong>5.26</strong></p>
<p>昨天极难直接跳过。</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1190-反转每对括号间的子串"><a href="https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/">1190. 反转每对括号间的子串</a></h4>
<p>难度中等</p>
<p>给出一个字符串 <code>s</code>（仅含有小写英文字母和括号）。</p>
<p>请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。</p>
<p>注意，您的结果中 <strong>不应</strong> 包含任何括号。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;(abcd)&quot;</span><br><span class="line">输出：&quot;dcba&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;(u(love)i)&quot;</span><br><span class="line">输出：&quot;iloveu&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;(ed(et(oc))el)&quot;</span><br><span class="line">输出：&quot;leetcode&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a(bcdefghijkl(mno)p)q&quot;</span><br><span class="line">输出：&quot;apmnolkjihgfedcbq&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 2000</code></li>
<li><code>s</code> 中只有小写英文字母和括号</li>
<li>我们确保所有括号都是成对出现的</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>用栈来模拟反转的过程，把字符逐个放入栈中，分两种情况处理：</p>
<ul>
<li>当前字符为字母或 <code>(</code>，直接存入栈</li>
<li>当前字符为 <code>)</code>，这个时候我们需要翻转的是直至上一个 <code>(</code> 为止的字符，通过在新建一个栈倒序放字符实现翻转即可。</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseParentheses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># 栈模拟</span></span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="comment"># 找到左括号</span></span><br><span class="line">                t = []</span><br><span class="line">                <span class="keyword">while</span> stk[-<span class="number">1</span>] != <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                    t.append(stk.pop())</span><br><span class="line">                stk.pop()</span><br><span class="line">                stk += t</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                stk.append(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(stk)</span><br></pre></td></tr></table></figure>
<p><strong>5.24</strong></p>
<p>又是困难 🤦‍♂️</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="664-奇怪的打印机"><a href="https://leetcode-cn.com/problems/strange-printer/">664. 奇怪的打印机</a></h4>
<p>难度困难</p>
<p>有台奇怪的打印机有以下两个特殊要求：</p>
<ul>
<li>打印机每次只能打印由 <strong>同一个字符</strong> 组成的序列。</li>
<li>每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。</li>
</ul>
<p>给你一个字符串 <code>s</code> ，你的任务是计算这个打印机打印它需要的最少打印次数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aaabbb&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：首先打印 &quot;aaa&quot; 然后打印 &quot;bbb&quot;。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aba&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：首先打印 &quot;aaa&quot; 然后在第二个位置打印 &quot;b&quot; 覆盖掉原来的字符 &#x27;a&#x27;。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 100</code></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>动态规划，动态转移方程的前提是要知道，如果字符串中的一个子串的头尾字母相同，那么在打印首字母的同时就可以打印尾字母。</p>
<blockquote>
<p>由于我对区间DP的理解比较浅，解释不清，建议直接看<a href="https://leetcode-cn.com/problems/strange-printer/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-xqeo9/">题解</a></p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">strangePrinter</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="comment"># dp[i][j] 表示从i到j的最少打印次数</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(n): <span class="comment"># 区间长度</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - l): <span class="comment"># 区间起点</span></span><br><span class="line">                j = i + l <span class="comment"># 区间结尾</span></span><br><span class="line">                dp[i][j] = dp[i + <span class="number">1</span>][j] + <span class="number">1</span> <span class="comment"># 默认变首字母，需要+1</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, j + <span class="number">1</span>): <span class="comment"># 分割点</span></span><br><span class="line">                    <span class="keyword">if</span> s[k] == s[i]:</span><br><span class="line">                        dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k - <span class="number">1</span>] + dp[k + <span class="number">1</span>][j])</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p><strong>5.23</strong></p>
<p>谁能想到昨天写了题解却没提交呢 😰 不过昨天答辩拿了省二还不错。</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1707-与数组中元素的最大异或值"><a href="https://leetcode-cn.com/problems/maximum-xor-with-an-element-from-array/">1707. 与数组中元素的最大异或值</a></h4>
<p>难度困难</p>
<p>给你一个由非负整数组成的数组 <code>nums</code> 。另有一个查询数组 <code>queries</code> ，其中 <code>queries[i] = [xi, mi]</code> 。</p>
<p>第 <code>i</code> 个查询的答案是 <code>xi</code> 和任何 <code>nums</code> 数组中不超过 <code>mi</code> 的元素按位异或（<code>XOR</code>）得到的最大值。换句话说，答案是 <code>max(nums[j] XOR xi)</code> ，其中所有 <code>j</code> 均满足 <code>nums[j] &lt;= mi</code> 。如果 <code>nums</code> 中的所有元素都大于 <code>mi</code>，最终答案就是 <code>-1</code> 。</p>
<p>返回一个整数数组 <code>answer</code> 作为查询的答案，其中 <code>answer.length == queries.length</code> 且 <code>answer[i]</code> 是第 <code>i</code> 个查询的答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,2,3,4], queries = [[3,1],[1,3],[5,6]]</span><br><span class="line">输出：[3,3,7]</span><br><span class="line">解释：</span><br><span class="line">1) 0 和 1 是仅有的两个不超过 1 的整数。0 XOR 3 = 3 而 1 XOR 3 = 2 。二者中的更大值是 3 。</span><br><span class="line">2) 1 XOR 2 = 3.</span><br><span class="line">3) 5 XOR 2 = 7.</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,2,4,6,6,3], queries = [[12,4],[8,1],[6,3]]</span><br><span class="line">输出：[15,-1,5]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>周末两道异或困难题，真狠呐。</p>
<p>不过这道题的思路是和一周前那道差不多，都是通过构造字典树，贪心法求最大值。</p>
<p>我们根据 <code>queries</code> 中的 <code>m</code> 的从小到大的顺序，逐个求最大异或值，这样能够保证每次字典树上的所有分支组成的值比 <code>m</code> 小。</p>
<p>贪心的思路则是，从 <code>x</code> 的最高位开始，字典树上的结点能取反则取反，保证异或的结果尽可能高的位是 <code>1</code> 。</p>
<p>唯一要注意的是，在对 <code>queries</code> 排序的时候，需要保存每个 <code>query</code> 原来的位置，在输出答案的时候需要用到。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># left: 0, right: 1</span></span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximizeXor</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], queries: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        root = Trie()</span><br><span class="line">        nums.sort(reverse = <span class="literal">True</span>)</span><br><span class="line">        newQueries = <span class="built_in">sorted</span>(<span class="built_in">enumerate</span>(queries),key=<span class="keyword">lambda</span> x:x[<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">val</span>):</span><br><span class="line">            node = root</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                bit = (val &gt;&gt; k) &amp; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> bit == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> node.left:</span><br><span class="line">                        node.left = Trie()</span><br><span class="line">                    node = node.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                        node.right = Trie()</span><br><span class="line">                    node = node.right</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        res = [<span class="number">0</span>] * <span class="built_in">len</span>(queries)</span><br><span class="line">        <span class="keyword">for</span> idx, [x, m] <span class="keyword">in</span> newQueries:</span><br><span class="line">            <span class="keyword">while</span> nums <span class="keyword">and</span> nums[-<span class="number">1</span>] &lt;= m:</span><br><span class="line">                build(nums.pop())</span><br><span class="line">            maxRes = <span class="number">0</span></span><br><span class="line">            node = root</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">                    res[idx] = -<span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                bit = (x &gt;&gt; k) &amp; <span class="number">1</span></span><br><span class="line">                mBit = (m &gt;&gt; k) &amp; <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> bit == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">if</span> node.right:</span><br><span class="line">                        node = node.right</span><br><span class="line">                        maxRes = maxRes * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        node = node.left</span><br><span class="line">                        maxRes *= <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> node.left:</span><br><span class="line">                        node = node.left</span><br><span class="line">                        maxRes = maxRes * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        node = node.right</span><br><span class="line">                        maxRes *= <span class="number">2</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[idx] = maxRes</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>5.22</strong></p>
<p>镇江比赛现场，答辩前刷道每日一题。</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="810-黑板异或游戏"><a href="https://leetcode-cn.com/problems/chalkboard-xor-game/">810. 黑板异或游戏</a></h4>
<p>难度困难</p>
<p>黑板上写着一个非负整数数组 <code>nums[i]</code> 。Alice 和 Bob 轮流从黑板上擦掉一个数字，Alice 先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于 0 的话，当前玩家游戏失败。 (另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为 0。）</p>
<p>换种说法就是，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 0，这个玩家获胜。</p>
<p>假设两个玩家每步都使用最优解，当且仅当 Alice 获胜时返回 <code>true</code>。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1, 1, 2]</span><br><span class="line">输出: false</span><br><span class="line">解释: </span><br><span class="line">Alice 有两个选择: 擦掉数字 1 或 2。</span><br><span class="line">如果擦掉 1, 数组变成 [1, 2]。剩余数字按位异或得到 1 XOR 2 = 3。那么 Bob 可以擦掉任意数字，因为 Alice 会成为擦掉最后一个数字的人，她总是会输。</span><br><span class="line">如果 Alice 擦掉 2，那么数组变成[1, 1]。剩余数字按位异或得到 1 XOR 1 = 0。Alice 仍然会输掉游戏。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= N &lt;= 1000</code></li>
<li><code>0 &lt;= nums[i] &lt;= 2^16</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>博弈论，详细数学证明过程可以看<a href="https://leetcode-cn.com/problems/chalkboard-xor-game/solution/hei-ban-yi-huo-you-xi-by-leetcode-soluti-eb0c/">官方题解</a>。</p>
<p>Alice 有两种必胜情况：</p>
<ul>
<li>数组中所有数异或的结果是 0（不管是什么顺序， 必然是先手的将数组清空）</li>
<li>数组的长度为偶数（可以通过数学证明先手必定能异或到最后一个数）</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">xorGame</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            res ^= num</span><br><span class="line">        <span class="keyword">return</span> res == <span class="number">0</span> <span class="keyword">or</span> nums.length % <span class="number">2</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>5.21</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1035-不相交的线"><a href="https://leetcode-cn.com/problems/uncrossed-lines/">1035. 不相交的线</a></h4>
<p>难度中等</p>
<p>在两条独立的水平线上按给定的顺序写下 <code>nums1</code> 和 <code>nums2</code> 中的整数。</p>
<p>现在，可以绘制一些连接两个数字 <code>nums1[i]</code> 和 <code>nums2[j]</code> 的直线，这些直线需要同时满足满足：</p>
<ul>
<li><code>nums1[i] == nums2[j]</code></li>
<li>且绘制的直线不与任何其他连线（非水平线）相交。</li>
</ul>
<p>请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。</p>
<p>以这种方法绘制线条，并返回可以绘制的最大连线数。</p>
<p><strong>示例 1：</strong></p>
<p><strong><img src="https://cdn.ethanloo.cn/img/20210521085241.png" alt="img" style="zoom: 25%;" /></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,4,2], nums2 = [1,2,4]</span><br><span class="line">输出：2</span><br><span class="line">解释：可以画出两条不交叉的线，如上图所示。 </span><br><span class="line">但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums1.length &lt;= 500</code></li>
<li><code>1 &lt;= nums2.length &lt;= 500</code></li>
<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 2000</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>第一直觉是 DFS，结果十分钟写完之后超时了 💫</p>
<p>看了题解发现是动规，思想就是最长公共子序列，写呗。</p>
<p><strong>代码</strong></p>
<blockquote>
<p>昨天还忘记说了用 Python 的原因，是六月份有个蓝桥杯国赛。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxUncrossedLines</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n = <span class="built_in">len</span>(nums1), <span class="built_in">len</span>(nums2)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums1[i - <span class="number">1</span>] == nums2[j - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[m][n]</span><br></pre></td></tr></table></figure>
<p><strong>5.20</strong></p>
<p>昨晚得知了 MS 实习被分到 NLP 组的消息 🤦‍♂️ 吓得我以为前端的梦破灭了，后来询问学长发现其实还是做全栈偏前端的项目。</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="692-前K个高频单词"><a href="https://leetcode-cn.com/problems/top-k-frequent-words/">692. 前K个高频单词</a></h4>
<p>难度中等</p>
<p>给一非空的单词列表，返回前 <em>k</em> 个出现次数最多的单词。</p>
<p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [&quot;i&quot;, &quot;love&quot;, &quot;leetcode&quot;, &quot;i&quot;, &quot;love&quot;, &quot;coding&quot;], k = 2</span><br><span class="line">输出: [&quot;i&quot;, &quot;love&quot;]</span><br><span class="line">解析: &quot;i&quot; 和 &quot;love&quot; 为出现次数最多的两个单词，均为2次。</span><br><span class="line">    注意，按字母顺序 &quot;i&quot; 在 &quot;love&quot; 之前。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [&quot;the&quot;, &quot;day&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;the&quot;, &quot;the&quot;, &quot;the&quot;, &quot;sunny&quot;, &quot;is&quot;, &quot;is&quot;], k = 4</span><br><span class="line">输出: [&quot;the&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;day&quot;]</span><br><span class="line">解析: &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; 和 &quot;day&quot; 是出现次数最多的四个单词，</span><br><span class="line">    出现次数依次为 4, 3, 2 和 1 次。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>哈希表计数 + 排序</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">self, words: <span class="type">List</span>[<span class="built_in">str</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        dic = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">            dic[word] += <span class="number">1</span></span><br><span class="line">        res = <span class="built_in">list</span>(dic.items())</span><br><span class="line">        res.sort(key = <span class="keyword">lambda</span> x: (-x[<span class="number">1</span>], x[<span class="number">0</span>]))</span><br><span class="line">        <span class="keyword">return</span> [i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> res[:k]]</span><br></pre></td></tr></table></figure>
<p><strong>5.19</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1738-找出第-K-大的异或坐标值"><a href="https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/">1738. 找出第 K 大的异或坐标值</a></h4>
<p>难度中等</p>
<p>给你一个二维矩阵 <code>matrix</code> 和一个整数 <code>k</code> ，矩阵大小为 <code>m x n</code> 由非负整数组成。</p>
<p>矩阵中坐标 <code>(a, b)</code> 的 <strong>值</strong> 可由对所有满足 <code>0 &lt;= i &lt;= a &lt; m</code> 且 <code>0 &lt;= j &lt;= b &lt; n</code> 的元素 <code>matrix[i][j]</code>（<strong>下标从 0 开始计数</strong>）执行异或运算得到。</p>
<p>请你找出 <code>matrix</code> 的所有坐标中第 <code>k</code> 大的值（<strong><code>k</code> 的值从 1 开始计数</strong>）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[5,2],[1,6]], k = 1</span><br><span class="line">输出：7</span><br><span class="line">解释：坐标 (0,1) 的值是 5 XOR 2 = 7 ，为最大的值。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[5,2],[1,6]], k = 2</span><br><span class="line">输出：5</span><br><span class="line">解释：坐标 (0,0) 的值是 5 = 5 ，为第 2 大的值。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>似曾相识，不久之前做过一次二维前缀和，一个性质。</p>
<p>开辟一个二维数组 <code>sums</code> 计算从左上角开始的累计异或值，<code>sums[i][j]</code> 表示的是从 <code>matrix[0][0]</code> 一直异或到 <code>matrix[i - 1][j - 1]</code> 的值。</p>
<p>通过遍历一遍 <code>martix</code> 来生成该二维数组，要计算 <code>sums[i][j]</code> 只需要将对以下四个值进行异或操作。</p>
<ul>
<li>
<p><code>sums[i - 1][j - 1]</code></p>
</li>
<li>
<p><code>sums[i - 1][j]</code></p>
</li>
<li>
<p><code>sums[i][j - 1]</code></p>
</li>
<li>
<p><code>matrix[i][j]</code></p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">kthLargestValue</span>(<span class="params">matrix: <span class="built_in">number</span>[][], k: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="comment">// 类前缀和，二维异或版</span></span><br><span class="line">    <span class="keyword">let</span> m = matrix.<span class="property">length</span>, n = matrix[<span class="number">0</span>].<span class="property">length</span></span><br><span class="line">    <span class="keyword">const</span> sum = <span class="keyword">new</span> <span class="title class_">Array</span>(m + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">const</span> nums = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            sum[i + <span class="number">1</span>][j + <span class="number">1</span>] = sum[i][j] ^ sum[i + <span class="number">1</span>][j] ^ sum[i][j + <span class="number">1</span>] ^ matrix[i][j]</span><br><span class="line">            nums.<span class="title function_">push</span>(sum[i + <span class="number">1</span>][j + <span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">x, y</span>) =&gt;</span> y - x)</span><br><span class="line">    <span class="keyword">return</span> nums[k-<span class="number">1</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>5.18</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1442-形成两个异或相等数组的三元组数目"><a href="https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/">1442. 形成两个异或相等数组的三元组数目</a></h4>
<p>难度中等</p>
<p>给你一个整数数组 <code>arr</code> 。</p>
<p>现需要从数组中取三个下标 <code>i</code>、<code>j</code> 和 <code>k</code> ，其中 <code>(0 &lt;= i &lt; j &lt;= k &lt; arr.length)</code> 。</p>
<p><code>a</code> 和 <code>b</code> 定义如下：</p>
<ul>
<li><code>a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]</code></li>
<li><code>b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]</code></li>
</ul>
<p>注意：<strong>^</strong> 表示 <strong>按位异或</strong> 操作。</p>
<p>请返回能够令 <code>a == b</code> 成立的三元组 (<code>i</code>, <code>j</code> , <code>k</code>) 的数目。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [2,3,1,6,7]</span><br><span class="line">输出：4</span><br><span class="line">解释：满足题意的三元组分别是 (0,1,2), (0,2,2), (2,3,4) 以及 (2,4,4)</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [1,1,1,1,1]</span><br><span class="line">输出：10</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>还算是看完题解就能立马就能看懂的题。</p>
<p>为了快速获取 <code>arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]</code> 这种连续异或值，首先需要考虑使用类前缀和数组。</p>
<p>表面上看需要三重循环穷举 <code>i, j ,k</code> 的值，但是这里有一个小 trick，当我找到一对 <code>i, j, k</code> 满足题目要求时，事实上这个 <code>j</code> 的位置并不重要，或者说它在哪都都无所谓。</p>
<p>因为如果 <code>j</code> 前移，根据异或的性质，新的 <code>a, b</code> 可以根据 <code>a ^ arr[j - 1], b ^ arr[j - 1]</code> 求出，显然此时 <code>a, b</code> 还是相等。</p>
<p>所以只需要穷举 <code>i ,k</code> 的值即可知道所有的可能性。</p>
<p><strong>代码</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">countTriplets</span>(<span class="params">arr: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="comment">// arr[i:j], arr[j+1:k+1] </span></span><br><span class="line">    <span class="comment">// 类前缀和</span></span><br><span class="line">    <span class="keyword">const</span> n = arr.<span class="property">length</span></span><br><span class="line">    <span class="keyword">const</span> sum = <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">// arr[i:j] = sum[j] ^ sum[i]</span></span><br><span class="line">        sum[i + <span class="number">1</span>] = sum[i] ^ arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// a ^ b = (a ^ x) ^ (b ^ x)</span></span><br><span class="line">    <span class="comment">// a中少一个，b中多一个，结果不变，只需要循环i, k</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k = i + <span class="number">1</span>; k &lt; n; k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sum[i] ^ sum[k]) === arr[k]) res += (k - i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>5.17</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="993-二叉树的堂兄弟节点"><a href="https://leetcode-cn.com/problems/cousins-in-binary-tree/">993. 二叉树的堂兄弟节点</a></h4>
<p>难度简单</p>
<p>在二叉树中，根节点位于深度 <code>0</code> 处，每个深度为 <code>k</code> 的节点的子节点位于深度 <code>k+1</code> 处。</p>
<p>如果二叉树的两个节点深度相同，但 <strong>父节点不同</strong> ，则它们是一对<em>堂兄弟节点</em>。</p>
<p>我们给出了具有唯一值的二叉树的根节点 <code>root</code> ，以及树中两个不同节点的值 <code>x</code> 和 <code>y</code> 。</p>
<p>只有与值 <code>x</code> 和 <code>y</code> 对应的节点是堂兄弟节点时，才返回 <code>true</code> 。否则，返回 <code>false</code>。</p>
<p><strong>示例 1：<br>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-01.png" alt="img"></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,3,4], x = 4, y = 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：<br>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/q1248-02.png" alt="img"></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,3,null,4,null,5], x = 5, y = 4</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>简单题，既然之前一直 DFS，这次就换个 BFS 吧。</p>
<p>利用数组进行层序的遍历，每次遍历做的事情：</p>
<ul>
<li>检查上一层的结点值，如果同时发现 <code>x</code> 和 <code>y</code>，返回 <code>true</code>，如果只有其中之一，返回 <code>false</code>，两者都没出现，继续找。</li>
<li>存储下一层的结点值</li>
<li>判断当前的结点的两个子节点是否正好是 <code>x</code> 和 <code>y</code>，如果是，说明两者是 <code>亲兄弟</code> 关系，和题目不符，返回 <code>false</code>。</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">isCousins</span>(<span class="params">root: TreeNode | <span class="literal">null</span>, x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 层序遍历</span></span><br><span class="line">    <span class="keyword">let</span> nodes = [root]</span><br><span class="line">    <span class="keyword">while</span> (nodes.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> nxt = []</span><br><span class="line">        <span class="keyword">let</span> existsX = <span class="literal">false</span>, existsY = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> node <span class="keyword">of</span> nodes) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.<span class="property">val</span> === x) existsX = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">if</span> (node.<span class="property">val</span> === y) existsY = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">if</span> (node.<span class="property">left</span>) &#123;</span><br><span class="line">                nxt.<span class="title function_">push</span>(node.<span class="property">left</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.<span class="property">right</span>) &#123;</span><br><span class="line">                nxt.<span class="title function_">push</span>(node.<span class="property">right</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.<span class="property">left</span> &amp;&amp; node.<span class="property">right</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.<span class="property">left</span>.<span class="property">val</span> === x &amp;&amp; node.<span class="property">right</span>.<span class="property">val</span> === y) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (node.<span class="property">left</span>.<span class="property">val</span> === y &amp;&amp; node.<span class="property">right</span>.<span class="property">val</span> === x) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (existsX &amp;&amp; existsY) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (existsX || existsY) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        nodes = nxt</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>5.16</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="421-数组中两个数的最大异或值"><a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/">421. 数组中两个数的最大异或值</a></h4>
<p>难度中等</p>
<p>给你一个整数数组 <code>nums</code> ，返回 <code>nums[i] XOR nums[j]</code> 的最大运算结果，其中 <code>0 ≤ i ≤ j &lt; n</code> 。</p>
<p>**进阶：**你可以在 <code>O(n)</code> 的时间解决这个问题吗？</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,10,5,25,2,8]</span><br><span class="line">输出：28</span><br><span class="line">解释：最大运算结果是 5 XOR 25 = 28.</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,4]</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [8,10,2]</span><br><span class="line">输出：10</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [14,70,53,83,49,91,36,80,92,51,66,70]</span><br><span class="line">输出：127</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>官方给出了两种方法，一种是用哈希表，另一种是前缀树，这两种算法的核心思想是相同的：</p>
<ul>
<li>要想知道数组中最大的两个数的异或值，我们就需要知道最大值的每个「位」是 1 还是 0。</li>
<li>假设我们已经知道了最大值前 <code>i</code> 位，想要知道 <code>i + 1</code> 位的值，那为了令这个数尽可能大，则需要「贪心」地去令这个位为 1。</li>
<li>想要让这个位为 1 的方法也很朴素，在满足前 <code>i</code> 位最大的数中，找到能使第 <code>i + 1</code> 位为 1 的数即可。</li>
</ul>
<p>接下来解释一下怎么使用前缀树判断。</p>
<p>在本题中，由于每一位只可能是 1 或者 0，所以我们使用 <code>left</code> 指针表示 0，用 <code>right</code> 指针表示 1。</p>
<p>我们遍历数组进行建树，从每个数字的 31 位开始（不足补0），如果是 1，那么根节点就应该有右节点，反之，根节点就应该有左节点。详细过程见代码。</p>
<p>然后对我们枚举数组中每个数，逐个寻找异或最大值。</p>
<p>因为我们的树就是类似如下的，所以我们可以很快知道每个位置能不能取1。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210516110339.svg" alt="字典树"></p>
<p><strong>代码</strong></p>
<blockquote>
<p>剪枝操作：遍历的同时判断最大异或值</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    left?: <span class="title class_">Trie</span></span><br><span class="line">    right?: <span class="title class_">Trie</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// left 代表 0，right 代表 1</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">left</span> = <span class="literal">null</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">right</span> = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">findMaximumXOR</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> root = <span class="keyword">new</span> <span class="title class_">Trie</span>()</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 建立字典树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> node = root</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">30</span>; k &gt;= <span class="number">0</span>; k--)&#123;</span><br><span class="line">            <span class="keyword">let</span> bit = (nums[i] &gt;&gt; k) &amp; <span class="number">1</span> <span class="comment">// 左移 k 位</span></span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!node.<span class="property">left</span>) &#123;</span><br><span class="line">                    node.<span class="property">left</span> = <span class="keyword">new</span> <span class="title class_">Trie</span>()</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.<span class="property">left</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bit == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!node.<span class="property">right</span>) &#123;</span><br><span class="line">                    node.<span class="property">right</span> = <span class="keyword">new</span> <span class="title class_">Trie</span>()</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.<span class="property">right</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次加入一个数字后 check 一下最大值</span></span><br><span class="line">        <span class="title function_">check</span>(nums[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">check</span> (<span class="attr">num</span>: <span class="built_in">number</span>)&#123;</span><br><span class="line">        <span class="comment">// 遍历字典树求最大可能的值</span></span><br><span class="line">        <span class="keyword">let</span> node = root</span><br><span class="line">        <span class="keyword">let</span> tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> k = <span class="number">30</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">            <span class="keyword">let</span> bit = (num &gt;&gt; k) &amp; <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (bit == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.<span class="property">right</span>) &#123;</span><br><span class="line">                    node = node.<span class="property">right</span></span><br><span class="line">                    tmp = tmp * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node = node.<span class="property">left</span></span><br><span class="line">                    tmp = tmp * <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bit == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.<span class="property">left</span>) &#123;</span><br><span class="line">                    node = node.<span class="property">left</span></span><br><span class="line">                    tmp = tmp * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    node = node.<span class="property">right</span></span><br><span class="line">                    tmp = tmp * <span class="number">2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="title class_">Math</span>.<span class="title function_">max</span>(tmp, res)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>5.15</strong></p>
<p>昨天中等版，今天简单版，反着来？</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="13-罗马数字转整数"><a href="https://leetcode-cn.com/problems/roman-to-integer/">13. 罗马数字转整数</a></h4>
<p>难度简单</p>
<p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>
<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure>
<p><strong>示例 4:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure>
<p><strong>示例 5:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>用哈希表存储每个字母代表的数字，顺序遍历一遍字符串，逐个转换。</p>
<p>每次除了把当前字母转换为数字，还要考虑以下前一个数字是否比当前数字小。</p>
<p>如果前小，需要扣掉两倍小数，例如 <code>IX = 1 + 10 - 1 * 2</code> 。</p>
<p><strong>代码</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">romanToInt</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> n = s.<span class="property">length</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>], [<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>], [<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>], [<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>], [<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>], [<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>], [<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>]])</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res += map.<span class="title function_">get</span>(s[i])</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; map.<span class="title function_">get</span>(s[i-<span class="number">1</span>]) &lt; map.<span class="title function_">get</span>(s[i])) &#123;</span><br><span class="line">            res -= <span class="number">2</span> * map.<span class="title function_">get</span>(s[i-<span class="number">1</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>5.14</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="12-整数转罗马数字"><a href="https://leetcode-cn.com/problems/integer-to-roman/">12. 整数转罗马数字</a></h4>
<p>难度中等</p>
<p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure>
<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做 <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>
<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>
<ul>
<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。</li>
<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>
<p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 3</span><br><span class="line">输出: &quot;III&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: &quot;IV&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 9</span><br><span class="line">输出: &quot;IX&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 4:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 58</span><br><span class="line">输出: &quot;LVIII&quot;</span><br><span class="line">解释: L = 50, V = 5, III = 3.</span><br></pre></td></tr></table></figure>
<p><strong>示例 5:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 1994</span><br><span class="line">输出: &quot;MCMXCIV&quot;</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>用简单题的解法做中等题，不过分吧 🙄</p>
<p>把数字和字母的对应关系存储到数组中，每次从大到小尝试减。</p>
<p><strong>代码</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">intToRoman</span>(<span class="params">num: <span class="built_in">number</span></span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dic = [</span><br><span class="line">        [<span class="number">1000</span>, <span class="string">&#x27;M&#x27;</span>],</span><br><span class="line">        [<span class="number">900</span>, <span class="string">&#x27;CM&#x27;</span>],</span><br><span class="line">        [<span class="number">500</span>, <span class="string">&#x27;D&#x27;</span>],</span><br><span class="line">        [<span class="number">400</span>, <span class="string">&#x27;CD&#x27;</span>],</span><br><span class="line">        [<span class="number">100</span>, <span class="string">&#x27;C&#x27;</span>],</span><br><span class="line">        [<span class="number">90</span>, <span class="string">&#x27;XC&#x27;</span>],</span><br><span class="line">        [<span class="number">50</span>, <span class="string">&#x27;L&#x27;</span>],</span><br><span class="line">        [<span class="number">40</span>, <span class="string">&#x27;XL&#x27;</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="string">&#x27;X&#x27;</span>],</span><br><span class="line">        [<span class="number">9</span>, <span class="string">&#x27;IX&#x27;</span>],</span><br><span class="line">        [<span class="number">5</span>, <span class="string">&#x27;V&#x27;</span>],</span><br><span class="line">        [<span class="number">4</span>, <span class="string">&#x27;IV&#x27;</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="string">&#x27;I&#x27;</span>],</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">let</span> res = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> [key, val] <span class="keyword">of</span> dic) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= key) &#123;</span><br><span class="line">                num -= +key</span><br><span class="line">                res += val</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>5.13</strong></p>
<p>因为数组太大被迫优化空间，结果发现我耗时 3000ms，别人 100ms 😓。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210513105252.png" alt="image-20210513103657907"></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1269-停在原地的方案数"><a href="https://leetcode-cn.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/">1269. 停在原地的方案数</a></h4>
<p>难度困难</p>
<p>有一个长度为 <code>arrLen</code> 的数组，开始有一个指针在索引 <code>0</code> 处。</p>
<p>每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。</p>
<p>给你两个整数 <code>steps</code> 和 <code>arrLen</code> ，请你计算并返回：在恰好执行 <code>steps</code> 次操作以后，指针仍然指向索引 <code>0</code> 处的方案数。</p>
<p>由于答案可能会很大，请返回方案数 <strong>模</strong> <code>10^9 + 7</code> 后的结果。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：steps = 3, arrLen = 2</span><br><span class="line">输出：4</span><br><span class="line">解释：3 步后，总共有 4 种不同的方法可以停在索引 0 处。</span><br><span class="line">向右，向左，不动</span><br><span class="line">不动，向右，向左</span><br><span class="line">向右，不动，向左</span><br><span class="line">不动，不动，不动</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：steps = 2, arrLen = 4</span><br><span class="line">输出：2</span><br><span class="line">解释：2 步后，总共有 2 种不同的方法可以停在索引 0 处。</span><br><span class="line">向右，向左</span><br><span class="line">不动，不动</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：steps = 4, arrLen = 2</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= steps &lt;= 500</code></li>
<li><code>1 &lt;= arrLen &lt;= 10^6</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>虽然题目标了困难，但其实就是个经典动规。</p>
<p>DP table：本质上就是使用 <code>dp[i][j]</code> 来记录 <code>第i步后，停留在第j格的方案数</code>。</p>
<p>Base case：默认 <code>dp[0][0] = 1</code>，表示移动 0 步，停留在第 0 格的方案有一种。</p>
<p>动态转移方程：想知道 <code>dp[i][j]</code> ，只需要计算 <code>dp[i-1][j-1] + dp[i-1][j] + dp[i-1][j+1]</code>，当然还需要保证位置合法。</p>
<p>最后答案就是 <code>dp[steps][0]</code> 啦。</p>
<p>代码在这个基础上进行了剪枝和空间优化。</p>
<p><strong>代码</strong></p>
<blockquote>
<p>一开始我的数组 <code>dp</code> 开辟的是 <code>arrLen</code> 大小的，因为我想着记录所有可能的位置。</p>
<p>结果后来发现 <code>steps</code> 最大只有 500 🤯，我佛啦，那 <code>arrLen</code> 最大 <code>10e6</code> 有个 🔨 用！</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">numWays</span>(<span class="params">steps: <span class="built_in">number</span>, arrLen: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="comment">// 动规</span></span><br><span class="line">    <span class="comment">// dp[i][j] 表示第 i 步后，停留在 j 格的方案数。</span></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(steps + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= steps; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> newDp = <span class="keyword">new</span> <span class="title class_">Array</span>(steps + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; <span class="title class_">Math</span>.<span class="title function_">min</span>(steps + <span class="number">1</span>, arrLen); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                newDp[j] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            newDp[j] = dp[j]</span><br><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span>) newDp[j] += dp[j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> (j &lt; arrLen) newDp[j] += dp[j + <span class="number">1</span>]</span><br><span class="line">            newDp[j] %= <span class="number">1000000007</span></span><br><span class="line">        &#125;</span><br><span class="line">        dp = newDp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>5.12</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1310-子数组异或查询"><a href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray/">1310. 子数组异或查询</a></h4>
<p>难度中等</p>
<p>有一个正整数数组 <code>arr</code>，现给你一个对应的查询数组 <code>queries</code>，其中 <code>queries[i] = [Li, Ri]</code>。</p>
<p>对于每个查询 <code>i</code>，请你计算从 <code>Li</code> 到 <code>Ri</code> 的 <strong>XOR</strong> 值（即 <code>arr[Li] **xor** arr[Li+1] **xor** ... **xor** arr[Ri]</code>）作为本次查询的结果。</p>
<p>并返回一个包含给定查询 <code>queries</code> 所有结果的数组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]</span><br><span class="line">输出：[2,7,14,8] </span><br><span class="line">解释：</span><br><span class="line">数组中元素的二进制表示形式是：</span><br><span class="line">1 = 0001 </span><br><span class="line">3 = 0011 </span><br><span class="line">4 = 0100 </span><br><span class="line">8 = 1000 </span><br><span class="line">查询的 XOR 值为：</span><br><span class="line">[0,1] = 1 xor 3 = 2 </span><br><span class="line">[1,2] = 3 xor 4 = 7 </span><br><span class="line">[0,3] = 1 xor 3 xor 4 xor 8 = 14 </span><br><span class="line">[3,3] = 8</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]</span><br><span class="line">输出：[8,0,4,4]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>前缀和数组的变形，本质是一样的。</p>
<p>我们新建一个数组 <code>nums</code> 存储 <code>arr[0:i]</code> 的异或和</p>
<ul>
<li>比如 <code>nums[2]</code> 就是 <code>0 ^ arr[0] ^ arr[1]</code></li>
<li>比如 <code>nums[3]</code> 就是 <code>0 ^ arr[0] ^ arr[1] ^ arr[2]</code></li>
</ul>
<p>那么我们想知道从 <code>arr[l]</code> 一直异或到 <code>arr[r]</code> 的和，只需要拿 <code>nums[r + 1] ^ nums[l]</code></p>
<p>实现了一次遍历，多次求子数组的异或和。</p>
<p><strong>代码</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">xorQueries</span>(<span class="params">arr: <span class="built_in">number</span>[], queries: <span class="built_in">number</span>[][]</span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">    <span class="keyword">const</span> n = arr.<span class="property">length</span></span><br><span class="line">    <span class="keyword">const</span> nums = <span class="keyword">new</span> <span class="title class_">Array</span>(n+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        nums[i+<span class="number">1</span>] = nums[i] ^ arr[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> [x, y] <span class="keyword">of</span> queries) &#123;</span><br><span class="line">        res.<span class="title function_">push</span>(nums[x] ^ nums[y + <span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>5.11</strong></p>
<p>数学题？脑筋急转弯？</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1734-解码异或后的排列"><a href="https://leetcode-cn.com/problems/decode-xored-permutation/">1734. 解码异或后的排列</a></h4>
<p>难度中等</p>
<p>给你一个整数数组 <code>perm</code> ，它是前 <code>n</code> 个正整数的排列，且 <code>n</code> 是个 <strong>奇数</strong> 。</p>
<p>它被加密成另一个长度为 <code>n - 1</code> 的整数数组 <code>encoded</code> ，满足 <code>encoded[i] = perm[i] XOR perm[i + 1]</code> 。比方说，如果 <code>perm = [1,3,2]</code> ，那么 <code>encoded = [2,1]</code> 。</p>
<p>给你 <code>encoded</code> 数组，请你返回原始数组 <code>perm</code> 。题目保证答案存在且唯一。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：encoded = [3,1]</span><br><span class="line">输出：[1,2,3]</span><br><span class="line">解释：如果 perm = [1,2,3] ，那么 encoded = [1 XOR 2,2 XOR 3] = [3,1]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：encoded = [6,5,4,6]</span><br><span class="line">输出：[2,4,1,5,3]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>参考<a href="https://leetcode-cn.com/problems/decode-xored-permutation/solution/gong-shui-san-xie-note-bie-pian-li-yong-zeh6o/">题解</a></p>
<ul>
<li>将 <code>encoded</code> 数组的奇数位上的数字逐个异或，其结果就等于原数组 <code>perm</code> 中的前 <code>n-1</code> 个数字异或的结果。</li>
<li>将 <code>1-n</code> 进行异或，其结果等于原数组 <code>perm</code> 中所有数字异或的结果。</li>
<li>将以上两个结果求异或，即可求出 <code>perm</code> 数组中的最后一个数字。</li>
<li>利用该数字和 <code>encoded</code> 数字进行迭代异或，即可求出最后结果。</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">decode</span>(<span class="params">encoded: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">    <span class="keyword">let</span> n = encoded.<span class="property">length</span> + <span class="number">1</span></span><br><span class="line">    <span class="comment">// 求 perm[0:n-1] 的异或结果</span></span><br><span class="line">    <span class="keyword">let</span> last = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        last ^= encoded[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 求 [1:n] 的异或结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        last ^= i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时已知原数组最后一个数为 last</span></span><br><span class="line">    <span class="keyword">const</span> perm = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">    perm[n-<span class="number">1</span>] = last</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        perm[i] = perm[i+<span class="number">1</span>] ^ encoded[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> perm</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>5.10</strong></p>
<p>简单题，重拳出击👊</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="872-叶子相似的树"><a href="https://leetcode-cn.com/problems/leaf-similar-trees/">872. 叶子相似的树</a></h4>
<p>难度简单</p>
<p>请考虑一棵二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 <em>叶值序列</em> 。</p>
<img src="https://cdn.ethanloo.cn/img/20210510190727.jpg" alt="img" style="zoom:50%;" />
<p>举个例子，如上图所示，给定一棵叶值序列为 <code>(6, 7, 4, 9, 8)</code> 的树。</p>
<p>如果有两棵二叉树的叶值序列是相同，那么我们就认为它们是 <em>叶相似</em> 的。</p>
<p>如果给定的两个根结点分别为 <code>root1</code> 和 <code>root2</code> 的树是叶相似的，则返回 <code>true</code>；否则返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<img src="https://cdn.ethanloo.cn/img/20210510190727.jpg" alt="img" style="zoom:50%;" />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>深搜获取所有的叶子的值，然后比较两棵树的值是否相等。</p>
<p><strong>代码</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     val: number</span></span><br><span class="line"><span class="comment"> *     left: TreeNode | null</span></span><br><span class="line"><span class="comment"> *     right: TreeNode | null</span></span><br><span class="line"><span class="comment"> *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *         this.left = (left===undefined ? null : left)</span></span><br><span class="line"><span class="comment"> *         this.right = (right===undefined ? null : right)</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">leafSimilar</span>(<span class="params">root1: TreeNode | <span class="literal">null</span>, root2: TreeNode | <span class="literal">null</span></span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> nodes1 = [], nodes2 = []</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">node: TreeNode, nodes: <span class="built_in">number</span>[]</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node.<span class="property">left</span> &amp;&amp; !node.<span class="property">right</span>) &#123;</span><br><span class="line">            nodes.<span class="title function_">push</span>(node.<span class="property">val</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.<span class="property">left</span>) &#123;</span><br><span class="line">            <span class="title function_">dfs</span>(node.<span class="property">left</span>, nodes)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.<span class="property">right</span>) &#123;</span><br><span class="line">            <span class="title function_">dfs</span>(node.<span class="property">right</span>, nodes)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfs</span>(root1, nodes1)</span><br><span class="line">    <span class="title function_">dfs</span>(root2, nodes2)</span><br><span class="line">    <span class="keyword">if</span> (nodes1.<span class="property">length</span> !== nodes2.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">return</span> nodes1.<span class="title function_">every</span>(<span class="function">(<span class="params">val, ind</span>) =&gt;</span> val === nodes2[ind])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>5.9</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1482-制作-m-束花所需的最少天数"><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/">1482. 制作 m 束花所需的最少天数</a></h4>
<p>难度中等</p>
<p>给你一个整数数组 <code>bloomDay</code>，以及两个整数 <code>m</code> 和 <code>k</code> 。</p>
<p>现需要制作 <code>m</code> 束花。制作花束时，需要使用花园中 <strong>相邻的 <code>k</code> 朵花</strong> 。</p>
<p>花园中有 <code>n</code> 朵花，第 <code>i</code> 朵花会在 <code>bloomDay[i]</code> 时盛开，<strong>恰好</strong> 可以用于 <strong>一束</strong> 花中。</p>
<p>请你返回从花园中摘 <code>m</code> 束花需要等待的最少的天数。如果不能摘到 <code>m</code> 束花则返回 <strong>-1</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：bloomDay = [1,10,3,10,2], m = 3, k = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：让我们一起观察这三天的花开过程，x 表示花开，而 _ 表示花还未开。</span><br><span class="line">现在需要制作 3 束花，每束只需要 1 朵。</span><br><span class="line">1 天后：[x, _, _, _, _]   // 只能制作 1 束花</span><br><span class="line">2 天后：[x, _, _, _, x]   // 只能制作 2 束花</span><br><span class="line">3 天后：[x, _, x, _, x]   // 可以制作 3 束花，答案为 3</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：bloomDay = [1,10,3,10,2], m = 3, k = 2</span><br><span class="line">输出：-1</span><br><span class="line">解释：要制作 3 束花，每束需要 2 朵花，也就是一共需要 6 朵花。而花园中只有 5 朵花，无法满足制作要求，返回 -1 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：bloomDay = [7,7,7,7,12,7,7], m = 2, k = 3</span><br><span class="line">输出：12</span><br><span class="line">解释：要制作 2 束花，每束需要 3 朵。</span><br><span class="line">花园在 7 天后和 12 天后的情况如下：</span><br><span class="line">7 天后：[x, x, x, x, _, x, x]</span><br><span class="line">可以用前 3 朵盛开的花制作第一束花。但不能使用后 3 朵盛开的花，因为它们不相邻。</span><br><span class="line">12 天后：[x, x, x, x, x, x, x]</span><br><span class="line">显然，我们可以用不同的方式制作两束花。</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：bloomDay = [1000000000,1000000000], m = 1, k = 1</span><br><span class="line">输出：1000000000</span><br><span class="line">解释：需要等 1000000000 天才能采到花来制作花束</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：bloomDay = [1,10,2,9,3,8,4,7,5,6], m = 4, k = 2</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>直接用二分是我没想到的。</p>
<p><strong>代码</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">minDays</span>(<span class="params">bloomDay: <span class="built_in">number</span>[], m: <span class="built_in">number</span>, k: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> n = bloomDay.<span class="property">length</span></span><br><span class="line">    <span class="keyword">if</span> (m * k &gt; n) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">check</span> = (<span class="params">days: <span class="built_in">number</span></span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 检查过了 days 天能否完成任务</span></span><br><span class="line">        <span class="keyword">let</span> pre = <span class="number">0</span>, cnt = <span class="number">0</span></span><br><span class="line">        bloomDay.<span class="title function_">map</span>(<span class="function">(<span class="params">day</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (day &lt;= days) &#123;</span><br><span class="line">                pre += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> (pre === k) &#123;</span><br><span class="line">                    pre = <span class="number">0</span></span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> cnt &gt;= m</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = <span class="title class_">Math</span>.<span class="title function_">max</span>(...bloomDay)</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right) / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">check</span>(mid)) &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>5.8</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1723-完成所有工作的最短时间"><a href="https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/">1723. 完成所有工作的最短时间</a></h4>
<p>难度困难</p>
<p>给你一个整数数组 <code>jobs</code> ，其中 <code>jobs[i]</code> 是完成第 <code>i</code> 项工作要花费的时间。</p>
<p>请你将这些工作分配给 <code>k</code> 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 <strong>工作时间</strong> 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 <strong>最大工作时间</strong> 得以 <strong>最小化</strong> 。</p>
<p>返回分配方案中尽可能 <strong>最小</strong> 的 <strong>最大工作时间</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：jobs = [3,2,3], k = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：给每位工人分配一项工作，最大工作时间是 3 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：jobs = [1,2,4,7,8], k = 2</span><br><span class="line">输出：11</span><br><span class="line">解释：按下述方式分配工作：</span><br><span class="line">1 号工人：1、2、8（工作时间 = 1 + 2 + 8 = 11）</span><br><span class="line">2 号工人：4、7（工作时间 = 4 + 7 = 11）</span><br><span class="line">最大工作时间是 11 。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>困难折磨题，<a href="https://leetcode-cn.com/problems/find-minimum-time-to-finish-all-jobs/solution/gong-shui-san-xie-yi-ti-shuang-jie-jian-4epdd/">参考题解</a></p>
<p>DFS + 剪枝</p>
<p>本质上深搜，逐个安排任务，并且更新个人最长工作时间。</p>
<p>优化两点：</p>
<ol>
<li>如果当前的个人最大工作时长已经超过了之前找到的可能答案，则退出递归。</li>
<li>尽可能把工作安排给没有工作的人。</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">minimumTimeRequired</span>(<span class="params">jobs: <span class="built_in">number</span>[], k: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> n = jobs.<span class="property">length</span></span><br><span class="line">    <span class="keyword">let</span> times = <span class="keyword">new</span> <span class="title class_">Array</span>(k).<span class="title function_">fill</span>(<span class="number">0</span>) <span class="comment">// times[i] 表示第 i 个工人的工作时间</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="title class_">Number</span>.<span class="property">MAX_SAFE_INTEGER</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">idx, times, max, used</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (max &gt;= res) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (idx === n) &#123;</span><br><span class="line">            res = max</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 优先分配空闲工人</span></span><br><span class="line">        <span class="keyword">if</span> (used &lt; k) &#123;</span><br><span class="line">            times[used] = jobs[idx]</span><br><span class="line">            <span class="title function_">dfs</span>(idx + <span class="number">1</span>, times, <span class="title class_">Math</span>.<span class="title function_">max</span>(times[used], max), used + <span class="number">1</span>)</span><br><span class="line">            times[used] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; used; i++) &#123;</span><br><span class="line">            times[i] += jobs[idx]</span><br><span class="line">            <span class="title function_">dfs</span>(idx + <span class="number">1</span>, times, <span class="title class_">Math</span>.<span class="title function_">max</span>(times[i], max), used)</span><br><span class="line">            times[i] -= jobs[idx]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfs</span>(<span class="number">0</span>, times, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>5.7</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1486-数组异或操作"><a href="https://leetcode-cn.com/problems/xor-operation-in-an-array/">1486. 数组异或操作</a></h4>
<p>难度简单</p>
<p>给你两个整数，<code>n</code> 和 <code>start</code> 。</p>
<p>数组 <code>nums</code> 定义为：<code>nums[i] = start + 2*i</code>（下标从 0 开始）且 <code>n == nums.length</code> 。</p>
<p>请返回 <code>nums</code> 中所有元素按位异或（<strong>XOR</strong>）后得到的结果。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 5, start = 0</span><br><span class="line">输出：8</span><br><span class="line">解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。</span><br><span class="line">     &quot;^&quot; 为按位异或 XOR 运算符。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>别问，问就是模拟。</p>
<p><strong>代码</strong></p>
<blockquote>
<p>模拟</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">xorOperation</span>(<span class="params">n: <span class="built_in">number</span>, start: <span class="built_in">number</span></span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> res = start</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res ^= (start + <span class="number">2</span> * i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>5.6</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1720-解码异或后的数组"><a href="https://leetcode-cn.com/problems/decode-xored-array/">1720. 解码异或后的数组</a></h4>
<p>难度简单</p>
<p><strong>未知</strong> 整数数组 <code>arr</code> 由 <code>n</code> 个非负整数组成。</p>
<p>经编码后变为长度为 <code>n - 1</code> 的另一个整数数组 <code>encoded</code> ，其中 <code>encoded[i] = arr[i] XOR arr[i + 1]</code> 。例如，<code>arr = [1,0,2,1]</code> 经编码后得到 <code>encoded = [1,2,3]</code> 。</p>
<p>给你编码后的数组 <code>encoded</code> 和原数组 <code>arr</code> 的第一个元素 <code>first</code>（<code>arr[0]</code>）。</p>
<p>请解码返回原数组 <code>arr</code> 。可以证明答案存在并且是唯一的。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：encoded = [1,2,3], first = 1</span><br><span class="line">输出：[1,0,2,1]</span><br><span class="line">解释：若 arr = [1,0,2,1] ，那么 first = 1 且 encoded = [1 XOR 0, 0 XOR 2, 2 XOR 1] = [1,2,3]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：encoded = [6,2,7,3], first = 4</span><br><span class="line">输出：[4,2,0,7,4]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>利用异或的特性 <code>x ^ y ^ x = y</code>，逐个恢复被编码后的数字。</p>
<p><strong>代码</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">decode</span>(<span class="params">encoded: <span class="built_in">number</span>[], first: <span class="built_in">number</span></span>): <span class="built_in">number</span>[] &#123;</span><br><span class="line">    <span class="keyword">const</span> arr = [first, ...encoded]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        arr[i] ^= arr[i - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>5.5</strong></p>
<p>假期结束啦，回来继续动规了</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="740-删除并获得点数"><a href="https://leetcode-cn.com/problems/delete-and-earn/">740. 删除并获得点数</a></h4>
<p>难度中等</p>
<p>给你一个整数数组 <code>nums</code> ，你可以对它进行一些操作。</p>
<p>每次操作中，选择任意一个 <code>nums[i]</code> ，删除它并获得 <code>nums[i]</code> 的点数。之后，你必须删除<strong>每个</strong>等于 <code>nums[i] - 1</code> 或 <code>nums[i] + 1</code> 的元素。</p>
<p>开始你拥有 <code>0</code> 个点数。返回你能通过这些操作获得的最大点数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,4,2]</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">删除 4 获得 4 个点数，因此 3 也被删除。</span><br><span class="line">之后，删除 2 获得 2 个点数。总共获得 6 个点数。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,2,3,3,3,4]</span><br><span class="line">输出：9</span><br><span class="line">解释：</span><br><span class="line">删除 3 获得 3 个点数，接着要删除两个 2 和 4 。</span><br><span class="line">之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。</span><br><span class="line">总共获得 9 个点数。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li>
<li><code>1 &lt;= nums[i] &lt;= 104</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>看了题解发现就跟打家劫舍动规实际上是一个思路。</p>
<p>首先用哈希表计数，因为 <code>每个数字的价值 = 数字大小 * 出现次数</code></p>
<p>然后对数组进行去重和排序，从最小的数字开始看，比较删除当前数字和不删除当前数字的情况的最大分数。</p>
<p>当然这里如果这个数字和上一个数字不相同，则不需要删，将当前分数直接和上一个数的最大分数相加即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deleteAndEarn</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="comment">// 计数</span></span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="title function_">has</span>(i)) &#123;</span><br><span class="line">            map.<span class="title function_">set</span>(i, map.<span class="title function_">get</span>(i) + <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.<span class="title function_">set</span>(i, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">x, y</span>) =&gt;</span> x - y)</span><br><span class="line">    <span class="keyword">const</span> sortedNums = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Set</span>(nums))</span><br><span class="line">    <span class="keyword">const</span> n = sortedNums.<span class="property">length</span></span><br><span class="line">    <span class="comment">// 动态规划</span></span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">    dp[<span class="number">1</span>] = map.<span class="title function_">get</span>(sortedNums[<span class="number">0</span>]) * sortedNums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> num = sortedNums[i]</span><br><span class="line">        <span class="keyword">if</span> (num == sortedNums[i-<span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 数字相连必须删</span></span><br><span class="line">            dp[i + <span class="number">1</span>] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i], dp[i - <span class="number">1</span>] + map.<span class="title function_">get</span>(num) * num)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不相连直接加</span></span><br><span class="line">            dp[i + <span class="number">1</span>] = dp[i] + map.<span class="title function_">get</span>(num) * num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题日志</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>手撕 Promise</title>
    <url>/post/2021-04-23-Weber/Promise/</url>
    <content><![CDATA[<blockquote>
<p>字节前端实习一面就让我手写 Promise，没写出直接挂了 💔，亡羊补牢，为时不晚。</p>
</blockquote>
<h2 id="使用方法回顾">使用方法回顾</h2>
<p>作为 ES6 提出来的新语法，首先回顾一下 Promise 的使用方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">reslove, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reslove</span>(<span class="number">233</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value) <span class="comment">// 233</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>简单来说就是实例化一个 <code>Promise</code> 对象，实例化的时候传一个函数进去，这个函数有两个变量：</p>
<ul>
<li><code>resolve</code>，是一个回调函数，用于处理成功的数据</li>
<li><code>reject</code>，也是一个回调函数，用于处理失败的信息</li>
</ul>
<h2 id="简易版-Promise">简易版 Promise</h2>
<p>简易版 Promise 🍣 呈上：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULLFILLED</span> = <span class="string">&#x27;resolved&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="comment">// 实例化的时候立刻执行传入的这个参数</span></span><br><span class="line">    <span class="title function_">executor</span>(<span class="variable language_">this</span>.<span class="property">resolve</span>, <span class="variable language_">this</span>.<span class="property">reject</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化状态为 pending</span></span><br><span class="line">  status = <span class="variable constant_">PENDING</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// value 存储成功的结果，reason 存储失败的结果</span></span><br><span class="line">  value = <span class="literal">null</span></span><br><span class="line">  reason = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只有当状态为 pending 的时候才执行成功回调</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">FULLFILLED</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只有当状态为 pending 的时候才执行失败回调</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">REJECTED</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">reason</span> = reason</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFullfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">FULLFILLED</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果传入的实例的状态是成功，则执行成功回调</span></span><br><span class="line">      <span class="title function_">onFullfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果传入的实例的状态是失败，则执行失败回调</span></span><br><span class="line">      <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试成功：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">reslove, rejectct</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reslove</span>(<span class="number">233</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value) <span class="comment">// 233</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然而这样子的代码是无法实现异步操作的，因为我们的 <code>then</code> 方法是在主线程中直接运行的，不会受到 <code>executor</code>（也就是新建 Promise 对象的时候传的函数）里异步操作的限制。</p>
<h2 id="异步操作扩展">异步操作扩展</h2>
<p>因此，为了允许异步操作，我们要进行以下扩展：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储成功回调函数</span></span><br><span class="line">onFulfilledCallback = <span class="literal">null</span></span><br><span class="line"><span class="comment">// 存储失败回调函数</span></span><br><span class="line">onRejectedCallback = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 只有当状态为 pending 的时候才执行成功回调</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">FULFILLED</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">    <span class="comment">// 如果存在成功回调，就调用</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onFulfilledCallback</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">onFulfilledCallback</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 只有当状态为 pending 的时候才执行失败回调</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">REJECTED</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = reason</span><br><span class="line">    <span class="comment">// 如果存在成失败回调，就调用</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedCallback</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">onRejectedCallback</span>(reason)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">    <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">    <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果传入的实例仍是等待中，那么需要先存储成功和失败的回调函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onFulfilledCallback</span> = onFulfilled</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedCallback</span> = onRejected</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这个方式有个很明显的缺陷，就是我们的 <code>promise</code> 一旦有多个 <code>then</code>，它的原先的回调函数就会被新的回调函数覆盖掉。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// success</span></span><br></pre></td></tr></table></figure>
<p>很容易就能想到，用数组来存储所有的成功回调和失败回调函数即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储成功回调函数</span></span><br><span class="line">onFulfilledCallback = []</span><br><span class="line"><span class="comment">// 存储失败回调函数</span></span><br><span class="line">onRejectedCallback = []</span><br><span class="line"></span><br><span class="line">resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 只有当状态为 pending 的时候才执行成功回调</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">FULFILLED</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">    <span class="comment">// 如果存在成功回调，就调用</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">onFulfilledCallback</span>.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="comment">// 这里用 shift() 保证了每个成功回调只会运行一次</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onFulfilledCallback</span>.<span class="title function_">shift</span>()(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 只有当状态为 pending 的时候才执行失败回调</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">REJECTED</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">reason</span> = reason</span><br><span class="line">    <span class="comment">// 如果存在成失败回调，就调用</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">onRejectedCallback</span>.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onRejectedCallback</span>.<span class="title function_">shift</span>()(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果传入的实例的状态是成功，则执行成功回调</span></span><br><span class="line">    <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果传入的实例的状态是失败，则执行失败回调</span></span><br><span class="line">    <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果传入的实例仍是等待中，那么需要先存储成功和失败的回调函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onFulfilledCallback</span>.<span class="title function_">push</span>(onFulfilled)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">onRejectedCallback</span>.<span class="title function_">pop</span>(onRejected)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链式调用">链式调用</h2>
<p>我们一鼓作气，再把 <code>then</code> 的链式调用给实现了。</p>
<p>逻辑也很清晰，就是在调用 <code>then</code> 的时候，我们需要判断一下，执行成功回调函数的返回值是否是一个 <code>MyPromise</code> 对象，两种情况：</p>
<ul>
<li>是 <code>MyPromise</code> 对象，就继续调用返回的这个对象的 <code>then</code> 方法</li>
<li>是普通值，就直接调用成功的回调函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="comment">// 为了实现链式调用，需要返回一个 MyPromise 对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">      <span class="comment">// 获取成功回调的结果</span></span><br><span class="line">      <span class="keyword">const</span> ret = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">      <span class="keyword">if</span> (ret <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果返回值仍然是一个 MyPromise 实例，则进行链式调用</span></span><br><span class="line">        ret.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ret 是普通值，则直接调用成功回调</span></span><br><span class="line">        <span class="title function_">resolve</span>(ret)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果传入的实例的状态是失败，则执行失败回调</span></span><br><span class="line">      <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果传入的实例仍是等待中，那么需要先存储成功和失败的回调函数</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onFulfilledCallback</span>.<span class="title function_">push</span>(onFulfilled)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onRejectedCallback</span>.<span class="title function_">pop</span>(onRejected)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>))</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>))</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// success</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// success</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// success</span></span><br></pre></td></tr></table></figure>
<p>但是，这个实现还有很多限制，我们逐步解决。</p>
<h3 id="循环调用">循环调用</h3>
<p>按我们上面的写法，我们如果在 <code>promise.then</code> 里面返回了同一个 <code>promise</code>，结果会报 <code>Uncaught ReferenceError</code> 的错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = promise.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.ethanloo.cn/img/20210423113804.png" alt="image-20210423113756496"></p>
<p>但是，官方的 Promise 报的却是 <code>Type Error</code> 的错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = promise.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.ethanloo.cn/img/20210423113849.png" alt="image-20210423113849223"></p>
<p>该怎么还原呢，我们尝试修改 <code>then</code> 方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="comment">// 为了实现链式调用，需要返回一个 MyPromise 对象</span></span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">      <span class="comment">// 创建一个微任务</span></span><br><span class="line">      <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成功回调的结果</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> ret = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">          <span class="keyword">if</span> (p === ret) &#123;</span><br><span class="line">            <span class="comment">// 如果返回值和原 promise 相同，抛出循环调用异常</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">reject</span>(</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27;</span>)</span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (ret <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果返回值仍然是一个 MyPromise 实例，则进行链式调用</span></span><br><span class="line">            ret.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ret 是普通值，则直接调用成功回调</span></span><br><span class="line">            <span class="title function_">resolve</span>(ret)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果传入的实例的状态是失败，则执行失败回调</span></span><br><span class="line">      <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果传入的实例仍是等待中，那么需要先存储成功和失败的回调函数</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onFulfilledCallback</span>.<span class="title function_">push</span>(onFulfilled)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onRejectedCallback</span>.<span class="title function_">pop</span>(onRejected)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，还记得之前为了实现链式调用而新建了 <code>MyPromise</code> 对象，当时是直接 <code>return</code> 了这个对象，现在我们对其命名为 <code>p</code>，并且保存下来，以便后续判断循环调用。</p>
<p>只需要在获取成功回调返回值的时候，判断其是否和我们新建的 <code>p</code> 相同</p>
<p>由于 <code>p</code> 是 <code>New</code> 完之后才能获得的一个对象，所以直接在原本的 <code>then</code> 函数中增加判重逻辑即可。</p>
<p>验证：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;new success&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个循环调用的 promise</span></span><br><span class="line"><span class="keyword">const</span> p = promise.<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(</span><br><span class="line">  <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(reason)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.ethanloo.cn/img/20210423192328.png" alt="image-20210423192328052"></p>
<h2 id="捕获错误">捕获错误</h2>
<p>在 Promise 中，为了避免发生错误就中断代码运行，我们需要对两个地方的错误进行捕获。</p>
<ol>
<li>
<p>在实例化 <code>MyPromise</code> 的时候</p>
</li>
<li>
<p>在 <code>then</code> 的过程中</p>
</li>
</ol>
<p>针对实例化的错误肯定是在构造函数中进行捕捉，实际上只需要对 <code>executor</code> 执行的增加异常捕获操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 实例化的时候立刻执行传入的这个参数</span></span><br><span class="line">    <span class="title function_">executor</span>(<span class="variable language_">this</span>.<span class="property">resolve</span>, <span class="variable language_">this</span>.<span class="property">reject</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="comment">// 捕获错误并执行失败回调</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对 <code>then</code> 方法中出现的错误，显然就是处理对其进行异常捕获啦。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取成功回调的结果</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ret = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">    <span class="keyword">if</span> (p === ret) &#123;</span><br><span class="line">      <span class="comment">// 如果返回值和原 promise 相同，抛出循环调用异常</span></span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">reject</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27;</span>)</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ret <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果返回值仍然是一个 MyPromise 实例，则进行链式调用</span></span><br><span class="line">      ret.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// ret 是普通值，则直接调用成功回调</span></span><br><span class="line">      <span class="title function_">resolve</span>(ret)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="title function_">reject</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>让我们来看看效果是否和我们预期一样。</p>
<p>构造函数中捕获错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;new failed&#x27;</span>)</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.ethanloo.cn/img/20210423191329.png" alt="image-20210423191321826"></p>
<p><code>then</code> 中捕获错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;new success&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(</span><br><span class="line">    <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>, value)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;then failed&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">then</span>(</span><br><span class="line">    <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>, reason)</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.ethanloo.cn/img/20210423192719.png" alt="image-20210423192718969"></p>
<h2 id="优化-then-中的-REJECTED-和-PENDING-状态">优化 then 中的 REJECTED 和 PENDING 状态</h2>
<p>先前我们对 <code>then</code> 方法中 <code>FULFLLED</code> 状态的操作进行了优化，包括：</p>
<ul>
<li>创建微任务，实现检测循环调用错误</li>
<li>执行回调时增加捕获异常功能</li>
</ul>
<p>现在我们也对 <code>REJECTED</code> 和 <code>PENDING</code> 状态进行以上补充。</p>
<p>首先为了书写方便，先定义一个处理 promise 返回值的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resolvePromise</span>(<span class="params">p, ret, resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (p === ret) &#123;</span><br><span class="line">    <span class="comment">// 如果返回值和原 promise 相同，抛出循环调用异常</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reject</span>(</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27;</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ret <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果返回值仍然是一个 MyPromise 实例，则进行链式调用</span></span><br><span class="line">    ret.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ret 是普通值，则直接调用成功回调</span></span><br><span class="line">    <span class="title function_">resolve</span>(ret)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改 <code>then</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="comment">// 为了实现链式调用，需要返回一个 MyPromise 对象</span></span><br><span class="line">  <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">      <span class="comment">// 创建一个微任务</span></span><br><span class="line">      <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 获取成功回调的结果</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> ret = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">          <span class="title function_">resolvePromise</span>(p, ret, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果传入的实例的状态是失败，则执行失败回调</span></span><br><span class="line">      <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> ret = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>)</span><br><span class="line">          <span class="title function_">resolvePromise</span>(p, ret, resolve, reject)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          <span class="title function_">reject</span>(error)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果传入的实例仍是等待中，那么需要先存储成功和失败的回调函数</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onFulfilledCallback</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> ret = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">            <span class="title function_">resolvePromise</span>(p, ret, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">onRejectedCallback</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> ret = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">            <span class="title function_">resolvePromise</span>(p, ret, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="then-方法中的默认函数">then 方法中的默认函数</h2>
<p>在调用 <code>then</code> 方法的时候，应该允许不写成功和失败的回调。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">  <span class="comment">// 未指定成功和失败回调时，使用默认函数</span></span><br><span class="line">  onFulfilled =</span><br><span class="line">    <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function">(<span class="params">value</span>) =&gt;</span> value</span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> reason</span><br><span class="line">        &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="resolve-和-reject-的静态调用">resolve 和 reject 的静态调用</h2>
<p>原生的 Promise 是支持无需实例化，直接调用 <code>Promise.resolve()</code> 来返回一个 <code>Promise</code> 对象的。</p>
<p>如果我们尝试用自定义的 <code>MyPromise</code> 进行这种操作：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">MyPromise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>, value)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>报错提示如下：</p>
<p><img src="https://cdn.ethanloo.cn/img/20210423200557.png" alt="image-20210423200556984"></p>
<p>因为是需要调用类方法，所以我们需要用 <code>static</code> 关键字声明 <code>resolve</code> 和 <code>reject</code> 的静态方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// resolve 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">parameter</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parameter <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> parameter</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(parameter)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reject 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果：</p>
<p><img src="https://cdn.ethanloo.cn/img/20210423201541.png" alt="image-20210423201541575"></p>
<h2 id="代码优化">代码优化</h2>
<p>对声明类时的冗余代码进行优化，优化完代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">PENDING</span> = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">FULFILLED</span> = <span class="string">&#x27;resolved&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">REJECTED</span> = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPromise</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">executor</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 实例化的时候立刻执行传入的这个执行器，并传入 resolve 和 reject</span></span><br><span class="line">      <span class="title function_">executor</span>(<span class="variable language_">this</span>.<span class="property">resolve</span>, <span class="variable language_">this</span>.<span class="property">reject</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="comment">// 捕获错误并执行失败回调</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化状态为 pending</span></span><br><span class="line">  status = <span class="variable constant_">PENDING</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// value 存储成功的结果，reason 存储失败的结果</span></span><br><span class="line">  value = <span class="literal">null</span></span><br><span class="line">  reason = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储成功回调函数</span></span><br><span class="line">  onFulfilledCallback = []</span><br><span class="line">  <span class="comment">// 存储失败回调函数</span></span><br><span class="line">  onRejectedCallback = []</span><br><span class="line"></span><br><span class="line">  resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只有当状态为 pending 的时候才执行成功回调</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">FULFILLED</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span> = value</span><br><span class="line">      <span class="comment">// 如果存在成功回调，就调用</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">onFulfilledCallback</span>.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onFulfilledCallback</span>.<span class="title function_">shift</span>()(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只有当状态为 pending 的时候才执行失败回调</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">status</span> = <span class="variable constant_">REJECTED</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">reason</span> = reason</span><br><span class="line">      <span class="comment">// 如果存在成失败回调，就调用</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">onRejectedCallback</span>.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onRejectedCallback</span>.<span class="title function_">shift</span>()(reason)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">then</span>(<span class="params">onFulfilled, onRejected</span>) &#123;</span><br><span class="line">    <span class="comment">// 未指定成功和失败回调时，使用默认函数</span></span><br><span class="line">    <span class="keyword">const</span> realOnFulfilled =</span><br><span class="line">      <span class="keyword">typeof</span> onFulfilled === <span class="string">&#x27;function&#x27;</span> ? onFulfilled : <span class="function">(<span class="params">value</span>) =&gt;</span> value</span><br><span class="line">    <span class="keyword">const</span> realOnRejected =</span><br><span class="line">      <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">        ? onRejected</span><br><span class="line">        : <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> reason</span><br><span class="line">          &#125;</span><br><span class="line">    <span class="comment">// 为了实现链式调用，需要返回一个 MyPromise 对象</span></span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">FULFILLED</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个微任务</span></span><br><span class="line">        <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 获取成功回调的结果</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> x = <span class="title function_">realOnFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">            <span class="title function_">resolvePromise</span>(p, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">REJECTED</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果传入的实例的状态是失败，则执行失败回调</span></span><br><span class="line">        <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> x = (realo = <span class="title class_">OnRejected</span>(<span class="variable language_">this</span>.<span class="property">reason</span>))</span><br><span class="line">            <span class="title function_">resolvePromise</span>(p, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">status</span> === <span class="variable constant_">PENDING</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果传入的实例仍是等待中，那么需要先存储成功和失败的回调函数</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onFulfilledCallback</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> x = <span class="title function_">onFulfilled</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">              <span class="title function_">resolvePromise</span>(p, x, resolve, reject)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">              <span class="title function_">reject</span>(error)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">onRejectedCallback</span>.<span class="title function_">push</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">queueMicrotask</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> ret = <span class="title function_">onRejected</span>(<span class="variable language_">this</span>.<span class="property">value</span>)</span><br><span class="line">              <span class="title function_">resolvePromise</span>(p, ret, resolve, reject)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">              <span class="title function_">reject</span>(error)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// resolve 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">resolve</span>(<span class="params">parameter</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parameter <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> parameter</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(parameter)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reject 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">reject</span>(<span class="params">reason</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MyPromise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(reason)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">resolvePromise</span>(<span class="params">promise, x, resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (promise === x) &#123;</span><br><span class="line">    <span class="comment">// 如果返回值和原 promise 相同，抛出循环调用异常</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reject</span>(</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27;</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="title class_">MyPromise</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果返回值仍然是一个 MyPromise 实例，则进行链式调用</span></span><br><span class="line">    x.<span class="title function_">then</span>(resolve, reject)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// x 是普通值，则直接调用成功回调</span></span><br><span class="line">    <span class="title function_">resolve</span>(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="面向-Promise-A-规范">面向 Promise A+ 规范</h2>
<p>为了更加符合 Promise A+ 的要求，需要对 <code>resolvePromise</code> 进行优化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">resolvePromise</span>(<span class="params">promise, x, resolve, reject</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (promise === x) &#123;</span><br><span class="line">    <span class="comment">// 如果返回值和原 promise 相同，抛出循环调用异常</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">reject</span>(</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27;</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> x === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">resolve</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> then</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      then = x.<span class="property">then</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">reject</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        then.<span class="title function_">call</span>(</span><br><span class="line">          x,</span><br><span class="line">          <span class="function">(<span class="params">y</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            <span class="title function_">resolvePromise</span>(promise, y, resolve, reject)</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">            called = <span class="literal">true</span></span><br><span class="line">            <span class="title function_">reject</span>(r)</span><br><span class="line">          &#125;</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (called) <span class="keyword">return</span></span><br><span class="line">        <span class="title function_">reject</span>(error)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(x)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// x 是普通值，则直接调用成功回调</span></span><br><span class="line">    <span class="title function_">resolve</span>(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise</a></p>
<p><a href="https://juejin.cn/post/6945319439772434469#comment">https://juejin.cn/post/6945319439772434469#comment</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 手写题</title>
    <url>/post/2021-04-07-Weber/JS%E6%89%8B%E5%86%99%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>第一次经历春招（暑期实习）后，也算是见识到了大厂对 JS 手写题的偏爱，也认识到了自己对 JS 的认识的浅薄，甚至连 API 工程师都不配叫。于是我选择回炉重造，跟着<a href="https://juejin.cn/post/6946022649768181774">掘金上的手写教程 </a>写一遍 36 道手写题。</p>
</blockquote>
<h2 id="数据类型">数据类型</h2>
<p>对于原生的 <code>typeof</code> 而言，它能够正确识别的有：<code>undefined, boolean, number, string, symbol, function</code>。但无法识别其他的类型，包括：<code>null, date</code>。</p>
<p>每个对象都有一个 <code>toString()</code> 方法，如果是默认继承自 <code>Object</code> 的 <code>toString()</code> 方法，则最后会输出 <code>[object type]</code> ，其中的 <code>type</code> 是对象的类型，也是我们可以更加准确的识别数据类型的原理。</p>
<p>由于对象可能重写过这个方法（和 <code>Object</code> 自带的 <code>toString()</code> 返回值不同），所以我们通过调用原版的方法 <code>Object.prototype.toString</code> 来获取对象的类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(arr)) <span class="comment">// &#x27;[object Array]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>返回的类型是一个字符串，所以通过 <code>split(' ')</code>，先将字符串转成数组。<code>['[object', 'Array]']</code>。</p>
<p>选取后面一个字符串，去除括号并转换为小写。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">typeOf</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj).<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)[<span class="number">1</span>]</span><br><span class="line">    res = res.<span class="title function_">substring</span>(<span class="number">0</span>, res.<span class="property">length</span> - <span class="number">1</span>).<span class="title function_">toLowerCase</span>()</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">typeOf</span>([])) <span class="comment">// array</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">typeOf</span>(&#123;&#125;)) <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">typeOf</span>(<span class="keyword">new</span> <span class="title class_">Date</span>())) <span class="comment">// date</span></span><br></pre></td></tr></table></figure>
<h2 id="继承">继承</h2>
<h3 id="原型链实现继承">原型链实现继承</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;white&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getColor</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">colors</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Asian</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Asian</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="keyword">let</span> asian1 = <span class="keyword">new</span> <span class="title class_">Asian</span>()</span><br><span class="line">asian1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> asian2 = <span class="keyword">new</span> <span class="title class_">Asian</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(asian2.<span class="property">colors</span>) <span class="comment">// [&#x27;black&#x27;, &#x27;white&#x27;, &#x27;yellow&#x27;]</span></span><br></pre></td></tr></table></figure>
<p>缺陷：</p>
<ul>
<li>属性中的引用类型被所有实例共享</li>
<li>子类在实例化的时候不能给父类构造函数传参</li>
</ul>
<h3 id="构造函数实现继承">构造函数实现继承</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Asian</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Asian</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br></pre></td></tr></table></figure>
<p>解决了原型链继承的问题，但是还有缺陷：</p>
<ul>
<li>方法定义在构造函数中，创建子类实例时都会创建一次方法</li>
</ul>
<h3 id="组合继承">组合继承</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Asian</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Asian</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="title class_">Asian</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Person</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Asian</span>(<span class="string">&#x27;ethan&#x27;</span>, <span class="number">21</span>)</span><br></pre></td></tr></table></figure>
<p>缺陷：</p>
<ul>
<li>调用了两次父类的构造函数，包括：<code>new Asian(), Person.call(this, name)</code></li>
</ul>
<h3 id="寄生式组合继承">寄生式组合继承</h3>
<p>为了不调用两次构造函数，选择使用通过创建空函数获取父类的副本。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">- <span class="title class_">Asian</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line">- <span class="title class_">Asian</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Person</span></span><br><span class="line"></span><br><span class="line">+ <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">+ F.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line">+ <span class="keyword">let</span> f = <span class="keyword">new</span> <span class="title function_">F</span>()</span><br><span class="line">+ f.<span class="property">constructor</span> = <span class="title class_">Asian</span></span><br><span class="line">+ <span class="title class_">Asian</span>.<span class="property"><span class="keyword">prototype</span></span> = f</span><br></pre></td></tr></table></figure>
<p>封装：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = o</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">child, parent</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> prototype = <span class="title function_">object</span>(parent.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">    prototype.<span class="property">constructor</span> = child</span><br><span class="line">    child.<span class="property"><span class="keyword">prototype</span></span> = prototype</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">inheritPrototype</span>(<span class="title class_">Asian</span>, <span class="title class_">Person</span>)</span><br></pre></td></tr></table></figure>
<p>简单版：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Asian</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line"><span class="title class_">Asian</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Asian</span></span><br></pre></td></tr></table></figure>
<h3 id="class-继承"><code>class</code> 继承</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Asian</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(name)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组去重">数组去重</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5 语法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">unique</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> res = arr.<span class="title function_">filter</span>(<span class="keyword">function</span> (<span class="params">item, index, array</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> array.<span class="title function_">indexOf</span>(item) === index</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ES6 语法</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">unique</span> = arr =&gt; [...<span class="keyword">new</span> <span class="title class_">Set</span>(arr)]</span><br></pre></td></tr></table></figure>
<h2 id="数组扁平化">数组扁平化</h2>
<p>对高维的数组进行降维打击，变成一维数组。<code>[1, [2, [3]]] =&gt; [1, 2, 3]</code></p>
<p>使用 JS 的 <code>Array.prototype.flat([depth])</code> 方法，可以对数组进行降维，其中参数 <code>depth</code> 表示最大递归深度。</p>
<blockquote>
<p>使用 <code>Infinity</code>，可以展开任意深度的嵌套数组；该方法还会移除数组中的空项。不支持 IE</p>
</blockquote>
<p>使用 <code>reduce</code> 和 <code>concat</code> 可以代替该方法。</p>
<blockquote>
<p><code>x.concat(y, z)</code> 的特性是把数组 <code>x</code> 和对象 <code>y,z</code> 拼接到一起，形成一个新的数组。</p>
<p>✨值得注意的是，如果待拼接的元素是数组，就会把数组中的所有元素依次放到最终数组中；如果带拼接的元素不是数组，那么就直接放到最终数组中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([<span class="number">1</span>].<span class="title function_">concat</span>([<span class="number">2</span>,<span class="number">3</span>], <span class="number">4</span>)) <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>展开一层数组：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line">arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, val</span>) =&gt;</span> acc.<span class="title function_">concat</span>(val), [])</span><br><span class="line"><span class="comment">// 或者使用扩展运算符</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">flattened</span> = arr =&gt; [].<span class="title function_">concat</span>(...arr)</span><br></pre></td></tr></table></figure>
<p>无限维的展开：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, [<span class="number">4</span>]]]]</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flatter</span>(<span class="params">arr, d = <span class="number">1</span></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(</span><br><span class="line">            <span class="function">(<span class="params">acc, val</span>) =&gt;</span></span><br><span class="line">            acc.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(val) ? <span class="title function_">flatter</span>(val, d - <span class="number">1</span>) : val),</span><br><span class="line">            []</span><br><span class="line">        )</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr.<span class="title function_">slice</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">flatter</span>(nums, <span class="title class_">Infinity</span>)) <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p>ES5 语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flatter</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> res = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr[i])) &#123;</span><br><span class="line">            res = res.<span class="title function_">concat</span>(<span class="title function_">flatter</span>(arr[i]))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(arr[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6 非递归：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">flatter</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (arr.<span class="title function_">some</span>(<span class="function"><span class="params">item</span> =&gt;</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(item))) &#123;</span><br><span class="line">        arr = [].<span class="title function_">concat</span>(...arr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="深浅拷贝">深浅拷贝</h2>
<p>浅拷贝：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">deepClone</span> = (<span class="params">target</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span> target</span><br><span class="line">    <span class="keyword">const</span> cloneTarget = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target.<span class="title function_">hasOwnProperty</span>(prop)) &#123;</span><br><span class="line">            cloneTarget[prop] = target[prop]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简易版深拷贝：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">deepClone</span> = (<span class="params">target</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span> target</span><br><span class="line">    <span class="keyword">const</span> cloneTarget = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (target.<span class="title function_">hasOwnProperty</span>(prop)) &#123;</span><br><span class="line">            cloneTarget[prop] = <span class="title function_">deepClone</span>(target[prop])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneTarget</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简易版深拷贝的缺陷：</p>
<ul>
<li>只考虑了普通的对象属性，不考虑内置对象（<code>Date, RegExp</code>）和函数</li>
<li>循环引用</li>
</ul>
<p>完整版深拷贝：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">isObject</span> = (<span class="params">target</span>) =&gt;</span><br><span class="line">(<span class="keyword">typeof</span> taget === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> target === <span class="string">&#x27;function&#x27;</span>) &amp;&amp;</span><br><span class="line">      target !== <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">deepClone</span> = (<span class="params">target, map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (map.<span class="title function_">get</span>(target)) &#123;</span><br><span class="line">        <span class="comment">// 解决循环引用问题</span></span><br><span class="line">        <span class="keyword">return</span> target</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据当前对象的构造函数获取它的类型</span></span><br><span class="line">    <span class="keyword">let</span> constructor = target.<span class="property">constructor</span></span><br><span class="line">    <span class="comment">// 检测当前对象是否是正则或日期对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/^(RegExp|Date)$/i</span>.<span class="title function_">test</span>(constructor.<span class="property">name</span>)) &#123;</span><br><span class="line">        <span class="comment">// 创建新的特殊对象实例</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">constructor</span>(<span class="params">target</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isObject</span>(target)) &#123;</span><br><span class="line">        map.<span class="title function_">set</span>(target, <span class="literal">true</span>) <span class="comment">// 标记已经被复制</span></span><br><span class="line">        <span class="keyword">const</span> cloneTarget = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target.<span class="title function_">hasOwnProperty</span>(prop)) &#123;</span><br><span class="line">                <span class="comment">// 判断当前属性是否是对象自身的属性，不是原型链上的属性</span></span><br><span class="line">                cloneTarget[prop] = <span class="title function_">deepClone</span>(target[prop], map)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="发布订阅模式">发布订阅模式</h2>
<p>发布订阅模式描述的是对象间一对多的依赖关系，当一个对象的状态发生变化，所有依赖它的对象都得到状态改变的通知。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventEmitter</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cache</span> = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">on</span>(<span class="params">name, fn</span>) &#123;</span><br><span class="line">    <span class="comment">// 增加订阅者</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cache</span>[name]) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cache</span>[name].<span class="title function_">push</span>(fn)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">cache</span>[name] = [fn]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">off</span>(<span class="params">name, fn</span>) &#123;</span><br><span class="line">    <span class="comment">// 关闭订阅</span></span><br><span class="line">    <span class="keyword">let</span> tasks = <span class="variable language_">this</span>.<span class="property">cache</span>[name]</span><br><span class="line">    <span class="keyword">if</span> (tasks) &#123;</span><br><span class="line">      <span class="comment">// 找到对应的订阅者的回调函数</span></span><br><span class="line">      <span class="keyword">const</span> index = tasks.<span class="title function_">findIndex</span>(<span class="function">(<span class="params">f</span>) =&gt;</span> f === fn || f.<span class="property">callback</span> === fn)</span><br><span class="line">      <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        tasks.<span class="title function_">splice</span>(index, <span class="number">1</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">emit</span>(<span class="params">name, once = <span class="literal">false</span>, ...args</span>) &#123;</span><br><span class="line">    <span class="comment">// 广播消息</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">cache</span>[name]) &#123;</span><br><span class="line">      <span class="comment">// 避免回调函数内继续注册相同事件造成死循环</span></span><br><span class="line">      <span class="keyword">let</span> tasks = <span class="variable language_">this</span>.<span class="property">cache</span>[name].<span class="title function_">slice</span>()</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> fn <span class="keyword">of</span> tasks) &#123;</span><br><span class="line">        <span class="title function_">fn</span>(...args)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (once) &#123;</span><br><span class="line">        <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">cache</span>[name]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eventBus = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>()</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn1</span> = (<span class="params">name, age</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`hello, <span class="subst">$&#123;name&#125;</span>, <span class="subst">$&#123;age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fn2</span> = (<span class="params">name, age</span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`bye, <span class="subst">$&#123;name&#125;</span>, <span class="subst">$&#123;age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eventBus.<span class="title function_">on</span>(<span class="string">&#x27;a&#x27;</span>, fn1)</span><br><span class="line">eventBus.<span class="title function_">on</span>(<span class="string">&#x27;a&#x27;</span>, fn2)</span><br><span class="line">eventBus.<span class="title function_">emit</span>(<span class="string">&#x27;a&#x27;</span>, <span class="literal">false</span>, <span class="string">&#x27;Ethan&#x27;</span>, <span class="number">21</span>)</span><br><span class="line"><span class="comment">// hello, Ethan, 21</span></span><br><span class="line"><span class="comment">// bye, Ethan, 21</span></span><br></pre></td></tr></table></figure>
<h2 id="URL-解析">URL 解析</h2>
<p>要知道中文是无法直接作为统一资源定位符的，所以需要使用 <code>encodeURIComponent()</code> 对其进行编码，变成英文和数字组成的字符串。</p>
<p>同样的，为了正确获得这个 URI 所代表的意义，使用 <code>decodeURIComponent()</code> 来进行解码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">encodeURIComponent</span>(<span class="string">&#x27;苏州大学&#x27;</span>)) </span><br><span class="line"><span class="comment">// %E8%8B%8F%E5%B7%9E%E5%A4%A7%E5%AD%A6</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">decodeURIComponent</span>(<span class="string">&#x27;%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%94%9F%E6%B4%BB&#x27;</span>))</span><br><span class="line"><span class="comment">// 从零开始的前端工程师生活</span></span><br></pre></td></tr></table></figure>
<p>了解完这两个函数之后之后开始正式手写 URL 解析为对象的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 URL 字符串解析为对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">parseParam</span> = (<span class="params">url</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> paramsStr = <span class="regexp">/.+\?(.+)$/</span>.<span class="title function_">exec</span>(url)[<span class="number">1</span>] <span class="comment">// 提取?后面的字符串</span></span><br><span class="line">  <span class="keyword">const</span> paramsArr = paramsStr.<span class="title function_">split</span>(<span class="string">&#x27;&amp;&#x27;</span>) <span class="comment">// 分割变量</span></span><br><span class="line">  <span class="keyword">const</span> paramsObj = &#123;&#125;</span><br><span class="line">  paramsArr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">param</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/=/</span>.<span class="title function_">test</span>(param)) &#123;</span><br><span class="line">      <span class="comment">// 解析键值对</span></span><br><span class="line">      <span class="keyword">let</span> [key, val] = param.<span class="title function_">split</span>(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">      val = <span class="built_in">decodeURIComponent</span>(val) <span class="comment">// 解码</span></span><br><span class="line">      val = <span class="regexp">/^\d+$/</span>.<span class="title function_">test</span>(val) ? <span class="built_in">parseFloat</span>(val) : val</span><br><span class="line">      <span class="keyword">if</span> (paramsObj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">        <span class="comment">// 如果对象已经由了对应key，就追加一个value</span></span><br><span class="line">        paramsObj[key] = [].<span class="title function_">concat</span>(paramsObj[key], val)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有对应key，创建键值对</span></span><br><span class="line">        paramsObj[key] = [val]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      paramsObj[param] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> paramsObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模板字符串">模板字符串</h2>
<p>我们知道 ES6 中提供了一种语法可以更加优雅地填充字符串中的变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> personName = <span class="string">&#x27;ethan&#x27;</span>, age = <span class="number">21</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">`I am <span class="subst">$&#123;personName&#125;</span>, <span class="subst">$&#123;age&#125;</span> years old`</span> <span class="comment">// I am ethan, 21 years old</span></span><br></pre></td></tr></table></figure>
<p>我们可以手写一个函数来模仿这种往字符串中填充变量的方式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">render</span> = (<span class="params">template, data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/</span></span><br><span class="line">  <span class="keyword">if</span> (reg.<span class="title function_">test</span>(template)) &#123;</span><br><span class="line">    <span class="comment">// 如果字符串中包含了模板字符串</span></span><br><span class="line">    <span class="keyword">const</span> name = reg.<span class="title function_">exec</span>(template)[<span class="number">1</span>] <span class="comment">// 获取对应的名字</span></span><br><span class="line">    template = template.<span class="title function_">replace</span>(reg, data[name])</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">render</span>(template, data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> template</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> template = <span class="string">&#x27;I am &#123;&#123;name&#125;&#125;, &#123;&#123;age&#125;&#125; years old.&#x27;</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;ethan&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">render</span>(template, person))</span><br></pre></td></tr></table></figure>
<h2 id="图片懒加载">图片懒加载</h2>
<p>为了加快首屏加载的速度，通常我们会对网页上的图片实行懒加载，即只加载可视区域的图片。</p>
<p>网上开源的懒加载库已经很多了，现在我们来手写一个。</p>
<p>基本原理：</p>
<ul>
<li>在 HTML 中把图片地址属性从 <code>src</code> 改成 <code>data-src</code>，避免了直接加载图片。</li>
<li>监听网页的滚动事件，每次加载视口内的图片。</li>
<li>使用 <code>getBoundingClientRect()</code> 来获取标签相对于网站的高度，通过和 视口的高度相比，确认图片是否在视口内。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> imgList = [...<span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;img&#x27;</span>)]</span><br><span class="line"><span class="keyword">const</span> length = imgList.<span class="property">length</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">lazyLoad</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> deleteList = []</span><br><span class="line">    imgList.<span class="title function_">forEach</span>(<span class="function">(<span class="params">img, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> rect = img.<span class="title function_">getBoundingClientRect</span>()</span><br><span class="line">      <span class="keyword">if</span> (rect.<span class="property">top</span> &lt; <span class="variable language_">window</span>.<span class="property">innerHeight</span>) &#123;</span><br><span class="line">        <span class="comment">// 图片在视口内</span></span><br><span class="line">        img.<span class="property">src</span> = img.<span class="property">dataset</span>.<span class="property">src</span></span><br><span class="line">        deleteList.<span class="title function_">push</span>(index)</span><br><span class="line">        count++</span><br><span class="line">        <span class="keyword">if</span> (count == length) &#123;</span><br><span class="line">          <span class="variable language_">document</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, lazyLoad)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    imgList = imgList.<span class="title function_">filter</span>(<span class="function">(<span class="params">_, index</span>) =&gt;</span> !deleteList.<span class="title function_">includes</span>(index))</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;scroll&#x27;</span>, lazyLoad)</span><br></pre></td></tr></table></figure>
<h2 id="防抖">防抖</h2>
<p>上面一个懒加载其实有一个很严重的性能缺陷，我们对 <code>document</code> 的滚动事件进行了监听去出发懒加载的函数。事实上当我们滚动滑轮的时候，这个监听的函数会一直触发，导致函数的执行频率太高了。</p>
<p>为了对这个场景进行优化，实现在事件触发n秒后在执行回调，如果在这n秒内又被触发则重新计时，这种效果就是“防抖”。这里考虑使用 <code>setTimeout()</code> 函数和闭包来实现防抖效果。</p>
<blockquote>
<p>掘金上一个博主的比喻我觉得很好，防抖就像是法师施法需要读条，如果读条中断就需要重新读条，读完条才能释放技能。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">debounce</span> = (<span class="params">fn, time</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// fn 是一个回调函数，time 是触发回调函数的冷却时间</span></span><br><span class="line">  <span class="keyword">let</span> timeout</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> context = <span class="variable language_">this</span></span><br><span class="line">    <span class="keyword">const</span> args = <span class="variable language_">arguments</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout)</span><br><span class="line">    timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.<span class="title function_">apply</span>(context, args)</span><br><span class="line">    &#125;, time)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ele = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;my-input&#x27;</span>)</span><br><span class="line">ele.<span class="title function_">addEventListener</span>(</span><br><span class="line">  <span class="string">&#x27;keypress&#x27;</span>,</span><br><span class="line">  <span class="title function_">debounce</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>), <span class="number">1000</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>通过给输入框的 <code>keypress</code> 事件增加防抖处理，实现了在用户结束输入后 1s，才会触发回调函数。</p>
<h2 id="节流">节流</h2>
<p>规定在一定时间内，只能触发一次函数，如果这段时间内多次尝试触发，则只有一次生效。</p>
<p>这种方法也可以解决之前的滚动事件触发频率过高的问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 利用时间戳实现节流</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">throttle</span> = (<span class="params">fn, time</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> context, args</span><br><span class="line">  <span class="keyword">let</span> pre = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">    context = <span class="variable language_">this</span></span><br><span class="line">    args = <span class="variable language_">arguments</span></span><br><span class="line">    <span class="keyword">if</span> (now - pre &gt; time) &#123;</span><br><span class="line">      <span class="comment">// 对距离上次的时间进行限制</span></span><br><span class="line">      fn.<span class="title function_">apply</span>(context, args)</span><br><span class="line">      pre = now</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里写的是初级版，高级版见 <a href="https://github.com/mqyqingfeng/Blog/issues/26">JavaScript专题之跟着 underscore 学节流</a></p>
</blockquote>
<h2 id="函数柯里化">函数柯里化</h2>
<p>我们的目标是实现一个函数，这个函数的作用如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> addCurry = <span class="title function_">curry</span>(add)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">addCurry</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>可以看出来，正常我们调用 <code>add</code>，应该传三个参数。</p>
<p>但是在柯里化之后，我们可以通过多次每次传一个参数来实现分步的调用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="title function_">judge</span> = (<span class="params">...args</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (args.<span class="property">length</span> == fn.<span class="property">length</span>) <span class="keyword">return</span> <span class="title function_">fn</span>(...args)</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...arg</span>) =&gt;</span> <span class="title function_">judge</span>(...args, ...arg)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> judge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="偏函数">偏函数</h2>
<p>柯里化的低阶版，效果如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> partialAdd = <span class="title function_">partial</span>(add, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">partialAdd</span>(<span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>允许我们再调用函数的时候先传入一些参数，下次再传剩下的参数，实现也比柯里化简单。</p>
<blockquote>
<p>有点像是工厂函数的味道，对一个现有的函数进行二次包装</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">partial</span>(<span class="params">fn, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...arg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fn</span>(...args, ...arg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JSONP">JSONP</h2>
<p>在写 JSONP 之前，先对跨域操作有一个初步的了解。</p>
<p>出于安全性考虑，浏览器限制了 JS 的跨源 HTTP 请求。</p>
<p>例如我为了获取数据，尝试在我的主页<code>https://blog.ethanloo.cn</code> 调一个接口 <code>https://api.ethanloo.cn/todos</code>，这就是一个跨域请求，因为请求的地址和当前的域名不同。</p>
<p>JSONP 就是为了解决跨域请求资源而产生的解决方案，本质利用了 <code>&lt;script&gt;</code> 标签不受跨域限制。</p>
<blockquote>
<p>JSONP 属于古老但成熟的解决方案，只能进行 GET 请求；CORS 是另一个解决跨域问题的方案，复杂但更加强大。</p>
</blockquote>
<p><strong>JSONP 实现流程：</strong></p>
<ol>
<li>利用 <code>script</code> 标签规避跨域：<code>&lt;script src=&quot;url&quot;&gt;</code></li>
<li>客户端声明一个函数：<code>function jsonCallback() &#123;&#125;</code></li>
<li>在服务端根据客户端传的信息，查找数据库，返回字符串。</li>
<li>客户端利用 <code>script</code> 标签解析为可运行的 <code>JavaScript</code> 代码，调用 <code>jsonCallback()</code> 函数。</li>
</ol>
<p><strong>客户端代码 🍣 ：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">jsonCallback</span>(<span class="params">data</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 发送跨域请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://localhost:3000/todos&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>服务端代码 🍣 ：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">date</span>: <span class="string">&#x27;2021-04-17&#x27;</span>,</span><br><span class="line">  <span class="attr">desc</span>: <span class="string">&#x27;learn jsonp&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (request.<span class="property">url</span> == <span class="string">&#x27;/todos&#x27;</span>) &#123;</span><br><span class="line">    response.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json;charset=utf-8&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    response.<span class="title function_">end</span>(<span class="string">`jsonCallback(<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>)`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server is running on http://localhost:3000&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.ethanloo.cn/img/20210417165220.png" alt="image-20210417165212711"></p>
<p>上面这个方法把回调函数和请求都在客户端里写死了，接下来手写一个更灵活通用的 JSONP 方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">jsonp</span> = (<span class="params">&#123; url, params, callbackName &#125;</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">generateUrl</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 首先根据 url 和 params 生成最终请求的 url</span></span><br><span class="line">    <span class="keyword">let</span> src = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">      <span class="keyword">if</span> (params.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">        src += <span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>&amp;`</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后加上回调函数的名字</span></span><br><span class="line">    src += <span class="string">`callback=<span class="subst">$&#123;callbackName&#125;</span>`</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;src&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 创建用于跨域请求的 script 标签</span></span><br><span class="line">    <span class="keyword">const</span> scriptEle = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">    scriptEle.<span class="property">src</span> = <span class="title function_">generateUrl</span>()</span><br><span class="line">    <span class="comment">// 将 script 标签写入 body，浏览器会自动加载</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(scriptEle)</span><br><span class="line">    <span class="comment">// 包装回调函数，使其在执行完成后移除 script 标签</span></span><br><span class="line">    <span class="variable language_">window</span>[callbackName] = <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(data)</span><br><span class="line">      <span class="variable language_">document</span>.<span class="title function_">removeChild</span>(scriptEle)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AJAX">AJAX</h2>
<p>异步的数据请求，实现无刷新加载数据。<a href="https://blog.ethanloo.cn/post/2021-03-26-Weber/JS%20%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/#AJAX">JS 基础面试题</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getJSON</span> = (<span class="params">url</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pormise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 考虑兼容 IE6 的写法</span></span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="title class_">XMLHttpRequest</span></span><br><span class="line">      ? <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">      : <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&#x27;Microsoft.XMLHttp&#x27;</span>)</span><br><span class="line">    <span class="comment">// HTTP 方法，要发送的 URL，是否开启异步</span></span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, url, <span class="literal">false</span>)</span><br><span class="line">    xhr.<span class="title function_">setRequestHeader</span>(<span class="string">&#x27;Accept&#x27;</span>, <span class="string">&#x27;application/json&#x27;</span>)</span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.<span class="property">readState</span> !== <span class="number">4</span>) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (xhr.<span class="property">status</span> === <span class="number">200</span> || xhr.<span class="property">status</span> === <span class="number">304</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(xhr.<span class="property">responseText</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(xhr.<span class="property">responseText</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="forEach">forEach</h2>
<p>ES5 中实现的遍历数组的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">forEach</span> = <span class="keyword">function</span> (<span class="params">callback, thisArg</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;this is null&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(callback + <span class="string">&#x27; is not a fucntion&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>) <span class="comment">// 绑定 this</span></span><br><span class="line">  <span class="keyword">const</span> len = O.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">      <span class="comment">// 额外参数, value, index, arr</span></span><br><span class="line">      callback.<span class="title function_">call</span>(thisArg, O[k], k, O)</span><br><span class="line">    &#125;</span><br><span class="line">    k++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="map">map</h2>
<p>和上面 <code>forEach</code> 原理类似</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span> = <span class="keyword">function</span> (<span class="params">callback, thisArg</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;this is null or undefined!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(callback + <span class="string">&#x27; is not a function&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">const</span> len = O.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">      res[k] = callback.<span class="title function_">call</span>(thisArg, O[k], k, O)</span><br><span class="line">    &#125;</span><br><span class="line">    k++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="filter">filter</h2>
<p>本质也类似</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">filter</span> = <span class="keyword">function</span> (<span class="params">callback, thisArg</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;this is null or undefined!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(callback + <span class="string">&#x27; is not a function&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">const</span> len = O.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (callback.<span class="title function_">call</span>(thisArg, O[k], k, O)) &#123;</span><br><span class="line">      res.<span class="title function_">push</span>(O[k])</span><br><span class="line">    &#125;</span><br><span class="line">    k++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="some">some</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">some</span> = <span class="keyword">function</span> (<span class="params">callback, thisArg</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;this is null or undefined!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(callback + <span class="string">&#x27; is not a function&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">const</span> len = O.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (callback.<span class="title function_">call</span>(thisArg, O[k], k, O)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    k++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="reduce">reduce</h2>
<p>一个很酷的累加器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">reduce</span> = <span class="keyword">function</span> (<span class="params">callback, initialValue</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;this is null or undefined!&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(callback + <span class="string">&#x27; is not a function.&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> O = <span class="title class_">Object</span>(<span class="variable language_">this</span>)</span><br><span class="line">  <span class="keyword">const</span> len = O.<span class="property">length</span> &gt;&gt;&gt; <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> acc</span><br><span class="line">  <span class="keyword">let</span> k = <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    acc = initialValue</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 取数组中第一个非空值</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; len &amp;&amp; !(k <span class="keyword">in</span> O)) &#123;</span><br><span class="line">      k++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k &gt; len) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Reduce of empty array with no initial value&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    acc = O[k++]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">      acc = <span class="title function_">callback</span>(acc, O[k], k, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    k++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> acc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="call">call</h2>
<p>一个用于改变函数中 <code>this</code> 指向的方法。</p>
<p>调用形式如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">eat</span>(<span class="params">k</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">weight</span> += k</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;ethan&#x27;</span>,</span><br><span class="line">  <span class="attr">weight</span>: <span class="number">100</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// call(context, ...args) 后面可以传任意多个参数</span></span><br><span class="line">eat.<span class="title function_">call</span>(person, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">weight</span>) <span class="comment">// 110</span></span><br></pre></td></tr></table></figure>
<p><code>eat</code> 方法本身是不知道 <code>this</code> 是谁的，通过 <code>call</code>，我们就能让这个方法中的 <code>this</code> 指到我们想要的对象上去。</p>
<p>同时由于 <code>eat</code> 方法本身还需要一个参数 <code>k</code>，于是在调用 <code>call</code> 的时候就顺便也传给他。</p>
<p>代码 🍣：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">call</span> = <span class="keyword">function</span> (<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">// 防止没有传参</span></span><br><span class="line">  context = context || <span class="variable language_">window</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 防止 context 对象中出现过 fn 属性</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="title class_">Symbol</span>(<span class="string">&#x27;fn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法中的 this 指向的是调用该方法的对象，调用 call 的是一个函数</span></span><br><span class="line">  <span class="comment">// sayHi.call(person)，this === sayHi 方法</span></span><br><span class="line">  context[fn] = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行函数</span></span><br><span class="line">  <span class="keyword">const</span> res = context[fn](...args)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个手写是 ES6 语法，除开用了 <code>const</code> 和 <code>Symbol</code> 以外，展开运算符 <code>...</code> 也是 ES6 语法。</p>
</blockquote>
<h2 id="apply">apply</h2>
<p>功能和 <code>call</code> 类似，就是传参的方式从展开的一个个参数变成了传入一个参数的数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">apply</span> = <span class="keyword">function</span> (<span class="params">context, args</span>) &#123;</span><br><span class="line">  context = context || <span class="variable language_">window</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="title class_">Symbol</span>(<span class="string">&#x27;fn&#x27;</span>)</span><br><span class="line">  context[fn] = <span class="variable language_">this</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> res = context[fn](...args)</span><br><span class="line">  <span class="keyword">delete</span> context[fn]</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bind">bind</h2>
<p>也是用来改变函数中的 <code>this</code> 指向，和上面的 <code>call</code> 和 <code>apply</code> 相比区别在于不会直接调用函数，返回值是一个函数。</p>
<p>表面上看，包一层 apply 即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span> (<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">apply</span>(context, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么写的问题在于：</p>
<ul>
<li>除了在调用 <code>bind()</code> 的时候可以传参之外，<code>bind()</code> 返回的函数应该也可以接收参数</li>
<li>如果 <code>bind</code> 绑定过的函数被 <code>new</code> 了，那么 <code>this</code> 的指向又会改变</li>
<li>没有保留原函数在原型链上的属性和方法</li>
</ul>
<p>升级版：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">bind</span> = <span class="keyword">function</span> (<span class="params">context, ...args</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">var</span> fn = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    self.<span class="title function_">apply</span>(</span><br><span class="line">      <span class="variable language_">this</span> <span class="keyword">instanceof</span> self ? <span class="variable language_">this</span> : context,</span><br><span class="line">      args.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>))</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fn.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(self.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">  <span class="keyword">return</span> fn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="new">new</h2>
<p><code>new</code> 是一个用来实例化对象的关键字，比较简单，就不举例子说明了。</p>
<p>实现这个关键字的几个要点：</p>
<ul>
<li>实例可以访问私有属性</li>
<li>实例可以访问构造函数原型所在的原型链</li>
<li>需要判断构造函数执行完之后的返回值是否是对象</li>
</ul>
<blockquote>
<p>之所以需要判断返回值类型的原因是因为 <code>new</code> 本身的性质。</p>
<p>引自 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new">MDN 文档</a>：</p>
<p><strong><code>new</code></strong> 关键字会进行如下的操作：</p>
<ol>
<li>创建一个空的简单JavaScript对象（即<code>&#123;&#125;</code>）；</li>
<li>链接该对象（设置该对象的<strong>constructor</strong>）到另一个对象 ；</li>
<li>将步骤1新创建的对象作为<code>this</code>的上下文 ；</li>
<li>如果该函数没有返回对象，则返回<code>this</code>。</li>
</ol>
</blockquote>
<p>🍣 代码实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">newOperator</span>(<span class="params">cst, ...args</span>) &#123;</span><br><span class="line">  <span class="comment">// cst 是构造函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> cst !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;newOperator function the first param must be a function&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 让实例可以访问构造函数原型所在的原型链</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(cst.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">  <span class="keyword">let</span> res = cst.<span class="title function_">apply</span>(obj, args)</span><br><span class="line">  <span class="comment">// 判断构造函数返回的是否是引用类型</span></span><br><span class="line">  <span class="keyword">let</span> isObject = <span class="keyword">typeof</span> res === <span class="string">&#x27;object&#x27;</span> &amp;&amp; res !== <span class="literal">null</span></span><br><span class="line">  <span class="keyword">let</span> isFunction = <span class="keyword">typeof</span> res === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> isObject || isFunction ? res : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检验实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayHi</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27;: hello!&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="title function_">newOperator</span>(<span class="title class_">Person</span>, <span class="string">&#x27;ethan&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person)</span><br><span class="line">person.<span class="title function_">sayHi</span>()</span><br></pre></td></tr></table></figure>
<h2 id="instanceof">instanceof</h2>
<p>该关键字用于检查某个对象是否是由某个构造函数实例化生成的。</p>
<p>我们利用原型链的知识来实现 🍣 这个关键词。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210318145758.image" alt="img"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">instanceOf</span>(<span class="params">obj, cst</span>) &#123;</span><br><span class="line">  <span class="comment">// obj 是待检查的对象，cst 是待检查的构造函数</span></span><br><span class="line">  <span class="keyword">let</span> proto = obj.<span class="property">__proto__</span></span><br><span class="line">  <span class="keyword">while</span> (proto) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (proto === cst.<span class="property"><span class="keyword">prototype</span></span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    proto = proto.<span class="property">__proto__</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接使用 <code>__proto__</code> 属性来获取对象原型的方法并不好，更应该提倡的是使用 <code>Object.getPrototype()</code> 方法来获取原型对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">instanceOf</span>(<span class="params">obj, cst</span>) &#123;</span><br><span class="line">  <span class="comment">// obj 是待检查的对象，cst 是待检查的构造函数</span></span><br><span class="line">  <span class="comment">// let proto = obj.__proto__ // 避免这种写法</span></span><br><span class="line">  <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj)</span><br><span class="line">  <span class="keyword">while</span> (proto) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (proto === cst.<span class="property"><span class="keyword">prototype</span></span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">// proto = proto.__proto__</span></span><br><span class="line">    proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(proto)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检验：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;ethan&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">instanceOf</span>(person, <span class="title class_">Person</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">instanceOf</span>(person, <span class="title class_">Object</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">instanceOf</span>(person, <span class="title class_">Array</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h2 id="Object-create">Object.create</h2>
<p>完整的写法是 <code>Object.create(proto, [propertiesObject])</code>，允许指定一个原型和给定一个参数对象，来创建一个新的对象。</p>
<p>🍣 代码实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property">create</span> = <span class="keyword">function</span> (<span class="params">proto, propertiesObject = <span class="literal">undefined</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> proto !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> proto !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Object prototype may only be an Object or null&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (propertiesObject === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Cannot convert undefined or null to object&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新建一个构造函数</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="comment">// 将构造函数的原型指向给定的原型对象</span></span><br><span class="line">  f.<span class="property"><span class="keyword">prototype</span></span> = proto</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title function_">f</span>()</span><br><span class="line">  <span class="keyword">if</span> (propertiesObject !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(obj, propertiesObject)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (proto === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 允许给定的原型为 null</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(obj, <span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检测：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = <span class="title class_">Object</span>.<span class="title function_">create</span>(</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&#x27;ethan&#x27;</span> &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">age</span>: &#123;</span><br><span class="line">      <span class="attr">value</span>: <span class="number">3</span>,</span><br><span class="line">      <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.ethanloo.cn/img/20210421164839.png" alt="image-20210421164832738"></p>
<h2 id="Object-assign">Object.assign</h2>
<p><code>Object.assign()</code> 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象，它将返回目标对象。</p>
<p>MDN demo：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> source = &#123; <span class="attr">b</span>: <span class="number">4</span>, <span class="attr">c</span>: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> returnedTarget = <span class="title class_">Object</span>.<span class="title function_">assign</span>(target, source);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(target);</span><br><span class="line"><span class="comment">// expected output: Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(returnedTarget);</span><br><span class="line"><span class="comment">// expected output: Object &#123; a: 1, b: 4, c: 5 &#125;</span></span><br></pre></td></tr></table></figure>
<p>🍣 代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property">assign</span> = <span class="keyword">function</span> (<span class="params">target, ...sources</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (target == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Cannot conver undefined or null to object&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ret = <span class="title class_">Object</span>(target)</span><br><span class="line">  sources.<span class="title function_">forEach</span>(<span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="comment">// 遍历对象并赋值</span></span><br><span class="line">        <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(key)) &#123;</span><br><span class="line">          ret[key] = obj[key]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JSON-stringfy">JSON.stringfy</h2>
<p><code>JSON.stringfy(value, [replacer], [space])</code></p>
<p>这个方法可以将一个 JavaScript 对象或值转换为 JSON 字符串。可以使用 <code>replacer</code> 参数选择对序列化对象进行处理，也可以使用 <code>space</code> 参数美化输出的字符串中的空格数。</p>
<blockquote>
<p>这里不考虑实现后面两个参数</p>
</blockquote>
<p>由于 <code>value</code> 的变化性非常强，所以我们对其进行分类讨论。</p>
<ol>
<li>
<p>基本数据类型</p>
<ul>
<li><code>undefined/symbol =&gt; undefined</code></li>
<li><code>boolean =&gt; 'true'/'false'</code></li>
<li><code>NaN/Infinity/null =&gt; 'null'</code></li>
<li><code>number =&gt; '数字'</code></li>
<li><code>string =&gt; 字符串</code></li>
</ul>
</li>
<li>
<p>对象类型</p>
<ul>
<li>
<p><code>function =&gt; undefined</code></p>
</li>
<li>
<p><code>array</code>，如果出现了 <code>undefined, function, symbol</code>，则<code>=&gt; 'null'</code></p>
</li>
<li>
<p><code>RegExp =&gt; '&#123;&#125;'</code></p>
</li>
<li>
<p><code>Date =&gt; toJSON()</code></p>
</li>
<li>
<p><code>Object =&gt; toJSON()</code>，忽略为 <code>undefined, function, symbol</code> 的属性，忽略键为 <code>symbol</code> 的属性。</p>
</li>
</ul>
</li>
<li>
<p>对包含循环引用的对象报错</p>
</li>
</ol>
<p>🍣 代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">JSON</span>.<span class="property">stringify</span> = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> type = <span class="keyword">typeof</span> value</span><br><span class="line">  <span class="keyword">if</span> (type !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// string/number/null/undefined/boolean</span></span><br><span class="line">    <span class="keyword">let</span> res = value</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Number</span>.<span class="built_in">isNaN</span>(value) || value === <span class="title class_">Infinity</span>) &#123;</span><br><span class="line">      result = <span class="string">&#x27;null&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">      type === <span class="string">&#x27;function&#x27;</span> ||</span><br><span class="line">      type === <span class="string">&#x27;undefined&#x27;</span> ||</span><br><span class="line">      type === <span class="string">&#x27;symbol&#x27;</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      res = <span class="string">&#x27;&quot;&#x27;</span> + res + <span class="string">&#x27;&quot;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">String</span>(res)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;null&#x27;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value.<span class="property">toJSON</span> &amp;&amp; <span class="keyword">typeof</span> value.<span class="property">toJSON</span> === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(value.<span class="title function_">toJSON</span>())</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Array</span>) &#123;</span><br><span class="line">      <span class="comment">// 检查是否有非法值</span></span><br><span class="line">      <span class="keyword">let</span> res = []</span><br><span class="line">      value.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          <span class="keyword">typeof</span> item === <span class="string">&#x27;undefined&#x27;</span> ||</span><br><span class="line">          <span class="keyword">typeof</span> item === <span class="string">&#x27;function&#x27;</span> ||</span><br><span class="line">          <span class="keyword">typeof</span> item === <span class="string">&#x27;symbol&#x27;</span></span><br><span class="line">        ) &#123;</span><br><span class="line">          res[index] = <span class="string">&#x27;null&#x27;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          res[index] = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(item)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      res = <span class="string">&#x27;[&#x27;</span> + res + <span class="string">&#x27;]&#x27;</span></span><br><span class="line">      <span class="comment">// 将字符串中的单引号全部换成双引号</span></span><br><span class="line">      <span class="keyword">return</span> res.<span class="title function_">replace</span>(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 普通对象</span></span><br><span class="line">      <span class="keyword">let</span> res = []</span><br><span class="line">      <span class="title class_">Object</span>.<span class="title function_">keys</span>(value).<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, _</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 忽略 key 为 symbol</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">&#x27;symbol&#x27;</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            value[item] !== <span class="literal">undefined</span> &amp;&amp;</span><br><span class="line">            <span class="keyword">typeof</span> value[item] !== <span class="string">&#x27;function&#x27;</span> &amp;&amp;</span><br><span class="line">            <span class="keyword">typeof</span> value[item] !== <span class="string">&#x27;symbol&#x27;</span></span><br><span class="line">          ) &#123;</span><br><span class="line">            res.<span class="title function_">push</span>(<span class="string">&#x27;&quot;&#x27;</span> + item + <span class="string">&#x27;&quot;:&#x27;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(value[item]))</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      res = <span class="string">&#x27;&#123;&#x27;</span> + res + <span class="string">&#x27;&#125;&#x27;</span></span><br><span class="line">      <span class="keyword">return</span> res.<span class="title function_">replace</span>(<span class="regexp">/&#x27;/g</span>, <span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JSON-parse">JSON.parse</h2>
<p>该函数正好和 <code>JSON.stringfy()</code> 倒过来，用于将 JSON 格式的字符串解析成一个对象。</p>
<p>第一种方式，<code>eval</code> 实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 防止 xss 攻击，调用 eval 之前对字符串进行校验</span></span><br><span class="line"><span class="keyword">var</span> rx_one = <span class="regexp">/^[\],:&#123;&#125;\s]*$/</span>;</span><br><span class="line"><span class="keyword">var</span> rx_two = <span class="regexp">/\\(?:[&quot;\\\/bfnrt]|u[0-9a-fA-F]&#123;4&#125;)/g</span>;</span><br><span class="line"><span class="keyword">var</span> rx_three = <span class="regexp">/&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g</span>;</span><br><span class="line"><span class="keyword">var</span> rx_four = <span class="regexp">/(?:^|:|,)(?:\s*\[)+/g</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (</span><br><span class="line">    rx_one.<span class="title function_">test</span>(</span><br><span class="line">        json.<span class="title function_">replace</span>(rx_two, <span class="string">&quot;@&quot;</span>)</span><br><span class="line">            .<span class="title function_">replace</span>(rx_three, <span class="string">&quot;]&quot;</span>)</span><br><span class="line">            .<span class="title function_">replace</span>(rx_four, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    )</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="built_in">eval</span>(<span class="string">&quot;(&quot;</span> +json + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种方式，<code>new Function</code> 实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> json = <span class="string">&#x27;&#123;&quot;name&quot;:&quot;ethan&quot;, &quot;age&quot;:20&#125;&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> obj = (<span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;return &#x27;</span> + json))();</span><br></pre></td></tr></table></figure>
<h2 id="Promise">Promise</h2>
<p>来了，来了，Promise 它来了！</p>
<p>因为篇幅比较长，就新开了<a href="https://blog.ethanloo.cn/post/2021-04-23-Weber/Promise/">一篇文章</a>。</p>
<p>这边手写另一篇中没写到的几个 Promise 的类方法。</p>
<h3 id="Promise-resolve">Promise.resolve</h3>
<p>该方法允许将传入的一个 <code>value</code> 转换为一个 <code>fulfilled</code> 状态的 Promise 对象。</p>
<p>如果传入的 <code>value</code> 本身已经是一个 Promise 对象，就直接返回。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">resolve</span> = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="title class_">Promise</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="title function_">resolve</span>(value))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise-reject">Promise.reject</h3>
<p>该方法会将传入的 <code>reason</code> 实例化为一个 <code>rejected</code> 状态的 Promise 对象，无论这个 <code>reason</code> 是否本身就是一个 Promise。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">reject</span> = <span class="keyword">function</span> (<span class="params">reason</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reason</span>) =&gt;</span> <span class="title function_">reject</span>(reason))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise-all">Promise.all</h3>
<p>传入一个由 Promise 对象构成的数组（严格意义上只要是可迭代对象）：</p>
<ul>
<li>如果都是 <code>fulfilled</code>，就返回一个状态为 <code>fulfilled</code> 的新 Promise 对象，它的值由原数组内所有的值组成。</li>
<li>只要有一个是 <code>rejected</code>，就返回一个状态为 <code>rejected</code> 的新 Promise 对象，它的值是原数组内第一个 <code>rejected</code> 的 Promise 对象的值。</li>
<li>只要有一个是 <code>pending</code>，就返回一个状态为 <code>pending</code> 的新 Promise 对象。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">all</span> = <span class="keyword">function</span> (<span class="params">promiseArr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    promiseArr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">promise, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(promise).<span class="title function_">then</span>(</span><br><span class="line">        <span class="comment">// 如果有一个 pending，就不会 resolve，也不会 reject</span></span><br><span class="line">        <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">          cnt++</span><br><span class="line">          res[i] = val</span><br><span class="line">          <span class="keyword">if</span> (cnt === promiseArr.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="comment">// 都是 fulfilled，返回 res 值数组</span></span><br><span class="line">            <span class="title function_">resolve</span>(res)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 有一个 rejcted，直接返回</span></span><br><span class="line">          <span class="title function_">reject</span>(error)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise-race">Promise.race</h3>
<p>返回一个数组中第一个 <code>fulfilled</code> 或 <code>rejected</code> 的 Promise 实例，并重新包装。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">race</span> = <span class="keyword">function</span> (<span class="params">promiseArr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    promiseArr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">promise</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(promise).<span class="title function_">then</span>(</span><br><span class="line">        <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(value)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">reject</span>(error)</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise-allSettled">Promise.allSettled</h3>
<p>和 <code>all</code> 方法类似，两者区别在于，<code>allSettled</code> 认为无论是 <code>fulfilled</code> 还是 <code>rejected</code> 都是 <code>settled</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">allSettled</span> = <span class="keyword">function</span> (<span class="params">promiseArr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    promiseArr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">promise</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(promise).<span class="title function_">then</span>(</span><br><span class="line">        <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">          res.<span class="title function_">push</span>(&#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="string">&#x27;fulfilled&#x27;</span>,</span><br><span class="line">            value,</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="keyword">if</span> (res.<span class="property">length</span> === promiseArr.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(res)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          res.<span class="title function_">push</span>(&#123;</span><br><span class="line">            <span class="attr">status</span>: <span class="string">&#x27;rejected&#x27;</span>,</span><br><span class="line">            <span class="attr">reason</span>: error,</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="keyword">if</span> (res.<span class="property">length</span> === promiseArr.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(res)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Promise-any">Promise.any</h3>
<p>和 <code>all</code> 也很像，区别在于该方法只要有一个 <code>fulfilled</code> 就会返回 <code>fulfilled</code> 的新 Promise 对象，只有当全部 <code>rejected</code> 的时候，才会返回一个 <code>rejected</code> 的新 Promise 对象，且值为 <code>AggregateError</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">any</span> = <span class="keyword">function</span> (<span class="params">promiseArr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> cnt = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (promiseArr.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">AggregateError</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    promiseArr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">promise</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(promise).<span class="title function_">then</span>(</span><br><span class="line">        <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(value)</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">          cnt++</span><br><span class="line">          <span class="keyword">if</span> (cnt === promiseArr.<span class="property">length</span>) &#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">AggregateError</span>(<span class="string">&#x27;all promises were rejected&#x27;</span>))</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      )</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结">小结</h2>
<p>持续了半个月，陆陆续续终于是吃完了这 36 个 🍣 ，整个手撕过程基本就是跟着<a href="https://juejin.cn/post/6946022649768181774">掘金的文章</a>走的，也有一部分参考的 MDN 文档。在一天吃几个 🍣 的同时，我也重新学习 JavaScript 的语法，看的是一本<a href="https://zh.javascript.info/">在线的教程</a>，目前 JS 语言相关的看得差不多了。</p>
<blockquote>
<p>在这里强推这个在线教程，原型链的部分写得真的超级棒 👍！每一章还有很多配套的练习题（刷题怪的天堂）。</p>
</blockquote>
<p><img src="https://cdn.ethanloo.cn/img/20210424144445.png" alt="image-20210424144437319"></p>
<p>说是查漏补缺可能不太准确，严格意义上就跟我开篇说的一样，这次属于<strong>回炉重造</strong>。收获还是很多的，不仅熟悉了各种 API，也把我之前不太理解的原型链和 event loop 的知识弄清楚了，还有困扰了我很久的 Promise 💫！</p>
<p>不过我就不写自己对这些知识点的理解啦，因为作者已经写的很棒了（译者也很负责！），我的拙见写出来就成了班门弄斧了。</p>
<p>未来学习 JS 的路还很长，stay hungry and eat 🍣！</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年4月刷题日志</title>
    <url>/post/2021-04-01-Algorithm/2021%E5%B9%B44%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p><strong>4.30</strong></p>
<p>刷完题复习一下软件项目管理就去考试了，考完起飞！</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="137-只出现一次的数字-II"><a href="https://leetcode-cn.com/problems/single-number-ii/">137. 只出现一次的数字 II</a></h4>
<p>难度中等580</p>
<p>给你一个整数数组 <code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,2,3,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,0,1,0,1,99]</span><br><span class="line">输出：99</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>不会位运算，直接哈希表计数，一次遍历数组，一次遍历哈希表。</p>
<p><strong>代码</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">singleNumber</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    <span class="keyword">const</span> len = nums.<span class="property">length</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.<span class="title function_">has</span>(num)) &#123;</span><br><span class="line">            map.<span class="title function_">set</span>(num, <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.<span class="title function_">set</span>(num, <span class="number">3</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> key</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4.29</strong></p>
<p>单杀困难题，芜湖🛫！</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="403-青蛙过河"><a href="https://leetcode-cn.com/problems/frog-jump/">403. 青蛙过河</a></h4>
<p>难度困难</p>
<p>一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。</p>
<p>给你石子的位置列表 <code>stones</code>（用单元格序号 <strong>升序</strong> 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。</p>
<p>开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）。</p>
<p>如果青蛙上一步跳跃了 <code>k</code> 个单位，那么它接下来的跳跃距离只能选择为 <code>k - 1</code>、<code>k</code> 或 <code>k + 1</code> 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：stones = [0,1,3,5,6,8,12,17]</span><br><span class="line">输出：true</span><br><span class="line">解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：stones = [0,1,2,3,4,8,9,11]</span><br><span class="line">输出：false</span><br><span class="line">解释：这是因为第 5 和第 6 个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>很朴素的深搜，虽然题目中的数据规模是 2000，没想到记忆化一下就过了。</p>
<p>深搜过程：</p>
<ul>
<li>记录上一次的步长和位置，尝试找到可以跳到的所有位置</li>
<li>然后记录跳的步长，从下一个位置继续搜索</li>
</ul>
<p>记忆化：</p>
<ul>
<li>记录下从第 <code>i</code> 格出发且步长为 <code>j</code> 的可能</li>
<li>避免多次尝试无用解</li>
</ul>
<p><strong>代码</strong></p>
<blockquote>
<p>最近在试着用 TS 写项目，所以就用算法顺手练一下语法（不过似乎在这种函数里和 JS 区分不大）</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">canCross</span>(<span class="params">stones: <span class="built_in">number</span>[]</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> len = stones.<span class="property">length</span></span><br><span class="line">    <span class="comment">// reachables[i] = [3, 4] 表示到达第 i 格的前一步可能是 3 或 4 个单位</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">reachables</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt;&gt; = <span class="keyword">new</span> <span class="title class_">Array</span>(len).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>())</span><br><span class="line">    <span class="keyword">let</span> res = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">idx: <span class="built_in">number</span>, k: <span class="built_in">number</span></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx === len - <span class="number">1</span>) &#123;</span><br><span class="line">            res = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = idx + <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> step = stones[i] - stones[idx]</span><br><span class="line">            <span class="keyword">if</span> (step &gt;= k - <span class="number">1</span> &amp;&amp; step &lt;= k + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (reachables[i].<span class="title function_">indexOf</span>(step) !== -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 说明深搜过当前可能</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                reachables[i].<span class="title function_">push</span>(step)</span><br><span class="line">                <span class="title function_">dfs</span>(i, step)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (step &gt; k + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">dfs</span>(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4.28</strong></p>
<blockquote>
<h4 id="633-平方数之和"><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/">633. 平方数之和</a></h4>
<p>难度中等</p>
<p>给定一个非负整数 <code>c</code> ，你要判断是否存在两个整数 <code>a</code> 和 <code>b</code>，使得 <code>a2 + b2 = c</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：c = 5</span><br><span class="line">输出：true</span><br><span class="line">解释：1 * 1 + 2 * 2 = 5</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：c = 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：c = 4</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：c = 2</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：c = 1</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>两年前做过的第一到老题目了。</p>
<p>双指针，左指针初始值为 <code>0</code>，右指针为 <code>根号c</code>。</p>
<p>偏大右指针左移，偏小左指针右移，直到两个指针重合求出来的和还不满足，说明不存在。</p>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> judgeSquareSum = <span class="keyword">function</span>(<span class="params">c</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>, right = <span class="built_in">parseInt</span>(<span class="title class_">Math</span>.<span class="title function_">sqrt</span>(c))</span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="title class_">Math</span>.<span class="title function_">pow</span>(left, <span class="number">2</span>) + <span class="title class_">Math</span>.<span class="title function_">pow</span>(right, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> (res === c) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (res &gt; c) right--</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (res &lt; c) left++</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4.27</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="938-二叉搜索树的范围和"><a href="https://leetcode-cn.com/problems/range-sum-of-bst/">938. 二叉搜索树的范围和</a></h4>
<p>难度简单</p>
<p>给定二叉搜索树的根结点 <code>root</code>，返回值位于范围 <em><code>[low, high]</code></em> 之间的所有结点的值的和。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/05/bst1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [10,5,15,3,7,null,18], low = 7, high = 15</span><br><span class="line">输出：32</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/05/bst2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>利用二叉搜索树的性质：<code>左 &lt; 根 &lt; 右</code>，在求和的时候进行剪枝。</p>
<ul>
<li>
<p>如果根结点的值比题目给出的最小值 <code>low</code> 还要小，那么就只能往右子树里继续找。</p>
</li>
<li>
<p>如果根结点的值比题目给出的最大值 <code>high</code> 还要大，那么就只能往左子树里继续找。</p>
</li>
<li>
<p>否则，就需要向两边找。</p>
</li>
</ul>
<p>简单是简单，但是自己写完才发现官方题解代码真优雅。</p>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rangeSumBST = <span class="keyword">function</span>(<span class="params">root, low, high</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">val</span> &lt; low) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">rangeSumBST</span>(root.<span class="property">right</span>, low, high)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root.<span class="property">val</span> &gt; high) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">rangeSumBST</span>(root.<span class="property">left</span>, low, high)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root.<span class="property">val</span> + <span class="title function_">rangeSumBST</span>(root.<span class="property">left</span>, low, high) + <span class="title function_">rangeSumBST</span>(root.<span class="property">right</span>, low, high)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4.26</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1011-在-D-天内送达包裹的能力"><a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/">1011. 在 D 天内送达包裹的能力</a></h4>
<p>难度中等236</p>
<p>传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。</p>
<p>传送带上的第 <code>i</code> 个包裹的重量为 <code>weights[i]</code>。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p>
<p>返回能在 <code>D</code> 天内将传送带上的所有包裹送达的船的最低运载能力。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：weights = [1,2,3,4,5,6,7,8,9,10], D = 5</span><br><span class="line">输出：15</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：1, 2, 3, 4, 5</span><br><span class="line">第 2 天：6, 7</span><br><span class="line">第 3 天：8</span><br><span class="line">第 4 天：9</span><br><span class="line">第 5 天：10</span><br><span class="line"></span><br><span class="line">请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 </span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：weights = [3,2,2,4,1,4], D = 3</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：3, 2</span><br><span class="line">第 2 天：2, 4</span><br><span class="line">第 3 天：1, 4</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：weights = [1,2,3,1,1], D = 4</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">第 1 天：1</span><br><span class="line">第 2 天：2</span><br><span class="line">第 3 天：3</span><br><span class="line">第 4 天：1, 1</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>下意识看到 <code>在 * 天内 ** 的能力</code> 还以为是动态规划，看了一遍题目之后发现遍历就行。</p>
<p>遍历完发现超时了，超时完看题解发现要用二分 🤒</p>
<p>题目要返回的是最低运载能力，左边界设为最大包裹的重量，右边界设为所有包裹的总重量。</p>
<p>二分的依据是判断是按照当前的运载能力是否能在 D 天内完成：</p>
<ul>
<li>如果不能，说明运力偏小，左边界右移</li>
<li>如果能，说明运力偏大，右边界左移</li>
</ul>
<p>直到左边界超过右边界时，左边界就是所需的最小运力。</p>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shipWithinDays = <span class="keyword">function</span>(<span class="params">weights, D</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="title class_">Math</span>.<span class="title function_">max</span>(...weights), right = weights.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre + cur)</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right)/ <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">canFinish</span>(weights, mid, D)) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">canFinish</span>(<span class="params">weights, ability, D</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> d = <span class="number">1</span>, cur = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> weight <span class="keyword">of</span> weights) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ability &lt; cur + weight) &#123;</span><br><span class="line">            cur = <span class="number">0</span></span><br><span class="line">            d++</span><br><span class="line">            <span class="keyword">if</span> (d &gt; D) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur += weight</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.25</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="897-递增顺序搜索树"><a href="https://leetcode-cn.com/problems/increasing-order-search-tree/">897. 递增顺序搜索树</a></h4>
<p>难度简单166</p>
<p>给你一棵二叉搜索树，请你 <strong>按中序遍历</strong> 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/17/ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [5,3,6,2,4,null,8,1,null,null,null,7,9]</span><br><span class="line">输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/17/ex2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [5,1,7]</span><br><span class="line">输出：[1,null,5,null,7]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>整体思路就是中序遍历，不过有两种建树方式。</p>
<ol>
<li>先中序遍历一遍原树，然后把遍历到的结点值逐个存入数组，最终遍历完一棵树的数组就是一个递增数列。根据该数组，逐个新建结点，生成新树。</li>
<li>在中序遍历的同时改变原树上结点的指向，原地修改。</li>
</ol>
<p><strong>代码</strong></p>
<p>两种思路都比较简单，这里就贴个第二种。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> increasingBST = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">inOrder</span> = (<span class="params">node</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">inOrder</span>(node.<span class="property">left</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历的同时直接修改结点指向</span></span><br><span class="line">        pre.<span class="property">right</span> = node</span><br><span class="line">        node.<span class="property">left</span> = <span class="literal">null</span></span><br><span class="line">        pre = node</span><br><span class="line"></span><br><span class="line">        <span class="title function_">inOrder</span>(node.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> dummy = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> pre = dummy    </span><br><span class="line">    <span class="title function_">inOrder</span>(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="property">right</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4.24</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="377-组合总和-Ⅳ"><a href="https://leetcode-cn.com/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h4>
<p>难度中等</p>
<p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p>
<p>题目数据保证答案符合 32 位整数范围。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3], target = 4</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [9], target = 3</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 200</code></li>
<li><code>1 &lt;= nums[i] &lt;= 1000</code></li>
<li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li>
<li><code>1 &lt;= target &lt;= 1000</code></li>
</ul>
</blockquote>
<p><strong>思路1</strong></p>
<p>第一想法 DFS，写出来就超时了。</p>
<p>因为像是 <code>nums = [2, 1, 3], target = 35</code> 的情况，递归实在太久了。</p>
<p><strong>代码1</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> combinationSum4 = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">arr, sum</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> diff = target - sum</span><br><span class="line">        <span class="keyword">if</span> (diff === <span class="number">0</span>) &#123;</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        nums.<span class="title function_">map</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= diff) &#123;</span><br><span class="line">                arr.<span class="title function_">push</span>(num)</span><br><span class="line">                <span class="title function_">dfs</span>(arr, sum + num)</span><br><span class="line">                arr.<span class="title function_">pop</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfs</span>([], <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>思路2</strong></p>
<p>又又又是动态规划，本质上是一个完全背包问题。</p>
<blockquote>
<p>这篇<a href="https://leetcode-cn.com/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/">题解</a>针不戳。</p>
</blockquote>
<ul>
<li>DP table：开辟一个长度是 <code>target + 1</code> 的数组，<code>dp[i]</code> 表示的是和为 <code>i</code> 的组合数。</li>
<li>Base case：<code>dp[0] = 1</code>，表示和为 0 的组合只有一种，就是空数组。</li>
<li>动态转移方程
<ul>
<li>从 <code>dp[1]</code> 求到 <code>dp[target]</code></li>
<li>每次算 <code>dp[i]</code> 的时候，遍历一遍我们手头的数组 <code>nums</code></li>
<li>若 <code>nums[j] &lt;= i</code>，说明当前的这个数可以与之前某个的组合相结合，因此令 <code>dp[i] += dp[nums[j] - i]</code></li>
</ul>
</li>
</ul>
<p><strong>代码2</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> combinationSum4 = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(target + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// 和为 1 的组合是 []</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">        nums.<span class="title function_">map</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= i) &#123;</span><br><span class="line">                dp[i] += dp[i-num]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4.23</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="368-最大整除子集"><a href="https://leetcode-cn.com/problems/largest-divisible-subset/">368. 最大整除子集</a></h4>
<p>难度中等</p>
<p>给你一个由 <strong>无重复</strong> 正整数组成的集合 <code>nums</code> ，请你找出并返回其中最大的整除子集 <code>answer</code> ，子集中每一元素对 <code>(answer[i], answer[j])</code> 都应当满足：</p>
<ul>
<li><code>answer[i] % answer[j] == 0</code> ，或</li>
<li><code>answer[j] % answer[i] == 0</code></li>
</ul>
<p>如果存在多个有效解子集，返回其中任何一个均可。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[1,2]</span><br><span class="line">解释：[1,3] 也会被视为正确答案。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,4,8]</span><br><span class="line">输出：[1,2,4,8]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>初看题目要求子集，下意识是想去用 DFS 的，但是发现数组规模是 1000，而且 DFS 似乎也不太好写，求助于官方题解后得知是用 DP。</p>
<p>之所以是 DP，是因为整除的性质：</p>
<ul>
<li>对于一个给定的整除子集而言，如果另外有一个数是该子集中最大数的整数倍，那么把这个数加入子集也是合法的。</li>
</ul>
<p>由于有这条性质，所以数字的大小和我们的遍历应该是关系的，先对数组排序可以简化后续步骤。</p>
<p>同时基于这条性质，也可以联想到 DP table 的定义和状态转移方程。</p>
<ul>
<li>
<p>假设 <code>dp[i]</code> 表示在 <code>nums[0:i]</code> 子数组中包含 <code>nums[i]</code> 在内的最大整除子集数。</p>
</li>
<li>
<p>我们需要遍历比当前数字小的所有数字，根据上面的整除性质，可以很容易得到 <code>dp[i]</code></p>
</li>
</ul>
<p>Base case：由于数字自身整除于自身，所以 <code>dp[i]</code> 应该初始化为 1。</p>
<p>在进行动规后，我们就获得了一个 <code>dp</code> 数组，例如题目中的 <code>nums = [1, 2, 3], dp = [1, 2, 2]</code>。</p>
<p>但是题目要求的并不是最大整除子集的规模，而是子集本身，所以我们现在可以根据子集数求子集。</p>
<p>首先确定最大子集的规模 <code>maxSize</code>，通过倒序遍历 <code>dp[i]</code> ，找到 <code>dp[i] = maxSize</code> 的 <code>nums[i]</code>，加入到结果自己。令 <code>maxSize--</code>，继续往前找，找到能整除上一个数且 <code>dp[i] = maxSize</code> 的数。</p>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> largestDivisibleSubset = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = nums.<span class="property">length</span></span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">x,y</span>) =&gt;</span> x-y)</span><br><span class="line">    <span class="comment">// dp[i] 表示在 nums[0:i] 子数组中包含 nums[i] 在内的最大整除子集数</span></span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">1</span>) </span><br><span class="line">    <span class="comment">// 动态规划求解整除子集数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] % nums[j] === <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 倒序遍历求有效解子集</span></span><br><span class="line">    res = []</span><br><span class="line">    maxSize = <span class="title class_">Math</span>.<span class="title function_">max</span>(...dp)</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] === maxSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre == <span class="literal">null</span> || nums[pre] % nums[i] === <span class="number">0</span>) &#123;</span><br><span class="line">                pre = i</span><br><span class="line">                res.<span class="title function_">push</span>(nums[i])</span><br><span class="line">                maxSize--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4.22</strong></p>
<p>今日没追求，暴力解困难</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="363-矩形区域不超过-K-的最大数值和"><a href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/">363. 矩形区域不超过 K 的最大数值和</a></h4>
<p>难度困难</p>
<p>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code> 和一个整数 <code>k</code> ，找出并返回矩阵内部矩形区域的不超过 <code>k</code> 的最大数值和。</p>
<p>题目数据保证总会存在一个数值和不超过 <code>k</code> 的矩形区域。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/03/18/sum-grid.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,0,1],[0,-2,3]], k = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：蓝色边框圈出来的矩形区域 [[0, 1], [-2, 3]] 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[2,2,-1]], k = 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>首先需要将一维前缀和数组扩展到二维，然后遍历整个二维数组的所有子数组，找出小于 <code>k</code> 的最大和。</p>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSumSubmatrix = <span class="keyword">function</span>(<span class="params">matrix, k</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> m = matrix.<span class="property">length</span>, n = matrix[<span class="number">0</span>].<span class="property">length</span></span><br><span class="line">    <span class="keyword">const</span> sums = <span class="keyword">new</span> <span class="title class_">Array</span>(m + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>))</span><br><span class="line">    <span class="comment">// 先计算二维矩阵前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            sums[i + <span class="number">1</span>][j + <span class="number">1</span>] = sums[i][j + <span class="number">1</span>] + sums[i + <span class="number">1</span>][j] - sums[i][j] + matrix[i][j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = -<span class="title class_">Infinity</span></span><br><span class="line">    <span class="comment">// 枚举所有子矩阵之和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> p = i; p &lt; m; p++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> q = j; q &lt; n; q++) &#123;</span><br><span class="line">                    <span class="comment">// (i,j) 是左上角，(p,q) 是右下角</span></span><br><span class="line">                    <span class="keyword">let</span> cur = sums[p+<span class="number">1</span>][q+<span class="number">1</span>] - sums[i][q+<span class="number">1</span>] - sums[p+<span class="number">1</span>][j] + sums[i][j]</span><br><span class="line">                    <span class="keyword">if</span> (cur &lt;= k) &#123;</span><br><span class="line">                        res = <span class="title class_">Math</span>.<span class="title function_">max</span>(res, cur)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4.21</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="91-解码方法"><a href="https://leetcode-cn.com/problems/decode-ways/">91. 解码方法</a></h4>
<p>难度中等</p>
<p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;A&#x27; -&gt; 1</span><br><span class="line">&#x27;B&#x27; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#x27;Z&#x27; -&gt; 26</span><br></pre></td></tr></table></figure>
<p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code> 可以映射为：</p>
<ul>
<li><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1 1 10 6)</code></li>
<li><code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11 10 6)</code></li>
</ul>
<p>注意，消息不能分组为 <code>(1 11 06)</code> ，因为 <code>&quot;06&quot;</code> 不能映射为 <code>&quot;F&quot;</code> ，这是由于 <code>&quot;6&quot;</code> 和 <code>&quot;06&quot;</code> 在映射中并不等价。</p>
<p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p>
<p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;12&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路1</strong></p>
<p>利用 BFS，尝试遍历进行所有可能性的。</p>
<p>每个位置可以有两种向下延申的情况：</p>
<ul>
<li>往后扩展一位</li>
<li>往后扩展两位</li>
</ul>
<blockquote>
<p>会进行大量的重复计算，导致这个解法超时</p>
</blockquote>
<p><strong>代码1</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numDecodings = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> n = s.<span class="property">length</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">bfs</span> = (<span class="params">index</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= n) &#123;</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">parseInt</span>(s[index]) &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="title function_">bfs</span>(index + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> num = <span class="built_in">parseInt</span>(s.<span class="title function_">slice</span>(index, index+<span class="number">2</span>))</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= <span class="number">10</span> &amp;&amp; num &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">                <span class="title function_">bfs</span>(index + <span class="number">2</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">bfs</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>思路2</strong></p>
<p>动态规划，利用当前数和前一个数的大小，迭代计算。</p>
<ul>
<li>DP table：<code>dp = new Array(n+1).fill(0)</code>，数组长度为 <code>字符串长度+1</code>，<code>dp[i]</code> 表示 <code>s[0:i]</code> 的解码方法数。</li>
<li>Base case：<code>dp[0] = 1</code>，表示我们假设空字符串有一种解码方式。</li>
<li>动态转移方程：从 <code>i = 1 to n</code>，当前的字符为 <code>s[i-1]</code>，前一个字符为 <code>s[i-2]</code>
<ul>
<li>如果当前的字符本身不为0，说明他自己就可以进行解码，因此 <code>s[0:i]</code> 的解码方式和 <code>s[0:i-1]</code> 的解码方式数相同。</li>
<li>如果当前的字符可以和前一个字符组成一个 <code>10-26</code> 的数，那么此时 <code>s[0:i]</code> 的解码方式和 <code>s[0:i-2]</code> 的解码方式数相同。</li>
</ul>
</li>
</ul>
<p><strong>代码2</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numDecodings = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = s.<span class="property">length</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>) <span class="comment">// dp[i] 表示 s[0:i] 的解码方法</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// 默认空字符串有一种编码方式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> cur = <span class="built_in">parseInt</span>(s[i-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">let</span> pre = <span class="built_in">parseInt</span>(s[i-<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">if</span> (cur &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i] += dp[i-<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; pre !== <span class="number">0</span> &amp;&amp; cur + <span class="number">10</span> * pre &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">            dp[i] += dp[i-<span class="number">2</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4.20</strong></p>
<p>KMP？？？告辞</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="28-实现-strStr"><a href="https://leetcode-cn.com/problems/implement-strstr/">28. 实现 strStr()</a></h4>
<p>难度简单</p>
<p>实现 <a href="https://baike.baidu.com/item/strstr/811469">strStr()</a> 函数。</p>
<p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 <code>-1</code> 。</p>
<p><strong>说明：</strong></p>
<p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p>
<p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与 C 语言的 <a href="https://baike.baidu.com/item/strstr/811469">strstr()</a> 以及 Java 的 <a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)">indexOf()</a> 定义相符。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：haystack = &quot;&quot;, needle = &quot;&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>不搞竞赛，暴力就完事儿了。</p>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> strStr = <span class="keyword">function</span>(<span class="params">haystack, needle</span>) &#123;</span><br><span class="line">    <span class="comment">// 滑动窗口</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> m = haystack.<span class="property">length</span></span><br><span class="line">    <span class="keyword">let</span> n = needle.<span class="property">length</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; m &amp;&amp; i &lt;= j) &#123;</span><br><span class="line">        <span class="comment">// 根据两个指针的位置确定要对比的目标字符的位置</span></span><br><span class="line">        <span class="keyword">let</span> idx = j - i</span><br><span class="line">        <span class="keyword">if</span> (needle[idx] === haystack[j]) &#123;</span><br><span class="line">            j++</span><br><span class="line">            <span class="keyword">if</span> (needle[<span class="number">0</span>] !== haystack[i]) &#123;</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++</span><br><span class="line">            j = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j - i === n) &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4.19</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="27-移除元素"><a href="https://leetcode-cn.com/problems/remove-element/">27. 移除元素</a></h4>
<p>难度简单</p>
<p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong>。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>和昨天类似，也是双指针，直接上代码。</p>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> removeElement = <span class="keyword">function</span>(<span class="params">nums, val</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> idx = <span class="number">0</span></span><br><span class="line">    nums.<span class="title function_">forEach</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num != val) &#123;</span><br><span class="line">            nums[idx++] = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> idx</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4.18</strong></p>
<p>蓝桥杯考完了，10 道做出来 7 道 🤒 也不知道对不对。</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="26-删除有序数组中的重复项"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h4>
<p>难度简单</p>
<p>给你一个有序数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>说明:</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢?</p>
<p>请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：2, nums = [1,2]</span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>经典老题了，双指针，把非重复的数字直接放到数组前部即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != nums[i-<span class="number">1</span>]:</span><br><span class="line">                nums[cnt] = nums[i]</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
<p><strong>4.17</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="220-存在重复元素-III"><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/">220. 存在重复元素 III</a></h4>
<p>难度中等</p>
<p>给你一个整数数组 <code>nums</code> 和两个整数 <code>k</code> 和 <code>t</code> 。请你判断是否存在两个下标 <code>i</code> 和 <code>j</code>，使得 <code>abs(nums[i] - nums[j]) &lt;= t</code> ，同时又满足 <code>abs(i - j) &lt;= k</code> 。</p>
<p>如果存在则返回 <code>true</code>，不存在返回 <code>false</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,1], k = 3, t = 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,0,1,1], k = 1, t = 2</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,5,9,1,5,9], k = 2, t = 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>因为题目中对两个数字的距离有规定，很容易想到的是双指针（滑动窗口）的思路。</p>
<ul>
<li>开辟一个长度为 <code>k + 1</code> 的滑动窗口，从数组左边滑到右边</li>
<li>滑动的过程中，维护一个有序集合来存储当前窗口内的数</li>
<li>边滑动，边判断这个有序集合中是否存在满足条件要求的差值 <code>&lt;= t</code> 的两个数</li>
</ul>
<blockquote>
<p>然而 Python 原生库不提供有序集合，于是放弃了这个方法</p>
</blockquote>
<p>另一种思路是参考的官方题解，利用桶排序的思想。</p>
<ul>
<li>
<p>设我们当前遍历的数为 <code>x</code>，题目中允许的最大差值 <code>t</code></p>
</li>
<li>
<p>所以我们的思想是每隔 <code>t+1</code> 的范围划分一个桶，把每个数放到对应的桶中</p>
</li>
<li>
<p>公式：<code>x = (t + 1) * a + b</code>，其中 <code>a</code> 就是 <code>x</code> 的桶序号</p>
</li>
<li>
<p>边遍历数组，边判断当前数字的前一个桶和后一个桶以及自己桶里有没有满足的数字</p>
</li>
<li>
<p>同时，保证桶的个数小于等于 <code>k</code></p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyAlmostDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span>, t: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 要求两个数的差的绝对值&lt;=t，位置差&lt;=k</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 把每个数 x 存到对应的桶里</span></span><br><span class="line">        <span class="comment"># x = (t + 1) * a + b，这里的 a 表示的就是 x 应该放入的桶序号</span></span><br><span class="line">        dic = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getId</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> x // (t + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> (x + <span class="number">1</span>) // (t + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            numId = getId(num)</span><br><span class="line">            <span class="keyword">if</span> (numId - <span class="number">1</span>) <span class="keyword">in</span> dic <span class="keyword">and</span> <span class="built_in">abs</span>(num - dic[numId - <span class="number">1</span>]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> (numId + <span class="number">1</span>) <span class="keyword">in</span> dic <span class="keyword">and</span> <span class="built_in">abs</span>(num - dic[numId + <span class="number">1</span>]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> numId <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            dic[numId] = num</span><br><span class="line">            <span class="keyword">if</span> i &gt;= k:</span><br><span class="line">                <span class="keyword">del</span> dic[getId(nums[i-k])]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><strong>4.16</strong></p>
<p>动规周他来了！</p>
<blockquote>
<p>因为周日要参加蓝桥杯，所以又换回 python 写代码了。</p>
</blockquote>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="87-扰乱字符串"><a href="https://leetcode-cn.com/problems/scramble-string/">87. 扰乱字符串</a></h4>
<p>难度困难</p>
<p>使用下面描述的算法可以扰乱字符串 <code>s</code> 得到字符串 <code>t</code> ：</p>
<ol>
<li>如果字符串的长度为 1 ，算法停止</li>
<li>如果字符串的长度 &gt; 1 ，执行下述步骤：
<ul>
<li>在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 <code>s</code> ，则可以将其分成两个子字符串 <code>x</code> 和 <code>y</code> ，且满足 <code>s = x + y</code> 。</li>
<li><strong>随机</strong> 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，<code>s</code> 可能是 <code>s = x + y</code> 或者 <code>s = y + x</code> 。</li>
<li>在 <code>x</code> 和 <code>y</code> 这两个子字符串上继续从步骤 1 开始递归执行此算法。</li>
</ul>
</li>
</ol>
<p>给你两个 <strong>长度相等</strong> 的字符串 <code>s1</code> 和 <code>s2</code>，判断 <code>s2</code> 是否是 <code>s1</code> 的扰乱字符串。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s1 = &quot;great&quot;, s2 = &quot;rgeat&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：s1 上可能发生的一种情形是：</span><br><span class="line">&quot;great&quot; --&gt; &quot;gr/eat&quot; // 在一个随机下标处分割得到两个子字符串</span><br><span class="line">&quot;gr/eat&quot; --&gt; &quot;gr/eat&quot; // 随机决定：「保持这两个子字符串的顺序不变」</span><br><span class="line">&quot;gr/eat&quot; --&gt; &quot;g/r / e/at&quot; // 在子字符串上递归执行此算法。两个子字符串分别在随机下标处进行一轮分割</span><br><span class="line">&quot;g/r / e/at&quot; --&gt; &quot;r/g / e/at&quot; // 随机决定：第一组「交换两个子字符串」，第二组「保持这两个子字符串的顺序不变」</span><br><span class="line">&quot;r/g / e/at&quot; --&gt; &quot;r/g / e/ a/t&quot; // 继续递归执行此算法，将 &quot;at&quot; 分割得到 &quot;a/t&quot;</span><br><span class="line">&quot;r/g / e/ a/t&quot; --&gt; &quot;r/g / e/ a/t&quot; // 随机决定：「保持这两个子字符串的顺序不变」</span><br><span class="line">算法终止，结果字符串和 s2 相同，都是 &quot;rgeat&quot;</span><br><span class="line">这是一种能够扰乱 s1 得到 s2 的情形，可以认为 s2 是 s1 的扰乱字符串，返回 true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s1 = &quot;abcde&quot;, s2 = &quot;caebd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s1 = &quot;a&quot;, s2 = &quot;a&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>s1.length == s2.length</code></li>
<li><code>1 &lt;= s1.length &lt;= 30</code></li>
<li><code>s1</code> 和 <code>s2</code> 由小写英文字母组成</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>动规困难题，最终还是参考了题解。</p>
<p>先确定动规的几个关键要素：</p>
<ul>
<li>
<p>DP table</p>
<ul>
<li>动规的核心思想就是 <code>大化小，小化了</code>，本题的最终目标是要知道 <code>s1</code> 能否被扰乱成 <code>s2</code>，在什么子条件下我们会知道最终答案呢？</li>
<li>如果我们把 <code>s1</code> 划分成 <code>s11 + s12</code>，<code>s2</code> 划分成 <code>s21 + s22</code> ，若满足以下条件之一，我们可以确定 <code>s1</code> 能被扰乱成 <code>s2</code>
<ul>
<li><code>s11</code> 可以被扰乱成 <code>s21</code>，<code>s12</code> 可以被扰乱成 <code>s22</code></li>
<li><code>s11</code> 可以被扰乱成 <code>s22</code>，<code>s12</code> 可以被扰乱成 <code>s21</code></li>
</ul>
</li>
<li>由于被扰乱的字符串必定是等长的，我们只需要确定起始位置和字符串长度来表示状态。</li>
<li><code>dp[i][j][l]</code> 的含义：<code>s1[i:i+l]</code> 能否扰乱获得 <code>s2[j:j+l]</code></li>
</ul>
</li>
<li>
<p>Base case</p>
<ul>
<li>每个相同的字符必定是可扰乱的</li>
</ul>
</li>
<li>
<p>状态转移方程</p>
<ul>
<li>在之前定义 DP table 的时候，其实就已经写出了状态转移的思想</li>
<li>枚举 <code>k in range(1, l)</code>，表示切割的位置，下面两者之一为真则 <code>dp[i][j][l]</code> 为真
<ul>
<li><code>dp[i][j][k] and dp[i + k][j + k][l - k]</code></li>
<li><code>dp[i][j + l - k][k] and dp[i + k][j][l - k]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isScramble</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># dp[i][j][l]的含义：s1[i:i+l] 能否扰乱获得 s2[j:j+l]</span></span><br><span class="line">        n = <span class="built_in">len</span>(s1)</span><br><span class="line">        dp = [[[<span class="literal">False</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> s1[i] == s2[j]:</span><br><span class="line">                    dp[i][j][<span class="number">1</span>] = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 枚举划分长度</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - l + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 枚举s1起始位置</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n - l + <span class="number">1</span>):</span><br><span class="line">                    <span class="comment"># 枚举s2起始位置</span></span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, l):</span><br><span class="line">                        <span class="comment"># 枚举分割位置</span></span><br><span class="line">                        <span class="keyword">if</span> dp[i][j][k] <span class="keyword">and</span> dp[i + k][j + k][l - k]:</span><br><span class="line">                            <span class="comment"># 不交换 </span></span><br><span class="line">                            dp[i][j][l] = <span class="literal">True</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">if</span> dp[i][j + l - k][k] <span class="keyword">and</span> dp[i + k][j][l - k]:</span><br><span class="line">                            dp[i][j][l] = <span class="literal">True</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>][n]</span><br></pre></td></tr></table></figure>
<p><strong>4.15</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="213-打家劫舍-II"><a href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II</a></h4>
<p>难度中等</p>
<p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p>
<p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，能够偷窃到的最高金额。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 1000</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>经典动规，和传统的打家劫舍的差别在于不能同时偷头尾两家，所以将头尾拆开考虑。</p>
<p>第一次遍历<code>[0, n-2]</code>，第二次遍历 <code>[1, n-1]</code>，找出最大值。</p>
<p>先定义 <code>dp table</code> :  <code>dp[i]</code> 表示从第 <code>0</code> 家开始，打劫到第 <code>i</code> 家时，所获得的最大金额。</p>
<p>动态转移方程：<code>dp[i] = max(dp[i-2] + nums[i], dp[i-1])</code> ，<code>偷 i-2 和 i</code> 或者 <code>偷 i-1</code>，两者选最大值。</p>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rob = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = nums.<span class="property">length</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="number">0</span>, cur = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 拆环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> tmp = <span class="title class_">Math</span>.<span class="title function_">max</span>(pre+nums[i], cur)</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = tmp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = cur</span><br><span class="line">    pre = <span class="number">0</span></span><br><span class="line">    cur = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> tmp = <span class="title class_">Math</span>.<span class="title function_">max</span>(pre+nums[i], cur)</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = tmp</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="title class_">Math</span>.<span class="title function_">max</span>(cur, res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4.14</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="208-实现-Trie-前缀树"><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h4>
<p>难度中等</p>
<p><strong><a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin">Trie</a></strong>（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p>
<p>请你实现 Trie 类：</p>
<ul>
<li><code>Trie()</code> 初始化前缀树对象。</li>
<li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li>
<li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li>
<li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class="line">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class="line">输出</span><br><span class="line">[null, null, true, false, true, null, true]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Trie trie = new Trie();</span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   // 返回 True</span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 False</span><br><span class="line">trie.startsWith(&quot;app&quot;); // 返回 True</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 True</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li>
<li><code>word</code> 和 <code>prefix</code> 仅由小写英文字母组成</li>
<li><code>insert</code>、<code>search</code> 和 <code>startsWith</code> 调用次数 <strong>总计</strong> 不超过 <code>3 * 104</code> 次</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>数据结构题，能理解这棵树长什么样子就很容易画出来。</p>
<p>一般无非两种思路，一种是定义 <code>TrieNode(字典树节点)</code>，另一种是直接用哈希表（数组）。</p>
<p>JS 的语法就有点微妙，所以参考官方题解写的这个代码一开始有些费解。</p>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Trie</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Trie</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">insert</span> = <span class="keyword">function</span>(<span class="params">word</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">root</span></span><br><span class="line">    <span class="keyword">for</span> (ch <span class="keyword">of</span> word) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node[ch]) &#123;</span><br><span class="line">            node[ch] = &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node[ch]</span><br><span class="line">    &#125;</span><br><span class="line">    node.<span class="property">isEnd</span> = <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Trie</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">searchPrefix</span> = <span class="keyword">function</span>(<span class="params">preix</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">root</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> ch <span class="keyword">of</span> preix) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node[ch])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node[ch]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Trie</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">search</span> = <span class="keyword">function</span>(<span class="params">word</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="title function_">searchPrefix</span>(word)</span><br><span class="line">    <span class="keyword">return</span> node !== <span class="literal">undefined</span> &amp;&amp; node.<span class="property">isEnd</span> !== <span class="literal">undefined</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Trie</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">startsWith</span> = <span class="keyword">function</span>(<span class="params">prefix</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">searchPrefix</span>(prefix)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4.13</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="783-二叉搜索树节点最小距离"><a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/">783. 二叉搜索树节点最小距离</a></h4>
<p>难度简单1</p>
<p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [4,2,6,1,3]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,0,48,null,null,12,49]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点数目在范围 <code>[2, 100]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 105</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>利用二叉搜索树的特性，<code>node.left.val &lt; node.val &lt; node.right.val</code>，通过中序遍历一棵二叉搜索树就可以得到一个递增的序列。</p>
<p>有了这个递增序列之后，就很容易寻找任意两个结点的最小差值了。</p>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> minDiffInBST = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> nodes = []</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">inorder</span> = (<span class="params">node</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span></span><br><span class="line">        <span class="title function_">inorder</span>(node.<span class="property">left</span>)</span><br><span class="line">        nodes.<span class="title function_">push</span>(node.<span class="property">val</span>)</span><br><span class="line">        <span class="title function_">inorder</span>(node.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">inorder</span>(root)</span><br><span class="line">    <span class="keyword">let</span> res = <span class="title class_">Infinity</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nodes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        res = <span class="title class_">Math</span>.<span class="title function_">min</span>(res, nodes[i]-nodes[i-<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4.12</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="179-最大数"><a href="https://leetcode-cn.com/problems/largest-number/">179. 最大数</a></h4>
<p>难度中等</p>
<p>给定一组非负整数 <code>nums</code>，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p>
<p>**注意：**输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [10,2]</span><br><span class="line">输出：&quot;210&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,30,34,5,9]</span><br><span class="line">输出：&quot;9534330&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：&quot;1&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [10]</span><br><span class="line">输出：&quot;10&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 100</code></li>
<li><code>0 &lt;= nums[i] &lt;= 109</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>有脑筋急转弯内味了，参考了题解。</p>
<p>首先要知道肯定需要对 <code>nums</code> 排序，那么要确定 <code>x</code> 和 <code>y</code> 哪个应该放到更前面，我们可以直接通过以下两个字符串的值来确定</p>
<ul>
<li><code>x + y</code></li>
<li><code>y + x</code></li>
</ul>
<blockquote>
<p>注意，这边做的都是字符串的拼接，不是单纯加减</p>
</blockquote>
<p>如果前者大，那么 <code>x</code> 就放前面，否则放后面。</p>
<p>对排完序之后的数组进行拼接即可得到最终答案。</p>
<p>当然，也有可能出现数组全为 0 的情况，需要额外判断。</p>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> largestNumber = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> s1 = <span class="string">`<span class="subst">$&#123;x&#125;</span><span class="subst">$&#123;y&#125;</span>`</span></span><br><span class="line">        <span class="keyword">let</span> s2 = <span class="string">`<span class="subst">$&#123;y&#125;</span><span class="subst">$&#123;x&#125;</span>`</span></span><br><span class="line">        <span class="keyword">return</span> s2 - s1</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>] === <span class="number">0</span> ? <span class="string">&#x27;0&#x27;</span> : nums.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4.11</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="264-丑数-II"><a href="https://leetcode-cn.com/problems/ugly-number-ii/">264. 丑数 II</a></h4>
<p>难度中等</p>
<p>给你一个整数 <code>n</code> ，请你找出并返回第 <code>n</code> 个 <strong>丑数</strong> 。</p>
<p><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和/或 <code>5</code> 的正整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 10</span><br><span class="line">输出：12</span><br><span class="line">解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：1</span><br><span class="line">解释：1 通常被视为丑数。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 1690</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<ol>
<li>
<p>最小堆：先存后排序</p>
<p>一开始最小堆里存放的是 1，然后迭代 <code>n-1</code> 次，每次从最小堆中取出最小数，放回最小数的 2，3，5 倍。</p>
<p>迭代完之后，堆顶的数，就是第 <code>n</code> 小的数（因为前 <code>n-1</code> 个数已经被用掉了）</p>
</li>
<li>
<p>三指针：先排序后存</p>
<p>初始化一个 0 数组，长度为 <code>n</code>，第一个元素初始化为 <code>0</code></p>
<p>用三个指针 <code>idx1, idx2, idx3</code> 分别表示当前应该被乘 <code>2,3,5</code> 的基数的位置，一开始都初始为0</p>
<p>迭代 <code>n-1</code> 次，每次迭代中找到当前能添加的最小数，然后放到对应位置。</p>
</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最小堆</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nthUglyNumber</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums = [<span class="number">1</span>]</span><br><span class="line">        nums_set = <span class="built_in">set</span>()</span><br><span class="line">        nums_set.add(<span class="number">1</span>)</span><br><span class="line">        factors = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">            cur = heapq.heappop(nums)</span><br><span class="line">            <span class="keyword">for</span> factor <span class="keyword">in</span> factors:</span><br><span class="line">                <span class="keyword">if</span> (nxt := cur * factor) <span class="keyword">not</span> <span class="keyword">in</span> nums_set:</span><br><span class="line">                    nums_set.add(nxt)</span><br><span class="line">                    heapq.heappush(nums, nxt)</span><br><span class="line">        <span class="keyword">return</span> heapq.heappop(nums)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三指针</span></span><br><span class="line"><span class="keyword">var</span> nthUglyNumber = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> nums = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> idx1 = <span class="number">0</span>, idx2 = <span class="number">0</span>, idx3 = <span class="number">0</span></span><br><span class="line">    nums[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> cur = <span class="title class_">Math</span>.<span class="title function_">min</span>(nums[idx1] * <span class="number">2</span>, nums[idx2] * <span class="number">3</span>, nums[idx3] * <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">if</span> (nums[idx1] * <span class="number">2</span> === cur) &#123;</span><br><span class="line">            idx1++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[idx2] * <span class="number">3</span> === cur) &#123;</span><br><span class="line">            idx2++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[idx3] * <span class="number">5</span> === cur) &#123;</span><br><span class="line">            idx3++</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i] = cur</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[n-<span class="number">1</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4.10</strong></p>
<p>语法题</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="263-丑数"><a href="https://leetcode-cn.com/problems/ugly-number/">263. 丑数</a></h4>
<p>难度简单</p>
<p>给你一个整数 <code>n</code> ，请你判断 <code>n</code> 是否为 <strong>丑数</strong> 。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和/或 <code>5</code> 的正整数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 6</span><br><span class="line">输出：true</span><br><span class="line">解释：6 = 2 × 3</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isUgly = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">3</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">5</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4.8</strong></p>
<p>继续二分</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="153-寻找旋转排序数组中的最小值"><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></h4>
<p>难度中等</p>
<p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p>
<ul>
<li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li>
<li>若旋转 <code>4</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li>
</ul>
<p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p>
<p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2]</span><br><span class="line">输出：0</span><br><span class="line">解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [11,13,15,17]</span><br><span class="line">输出：11</span><br><span class="line">解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 5000</code></li>
<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>
<li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li>
<li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>通过二分来不断约束，找到最小数的位置。</p>
<p>之所以只需要判断 <code>nums[mid]</code> 和 <code>nums[right]</code> 的原因是：</p>
<ul>
<li>
<p>如果中间比右边大，说明最小数必定在右边数组中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	中</span><br><span class="line">左</span><br><span class="line">    	右</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果中间比右边小，那么最小数必定在左边数组中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">左</span><br><span class="line">		右</span><br><span class="line">	中</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>参考：<a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/">leetcode 题解</a></p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> findMin = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4.7</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="81-搜索旋转排序数组-II"><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">81. 搜索旋转排序数组 II</a></h4>
<p>难度中等</p>
<p>已知存在一个按非降序排列的整数数组 <code>nums</code> ，数组中的值不必互不相同。</p>
<p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong> ，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,4,4,5,6,6,7]</code> 在下标 <code>5</code> 处经旋转后可能变为 <code>[4,5,6,6,7,0,1,2,4,4]</code> 。</p>
<p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,5,6,0,0,1,2], target = 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,5,6,0,0,1,2], target = 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 5000</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li>
<li><code>-104 &lt;= target &lt;= 104</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>菜鸡写不出二分，只能官方题解了。</p>
<p>先说基础的思路：</p>
<ul>
<li>普通的二分可以直接搜索有序数组，但是题目中给的是翻转后的数组，所以只能保证数组部分有序</li>
<li>但是我们确实只需要部分有序就能够对二分的范围进行约束</li>
<li>假设当前的左指针为 <code>left</code>，右指针为 <code>right</code>，中指针 <code>mid = (left + right) // 2</code>，且此时的 <code>nums[mid] != target</code></li>
<li>此时 <code>nums[left:mid]</code> 和 <code>nums[mid:right]</code> 其中之一必定是有序的
<ul>
<li>如果 <code>nums[left] &lt;= nums[mid]</code> ，就是左边有序</li>
<li>如果 <code>nums[mid] &lt;= nums[right]</code>，就是右边有序</li>
</ul>
</li>
<li>如果此时左边有序
<ul>
<li>若 <code>nums[left] &lt;= target &lt; nums[mid]</code>，则区间向左约束 <code>right = mid - 1</code></li>
<li>否则区间向右约束 <code>left = mid + 1</code></li>
</ul>
</li>
<li>如果此时右边有序
<ul>
<li>若 <code>nums[mid] &lt; target &lt;= nums[right]</code>，则区间向右约束</li>
<li>否则向左约束</li>
</ul>
</li>
</ul>
<p>在这个基础上，由于题目中给出的数组会重现重复数组，可能出现  <code>[1, 0, 1, 1, 1]</code>，无法正确约束区间</p>
<p>参考官方题解给出的思路是，在 <code>nums[left] == nums[mid] == nums[right]</code> 时，直接将左指针右移一格，右指针左移一格，向中心约束。</p>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="comment">// [mid-1, ...., right, left, ..., mid]</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.<span class="property">length</span> - <span class="number">1</span>, mid = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((right + left) / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">const</span> cur = nums[mid]</span><br><span class="line">        <span class="keyword">if</span> (cur == target) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (nums[left] == cur &amp;&amp; cur == nums[right]) &#123;</span><br><span class="line">            left++</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &lt;= cur) &#123;</span><br><span class="line">            <span class="comment">// 前半段有序</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; cur) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 后半段有序</span></span><br><span class="line">            <span class="keyword">if</span> (cur &lt; target &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4.6</strong></p>
<p>收到 offer 啦 🤗</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="80-删除有序数组中的重复项-II"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/">80. 删除有序数组中的重复项 II</a></h4>
<p>难度中等</p>
<p>给你一个有序数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>最多出现两次</strong> ，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p>
<p><strong>说明：</strong></p>
<p>为什么返回数值是整数，但输出的答案是数组呢？</p>
<p>请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p>
<p>你可以想象内部操作如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,1,1,2,2,3]</span><br><span class="line">输出：5, nums = [1,1,2,2,3]</span><br><span class="line">解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,1,2,3,3]</span><br><span class="line">输出：7, nums = [0,0,1,1,2,3,3]</span><br><span class="line">解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>nums</code> 已按升序排列</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>快慢指针，这个思路真的🐂。</p>
<p>用慢指针指向合法的数组尾部，用快指针指向已经遍历过的数组尾部。</p>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> slow = <span class="number">2</span>, fast = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> (fast &lt; nums.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != nums[slow-<span class="number">2</span>]) &#123;</span><br><span class="line">            nums[slow++] = nums[fast]</span><br><span class="line">        &#125;</span><br><span class="line">        fast++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4.5</strong></p>
<p>简单题 😴</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="88-合并两个有序数组"><a href="https://leetcode-cn.com/problems/merge-sorted-array/">88. 合并两个有序数组</a></h4>
<p>难度简单</p>
<p>给你两个有序整数数组 <code>nums1</code> 和 <code>nums2</code>，请你将 <code>nums2</code> 合并到 <code>nums1</code> 中*，*使 <code>nums1</code> 成为一个有序数组。</p>
<p>初始化 <code>nums1</code> 和 <code>nums2</code> 的元素数量分别为 <code>m</code> 和 <code>n</code> 。你可以假设 <code>nums1</code> 的空间大小等于 <code>m + n</code>，这样它就有足够的空间保存来自 <code>nums2</code> 的元素。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class="line">输出：[1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1], m = 1, nums2 = [], n = 0</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>nums1.length == m + n</code></li>
<li><code>nums2.length == n</code></li>
<li><code>0 &lt;= m, n &lt;= 200</code></li>
<li><code>1 &lt;= m + n &lt;= 200</code></li>
<li><code>-109 &lt;= nums1[i], nums2[i] &lt;= 109</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>从 <code>nums1</code> 的尾部开始放数字，反向遍历数组，无需额外开辟数组。</p>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> cur = m + n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1[i] &gt;= nums2[j]) &#123;</span><br><span class="line">            nums1[cur--] = nums1[i--]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[cur--] = nums2[j--]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        nums1[cur--] = nums1[i--]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        nums1[cur--] = nums2[j--]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4.4</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="781-森林中的兔子"><a href="https://leetcode-cn.com/problems/rabbits-in-forest/">781. 森林中的兔子</a></h4>
<p>难度中等</p>
<p>森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。我们将这些回答放在 <code>answers</code> 数组里。</p>
<p>返回森林中兔子的最少数量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: answers = [1, 1, 2]</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">两只回答了 &quot;1&quot; 的兔子可能有相同的颜色，设为红色。</span><br><span class="line">之后回答了 &quot;2&quot; 的兔子不会是红色，否则他们的回答会相互矛盾。</span><br><span class="line">设回答了 &quot;2&quot; 的兔子为蓝色。</span><br><span class="line">此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。</span><br><span class="line">因此森林中兔子的最少数量是 5: 3 只回答的和 2 只没有回答的。</span><br><span class="line"></span><br><span class="line">输入: answers = [10, 10, 10]</span><br><span class="line">输出: 11</span><br><span class="line"></span><br><span class="line">输入: answers = []</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ol>
<li><code>answers</code> 的长度最大为<code>1000</code>。</li>
<li><code>answers[i]</code> 是在 <code>[0, 999]</code> 范围内的整数。</li>
</ol>
</blockquote>
<p><strong>思路</strong></p>
<p>哈希表 + 贪心，先按兔子回答的数字对兔子进行分组，再尽可能地把回答相同的数字分成一个颜色。</p>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numRabbits = <span class="keyword">function</span>(<span class="params">answers</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    answers.<span class="title function_">forEach</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> key = val + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (!m.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">            m.<span class="title function_">set</span>(key, <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m.<span class="title function_">set</span>(key, m.<span class="title function_">get</span>(key) + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> [key, val] <span class="keyword">of</span> m) &#123;</span><br><span class="line">        <span class="keyword">const</span> k = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(val / key)</span><br><span class="line">        res += k * key</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4.3</strong></p>
<p>字节不出所料，秒挂。</p>
<p>腾讯似乎有点希望？</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1143-最长公共子序列"><a href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h4>
<p>难度中等472</p>
<p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p>
<p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p>
<ul>
<li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li>
</ul>
<p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li>
<li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>动态规划：由于有两个变量，考虑使用二维的动态规划。</p>
<p>开辟一个二维数组 <code>dp</code> 记录 <code>dp[i][j]</code> 代表 <code>text1[0:i]</code> 和 <code>text[0:j]</code> 的最大公共子序列长度。</p>
<p>Base case：第一行和第一列全部初始化为 0</p>
<p>状态转移方程：如果 <code>text1[i] == text2[j]</code>，则 <code>dp[i][j] = dp[i-1][j-1] + 1</code>，否则 <code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code></p>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longestCommonSubsequence = <span class="keyword">function</span>(<span class="params">text1, text2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> m = text1.<span class="property">length</span>, n = text2.<span class="property">length</span></span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(m+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> c = text1[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c === text2[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4.2</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="面试题-17-21-直方图的水量"><a href="https://leetcode-cn.com/problems/volume-of-histogram-lcci/">面试题 17.21. 直方图的水量</a></h4>
<p>难度困难</p>
<p>给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="img"></p>
<p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的直方图，在这种情况下，可以接 6 个单位的水（蓝色部分表示水）。 <strong>感谢 Marcos</strong> 贡献此图。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>每个位置能储存的水的量，由它左侧的最高柱和右侧最高柱以及它本身的高度的决定。</p>
<p>例如，左侧最高 2，右侧最高 3，本身高度为 1，那么它能存的水就是 min(2, 3) - 1 = 1</p>
<p>有两种方式来统计每根柱子的左右最高情况</p>
<ul>
<li>开辟一个数组进行统计，时间复杂度 <code>O(N)</code>，空间复杂度 <code>O(N)</code></li>
<li>双指针，一边遍历统计，时间复杂度 <code>O(N)</code>，空间复杂度 <code>O(1)</code></li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 每个位置能接到的水收到左侧最大高度和右侧最大高度的限制</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(height) &lt; <span class="number">3</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        height = [<span class="number">0</span>] + height + [<span class="number">0</span>]</span><br><span class="line">        left = []</span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> height:</span><br><span class="line">            cur = <span class="built_in">max</span>(cur, i)</span><br><span class="line">            left.append(cur)</span><br><span class="line">        n = <span class="built_in">len</span>(height)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> height[i] &lt; <span class="built_in">min</span>(cur, left[i]):</span><br><span class="line">                res += (<span class="built_in">min</span>(cur, left[i]) - height[i])</span><br><span class="line">            cur = <span class="built_in">max</span>(cur, height[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> trap = <span class="keyword">function</span>(<span class="params">height</span>) &#123;</span><br><span class="line">    <span class="comment">// 双指针</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = height.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        leftMax = <span class="title class_">Math</span>.<span class="title function_">max</span>(leftMax, height[left])</span><br><span class="line">        rightMax = <span class="title class_">Math</span>.<span class="title function_">max</span>(rightMax, height[right])</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">            res += leftMax - height[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res += rightMax - height[right]</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>4.1</strong></p>
<p>🐟人节快乐嗷</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1006-笨阶乘"><a href="https://leetcode-cn.com/problems/clumsy-factorial/">1006. 笨阶乘</a></h4>
<p>难度中等50</p>
<p>通常，正整数 <code>n</code> 的阶乘是所有小于或等于 <code>n</code> 的正整数的乘积。例如，<code>factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1</code>。</p>
<p>相反，我们设计了一个笨阶乘 <code>clumsy</code>：在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(*)，除法(/)，加法(+)和减法(-)。</p>
<p>例如，<code>clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1</code>。然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。</p>
<p>另外，我们使用的除法是地板除法（<em>floor division</em>），所以 <code>10 * 9 / 8</code> 等于 <code>11</code>。这保证结果是一个整数。</p>
<p>实现上面定义的笨函数：给定一个整数 <code>N</code>，它返回 <code>N</code> 的笨阶乘。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：4</span><br><span class="line">输出：7</span><br><span class="line">解释：7 = 4 * 3 / 2 + 1</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：10</span><br><span class="line">输出：12</span><br><span class="line">解释：12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= N &lt;= 10000</code></li>
<li><code>-2^31 &lt;= answer &lt;= 2^31 - 1</code> （答案保证符合 32 位整数。）</li>
</ol>
</blockquote>
<p><strong>代码</strong></p>
<p>标准栈解法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">N</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> clumsy = <span class="keyword">function</span>(<span class="params">N</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> stk = [N--]</span><br><span class="line">    <span class="keyword">let</span> idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(N)&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            stk.<span class="title function_">push</span>(stk.<span class="title function_">pop</span>() * N)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idx % <span class="number">4</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> cur = stk.<span class="title function_">pop</span>();</span><br><span class="line">            stk.<span class="title function_">push</span>(cur &gt; <span class="number">0</span> ? <span class="title class_">Math</span>.<span class="title function_">floor</span>(cur / N) : <span class="title class_">Math</span>.<span class="title function_">ceil</span>(cur / N));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idx % <span class="number">4</span> == <span class="number">2</span>) &#123;</span><br><span class="line">            stk.<span class="title function_">push</span>(N)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stk.<span class="title function_">push</span>(-N)</span><br><span class="line">        &#125;</span><br><span class="line">        N--</span><br><span class="line">        idx++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> res = stk.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pre + cur</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>if else</code> 大法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clumsy</span>(<span class="params">self, N: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">3</span>: <span class="keyword">return</span> <span class="number">6</span></span><br><span class="line">        <span class="keyword">elif</span> N == <span class="number">2</span>: <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">elif</span> N == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> N &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> N &gt;= <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">                    res += N*(N-<span class="number">1</span>)//(N-<span class="number">2</span>)</span><br><span class="line">                    flag = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res -= N*(N-<span class="number">1</span>)//(N-<span class="number">2</span>)</span><br><span class="line">                res += (N-<span class="number">3</span>)</span><br><span class="line">                N -= <span class="number">4</span></span><br><span class="line">            <span class="keyword">elif</span> N == <span class="number">3</span>:</span><br><span class="line">                res -= <span class="number">6</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> N == <span class="number">2</span>:</span><br><span class="line">                res -= <span class="number">2</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> N == <span class="number">1</span>:</span><br><span class="line">                res -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题日志</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 基础面试题</title>
    <url>/post/2021-03-26-Weber/JS%20%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h2 id="搞懂-this">搞懂 this</h2>
<p>要明白 <code>this</code> 的指向，最有用的一句话：<strong><code>this</code> 永远指向最后调用它的对象</strong></p>
<p>最基础的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>() <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title function_">foo</span>() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>用 <code>var</code> 来声明的变量属于全局变量，所以执行完 <code>var a = 1</code> 之后，实际上就是 <code>window.a = 1</code>，<code>window</code> 在这里是一个全局的对象。</p>
<ol>
<li>
<p>第一次输出，由于我们是<strong>直接调用了函数</strong> <code>foo()</code>，根据我们的原则 <strong><code>this</code> 永远指向最后调用它的对象</strong>，因此很明显，此时 <code>this</code> 指向的就是 <code>windows</code>，自然控制台打印出来的就是 <code>1</code>。</p>
</li>
<li>
<p>第二次，我们新建了一个对象  <code>obj</code>，<code>foo</code> 属于<strong>这个对象的一个方法</strong>，所以最后调用 <code>foo()</code> 函数的其实是这个对象，所以 <code>this</code> 指向的是这个 <code>obj</code>，打印出来的就是 <code>2</code>。</p>
</li>
<li>
<p>第三次，我们 <code>new</code> 了一个 <code>foo()</code> 函数，<code>this</code> 被永远绑定在 <code>c</code> 的上面，由于在新建 <code>c</code> 的时候，实际上它并没有叫做 <code>a</code> 的属性，所以最后打印出来的是 <code>undefined</code>。</p>
</li>
</ol>
<p>再来看这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;ethan&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;echo&#x27;</span></span><br><span class="line">    <span class="title function_">innerFunction</span>()</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">innerFunction</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>) <span class="comment">// ethan</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure>
<p>这里的 <code>innerFunction()</code> 和我们上面那个例子中的第一次输出类似，都是直接调用了函数，没有挂载在任何对象上，因此它的 <code>this</code> 就是指向的是 <code>windows</code>。</p>
<p>下面这个例子可以帮你巩固这个知识点：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;ethan&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;echo&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">func1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">func2</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">func1</span>()</span><br><span class="line">        &#125;, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.<span class="title function_">func2</span>()     <span class="comment">// this.func1 is not a function</span></span><br></pre></td></tr></table></figure>
<p>可以简单地理解为，<strong>匿名函数的 <code>this</code> 永远指向 <code>windows</code></strong>，在我们调用对象 <code>a</code> 的 <code>func2</code> 方法的时候， 我们使用 <code>setTimeOut()</code> 来直接调用声明的匿名函数，此时由于 <code>windows</code> 并不具备 <code>func1()</code> 函数，所以会报错。</p>
<p>针对箭头函数而言，它的 <code>this</code> 永远绑定函数定义时候的 <code>this</code> ，而不是执行时候，也可以理解为箭头函数的 <code>this</code> 指向的是包裹箭头函数的第一个普通函数中的 <code>this</code>，如果找不到就是 <code>undefined</code>。</p>
<p>具体例子如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;ethan&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;echo&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">func1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">func2</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="title function_">func1</span>()</span><br><span class="line">        &#125;, <span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.<span class="title function_">func2</span>() <span class="comment">// echo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">b</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">b</span>() <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="改变-this-指向">改变 this 指向</h2>
<ol>
<li>
<p>使用 ES6 的语法，箭头函数：始终指向定义时的 <code>this</code>，而不是执行的时候。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;ethan&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;echo&#x27;</span>,</span><br><span class="line">    <span class="attr">func1</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">func2</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">			<span class="variable language_">this</span>.<span class="title function_">func1</span>();</span><br><span class="line">        &#125;, <span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不使用 ES6 的语法，使用 <code>_this = this</code>，来保存 <code>this</code> 指针。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;ethan&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;echo&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">func1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="attr">func2</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            _this.<span class="title function_">func1</span>()</span><br><span class="line">        &#125;, <span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.<span class="title function_">func2</span>() <span class="comment">// echo</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用 <code>apply, call, bind</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">func1</span>()</span><br><span class="line">&#125;.<span class="title function_">apply</span>(a), <span class="number">100</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">func1</span>()</span><br><span class="line">&#125;.<span class="title function_">call</span>(a), <span class="number">100</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">func1</span>()</span><br><span class="line">&#125;.<span class="title function_">bind</span>(a)(), <span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p><code>apply</code> 和 <code>call</code> 比较类似，它们都是改变 <code>this</code> 指向并且调用函数，<code>bind</code> 跟它们的区别就体现在它只改变绑定的 <code>this</code>，不会直接调用。</p>
<p><code>apply</code> 和 <code>call</code> 的区别体现在函数有多参数的情况下，前者是接收多参数的数组，后者是直接将多个参数平铺在 <code>apply()</code> 内部：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;ethan&#x27;</span>,</span><br><span class="line">    <span class="attr">fn</span>: <span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = a.<span class="property">fn</span>;</span><br><span class="line">b.<span class="title function_">apply</span>(a, [<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// 3</span></span><br><span class="line">b.<span class="title function_">call</span>(a, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>判断 <code>this</code> 指向的图片流程总结：</p>
<p><img src="https://cdn.ethanloo.cn/img/20210315214356" alt="img"></p>
<h2 id="">==</h2>
<p>关键记忆点：字符串转数字，布尔转数字，对象转基本类型</p>
<p><img src="https://cdn.ethanloo.cn/img/20210316131837" alt="img"></p>
<h2 id="闭包">闭包</h2>
<p>MDN 上对闭包的定义：一个函数和对其周围状态（<strong>lexical environment，词法环境</strong>）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是<strong>闭包</strong>（<strong>closure</strong>）。也就是说，<strong>闭包让你可以在一个内层函数中访问到其外层函数的作用域</strong>。</p>
<p>JS 中闭包的意义就是让我们可以间接地访问函数内部的变量。</p>
<p>经典例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="string">&#x27;echo&#x27;</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">b</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="title function_">a</span>()</span><br><span class="line"><span class="title function_">c</span>()</span><br></pre></td></tr></table></figure>
<p><strong>闭包</strong>是由函数以及声明该函数的词法环境组合而成，这个环境包含了该闭包创建时作用域内的任何局部变量。在上面这个例子中，实际上 <code>c</code> 是执行 <code>a</code> 时创建的 <code>b</code> 函数实例的引用。<code>b</code> 的实例维持了一个对它的词法环境的引用，因此调用 <code>c</code> 的时候仍然有 <code>name</code> 这个变量。</p>
<p>闭包的应用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">powerX</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">num</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">pow</span>(num, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> power2 = <span class="title function_">powerX</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> power3 = <span class="title function_">powerX</span>(<span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">power2</span>(<span class="number">2</span>)); <span class="comment">// 4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">power3</span>(<span class="number">2</span>)); <span class="comment">// 8</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">power2</span>(<span class="number">3</span>)); <span class="comment">// 9</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">power3</span>(<span class="number">3</span>)); <span class="comment">// 27</span></span><br></pre></td></tr></table></figure>
<p>这个例子相当于一个工厂函数，封装了一个可以求 <code>X</code> 次方的函数。</p>
<p>经典面试题：由于 <code>setTimeOut</code> 是一个异步函数，所以会先把循环执行完毕，当前输出结果是一堆 <code>6</code>，如何输出 <code>1</code> 到 <code>5</code>？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">  &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解法1：闭包的应用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="keyword">function</span> (<span class="params">j</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line">        &#125;, j * <span class="number">1000</span>)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解法2：使用 <code>setTimeOut</code> 的第三个参数，这个参数会作为回调函数的参数传入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params">j</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(j)</span><br><span class="line">    &#125;, i * <span class="number">1000</span>, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解法3：推荐，用 ES6 中的 <code>let</code> 来解决问题</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> <span class="title function_">timer</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(i)</span><br><span class="line">    &#125;, i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="深浅拷贝">深浅拷贝</h2>
<p>对于基本类型而言，例如 <code>number, boolean, string</code>，它们的拷贝不分深浅，都是将数值直接进行拷贝。</p>
<p>例如 <code>let a = 3; let b = a</code>，实际上就是直接赋值，不涉及任何拷贝。</p>
<p>同样是直接赋值的案例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> b = a</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">// [4, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>由于 <code>a</code> 变量是一个对象，我们直接引用的其实是对象的地址，因此 <code>b = a</code> 实际上就是让 <code>b</code> 指向 <code>a</code> 指向的地方。它们俩指的是同样一块内存空间，所以我们对其中任何一个的改变都影响到了对方。</p>
<p>数组的浅拷贝：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> b = a.<span class="title function_">slice</span>()</span><br><span class="line"><span class="keyword">const</span> c = a.<span class="title function_">concat</span>()</span><br><span class="line"><span class="keyword">const</span> d = [...a]</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>对象的浅拷贝：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">name</span>: <span class="string">&#x27;ethan&#x27;</span>, <span class="attr">age</span>: <span class="number">21</span> &#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, a)</span><br><span class="line"><span class="keyword">const</span> c = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, a, &#123; <span class="attr">name</span>: <span class="string">&#x27;ezreal&#x27;</span> &#125;)</span><br><span class="line">a.<span class="property">name</span> = <span class="string">&#x27;echo&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">// &#123;name: &quot;echo&quot;, age: 21&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c) <span class="comment">// &#123;name: &quot;ezreal&quot;, age: 21&#125;</span></span><br></pre></td></tr></table></figure>
<p>浅拷贝的问题体现在它只能解决第一层数据的复制，当出现引用的引用的时候，它就没有效果了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">name</span>: <span class="string">&#x27;ethan&#x27;</span>, <span class="attr">age</span>: <span class="number">21</span>, <span class="attr">games</span>: [<span class="string">&#x27;LOL&#x27;</span>] &#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, a)</span><br><span class="line">a.<span class="property">games</span>.<span class="title function_">push</span>(<span class="string">&#x27;OW&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">games</span>) <span class="comment">// [&quot;LOL&quot;, &quot;OW&quot;]</span></span><br></pre></td></tr></table></figure>
<p>为了解决这个问题，我们需要深克隆，来实现引用类型内部的引用类型数值的拷贝。</p>
<p>简易版实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123; <span class="attr">name</span>: <span class="string">&#x27;ethan&#x27;</span>, <span class="attr">age</span>: <span class="number">21</span>, <span class="attr">games</span>: [<span class="string">&#x27;LOL&#x27;</span>] &#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(a))</span><br><span class="line">a.<span class="property">games</span>.<span class="title function_">push</span>(<span class="string">&#x27;OW&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">games</span>) <span class="comment">// [&quot;LOL&quot;]</span></span><br></pre></td></tr></table></figure>
<p>简易版的问题体现在：</p>
<ul>
<li>会忽略 <code>undefined</code></li>
<li>会忽略 <code>symbol</code></li>
<li>无法拷贝函数</li>
<li>无法拷贝循环引用的对象</li>
</ul>
<p>手写深拷贝：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">deepClone</span> = (<span class="params">target</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target == <span class="string">&#x27;object&#x27;</span> &amp;&amp; target != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> cloneTarget = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) ? [] : &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> prop <span class="keyword">in</span> target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target.<span class="title function_">hasOwnProperty</span>(prop)) &#123;</span><br><span class="line">                <span class="comment">// 这里的判断是为了忽略从原型链上继承的属性</span></span><br><span class="line">                cloneTarget[prop] = <span class="title function_">deepClone</span>(target[prop])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当遇到需要拷贝的内容是对象且非空的时候，遍历目标对象的所有属性，进行递归的复制。</p>
<blockquote>
<p>当然这个函数还是有很多缺陷：循环引用，<code>Data, Set, Map</code> 等特殊对象的复制，函数拷贝。</p>
<p>完整版的可以参考 <a href="https://juejin.cn/post/6844903986479251464#heading-62%EF%BC%8C%E7%94%B1%E4%BA%8E%E6%8C%96%E7%9A%84%E6%AF%94%E8%BE%83%E6%B7%B1%EF%BC%8C%E6%88%91%E8%BF%99%E5%84%BF%E5%B0%B1%E5%85%88%E4%B8%8D%E6%8E%A2%E7%A9%B6%E4%BA%86%E3%80%82">https://juejin.cn/post/6844903986479251464#heading-62，由于挖的比较深，我这儿就先不探究了。</a></p>
</blockquote>
<h2 id="实现继承">实现继承</h2>
<p><strong>组合继承方式：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getVal</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">val</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="number">233</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c <span class="keyword">instanceof</span> <span class="title class_">Parent</span>) <span class="comment">// true</span></span><br><span class="line">c.<span class="title function_">getVal</span>() <span class="comment">// 233</span></span><br></pre></td></tr></table></figure>
<p>子类的构造函数通过 <code>Parent.call(this)</code> 继承了父类的属性，把子类的原型改成 <code>new Parent()</code> 来继承父类的函数。</p>
<p>该种继承方式的<strong>优点</strong>在于构造函数可以传参，不会和父类共享引用属性，可以继承父类的函数；<strong>缺点</strong>在于继承父类的函数的时候实际上调用了父类的构造函数，因此造成了子类的原型上存在了不需要的属性。</p>
<p>**寄生组合继承：**对组合继承的优化</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">val</span> = val</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getVal</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">val</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>, &#123;</span><br><span class="line">  <span class="attr">constructor</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="title class_">Child</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="number">233</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c <span class="keyword">instanceof</span> <span class="title class_">Parent</span>) <span class="comment">// true</span></span><br><span class="line">c.<span class="title function_">getVal</span>() <span class="comment">// 233</span></span><br></pre></td></tr></table></figure>
<p><code>class</code> 关键词实现继承，属于 ES6 中提供的语法糖</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">val</span> = val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">getVal</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">val</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Parent</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">val</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(val)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">val</span> = val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title class_">Child</span>(<span class="number">233</span>)</span><br><span class="line">c.<span class="title function_">getVal</span>() <span class="comment">// 233</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c <span class="keyword">instanceof</span> <span class="title class_">Parent</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="AJAX">AJAX</h2>
<p>AJAX(<strong>A</strong>synchronous <strong>J</strong>avaScript <strong>A</strong>nd <strong>X</strong>ML)：异步的 JS 和 XML（可扩展标记语言）</p>
<p>可以实现在不刷新的情况下，更新页面上的数据，提高用户体验。</p>
<p>AJAX 经典四步：</p>
<ol>
<li>创建 <code>XMLHttpRequest</code> 的一个实例</li>
<li>调用实例的 <code>open</code> 方法</li>
<li>指定状态变化事件处理函数</li>
<li>调用 <code>send</code> 方法发送请求</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">xhr.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;</span>);</span><br><span class="line">xhr.<span class="property">onreadystatechange</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.<span class="title function_">send</span>();</span><br></pre></td></tr></table></figure>
<h2 id="Promise">Promise</h2>
<blockquote>
<p>3.17 MS 二面问到了，面完赶紧补课</p>
</blockquote>
<p><code>Promise</code> 是 ES6 提出用来处理异步问题的一个方案。</p>
<p><code>Promise</code> 的三个状态：<code>pending(等待), resolved(已成功), rejected(已失败)</code>。它的优点在于将异步操作用同步方式的流程表达出来，使用链式的写法使得代码更加优雅。</p>
<p>基本用法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 封装 model 层的接口</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 用定时器模拟 Ajax 请求接口</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> data = &#123; <span class="attr">retCode</span>: <span class="number">0</span>, <span class="attr">msg</span>: <span class="string">&quot;hello!&quot;</span> &#125;; <span class="comment">// 模拟接口返回的数据</span></span><br><span class="line">    <span class="keyword">if</span> (data.<span class="property">retCode</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(&#123; <span class="attr">retCode</span>: -<span class="number">1</span>, <span class="attr">msg</span>: <span class="string">&quot;network error&quot;</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 业务层的接口调用</span></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 从 resolve 获取正常结果</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 从 reject 获取异常结果</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h2 id="原型和原型链">原型和原型链</h2>
<p>先记住原型链，再尝试理解原型。</p>
<p>一开始我们先看一张图：</p>
<img src="https://cdn.ethanloo.cn/img/20210318144315.image" alt="img" style="zoom:50%;" />
<p>再根据代码来理解：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&#x27;ethan&#x27;</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br></pre></td></tr></table></figure>
<p>构造函数的 <code>prototype</code> 属性：</p>
<p><img src="https://cdn.ethanloo.cn/img/20210318144805.png" alt="image-20210318144805494"></p>
<p>实例对象的 <code>__proto__</code> 属性：</p>
<p><img src="https://cdn.ethanloo.cn/img/20210318144833.png" alt="image-20210318144833365"></p>
<p>两者指向一个地方：<code>person.__proto__ === Person.prototype</code></p>
<p>同时，原型的 <code>constructor</code> 属性指向的是构造函数：<code>Person()</code></p>
<blockquote>
<p>ES5 中获取对象的原型的方法是 <code>Object.getPrototypeOf(person)</code></p>
</blockquote>
<p>我们能更新当前的关系图：</p>
<img src="https://cdn.ethanloo.cn/img/20210318145202.image" alt="img" style="zoom:50%;" />
<p>再来继续探究原型是什么东西，我们可以看到之前打印的<strong>原型</strong> <code>Person.prototype</code> 或者说 <code>person.__proto__</code>，它是一个<strong>对象</strong>，我们尝试获取它的原型（即<strong>原型的原型</strong>）</p>
<p><img src="https://cdn.ethanloo.cn/img/20210318145520.png" alt="image-20210318145519954"></p>
<p><code>Object()</code> 是 <code>Object</code> 的构造函数，而我们之前 <code>Person</code> 的原型是一个 <code>Object</code> 的实例，所以我们可以得到 <code>Person.prototype.__proto__ === Object.prototype</code>。</p>
<blockquote>
<p><code>Object</code> 的原型的原型为 <code>null</code></p>
</blockquote>
<p>最终的原型链图就张这样（图中的蓝色这根线）：</p>
<img src="https://cdn.ethanloo.cn/img/20210318145758.image" alt="img" style="zoom: 80%;" />
<p>那父类和子类的继承关系和这个<strong>原型</strong>又有什么关系呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">F</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_ inherited__">F</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(C.<span class="property">__proto__</span> === F); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(C.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === F.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>子类的 <code>__proto__</code> 属性，表示构造函数的继承，指向父类；因为作为一个对象，子类的原型是父亲</li>
<li>子类 <code>prototype</code> 属性的 <code>__proto__</code> 属性，表示方法的继承，总是指向父类的prototype属性；因为作为一个构造函数，子类的原型对象是父类的原型对象的实例</li>
</ul>
<p>走完这个流程之后，我们再来探究什么是 <code>prototype</code> ，什么是 <code>__proto__</code></p>
<p><code>__proto__</code> ，是对象的一个属性，它的值就是它所对应的原型对象</p>
<p><code>prototype</code>，是函数的一个属性，它的值是一个有 <code>constructor</code> 属性的对象。当我们把这个函数作为构造函数调用的时候，JS 就会帮我们创建该构造函数的实例，实例继承该构造函数的 <code>prototype</code> 的所有属性和方法（实例会把自己的 <code>__proto__</code> 指向构造函数的 <code>prototype</code>）。</p>
<blockquote>
<p>实际上我对原型链的理解还是很模糊，建议直接阅读 <a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Object_prototypes">MDN 相关文档</a>。</p>
</blockquote>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://juejin.cn/book/6844733763675488269">掘金小册：《前端面试之道》</a></p>
<p><a href="https://juejin.cn/post/6844903496253177863">this、apply、call、bind</a></p>
<p><a href="https://juejin.cn/post/6844903986479251464">三元大佬的原生 JS 灵魂之问</a></p>
<p><a href="https://juejin.cn/post/6844903843507994632">学习Promise基础及手写Promise</a></p>
<p><a href="https://juejin.cn/post/6921592119614570504#heading-0">原型？原型链？</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JS-ES6特性</title>
    <url>/post/2021-03-03-Weber/JS-ES6%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="ES6-简介">ES6 简介</h2>
<p>ES 全称 ECMAScript，是一套脚本语言的标准化规范。严格来说，ES 不仅是 JS 的语言标准，还包括其他脚本语言的语言标准。</p>
<p>2015年6月，ES6 正式发布，也可以叫做 ES2015，是新的 JS 语法标准，ES6 泛指 ES2015 以及后续版本。jQuery 偏向于 ES3，现在主流的 Vue.js 和 React.js 的默认语法都是 ES6。</p>
<p>ES6 的改进：</p>
<ol>
<li>通过 <code>let, const</code> 关键字优化了变量提升的特性。</li>
<li>增加了新功能，比如：常量，作用域，异步处理，类，继承等。</li>
<li>之前的语法过于松散，相同的功能可能会写出不同的代码。</li>
</ol>
<p>ES6 的目标：让 JS 语言可以编写复杂的大型应用程序。</p>
<h3 id="兼容性配置">兼容性配置</h3>
<p>写 ES6 语法的 JS 代码，通过 <code>Babel</code> 将 ES6 转换为 ES5。</p>
<p>参考：<a href="http://jspang.com/2017/06/03/es6/">http://jspang.com/2017/06/03/es6/</a></p>
<h2 id="ES5-巩固">ES5 巩固</h2>
<h3 id="严格模式">严格模式</h3>
<p>ES5 中新增的运行模式：strict mode，目的是为了消除 JS 语法中的不合理性和不安全之处，也是为了未来新版的 JS 做铺垫。</p>
<p>如果要使用，就将 <code>use strict</code> 放在脚本文件第一行即可。</p>
<h3 id="模式特点">模式特点</h3>
<ol>
<li>在正常模式种，对没有声明的变量赋值，默认就是全局变量，严格模式中，必须使用 <code>var</code> 显示声明变量。</li>
<li>在自定义函数中，禁止用 <code>this</code> 指向 <code>window</code>。</li>
<li>创建 <code>eval</code> 作用域，<code>eval()</code> 使用局部作用域，<code>evalg()</code> 使用全局作用域。</li>
<li>禁止使用 <code>with</code> 语句。</li>
<li>构造函数必须通过 <code>new</code> 实例化对象。</li>
<li>无法删除变量。</li>
<li>函数必须声明在顶层。</li>
</ol>
<h3 id="JSON">JSON</h3>
<p>ES5 中新增的两个关于 JSON 的方法。</p>
<ol>
<li><code>JSON.stringfy(obj/arr)</code>：JS 对象（数组） =&gt; JSON 对象（数组）</li>
<li><code>JSON.parse(json)</code>：JSON 对象（数组） =&gt; JS 对象（数组）</li>
</ol>
<h3 id="Object-扩展">Object 扩展</h3>
<p><code>Object.create(prototype, [descriptors])</code>：以指定对象为原型，创建新的对象，第二个参数可以添加新的属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">name</span>: <span class="string">&#x27;ethan&#x27;</span>, <span class="attr">age</span>: <span class="number">21</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;<span class="attr">sex</span>: <span class="string">&#x27;male&#x27;</span>&#125;;</span><br><span class="line">obj2 = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj1);</span><br><span class="line">obj3 = <span class="title class_">Object</span>.<span class="title function_">create</span>(obj1, &#123;</span><br><span class="line">    <span class="attr">country</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;Chine&#x27;</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">false</span>, <span class="comment">// 不可写</span></span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span>, <span class="comment">// 可删除</span></span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">true</span> <span class="comment">// 可枚举</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>Object.defineProperties(object, descriptors)</code>：为指定对象定义扩展属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">firstName</span>: <span class="string">&#x27;ethan&#x27;</span>, <span class="attr">lastName</span>: <span class="string">&#x27;lu&#x27;</span>&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(obj, &#123;</span><br><span class="line">	 <span class="attr">fullName</span>: &#123;</span><br><span class="line">         <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span></span><br><span class="line">         &#125;,</span><br><span class="line">         <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">             <span class="keyword">var</span> names = data.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">             <span class="variable language_">this</span>.<span class="property">firstName</span> = names[<span class="number">0</span>];</span><br><span class="line">             <span class="variable language_">this</span>.<span class="property">lastName</span> = names[<span class="number">1</span>];</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>get 属性名()&#123;&#125;</code>：返回当前属性值的回调函数</li>
<li><code>set 属性名()&#123;&#125;</code>：监视当前属性值变化的回调函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">firstName</span>: <span class="string">&#x27;ethan&#x27;</span>, </span><br><span class="line">    <span class="attr">lastName</span>: <span class="string">&#x27;lu&#x27;</span></span><br><span class="line">    <span class="attr">fullName</span>: &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + <span class="variable language_">this</span>.<span class="property">lastName</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">data</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> names = data.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">firstName</span> = names[<span class="number">0</span>];</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">lastName</span> = names[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">fullName</span>);</span><br><span class="line">obj.<span class="property">fullName</span> = <span class="string">&#x27;Echo Dee&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">fullName</span>);</span><br></pre></td></tr></table></figure>
<h3 id="数组扩展">数组扩展</h3>
<ol>
<li><code>Array.prototype.indexOf(value)</code>：获取 <code>value</code> 在数组中第一次出现的下标。</li>
<li><code>Array.prototype.lastIndexOf(value)</code>：获取 <code>value</code> 在数组中出现的最后一次下标。</li>
<li><code>Array.prototype.forEach(function(item, index)&#123;&#125;)</code>：遍历数组</li>
<li><code>Array.prototype.map(function(item, index)&#123;&#125;)</code>：遍历数组并返回一个新的加工后的数组。</li>
<li><code>Array.prototype.filter(function(item, index)&#123;&#125;)</code>：遍历并过滤出一个子数组。</li>
</ol>
<h3 id="改变-this-的指向">改变 this 的指向</h3>
<p><code>Function.prototype.bind(obj)</code>：将函数内的 <code>this</code> 绑定为 <code>obj</code>，并返回函数。</p>
<blockquote>
<p><code>call(), apply(), bind()</code> 都可以改变 <code>this</code> 的指向，但是前两者为立即调用函数，最后一个在绑定完之后，不会立即调用，而是将函数返回，需要再加括号才能调用。</p>
</blockquote>
<p>ES5 加入 <code>bind()</code> 的原因是该方法不会立即调用函数。</p>
<h2 id="ES6-的变量声明">ES6 的变量声明</h2>
<p>ES5 及之前，使用 <code>var</code> 定义全局变量。</p>
<p>ES6 中，使用 <code>let</code> 和 <code>const</code> 来定义变量：</p>
<ul>
<li><code>let</code>：定义局部变量</li>
<li><code>const</code>：定义常量（不可修改）</li>
</ul>
<h3 id="var-的问题">var 的问题</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>由于 <code>var</code> 声明的是全局变量，所以上述代码可以正常输出结果，由此也说明 <code>var</code> 声明的变量不具备<strong>块级作用域</strong>的特性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>在外层和内层的作用域对同一个变量进行了定义和赋值，可能会污染 JS 的作用域，因此应该尽量避免 <code>var</code> 定义变量。</p>
<h3 id="let-定义局部变量">let 定义局部变量</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// a is not defined</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p><code>let</code> 定义的变量，只在<strong>块级作用域</strong>内起作用。</p>
<p>同一个块级作用域内，如果使用 <code>let</code> 关键字重复定义同一个变量，会报错。</p>
<h3 id="const-定义常量">const 定义常量</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> blog = <span class="string">&#x27;https://blog.ethanlooo.top&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>用 <code>const</code> 声明的常量，只在块级作用域内起作用，而且在声明时必须赋值，否则报错。</p>
<h3 id="let-和-const-的特点">let 和 const 的特点</h3>
<ul>
<li>不存在变量提升</li>
<li>禁止重复声明</li>
<li>支持块级作用域</li>
<li>暂时性死区（在声明变量之前，该变量都是不可用的）</li>
</ul>
<h3 id="var-let-const-的共同点">var let const 的共同点</h3>
<ul>
<li>全局作用域中定义的变量，可以在函数中使用</li>
<li>函数中声明的变量，只能在函数及其子函数中使用</li>
</ul>
<h3 id="暂时性死区">暂时性死区</h3>
<p>使用 <code>let</code> 或者 <code>const</code> 声明的变量，会使区块形成封闭的作用域，如果在声明之前使用变量，会报错。暂时性死区 Temporal dead zone 就是这样一种机制，确保变量先声明，再使用。</p>
<h2 id="变量的解构赋值">变量的解构赋值</h2>
<p>ES6 允许从数组或者对象中提取值，再将提取出来的值赋给变量。</p>
<p>解构：分解数据结构；赋值：给变量赋值。</p>
<h3 id="数组的解构赋值">数组的解构赋值</h3>
<p>ES6 之前的写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> a = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> b = arr[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> c = arr[<span class="number">2</span>];</span><br></pre></td></tr></table></figure>
<p>ES6 之后的写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>正常情况应该是一一对应进行赋值，但是如果左边的数量大于右边数组的长度，多余的变量就是 <code>undefined</code>。</p>
<p>左边允许有默认值，如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> [name = <span class="string">&#x27;ethan&#x27;</span>] = [];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// ethan</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> [a, b] = [<span class="number">1</span>];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a + <span class="string">&#x27;, &#x27;</span> + b); <span class="comment">// 1, undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> [a, b = <span class="number">2</span>] = [<span class="number">1</span>];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a + <span class="string">&#x27;, &#x27;</span> + b); <span class="comment">// 1, 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> [a, b = <span class="number">2</span>] = [<span class="number">1</span>, <span class="literal">undefined</span>];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> [a, b = <span class="number">2</span>] = [<span class="number">1</span>, <span class="literal">null</span>];</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对象的解构赋值">对象的解构赋值</h3>
<p>将对象中的值按照属性匹配的方式提取出来。</p>
<p>ES6 之前：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = json.<span class="property">name</span>;</span><br><span class="line"><span class="keyword">var</span> age = json.<span class="property">age</span>;</span><br><span class="line"><span class="keyword">var</span> sex = json.<span class="property">sex</span>;</span><br></pre></td></tr></table></figure>
<p>ES6 之后：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;<span class="attr">name</span>: <span class="string">&#x27;ethan&#x27;</span>, <span class="attr">age</span>: <span class="number">21</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;name, age&#125; = person;</span><br></pre></td></tr></table></figure>
<p>同样，左边的变量数如果大于右边的对象的属性数，就会被赋值 <code>undefined</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;<span class="attr">name</span>: <span class="string">&#x27;ethan&#x27;</span>, <span class="attr">age</span>: <span class="number">21</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;name, age, sex&#125; = person; <span class="comment">// &#123;&#x27;ethan&#x27;, 21, undefined&#125;</span></span><br></pre></td></tr></table></figure>
<p>也可以自定义变量名，不一定和属性名一致。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;<span class="attr">name</span>: <span class="string">&#x27;ethan&#x27;</span>, <span class="attr">age</span>: <span class="number">21</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>: myName, <span class="attr">age</span>: myAge&#125; = person;</span><br></pre></td></tr></table></figure>
<p>如果变量名在解构前使用过，会报错：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;ethan&#x27;</span>;</span><br><span class="line">&#123;name&#125; = &#123;<span class="attr">name</span>: <span class="string">&#x27;echo&#x27;</span>&#125;; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>外层添加圆括号即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;ethan&#x27;</span>;</span><br><span class="line">(&#123;name&#125; = &#123;<span class="attr">name</span>: <span class="string">&#x27;echo&#x27;</span>&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// echo</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串结构">字符串结构</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d] = <span class="string">&#x27;ethan&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// e</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// t</span></span><br></pre></td></tr></table></figure>
<h2 id="箭头函数">箭头函数</h2>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(参数<span class="number">1</span>, 参数<span class="number">2</span>, ...) =&gt; &#123; 函数体 &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>如果只有 1 个参数，可以省略小括号。</p>
</li>
<li>
<p>如果函数体只有 1 条语句，且是 <code>return</code> 语句，可以省略大括号。</p>
</li>
</ul>
<p>传统的定义和调用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fc</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fc</span>(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>ES6 中的写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fc</span> = (<span class="params">a,b</span>) =&gt; &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hi&#x27;</span>);   </span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fc</span>(<span class="number">1</span>, <span class="number">2</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>ES6 中的函数简化版：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fc</span> = a =&gt; a + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">fc</span>(<span class="number">1</span>)); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>不过一般不会省略小括号，VSC 的自动格式化也会加上小括号。</p>
</blockquote>
<h3 id="this-指向">this 指向</h3>
<p>ES6 之前：<code>this</code> 指向的是调用函数的对象。</p>
<p>ES6 的箭头函数：函数本身不绑定 <code>this</code>，<code>this</code> 指向的是箭头函数定义位置的 <code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">name</span>: <span class="string">&#x27;ethan&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fc1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// obj</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// obj</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fc3</span> = (<span class="params">a</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// Window</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fc2 = fc1.<span class="title function_">call</span>(obj);</span><br><span class="line"><span class="title function_">fc2</span>();</span><br><span class="line"><span class="title function_">fc3</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h2 id="参数默认值">参数默认值</h2>
<p>传统写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fc</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> p = name || <span class="string">&#x27;ethan&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6 写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fc</span>(<span class="params">name = <span class="string">&#x27;ethan&#x27;</span></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，有默认值的参数后面的参数，也必须要有默认值。</p>
<h2 id="剩余参数">剩余参数</h2>
<p>剩余参数允许把不确定数量的多余的参数放到一个数组中。</p>
<p>传统写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fc</span>(<span class="params">a, b, c</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(d); <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6 写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fc</span> = (<span class="params">a, b, ...args</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(args[<span class="number">0</span>]); <span class="comment">// 3</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(args[<span class="number">1</span>]); <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fc</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<p>剩余参数和解构赋值配合：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> names = [<span class="string">&#x27;ethan&#x27;</span>, <span class="string">&#x27;echo&#x27;</span>, <span class="string">&#x27;elisa&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> [p1, ...p2] = names;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1); <span class="comment">// &#x27;ethan&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2); <span class="comment">// [&#x27;echo&#x27;, &#x27;elisa&#x27;]</span></span><br></pre></td></tr></table></figure>
<h2 id="扩展运算符">扩展运算符</h2>
<p>扩展运算符将数组或对象拆分成逗号分隔的参数序列。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...nums); <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure>
<p>可以使用扩展运算符实现数组的深复制。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr1];</span><br></pre></td></tr></table></figure>
<p>还可以快速合并数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1</span></span><br><span class="line"><span class="keyword">let</span> arr3 = [...arr1, ...arr2];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line">arr1.<span class="title function_">push</span>(...arr2);</span><br></pre></td></tr></table></figure>
<h2 id="string-扩展">string 扩展</h2>
<p>ES6 新增的字符串方法：</p>
<ul>
<li>
<p><code>includes(str)</code>：判断是否包含指定的字符串</p>
</li>
<li>
<p><code>startsWith(str)</code>：判断是否以指定字符串开头</p>
</li>
<li>
<p><code>endsWith(str)</code>：判断是否以指定字符串结尾</p>
</li>
<li>
<p><code>repeat(count)</code>：重复指定次数</p>
</li>
</ul>
<h2 id="number-扩展">number 扩展</h2>
<ul>
<li>
<p>二进制用 <code>0b</code> 开头，八进制用 <code>0o</code> 开头</p>
</li>
<li>
<p><code>Number.isFinite(i)</code>：判断是否为有限大的数。比如<code>Infinity</code>这种无穷大的数，返回的就是 false。</p>
</li>
<li>
<p><code>Number.isNaN(i)</code>：判断是否为 <code>NaN</code>。</p>
</li>
<li>
<p><code>Number.isInteger(i)</code>：判断是否为整数。</p>
</li>
<li>
<p><code>Number.parseInt(str)</code>：将字符串转换为对应的数值。</p>
</li>
<li>
<p><code>Math.trunc(i)</code>：去除小数部分。</p>
</li>
</ul>
<h2 id="array-扩展">array 扩展</h2>
<ul>
<li>
<p><code>Array.from(arr)</code>：将<strong>伪数组</strong>或者<strong>可遍历对象</strong>转换成<strong>真数组</strong></p>
</li>
<li>
<p><code>array.findIndex(function(currentValue, index, arr), thisValue)</code>：返回符合测试条件的第一个数组元素的下标</p>
</li>
<li>
<p><code>array.find(function(currentValue, index, arr),thisValue)</code>：返回符合测试条件的一个数组元素</p>
</li>
</ul>
<h2 id="object-扩展">object 扩展</h2>
<ul>
<li><code>Object.is(x, y)</code>：判断两个变量是否完全相等，底层是通过字符串判断。</li>
<li><code>Object.assign()</code>：可以将可枚举属性的值从一个或多个对象分配到目标对象。</li>
</ul>
<h2 id="Set-数据结构">Set 数据结构</h2>
<p>集合，非重复数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySet = <span class="keyword">new</span> <span class="title class_">Set</span>(); <span class="comment">// 新建 Set</span></span><br><span class="line"></span><br><span class="line">mySet.<span class="title function_">add</span>(<span class="number">1</span>); <span class="comment">// 添加元素</span></span><br><span class="line">mySet.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line">mySet.<span class="title function_">add</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mySet); <span class="comment">// &#123;1, 2&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mySet.<span class="title function_">has</span>(<span class="number">1</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mySet.<span class="title function_">has</span>(<span class="number">3</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mySet.<span class="property">size</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h2 id="Symbol-数据结构">Symbol 数据结构</h2>
<p>ES6 引入的数据结构，表示独一无二的值，解决命名冲突的问题，不能和其他数计算。</p>
<p>构造函数：<code>const symbol = Symbol()</code>，括号里可以加字符串作为符号描述。</p>
<h3 id="作为对象属性">作为对象属性</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;ethan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">21</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> symbol = <span class="title class_">Symbol</span>();</span><br><span class="line">obj[symbol] = <span class="number">1</span>; <span class="comment">// 只能通过属性选择器给对象添加 Symbol 属性，不可能写成 obj.symbol = 1</span></span><br></pre></td></tr></table></figure>
<h3 id="传参标识">传参标识</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> symbol1 = <span class="title class_">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> symbol2 = <span class="title class_">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(symbol1 == symbol2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> symbol3 = <span class="title class_">Symbol</span>(<span class="string">&#x27;three&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> symbol4 = <span class="title class_">Symbol</span>(<span class="string">&#x27;four&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(symbol3); <span class="comment">// Symbol(three)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(symbol4); <span class="comment">// Symbol(four)</span></span><br></pre></td></tr></table></figure>
<h2 id="Promise-入门">Promise 入门</h2>
<p>JavaScript 的执行环境是<strong>单线程</strong>的，即任务都是依次执行，无法并行。</p>
<p>异步模式可以一起执行多个任务，常见的异步模式有：定时器，接口调用，事件函数。</p>
<p>JS 中常见的接口调用方式：</p>
<ul>
<li>原生 Ajax</li>
<li>基于 jQuery 的 Ajax</li>
<li>Fetch</li>
<li>Promise</li>
<li>Axios</li>
</ul>
<p>ES5 中，如果异步调用的结果存在以来，需要进行多层嵌套回调，会导致代码层次过多，难维护，而且会导致<strong>回调地狱</strong>。</p>
<p>ES6 中的 Promise 可以解决这个问题。</p>
<h3 id="概述">概述</h3>
<p>ES6 中的 Promise 是<strong>异步编程</strong>的一种方案，Promise 是一个对象，可以获取异步操作的消息。</p>
<p>通过 Promise 对象，可以用同步的形式来书写异步代码。</p>
<h3 id="基本用法">基本用法</h3>
<ol>
<li><code>new</code> 一个 Promise 对象，传递一个参数，参数为一个用于处理异步任务的函数。</li>
<li>并且传入两个参数：<code>resolve</code> 和 <code>reject</code>，分别表示异步执行成功的回调函数和异步执行失败后的回调函数。</li>
<li>通过 <code>promise.then()</code> 处理返回结果。</li>
</ol>
<h3 id="异步任务处理">异步任务处理</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 封装 model 层的接口</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 用定时器代替 Ajax 请求接口</span></span><br><span class="line">  <span class="title function_">setTimeOut</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> data = &#123; <span class="attr">retCode</span>: <span class="number">0</span>, <span class="attr">msg</span>: <span class="string">&quot;hello!&quot;</span> &#125;; <span class="comment">// 模拟接口返回的数据</span></span><br><span class="line">    <span class="keyword">if</span> (data.<span class="property">retCode</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">reject</span>(&#123; <span class="attr">retCode</span>: -<span class="number">1</span>, <span class="attr">msg</span>: <span class="string">&quot;network error&quot;</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 业务层的接口调用</span></span><br><span class="line">promise</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 从 resolve 获取正常结果</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 从 reject 获取异常结果</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="封装-Ajax-请求">封装 Ajax 请求</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">&quot;request&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> request1 = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">request</span>(<span class="string">&quot;https://www.ethanloo.cn&quot;</span>, <span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((response.<span class="property">retCode</span> = <span class="number">200</span>)) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;request success,&quot;</span> + response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&quot;failed&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">request1</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res1</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res1);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">request2</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="基于-Promise-处理多次-Ajax-请求">基于 Promise 处理多次 Ajax 请求</h3>
<p>通过 Promise，可以使多层嵌套调用按线性方式书写，把<strong>多层嵌套调用</strong>改进为<strong>链式调用</strong>。</p>
<blockquote>
<p>例如有 3 个请求，请求 2 依赖于请求 1 的结果，请求 3 依赖于请求 2 的结果，传统写法会陷入回调地狱。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">&quot;request&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> request1 = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">request</span>(<span class="string">&quot;https://www.baidu.com&quot;</span>, <span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((response.<span class="property">retCode</span> = <span class="number">200</span>)) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;request1 success,&quot;</span> + response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&quot;failed&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> request2 = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">request</span>(<span class="string">&quot;https://www.google.com&quot;</span>, <span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (response.<span class="property">retCode</span> == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;request2 success,&quot;</span> + response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&quot;failed&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> request3 = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">request</span>(<span class="string">&quot;https://www.yahoo.com&quot;</span>, <span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (response.<span class="property">retCode</span> == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;request3 success,&quot;</span> + response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&quot;failed&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐个进行请求并打印返回结果</span></span><br><span class="line"><span class="title function_">request1</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res1</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res1);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">request2</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res2);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">request3</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">res3</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res3);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="return-的函数返回值">return 的函数返回值</h3>
<p><code>return</code> 有两种可能的返回值：</p>
<ol>
<li>返回 Promise 实例对象，然后该对象调用下一个 <code>then</code></li>
<li>返回普通值，返回的值会传递给下一个 <code>then</code>，通过 <code>then</code> 参数中函数的参数接收</li>
</ol>
<p>第一种情况类似上面的多 Ajax 请求；</p>
<p>第二种返回普通值的情况：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">queryData</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.<span class="property">readyState</span> != <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (xhr.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(xhr.<span class="property">responseText</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&quot;failed&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.<span class="property">responseText</span> = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&quot;get&quot;</span>, url);</span><br><span class="line">    xhr.<span class="title function_">send</span>(<span class="literal">null</span>); <span class="comment">// 请求接口</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">queryData</span>(<span class="string">&quot;https://www.ethanlooo.top&quot;</span>)</span><br><span class="line">  .<span class="title function_">then</span>(</span><br><span class="line">    <span class="function">(<span class="params">data1</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data1));</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">queryData</span>(<span class="string">&quot;https://blog.ethanlooo.top&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">error1</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(error1);</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">then</span>(</span><br><span class="line">    <span class="function">(<span class="params">data2</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(data2));</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;hello, ethan&quot;</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">error2</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(error2);</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data3</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data3); <span class="comment">// hello, ethan</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>第一个请求结束，返回的是 Promise 的实例对象，因此第二个请求会正常进行。</p>
<p>第二个请求结束，返回的是一个普通的字符串，为了确保继续进行链式操作，在第三个 <code>then</code> 前面会产生一个新的默认的 Promise 的实例对象来调用。同时，上一个返回的普通字符串会作为参数 <code>data3</code> 传入第三个函数。</p>
<h3 id="Promise-常用实例方法">Promise 常用实例方法</h3>
<ol>
<li><code>promise.then()</code>：获取异步任务的正常结果。</li>
<li><code>promise.catch()</code>：获取异步任务的异常结果。</li>
<li><code>promise.finally()</code>：异步任务无论成功与否，都会执行。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">queryData</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> data = &#123; <span class="attr">retCode</span>: <span class="number">0</span>, <span class="attr">msg</span>: <span class="string">&quot;ethanloo&quot;</span> &#125;; <span class="comment">// 模拟接口返回的数据</span></span><br><span class="line">      <span class="keyword">if</span> (data.<span class="property">retCode</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(data);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(&#123; <span class="attr">retCode</span>: -<span class="number">1</span>, <span class="attr">msg</span>: <span class="string">&quot;error&quot;</span> &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">queryData</span>()</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;failure&quot;</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;whatever&quot;</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="Promise-常用类方法">Promise 常用类方法</h3>
<ol>
<li><code>Promise.all()</code>：并发处理多个异步任务，所有任务成功才能得到结果</li>
<li><code>Promise.race()</code>：并发处理多个异步任务，只要有一个任务成功就得到结果</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> promise1 = <span class="title function_">queryData</span>(api1);</span><br><span class="line"><span class="keyword">let</span> promise2 = <span class="title function_">queryData</span>(api2);</span><br><span class="line"><span class="keyword">let</span> promise3 = <span class="title function_">queryData</span>(api3);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([promise1, promise2, promise3]).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">race</span>([promise1, promise2, promise3]).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="ES7-async-异步函数">ES7 async 异步函数</h2>
<ul>
<li><code>async</code> 意思是<strong>异步</strong>，加上该关键词的函数的返回值是 Promise 实例对象</li>
<li><code>await</code> 只能存在于 <code>async</code> 函数中，用于等待一个异步任务完成的结果。</li>
</ul>
<p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> request1 = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">request</span>(<span class="string">&quot;https://www.ethanloo.cn&quot;</span>, <span class="keyword">function</span> (<span class="params">response</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (response.<span class="property">retCode</span> == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&quot;request1 success, &quot;</span> + response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&quot;failure&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">queryData</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">request1</span>();</span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">queryData</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年3月刷题日志</title>
    <url>/post/2021-03-01-Algorithm/2021%E5%B9%B43%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p><strong>3.31</strong></p>
<p>还没等到 MS 的正式 offer 🤦‍♂️</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="90-子集-II"><a href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a></h4>
<p>难度中等</p>
<p>给你一个整数数组 <code>nums</code> ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。返回的解集中，子集可以按 <strong>任意顺序</strong> 排列。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,2]</span><br><span class="line">输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10</code></li>
<li><code>-10 &lt;= nums[i] &lt;= 10</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>迭代法</p>
<ul>
<li>新建一个空数组 <code>res</code>，用于存放遍历到的所有子集，同时需要往数组中首先加一个空数组，代表空集</li>
<li>逐个遍历数组中的所有数，针对每个数字而言有两种情况
<ol>
<li>加入这个数</li>
<li>不加入这个数</li>
</ol>
</li>
<li>对于上一次遍历所获得所有集合，都需要实行这两个操作</li>
<li>一般来说，假设原数组长度为 <code>n</code> 第一次 <code>res</code> 会变成长度 <code>1 + 1</code>，第二次会变成 <code>1 + 4</code>…</li>
<li>但是题目中的 <code>nums</code> 中可能出现重复整数，所以需要想办法规避掉重复的子集的添加</li>
</ul>
<p>重复子集判断</p>
<ul>
<li>
<p>首先需要对数组 <code>nums</code> 进行排序，保证是按顺序遍历的数字</p>
</li>
<li>
<p>我们在每次遍历的时候维护一个数组 <code>last</code>，用于记录当前 <code>res</code> 中的每个子集在上一次遍历的时候加入的数字</p>
</li>
<li>
<p>例如针对 <code>[1, 2, 2]</code> 而言</p>
<ul>
<li>第一遍：<code>res = [[], [1]], last = [1, -11]</code></li>
<li>第二遍：<code>res = [[], [1], [2], [1,2]], last = [2, 2, -11, -11]</code></li>
<li>第三遍：<code>res = [[], [1], [2], [1,2], [2,2], [1,2,2]], last = [2, 2, 2, 2, -11, -11]</code></li>
</ul>
</li>
<li>
<p>由于数字的范围是 <code>[-10, 10]</code>，所以这里我用 <code>-11</code> 来表示该子集在上次遍历的时候没有新加入数字</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> subsetsWithDup = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    nums.<span class="title function_">sort</span>()</span><br><span class="line">    <span class="keyword">let</span> res = [[]]</span><br><span class="line">    <span class="keyword">let</span> last = [-<span class="number">11</span>]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 每次有加入数字/不加入数字两个选项</span></span><br><span class="line">        <span class="keyword">const</span> tmp = []</span><br><span class="line">        <span class="keyword">const</span> nxt = []</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; res.<span class="property">length</span>; j++)&#123;</span><br><span class="line">            tmp.<span class="title function_">push</span>(res[j])</span><br><span class="line">            nxt.<span class="title function_">push</span>(nums[i])</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != last[j]) &#123;</span><br><span class="line">                tmp.<span class="title function_">push</span>([...res[j],nums[i]])</span><br><span class="line">                nxt.<span class="title function_">push</span>(-<span class="number">11</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = tmp</span><br><span class="line">        last = nxt</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>3.30</strong></p>
<p>昨日事多，刷题没写日志</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="74-搜索二维矩阵"><a href="https://leetcode-cn.com/problems/search-a-2d-matrix/">74. 搜索二维矩阵</a></h4>
<p>难度中等352</p>
<p>编写一个高效的算法来判断 <code>m x n</code> 矩阵中，是否存在一个目标值。该矩阵具有如下特性：</p>
<ul>
<li>每行中的整数从左到右按升序排列。</li>
<li>每行的第一个整数大于前一行的最后一个整数。</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li><code>-104 &lt;= matrix[i][j], target &lt;= 104</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>两周之前刷过的一道题，写两种思路</p>
<ul>
<li>一维的二分
<ul>
<li>先根据第一列数字确定 <code>target</code> 可能出现的行</li>
<li>再到对应行，利用 <code>index</code> （本质是二分），寻找 <code>target</code></li>
</ul>
</li>
<li>二维的二分
<ul>
<li>可以把二维数组的每行抽出来拼到一起，抽象出来之后对这个二维数组本身直接二分搜索即可</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchMatrix</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 二维二分</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        left, right = <span class="number">0</span>, m * n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left &lt;= right:</span><br><span class="line">            mid = (left + right) // <span class="number">2</span></span><br><span class="line">            row, col = mid // n, mid % n</span><br><span class="line">            <span class="keyword">if</span> matrix[row][col] &lt; target:</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> matrix[row][col] &gt; target:</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><strong>3.28</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="173-二叉搜索树迭代器"><a href="https://leetcode-cn.com/problems/binary-search-tree-iterator/">173. 二叉搜索树迭代器</a></h4>
<p>难度中等</p>
<p>实现一个二叉搜索树迭代器类<code>BSTIterator</code> ，表示一个按中序遍历二叉搜索树（BST）的迭代器：</p>
<ul>
<li><code>BSTIterator(TreeNode root)</code> 初始化 <code>BSTIterator</code> 类的一个对象。BST 的根节点 <code>root</code> 会作为构造函数的一部分给出。指针应初始化为一个不存在于 BST 中的数字，且该数字小于 BST 中的任何元素。</li>
<li><code>boolean hasNext()</code> 如果向指针右侧遍历存在数字，则返回 <code>true</code> ；否则返回 <code>false</code> 。</li>
<li><code>int next()</code>将指针向右移动，然后返回指针处的数字。</li>
</ul>
<p>注意，指针初始化为一个不存在于 BST 中的数字，所以对 <code>next()</code> 的首次调用将返回 BST 中的最小元素。</p>
<p>你可以假设 <code>next()</code> 调用总是有效的，也就是说，当调用 <code>next()</code> 时，BST 的中序遍历中至少存在一个下一个数字。</p>
<p><strong>示例：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;]</span><br><span class="line">[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]</span><br><span class="line">输出</span><br><span class="line">[null, 3, 7, true, 9, true, 15, true, 20, false]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">BSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);</span><br><span class="line">bSTIterator.next();    // 返回 3</span><br><span class="line">bSTIterator.next();    // 返回 7</span><br><span class="line">bSTIterator.hasNext(); // 返回 True</span><br><span class="line">bSTIterator.next();    // 返回 9</span><br><span class="line">bSTIterator.hasNext(); // 返回 True</span><br><span class="line">bSTIterator.next();    // 返回 15</span><br><span class="line">bSTIterator.hasNext(); // 返回 True</span><br><span class="line">bSTIterator.next();    // 返回 20</span><br><span class="line">bSTIterator.hasNext(); // 返回 False</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>树中节点的数目在范围 <code>[1, 105]</code> 内</li>
<li><code>0 &lt;= Node.val &lt;= 106</code></li>
<li>最多调用 <code>105</code> 次 <code>hasNext</code> 和 <code>next</code> 操作</li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>你可以设计一个满足下述条件的解决方案吗？<code>next()</code> 和 <code>hasNext()</code> 操作均摊时间复杂度为 <code>O(1)</code> ，并使用 <code>O(h)</code> 内存。其中 <code>h</code> 是树的高度。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>迭代，利用栈模拟递归</p>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">TreeNode</span>&#125; <span class="variable">root</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">BSTIterator</span> = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stk</span> = []</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cur</span> = root</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">BSTIterator</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">next</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">cur</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">stk</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">cur</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">cur</span> = <span class="variable language_">this</span>.<span class="property">cur</span>.<span class="property">left</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cur</span> = <span class="variable language_">this</span>.<span class="property">stk</span>.<span class="title function_">pop</span>()</span><br><span class="line">    <span class="keyword">const</span> res = <span class="variable language_">this</span>.<span class="property">cur</span>.<span class="property">val</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">cur</span> = <span class="variable language_">this</span>.<span class="property">cur</span>.<span class="property">right</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">BSTIterator</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hasNext</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">stk</span>.<span class="property">length</span> &gt; <span class="number">0</span> || <span class="variable language_">this</span>.<span class="property">cur</span> !== <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>3.27</strong></p>
<p>美好的周六，哦哈哟</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="61-旋转链表"><a href="https://leetcode-cn.com/problems/rotate-list/">61. 旋转链表</a></h4>
<p>难度中等</p>
<p>给你一个链表的头节点 <code>head</code> ，旋转链表，将链表每个节点向右移动 <code>k</code> 个位置。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/rotate1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], k = 2</span><br><span class="line">输出：[4,5,1,2,3]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/roate2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [0,1,2], k = 4</span><br><span class="line">输出：[2,0,1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 500]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li><code>0 &lt;= k &lt;= 2 * 10^9</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>经典快慢指针，和之前一道好像叫翻转链表的题目差不多，思路也几乎一样。区别是之前那道题的 <code>k</code> 是比链表小的，所以快指针不会超过尾结点。</p>
<ul>
<li>快慢指针指向头结点</li>
<li>先将快指针往后移动 <code>k</code> 个位置
<ul>
<li>由于题目说明 <code>k &lt;= 2*10^9</code>，所以直接往后移动 <code>k</code> 个位置是很浪费时间的</li>
<li>考虑到结点数目小于 500，于是在第一次向后移动的时候，我们会记录下链表的长度</li>
<li>当快指针指向尾结点的时候，通过链表长度和 <code>k</code>，我们可以直接计算出还应该往后移动多少个单位</li>
</ul>
</li>
<li>当快指针在合适的位置之后，令快慢指针同时向后移，直到快指针指向尾结点</li>
<li>这个时候把慢指针后面的那段链表拼接到头节点前面即可</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> rotateRight = <span class="keyword">function</span>(<span class="params">head, k</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (! head) &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head)</span><br><span class="line">    <span class="keyword">let</span> fast = head</span><br><span class="line">    <span class="keyword">let</span> slow = head</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 先将快指针往后移动k个</span></span><br><span class="line">    <span class="keyword">while</span> (k&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast.<span class="property">next</span>) &#123;</span><br><span class="line">            fast = fast.<span class="property">next</span></span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            fast = head</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">            k %= cnt</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 两根指针同时往后移，直到快指针指向尾结点</span></span><br><span class="line">    <span class="keyword">while</span>(fast.<span class="property">next</span>) &#123;</span><br><span class="line">        fast = fast.<span class="property">next</span></span><br><span class="line">        slow = slow.<span class="property">next</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将慢指针后面的链表迁移到原头节点前</span></span><br><span class="line">    fast.<span class="property">next</span> = dummy.<span class="property">next</span></span><br><span class="line">    dummy.<span class="property">next</span> = slow.<span class="property">next</span></span><br><span class="line">    slow.<span class="property">next</span> = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="property">next</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>3.26</strong></p>
<p>昨天每日一题的简化版。</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="83-删除排序链表中的重复元素"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h4>
<p>难度简单</p>
<p>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除所有重复的元素，使每个元素 <strong>只出现一次</strong> 。</p>
<p>返回同样按升序排列的结果链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/04/list1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,1,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/04/list2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,1,2,3,3]</span><br><span class="line">输出：[1,2,3]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目在范围 <code>[0, 300]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li>题目数据保证链表已经按升序排列</li>
</ul>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteDuplicates = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">101</span>, head)</span><br><span class="line">    <span class="keyword">let</span> node = dummy</span><br><span class="line">    <span class="keyword">while</span>(node.<span class="property">next</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">next</span>.<span class="property">val</span> == node.<span class="property">val</span>) &#123;</span><br><span class="line">            node.<span class="property">next</span> = node.<span class="property">next</span>.<span class="property">next</span> </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = node.<span class="property">next</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="property">next</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>3.25</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="82-删除排序链表中的重复元素-II"><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></h4>
<p>难度中等</p>
<p>存在一个按升序排列的链表，给你这个链表的头节点 <code>head</code> ，请你删除链表中所有存在数字重复情况的节点，只保留原始链表中 <strong>没有重复出现</strong> 的数字。</p>
<p>返回同样按升序排列的结果链表。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,3,4,4,5]</span><br><span class="line">输出：[1,2,5]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2021/01/04/linkedlist2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,1,1,2,3]</span><br><span class="line">输出：[2,3]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点数目在范围 <code>[0, 300]</code> 内</li>
<li><code>-100 &lt;= Node.val &lt;= 100</code></li>
<li>题目数据保证链表已经按升序排列</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>一次遍历</p>
<p>设置一个哑节点 <code>dummy</code> 放到 <code>head</code> 的前面，从 <code>dummy</code> 开始向后遍历。</p>
<p>当遇到后一个结点的值和后一个的后一个的结点的值一样的时候，就记录下后一个结点的值 <code>x</code>，然后把之后所有值为 <code>x</code> 的结点全部去掉。</p>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> deleteDuplicates = <span class="keyword">function</span>(<span class="params">head</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> dummy = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>)</span><br><span class="line">    dummy.<span class="property">next</span> = head</span><br><span class="line">    <span class="keyword">let</span> node = dummy</span><br><span class="line">    <span class="keyword">while</span>(node.<span class="property">next</span> &amp;&amp; node.<span class="property">next</span>.<span class="property">next</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">next</span>.<span class="property">val</span> == node.<span class="property">next</span>.<span class="property">next</span>.<span class="property">val</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> x = node.<span class="property">next</span>.<span class="property">val</span></span><br><span class="line">            <span class="keyword">while</span> (node.<span class="property">next</span> &amp;&amp; node.<span class="property">next</span>.<span class="property">val</span> == x) &#123;</span><br><span class="line">                node.<span class="property">next</span> = node.<span class="property">next</span>.<span class="property">next</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node = node.<span class="property">next</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="property">next</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>3.24</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="456-132模式"><a href="https://leetcode-cn.com/problems/132-pattern/">456. 132模式</a></h4>
<p>难度中等363</p>
<p>给你一个整数数组 <code>nums</code> ，数组中共有 <code>n</code> 个整数。<strong>132 模式的子序列</strong> 由三个整数 <code>nums[i]</code>、<code>nums[j]</code> 和 <code>nums[k]</code> 组成，并同时满足：<code>i &lt; j &lt; k</code> 和 <code>nums[i] &lt; nums[k] &lt; nums[j]</code> 。</p>
<p>如果 <code>nums</code> 中存在 <strong>132 模式的子序列</strong> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>**进阶：**很容易想到时间复杂度为 <code>O(n^2)</code> 的解决方案，你可以设计一个时间复杂度为 <code>O(n logn)</code> 或 <code>O(n)</code> 的解决方案吗？</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：序列中不存在 132 模式的子序列。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,1,4,2]</span><br><span class="line">输出：true</span><br><span class="line">解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,3,2,0]</span><br><span class="line">输出：true</span><br><span class="line">解释：序列中有 3 个 132 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>n == nums.length</code></li>
<li><code>1 &lt;= n &lt;= 104</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
</ul>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find132pattern</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        left_min = [<span class="number">0</span>] * n</span><br><span class="line">        cur = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            cur = <span class="built_in">min</span>(cur, nums[i])</span><br><span class="line">            left_min[i] = cur</span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> stk <span class="keyword">and</span> stk[-<span class="number">1</span>] &lt;= left_min[j]:</span><br><span class="line">                stk.pop()</span><br><span class="line">            <span class="keyword">if</span> stk <span class="keyword">and</span> stk[-<span class="number">1</span>] &lt; nums[j]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            stk.append(nums[j])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><strong>3.22</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="341-扁平化嵌套列表迭代器"><a href="https://leetcode-cn.com/problems/flatten-nested-list-iterator/">341. 扁平化嵌套列表迭代器</a></h4>
<p>难度中等</p>
<p>给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。</p>
<p>列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [[1,1],2,[1,1]]</span><br><span class="line">输出: [1,1,2,1,1]</span><br><span class="line">解释: 通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,1,2,1,1]。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,[4,[6]]]</span><br><span class="line">输出: [1,4,6]</span><br><span class="line">解释: 通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,4,6]。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<ol>
<li>递归：在初始化函数中就利用深搜把数组处理成扁平的</li>
<li>迭代：在 <code>hasNext</code> 方法中用栈模拟递归，每次把栈顶元素转换成数字之后再返回 <code>True</code></li>
</ol>
<p><strong>代码</strong></p>
<p>递归</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NestedIterator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nestedList: [NestedInteger]</span>):</span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">nestedList</span>):</span><br><span class="line">            <span class="keyword">for</span> nest <span class="keyword">in</span> nestedList:</span><br><span class="line">                <span class="keyword">if</span> nest.isInteger():</span><br><span class="line">                    nums.append(nest.getInteger())</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dfs(nest.getList())</span><br><span class="line">        dfs(nestedList)</span><br><span class="line">        self.val = nums[::-<span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.val.pop()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasNext</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.val):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>迭代</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NestedIterator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nestedList: [NestedInteger]</span>):</span><br><span class="line">        self.stk = nestedList</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">next</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.stk.pop(<span class="number">0</span>).getInteger()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasNext</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">while</span> self.stk:</span><br><span class="line">            <span class="keyword">if</span> self.stk[<span class="number">0</span>].isInteger():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nest = self.stk.pop(<span class="number">0</span>)</span><br><span class="line">                self.stk = nest.getList() + self.stk</span><br></pre></td></tr></table></figure>
<p><strong>3.21</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="73-矩阵置零"><a href="https://leetcode-cn.com/problems/set-matrix-zeroes/">73. 矩阵置零</a></h4>
<p>难度中等428</p>
<p>给定一个 <code>*m* x *n*</code> 的矩阵，如果一个元素为 <strong>0</strong> ，则将其所在行和列的所有元素都设为 <strong>0</strong> 。请使用 <strong><a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 算法**。**</p>
<p><strong>进阶：</strong></p>
<ul>
<li>一个直观的解决方案是使用  <code>O(*m**n*)</code> 的额外空间，但这并不是一个好的解决方案。</li>
<li>一个简单的改进方案是使用 <code>O(*m* + *n*)</code> 的额外空间，但这仍然不是最好的解决方案。</li>
<li>你能想出一个仅使用常量空间的解决方案吗？</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">输出：[[1,0,1],[0,0,0],[1,0,1]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]</span><br><span class="line">输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>跟着题目中的进阶方案思路去思考</p>
<blockquote>
<ul>
<li>一个直观的解决方案是使用  <code>O(m*n)</code> 的额外空间，但这并不是一个好的解决方案。</li>
</ul>
</blockquote>
<p>直接克隆原矩阵，然后遍历原矩阵，如果遇到 <code>0</code> 就将新矩阵中的对应行和列置 <code>0</code>。</p>
<blockquote>
<ul>
<li>一个简单的改进方案是使用 <code>O(m + n)</code> 的额外空间，但这仍然不是最好的解决方案。</li>
</ul>
</blockquote>
<p>新建两个数组 <code>rows, cols</code>，遍历一遍原矩阵存储需要被置 <code>0</code> 的行和列，然后根据这两个数组对行和列进行置 <code>0</code>。</p>
<blockquote>
<ul>
<li>你能想出一个仅使用常量空间的解决方案吗？</li>
</ul>
</blockquote>
<p>看了题解，真是鬼才。用第一行和第一列的来作为我们刚刚设置的两个数组，标记需要被置 <code>0</code> 的行和列。不过需要另外设置两个变量来记录第一行和第一列中有没有原生的0。</p>
<p>题解中给出了只需要一个变量的解法，思路是</p>
<p><strong>3.20</strong></p>
<p>昨天的题目太降智了，没记下来。</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="150-逆波兰表达式求值"><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h4>
<p>难度中等</p>
<p>根据<a href="https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437"> 逆波兰表示法</a>，求表达式的值。</p>
<p>有效的算符包括 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</p>
<p><strong>说明：</strong></p>
<ul>
<li>整数除法只保留整数部分。</li>
<li>给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：tokens = [&quot;2&quot;,&quot;1&quot;,&quot;+&quot;,&quot;3&quot;,&quot;*&quot;]</span><br><span class="line">输出：9</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：tokens = [&quot;4&quot;,&quot;13&quot;,&quot;5&quot;,&quot;/&quot;,&quot;+&quot;]</span><br><span class="line">输出：6</span><br><span class="line">解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：tokens = [&quot;10&quot;,&quot;6&quot;,&quot;9&quot;,&quot;3&quot;,&quot;+&quot;,&quot;-11&quot;,&quot;*&quot;,&quot;/&quot;,&quot;*&quot;,&quot;17&quot;,&quot;+&quot;,&quot;5&quot;,&quot;+&quot;]</span><br><span class="line">输出：22</span><br><span class="line">解释：</span><br><span class="line">该算式转化为常见的中缀算术表达式为：</span><br><span class="line">  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5</span><br><span class="line">= ((10 * 0) + 17) + 5</span><br><span class="line">= (0 + 17) + 5</span><br><span class="line">= 17 + 5</span><br><span class="line">= 22</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= tokens.length &lt;= 104</code></li>
<li><code>tokens[i]</code> 要么是一个算符（<code>&quot;+&quot;</code>、<code>&quot;-&quot;</code>、<code>&quot;*&quot;</code> 或 <code>&quot;/&quot;</code>），要么是一个在范围 <code>[-200, 200]</code> 内的整数</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>Leetcode 直接把解题方法写在了问题的后面。</p>
<hr>
<p><strong>逆波兰表达式：</strong></p>
<p>逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</p>
<ul>
<li>平常使用的算式则是一种中缀表达式，如 <code>( 1 + 2 ) * ( 3 + 4 )</code> 。</li>
<li>该算式的逆波兰表达式写法为 <code>( ( 1 2 + ) ( 3 4 + ) * )</code> 。</li>
</ul>
<p>逆波兰表达式主要有以下两个优点：</p>
<ul>
<li>去掉括号后表达式无歧义，上式即便写成 <code>1 2 + 3 4 + * </code>也可以依据次序计算出正确结果。</li>
<li>适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</li>
</ul>
<hr>
<p>我们直接跟着他的指示，用栈这么做就行了。记得上次遇到这个逆波兰表达式还是在大二上学期的数据结构课上，当时老师会让我们手动转成逆波兰和波兰表达式。</p>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string[]</span>&#125; <span class="variable">tokens</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> evalRPN = <span class="keyword">function</span>(<span class="params">tokens</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> nums = <span class="keyword">new</span> <span class="title class_">Array</span>()</span><br><span class="line">    <span class="keyword">const</span> n = tokens.<span class="property">length</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> token = tokens[i]</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">isNumber</span>(token)) &#123;</span><br><span class="line">            nums.<span class="title function_">push</span>(<span class="title class_">Number</span>(token))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> num2 = nums.<span class="title function_">pop</span>()</span><br><span class="line">            <span class="keyword">const</span> num1 = nums.<span class="title function_">pop</span>()</span><br><span class="line">            <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> (token == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                res = num1 + num2</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(token == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                res = num1 - num2</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                res = num1 * num2</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                res = <span class="built_in">parseInt</span>(num1 / num2)</span><br><span class="line">            &#125;</span><br><span class="line">            nums.<span class="title function_">push</span>(res)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isNumber</span> = (<span class="params">token</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> !(token == <span class="string">&#x27;+&#x27;</span> || token == <span class="string">&#x27;-&#x27;</span> || token == <span class="string">&#x27;*&#x27;</span> || token == <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.18</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="115-不同的子序列"><a href="https://leetcode-cn.com/problems/distinct-subsequences/">115. 不同的子序列</a></h4>
<p>难度困难</p>
<p>给定一个字符串 <code>s</code> 和一个字符串 <code>t</code> ，计算在 <code>s</code> 的子序列中 <code>t</code> 出现的个数。</p>
<p>字符串的一个 <strong>子序列</strong> 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，<code>&quot;ACE&quot;</code> 是 <code>&quot;ABCDE&quot;</code> 的一个子序列，而 <code>&quot;AEC&quot;</code> 不是）</p>
<p>题目数据保证答案符合 32 位带符号整数范围。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;rabbbit&quot;, t = &quot;rabbit&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">如下图所示, 有 3 种可以从 s 中得到 &quot;rabbit&quot; 的方案。</span><br><span class="line">(上箭头符号 ^ 表示选取的字母)</span><br><span class="line">rabbbit</span><br><span class="line">^^^^ ^^</span><br><span class="line">rabbbit</span><br><span class="line">^^ ^^^^</span><br><span class="line">rabbbit</span><br><span class="line">^^^ ^^^</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;babgbag&quot;, t = &quot;bag&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：</span><br><span class="line">如下图所示, 有 5 种可以从 s 中得到 &quot;bag&quot; 的方案。 </span><br><span class="line">(上箭头符号 ^ 表示选取的字母)</span><br><span class="line">babgbag</span><br><span class="line">^^ ^</span><br><span class="line">babgbag</span><br><span class="line">^^    ^</span><br><span class="line">babgbag</span><br><span class="line">^    ^^</span><br><span class="line">babgbag</span><br><span class="line">  ^  ^^</span><br><span class="line">babgbag</span><br><span class="line">    ^^^</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length, t.length &lt;= 1000</code></li>
<li><code>s</code> 和 <code>t</code> 由英文字母组成</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>动态规划，设字符串 <code>s</code> 长度为 <code>m</code>，<code>t</code> 长度为 <code>n</code></p>
<ul>
<li>DP table：<code>m+1</code> 行，<code>n+1</code> 列，初始化为 <code>0</code>，<code>dp[i][j]</code> 代表的是 <code>s[i:]</code> 中子序列 <code>t[j:]</code> 的个数。</li>
<li>Base case：最后一列，即 <code>j = n</code> 的时候，目标子序列为空串，则子串数应该为 <code>1</code>；最后一行，即当 <code>i = m</code> 的时候，无论目标子序列为何，自身都是空串，所以子串数为 <code>0</code>。</li>
<li>状态转移方程：考虑 <code>dp[i][j]</code> 的大小的时候，应该分两种递推的情况
<ul>
<li><code>s[i] == t[j]</code>，此时当前的子序列是可以直接从各字符串的后一个位置递推过来 <code>dp[i][j] += dp[i+1][j+1]</code>，当然也可以从当前字符串的后一个位置递推过来 <code>dp[i][j] += dp[i+1][j]</code></li>
<li><code>s[i] != t[j]</code>，这个时候就必不能匹配当前位置，则只能 <code>dp[i][j] += dp[i+1][j]</code></li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numDistinct</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m, n= <span class="built_in">len</span>(s), <span class="built_in">len</span>(t)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m + <span class="number">1</span>)]</span><br><span class="line">        <span class="comment"># dp[i][j] 代表的意思是 s[i:] 和 t[j:] 的子序列数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 最后一列初始化为 1</span></span><br><span class="line">            dp[i][n] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 最后一行初始化为 0</span></span><br><span class="line">            dp[m][i] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i] == t[j]:</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j+<span class="number">1</span>] + dp[i+<span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p><strong>3.17</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="118-杨辉三角"><a href="https://leetcode-cn.com/problems/pascals-triangle/">118. 杨辉三角</a></h4>
<p>难度简单</p>
<p>给定一个非负整数 <code>numRows</code>，生成杨辉三角的前 <code>numRows</code> 行。</p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">numRows</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> generate = <span class="keyword">function</span>(<span class="params">numRows</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(i+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">            arr[j] = res[i-<span class="number">1</span>][j-<span class="number">1</span>] + res[i-<span class="number">1</span>][j]</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="title function_">push</span>(arr)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>3.15</strong></p>
<p>久违的原题</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="54-螺旋矩阵"><a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵</a></h4>
<p>难度中等</p>
<p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[1,2,3,6,9,8,7,4,5]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span><br><span class="line">输出：[1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 10</code></li>
<li><code>-100 &lt;= matrix[i][j] &lt;= 100</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<ol>
<li>模拟螺旋：想象成有一个小人从左上角出发，他的方向顺序分别是：<code>[右，下，左，上]</code>，当即将撞到墙或者走上回头路的时候，小人都会非常机智地调整方向。</li>
<li>按圈迭代：将整个迷宫看成由若干个矩形边框组成，这个边框由最外层往最里层，逐渐缩小。每次只需要确定一个左上角，一个右下角，就可以很方便地遍历整个方框。我们依次迭代左上角和右下角的位置，直到两个点重合。</li>
</ol>
<p><strong>代码</strong></p>
<p>模拟螺旋</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">spiralOrder</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 右 下 左 上</span></span><br><span class="line">        directions = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>], [-<span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        visited = [[<span class="number">0</span>]* n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        i, j, k = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        res.append(matrix[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        x, y = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m*n-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> (<span class="number">0</span> &lt;= i + x &lt; m) <span class="keyword">or</span> <span class="keyword">not</span>(<span class="number">0</span> &lt;= j + y &lt; n) <span class="keyword">or</span> visited[i+x][j+y]:</span><br><span class="line">                k = (k + <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">                x, y = directions[k]  </span><br><span class="line">            i += x</span><br><span class="line">            j += y</span><br><span class="line">            res.append(matrix[i][j])</span><br><span class="line">            visited[i][j] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>按圈迭代</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">matrix</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> spiralOrder = <span class="keyword">function</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    <span class="keyword">const</span> m = matrix.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">const</span> n = matrix[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>, bottom = <span class="number">0</span>, top = m - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right &amp;&amp; bottom &lt;= top)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = left; i &lt;= right; i++) res.<span class="title function_">push</span>(matrix[bottom][i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = bottom + <span class="number">1</span>; i &lt;= top; i++) res.<span class="title function_">push</span>(matrix[i][right])</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right &amp;&amp; bottom &lt; top) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = right - <span class="number">1</span>; i &gt; left; i--) res.<span class="title function_">push</span>(matrix[top][i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> i = top ; i &gt; bottom; i--) res.<span class="title function_">push</span>(matrix[i][left]);</span><br><span class="line">        &#125;   </span><br><span class="line">        [left, right, bottom, top] = [left + <span class="number">1</span>, right - <span class="number">1</span>, bottom + <span class="number">1</span>, top - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>3.14</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="706-设计哈希映射"><a href="https://leetcode-cn.com/problems/design-hashmap/">706. 设计哈希映射</a></h4>
<p>难度简单</p>
<p>不使用任何内建的哈希表库设计一个哈希映射（HashMap）。</p>
<p>实现 <code>MyHashMap</code> 类：</p>
<ul>
<li><code>MyHashMap()</code> 用空映射初始化对象</li>
<li><code>void put(int key, int value)</code> 向 HashMap 插入一个键值对 <code>(key, value)</code> 。如果 <code>key</code> 已经存在于映射中，则更新其对应的值 <code>value</code> 。</li>
<li><code>int get(int key)</code> 返回特定的 <code>key</code> 所映射的 <code>value</code> ；如果映射中不包含 <code>key</code> 的映射，返回 <code>-1</code> 。</li>
<li><code>void remove(key)</code> 如果映射中存在 <code>key</code> 的映射，则移除 <code>key</code> 和它所对应的 <code>value</code> 。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyHashMap&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;remove&quot;, &quot;get&quot;]</span><br><span class="line">[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, -1, null, 1, null, -1]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyHashMap myHashMap = new MyHashMap();</span><br><span class="line">myHashMap.put(1, 1); // myHashMap 现在为 [[1,1]]</span><br><span class="line">myHashMap.put(2, 2); // myHashMap 现在为 [[1,1], [2,2]]</span><br><span class="line">myHashMap.get(1);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,2]]</span><br><span class="line">myHashMap.get(3);    // 返回 -1（未找到），myHashMap 现在为 [[1,1], [2,2]]</span><br><span class="line">myHashMap.put(2, 1); // myHashMap 现在为 [[1,1], [2,1]]（更新已有的值）</span><br><span class="line">myHashMap.get(2);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,1]]</span><br><span class="line">myHashMap.remove(2); // 删除键为 2 的数据，myHashMap 现在为 [[1,1]]</span><br><span class="line">myHashMap.get(2);    // 返回 -1（未找到），myHashMap 现在为 [[1,1]]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= key, value &lt;= 106</code></li>
<li>最多调用 <code>104</code> 次 <code>put</code>、<code>get</code> 和 <code>remove</code> 方法</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>和昨天代码相差无几，昨天是直接存 <code>value</code>，今天是存键值对 <code>[key, value]</code></p>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize your data structure here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">MyHashMap</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">BASE</span> = <span class="number">769</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="variable language_">this</span>.<span class="property">BASE</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyHashMap</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hash</span> = <span class="keyword">function</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> key % <span class="variable language_">this</span>.<span class="property">BASE</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * value will always be non-negative. </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; key </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">value</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyHashMap</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">put</span> = <span class="keyword">function</span>(<span class="params">key, value</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> h = <span class="variable language_">this</span>.<span class="title function_">hash</span>(key);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> subArr <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">arr</span>[h]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (subArr[<span class="number">0</span>] == key) &#123;</span><br><span class="line">            subArr[<span class="number">1</span>] = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span>[h].<span class="title function_">push</span>([key, value]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">key</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyHashMap</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">get</span> = <span class="keyword">function</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> h = <span class="variable language_">this</span>.<span class="title function_">hash</span>(key);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> subArr <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">arr</span>[h])&#123;</span><br><span class="line">        <span class="keyword">if</span> (subArr[<span class="number">0</span>] == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> subArr[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the mapping of the specified value key if this map contains a mapping for the key </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">key</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyHashMap</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> h = <span class="variable language_">this</span>.<span class="title function_">hash</span>(key);</span><br><span class="line">    <span class="keyword">const</span> subs = <span class="variable language_">this</span>.<span class="property">arr</span>[h];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; subs.<span class="property">length</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(subs[i][<span class="number">0</span>] == key) &#123;</span><br><span class="line">            subs.<span class="title function_">splice</span>(i, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyHashMap object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new MyHashMap()</span></span><br><span class="line"><span class="comment"> * obj.put(key,value)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.get(key)</span></span><br><span class="line"><span class="comment"> * obj.remove(key)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p><strong>3.13</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="705-设计哈希集合"><a href="https://leetcode-cn.com/problems/design-hashset/">705. 设计哈希集合</a></h4>
<p>难度简单</p>
<p>不使用任何内建的哈希表库设计一个哈希集合（HashSet）。</p>
<p>实现 <code>MyHashSet</code> 类：</p>
<ul>
<li><code>void add(key)</code> 向哈希集合中插入值 <code>key</code> 。</li>
<li><code>bool contains(key)</code> 返回哈希集合中是否存在这个值 <code>key</code> 。</li>
<li><code>void remove(key)</code> 将给定值 <code>key</code> 从哈希集合中删除。如果哈希集合中没有这个值，什么也不做。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyHashSet&quot;, &quot;add&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;contains&quot;, &quot;add&quot;, &quot;contains&quot;, &quot;remove&quot;, &quot;contains&quot;]</span><br><span class="line">[[], [1], [2], [1], [3], [2], [2], [2], [2]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, true, false, null, true, null, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyHashSet myHashSet = new MyHashSet();</span><br><span class="line">myHashSet.add(1);      // set = [1]</span><br><span class="line">myHashSet.add(2);      // set = [1, 2]</span><br><span class="line">myHashSet.contains(1); // 返回 True</span><br><span class="line">myHashSet.contains(3); // 返回 False ，（未找到）</span><br><span class="line">myHashSet.add(2);      // set = [1, 2]</span><br><span class="line">myHashSet.contains(2); // 返回 True</span><br><span class="line">myHashSet.remove(2);   // set = [1]</span><br><span class="line">myHashSet.contains(2); // 返回 False ，（已移除）</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= key &lt;= 10^6</code></li>
<li>最多调用 <code>104</code> 次 <code>add</code>、<code>remove</code> 和 <code>contains</code> 。</li>
</ul>
<p>**进阶：**你可以不使用内建的哈希集合库解决此问题吗？</p>
</blockquote>
<p><strong>思路</strong></p>
<p>无脑法：开辟一个长度为 <code>10^6 + 1</code> 的数组，然后把出现的数字 <code>num</code> 放到 <code>index = num</code> 的位置上去，也就是不做哈希映射。</p>
<p>有脑法：去一个质数，把出现的数字 <code>num</code> 放到 <code>index = num mod 769</code> 的一个链表上去。</p>
<p><strong>代码</strong></p>
<p>无脑</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyHashSet</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.cnts = [<span class="number">0</span>] * <span class="number">1000001</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.cnts[key] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">remove</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> self.cnts[key]:</span><br><span class="line">            self.cnts[key] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">contains</span>(<span class="params">self, key: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns true if this set contains the specified element</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> self.cnts[key] &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>有脑</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initialize your data structure here.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">MyHashSet</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">BASE</span> = <span class="number">769</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="variable language_">this</span>.<span class="property">BASE</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">key</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyHashSet</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">add</span> = <span class="keyword">function</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> h = <span class="variable language_">this</span>.<span class="title function_">hash</span>(key);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> element <span class="keyword">of</span> <span class="variable language_">this</span>.<span class="property">data</span>[h]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (element == key) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>[h].<span class="title function_">push</span>(key);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">key</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyHashSet</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">remove</span> = <span class="keyword">function</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> h = <span class="variable language_">this</span>.<span class="title function_">hash</span>(key);</span><br><span class="line">    <span class="keyword">const</span> d = <span class="variable language_">this</span>.<span class="property">data</span>[h];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; d.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[i] == key) &#123;</span><br><span class="line">            d.<span class="title function_">splice</span>(i, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns true if this set contains the specified element </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">key</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">MyHashSet</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">contains</span> = <span class="keyword">function</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> h = <span class="variable language_">this</span>.<span class="title function_">hash</span>(key);</span><br><span class="line">    <span class="keyword">const</span> d = <span class="variable language_">this</span>.<span class="property">data</span>[h];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; d.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[i] == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyHashSet</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hash</span> = <span class="keyword">function</span>(<span class="params">key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> key % <span class="variable language_">this</span>.<span class="property">BASE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.12</strong></p>
<p>昨天又收到面试📞，next Wed MS 二面</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="331-验证二叉树的前序序列化"><a href="https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/">331. 验证二叉树的前序序列化</a></h4>
<p>难度中等</p>
<p>序列化二叉树的一种方法是使用前序遍历。当我们遇到一个非空节点时，我们可以记录下这个节点的值。如果它是一个空节点，我们可以使用一个标记值记录，例如 <code>#</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     _9_</span><br><span class="line">    /   \</span><br><span class="line">   3     2</span><br><span class="line">  / \   / \</span><br><span class="line"> 4   1  #  6</span><br><span class="line">/ \ / \   / \</span><br><span class="line"># # # #   # #</span><br></pre></td></tr></table></figure>
<p>例如，上面的二叉树可以被序列化为字符串 <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>，其中 <code>#</code> 代表一个空节点。</p>
<p>给定一串以逗号分隔的序列，验证它是否是正确的二叉树的前序序列化。编写一个在不重构树的条件下的可行算法。</p>
<p>每个以逗号分隔的字符或为一个整数或为一个表示 <code>null</code> 指针的 <code>'#'</code> 。</p>
<p>你可以认为输入格式总是有效的，例如它永远不会包含两个连续的逗号，比如 <code>&quot;1,,3&quot;</code> 。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;1,#&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;9,#,#,1&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p><a href="https://leetcode-cn.com/problems/verify-preorder-serialization-of-a-binary-tree/solution/yan-zheng-er-cha-shu-de-qian-xu-xu-lie-h-jghn/">官方题解</a>，这个方法针不戳，偷一张图过来。</p>
<img src="https://cdn.ethanloo.cn/img/20210312085419.png" alt="fig1" style="zoom: 33%;" />
<p>根据这个思路，我们只需要</p>
<ul>
<li>将初始槽位设为 <code>1</code>，可以理解为需要一个槽位放根节点，同时 <code>#</code> 也是合法的空树。</li>
<li>遍历一遍结点数组，遇到非空结点就 <code>++</code>，遇到空结点就 <code>--</code></li>
<li>如果遍历中发现槽位数小于 <code>0</code>，说明就构不成树了</li>
<li>最后返回 <code>槽位数 == 0</code></li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isValidSerialization</span>(<span class="params">self, preorder: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        nodes = preorder.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nodes:</span><br><span class="line">            <span class="keyword">if</span> cnt &lt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">                cnt -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">preorder</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isValidSerialization = <span class="keyword">function</span>(<span class="params">preorder</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> nodes = preorder.<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    <span class="keyword">let</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> node <span class="keyword">of</span> nodes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">            cnt -= <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt == <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>3.11</strong></p>
<p>MS 一面总算是过去了，马马虎虎吧，至少让我看到了或许对实习生的要求不会特别高</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="227-基本计算器-II"><a href="https://leetcode-cn.com/problems/basic-calculator-ii/">227. 基本计算器 II</a></h4>
<p>难度中等</p>
<p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p>
<p>整数除法仅保留整数部分。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;3+2*2&quot;</span><br><span class="line">输出：7</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot; 3/2 &quot;</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot; 3+5 / 2 &quot;</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 3 * 105</code></li>
<li><code>s</code> 由整数和算符 <code>('+', '-', '*', '/')</code> 组成，中间由一些空格隔开</li>
<li><code>s</code> 表示一个 <strong>有效表达式</strong></li>
<li>表达式中的所有整数都是非负整数，且在范围 <code>[0, 231 - 1]</code> 内</li>
<li>题目数据保证答案是一个 <strong>32-bit 整数</strong></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>用栈保存所有项，然后最后加起来，这里的项包括可以合并成一个数字的乘数法式子，比如 <code>3 + 1 * 2 - 4</code>，最后栈中应该就是三项 <code>[3, 2, -4]</code>。</p>
<p>遍历字符串，记录运算符和数字，并不断地压入栈，最后求栈的和即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        s = s.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>) <span class="comment"># 先去除字符串内的空格</span></span><br><span class="line">        s += <span class="string">&quot;+&quot;</span> <span class="comment"># 使得循环中能够处理最后一个项</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        num = <span class="built_in">int</span>()</span><br><span class="line">        nums = []</span><br><span class="line">        opt = <span class="string">&quot;+&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            ch = s[i]</span><br><span class="line">            <span class="keyword">if</span> ch.isdigit():</span><br><span class="line">                num = num * <span class="number">10</span> + <span class="built_in">int</span>(ch)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> opt == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    nums.append(num)</span><br><span class="line">                <span class="keyword">elif</span> opt == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    nums.append(-num)</span><br><span class="line">                <span class="keyword">elif</span> opt == <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                    nums.append(nums.pop() * num)</span><br><span class="line">                <span class="keyword">elif</span> opt == <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                    nums.append(<span class="built_in">int</span>(nums.pop() / num))</span><br><span class="line">                opt = s[i]</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(nums)</span><br></pre></td></tr></table></figure>
<p><strong>3.10</strong></p>
<p>昨天突然通知今天晚上 MS 实习面试，给爷紧张坏了。</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="224-基本计算器"><a href="https://leetcode-cn.com/problems/basic-calculator/">224. 基本计算器</a></h4>
<p>难度困难</p>
<p>实现一个基本的计算器来计算一个简单的字符串表达式 <code>s</code> 的值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;1 + 1&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot; 2-1 + 2 &quot;</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;(1+(4+5+2)-3)+(6+8)&quot;</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 3 * 105</code></li>
<li><code>s</code> 由数字、<code>'+'</code>、<code>'-'</code>、<code>'('</code>、<code>')'</code>、和 <code>' '</code> 组成</li>
<li><code>s</code> 表示一个有效的表达式</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>这道题因为没有乘法和除法，所以对于数值而言不需要用栈存储，只需要用栈存取运算符即可。</p>
<p>我们用 <code>1</code> 来代表 <code>+</code>，用 <code>-1</code> 代表 <code>+</code>，一开始默认为 <code>1</code>。</p>
<p>以 <code>1-(3-4)</code> 为例</p>
<ul>
<li><code>opt = 1, num = 0, res = 0</code></li>
<li>遍历到了 <code>1</code>，<code>opt = 1, num = 1, res = 0</code></li>
<li>遍历到了 <code>-</code>，要对运算符进行取反，而且由于不是数字，所以对之前的结果进行计算，<code>opt = -1, num = 0, res = 1</code></li>
<li>遍历到了 <code>(</code>，将之前的运算符压入栈（因为括号内的运算符不能影响外界），<code>stk = [1, -1]</code></li>
<li>遍历到了 <code>3</code>，暂存数字，<code>num = 3</code></li>
<li>遍历到了 <code>-</code>，对栈顶运算符取反，由于栈顶原来是 <code>-1</code>，所以现在的运算符变成了 <code>1</code>，即加号；同时计算之前暂存的数字</li>
<li>遍历到了 <code>4</code>，暂存数字</li>
<li>遍历到了 <code>)</code>，将栈顶的操作符压出，因为括号外要维持原运算符，计算暂存的数字</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stk = [<span class="number">1</span>] <span class="comment"># 存储标点符号的栈</span></span><br><span class="line">        s = s.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        res ,num, opt =<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> <span class="comment"># 默认初始的标点符号为 + </span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i.isdigit():</span><br><span class="line">                num = num * <span class="number">10</span> + <span class="built_in">int</span>(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res += num * opt</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> i == <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                    opt = stk[-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                    opt = -stk[-<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                    stk.append(opt)</span><br><span class="line">                <span class="keyword">elif</span> i == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                    stk.pop()</span><br><span class="line">        res += num * opt</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>3.9</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1047-删除字符串中的所有相邻重复项"><a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h4>
<p>难度简单</p>
<p>给出由小写字母组成的字符串 <code>S</code>，<strong>重复项删除操作</strong>会选择两个相邻且相同的字母，并删除它们。</p>
<p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p>
<p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;abbaca&quot;</span><br><span class="line">输出：&quot;ca&quot;</span><br><span class="line">解释：</span><br><span class="line">例如，在 &quot;abbaca&quot; 中，我们可以删除 &quot;bb&quot; 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 &quot;aaca&quot;，其中又只有 &quot;aa&quot; 可以执行重复项删除操作，所以最后的字符串为 &quot;ca&quot;。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= S.length &lt;= 20000</code></li>
<li><code>S</code> 仅由小写英文字母组成。</li>
</ol>
</blockquote>
<p><strong>思路</strong></p>
<p>一开始竟然朝着偶数长度的回文串这个思路去想了，属于前几天的后遗症吧，要抛弃这种思维定势。</p>
<p>其实就是很纯粹的用栈去判断是否要抛弃当前字母罢了。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, S: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(S)</span><br><span class="line">        stk = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stk <span class="keyword">or</span> stk[-<span class="number">1</span>] != i:</span><br><span class="line">                stk.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                stk.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(stk)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">S</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span>(<span class="params">S</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> stk = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> ch <span class="keyword">of</span> S) &#123;</span><br><span class="line">        <span class="keyword">if</span>(stk.<span class="property">length</span> == <span class="number">0</span> || stk[stk.<span class="property">length</span> - <span class="number">1</span>] != ch)&#123;</span><br><span class="line">            stk.<span class="title function_">push</span>(ch);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stk.<span class="title function_">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stk.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>3.8</strong></p>
<p>HAPPY WOMENS DAY</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="132-分割回文串-II"><a href="https://leetcode-cn.com/problems/palindrome-partitioning-ii/">132. 分割回文串 II</a></h4>
<p>难度困难</p>
<p>给你一个字符串 <code>s</code>，请你将 <code>s</code> 分割成一些子串，使每个子串都是回文。</p>
<p>返回符合要求的 <strong>最少分割次数</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aab&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：只需一次分割就可将 s 分割成 [&quot;aa&quot;,&quot;b&quot;] 这样两个回文子串。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ab&quot;</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 2000</code></li>
<li><code>s</code> 仅由小写英文字母组成</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>两次 DP</p>
<ol>
<li>
<p>第一次 DP 求出任意子串是否为回文串。</p>
</li>
<li>
<p>第二次 DP 求出最少需要分割多少次。</p>
</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minCut</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        f = [[<span class="literal">True</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n):</span><br><span class="line">                f[i][j] = f[i+<span class="number">1</span>][j-<span class="number">1</span>] <span class="keyword">and</span> (s[i] == s[j])</span><br><span class="line">        dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> f[<span class="number">0</span>][i]:</span><br><span class="line">                dp[i] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                    <span class="keyword">if</span> f[j+<span class="number">1</span>][i]:</span><br><span class="line">                        dp[i] = <span class="built_in">min</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p><strong>3.7</strong></p>
<p>又是菜到中等题看题解的一天。</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="131-分割回文串"><a href="https://leetcode-cn.com/problems/palindrome-partitioning/">131. 分割回文串</a></h4>
<p>难度中等522</p>
<p>给定一个字符串 <em>s</em>，将 <em>s</em> 分割成一些子串，使每个子串都是回文串。</p>
<p>返回 <em>s</em> 所有可能的分割方案。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;aab&quot;</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;aa&quot;,&quot;b&quot;],</span><br><span class="line">  [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>回溯（DFS）+ 动态规划</p>
<p>首先用动态规划的思想，求解出任意子串是否为回文串。</p>
<p>然后用 DFS 的方法，从头开始遍历字符串，在可能拆分成子串的时候进行递归。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        dp = [[<span class="literal">True</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n):</span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] <span class="keyword">and</span> (s[i] == s[j])</span><br><span class="line">        </span><br><span class="line">        res, tmp = [], []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            <span class="keyword">if</span> i == n:</span><br><span class="line">                res.append(tmp[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">                <span class="keyword">if</span> dp[i][j]:</span><br><span class="line">                    tmp.append(s[i:j+<span class="number">1</span>])</span><br><span class="line">                    dfs(j+<span class="number">1</span>)</span><br><span class="line">                    tmp.pop()</span><br><span class="line">        dfs(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>3.6</strong></p>
<p>回归校园，网易云 start！</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="503-下一个更大元素-II"><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></h4>
<p>难度中等</p>
<p>给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,1]</span><br><span class="line">输出: [2,-1,2]</span><br><span class="line">解释: 第一个 1 的下一个更大的数是 2；</span><br><span class="line">数字 2 找不到下一个更大的数； </span><br><span class="line">第二个 1 的下一个最大的数需要循环搜索，结果也是 2。</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong> 输入数组的长度不会超过 10000。</p>
</blockquote>
<p><strong>思路</strong></p>
<p>单调栈 + 循环数组。</p>
<p>单调栈，顾名思义就是从栈底到栈顶是单调递增或者单调递减的栈。本题中我们要构造的栈应该是递增栈。</p>
<p>栈中存放的是各个元素的下表，可以说是暂时还没有找到下一个更大元素的元素下标。</p>
<p>例如，<code>[1, 2, 1]</code>，一开始栈为 <code>[]</code>，所以栈中应该放入下标 <code>0</code>，当遍历到第二个元素的时候，发现 <code>2 &gt; 1</code>，所以这时候就找到了下标为 <code>0</code> 的元素的下一个更大元素，因此就把 <code>0</code> 压出栈，然后将下标 <code>1</code> 压入栈。</p>
<p>通过这个方法，还不能确保找到所有元素的下一个更大元素，例如 <code>[3, 2, 1]</code>，光遍历一遍数组是不够的，需要遍历两边，因此会用到循环数组。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElements</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        stk, res = [], [-<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n*<span class="number">2</span> - <span class="number">1</span>):</span><br><span class="line">            index = i % n</span><br><span class="line">            <span class="keyword">while</span> stk <span class="keyword">and</span> nums[stk[-<span class="number">1</span>]] &lt; nums[index]:</span><br><span class="line">                res[stk.pop()] = nums[index]</span><br><span class="line">            stk.append(index)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>3.5</strong></p>
<p>easy！</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="232-用栈实现队列"><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h4>
<p>难度简单</p>
<p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（<code>push</code>、<code>pop</code>、<code>peek</code>、<code>empty</code>）：</p>
<p>实现 <code>MyQueue</code> 类：</p>
<ul>
<li><code>void push(int x)</code> 将元素 x 推到队列的末尾</li>
<li><code>int pop()</code> 从队列的开头移除并返回元素</li>
<li><code>int peek()</code> 返回队列开头的元素</li>
<li><code>boolean empty()</code> 如果队列为空，返回 <code>true</code> ；否则，返回 <code>false</code></li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li>你只能使用标准的栈操作 —— 也就是只有 <code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。</li>
<li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li>
</ul>
<p><strong>进阶：</strong></p>
<ul>
<li>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyQueue&quot;, &quot;push&quot;, &quot;push&quot;, &quot;peek&quot;, &quot;pop&quot;, &quot;empty&quot;]</span><br><span class="line">[[], [1], [2], [], [], []]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, 1, false]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyQueue myQueue = new MyQueue();</span><br><span class="line">myQueue.push(1); // queue is: [1]</span><br><span class="line">myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)</span><br><span class="line">myQueue.peek(); // return 1</span><br><span class="line">myQueue.pop(); // return 1, queue is [2]</span><br><span class="line">myQueue.empty(); // return false</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= x &lt;= 9</code></li>
<li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code></li>
<li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>双栈模拟队列，似乎之前做过一个双队列模拟栈的，所以很快想到了这个方法。</p>
<p>虽然两个都是栈，但是我们使用的时候，第二个栈的逻辑是按照队列的倒叙考虑的。</p>
<p>对于 <code>push</code> 操作，所有的元素放到 <code>stk1</code> 中。</p>
<p>对于 <code>pop</code> 操作，由于需要返回的是队首的元素，也就是第一个进栈的元素，因此需要把 <code>stk1</code> 中的所有元素依次压出并压入 <code>stk2</code>。这样就实现了一个倒序的队列。即 <code>stk2</code> 的栈顶是队首元素，队伍依次从栈顶排到栈底，这样子出队顺序就合理了。因此 <code>pop</code> 掉 <code>stk2</code> 的栈顶元素即可。</p>
<p>对于 <code>peek</code> 操作，同上。</p>
<p>对于 <code>empty</code> 操作，只需要判断当前两个队列是否均为空。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.stk1 = []</span><br><span class="line">        self.stk2 = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Push element x to the back of queue.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.stk1.append(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Removes the element from in front of queue and returns that element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stk2:</span><br><span class="line">            <span class="keyword">while</span> self.stk1:</span><br><span class="line">                self.stk2.append(self.stk1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stk2.pop()</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">peek</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get the front element.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.stk2:</span><br><span class="line">            <span class="keyword">while</span> self.stk1:</span><br><span class="line">                self.stk2.append(self.stk1.pop())</span><br><span class="line">        <span class="keyword">return</span> self.stk2[-<span class="number">1</span>]</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">empty</span>(<span class="params">self</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Returns whether the queue is empty.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.stk1)+<span class="built_in">len</span>(self.stk2) == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MyQueue()</span></span><br><span class="line"><span class="comment"># obj.push(x)</span></span><br><span class="line"><span class="comment"># param_2 = obj.pop()</span></span><br><span class="line"><span class="comment"># param_3 = obj.peek()</span></span><br><span class="line"><span class="comment"># param_4 = obj.empty()</span></span><br></pre></td></tr></table></figure>
<p><strong>3.4</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="354-俄罗斯套娃信封问题"><a href="https://leetcode-cn.com/problems/russian-doll-envelopes/">354. 俄罗斯套娃信封问题</a></h4>
<p>难度困难</p>
<p>给定一些标记了宽度和高度的信封，宽度和高度以整数对形式 <code>(w, h)</code> 出现。当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。</p>
<p>请计算最多能有多少个信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。</p>
<p><strong>说明:</strong><br>
不允许旋转信封。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: envelopes = [[5,4],[6,4],[6,7],[2,3]]</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 最多信封的个数为 3, 组合为: [2,3] =&gt; [5,4] =&gt; [6,7]。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>把两个维度的问题分开考虑，我们首先按照宽度对信封进行升序排列，为了确保不会重复考虑一个宽度会算多个信封，需要对同样宽度的信封按降序排列。</p>
<p>为了尝试找到高度的最长递增序列，首先将第一封信的高度放到结果序列中，然后遍历剩下所有的信封高度。</p>
<p>算法流程：</p>
<ul>
<li>如果当前的高度比结果序列中的最后一个高度还要高，就直接放到序列尾部</li>
<li>否则，就把当前的高度插入到序列的合适的位置中去，通过二分查找的方式，找到当前高度能够插入的位置。这个位置保证了插入后的序列仍然是递增序列，而且这个位置的数可能会变小。</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxEnvelopes</span>(<span class="params">self, envelopes: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        envelopes.sort(key = <span class="keyword">lambda</span> x:(x[<span class="number">0</span>], -x[<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> envelopes: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        f = [envelopes[<span class="number">0</span>][<span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(envelopes)):</span><br><span class="line">            <span class="keyword">if</span> (num := envelopes[i][<span class="number">1</span>]) &gt; f[-<span class="number">1</span>]:</span><br><span class="line">                f.append(num)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                index = bisect.bisect_left(f, num) <span class="comment"># 找到num可以插入的位置</span></span><br><span class="line">                f[index] = num</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(f)</span><br></pre></td></tr></table></figure>
<p><strong>3.3</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="338-比特位计数"><a href="https://leetcode-cn.com/problems/counting-bits/">338. 比特位计数</a></h4>
<p>难度中等</p>
<p>给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num</strong> 范围中的每个数字 <strong>i</strong> ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 2</span><br><span class="line">输出: [0,1,1]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出: [0,1,1,2,1,2]</span><br></pre></td></tr></table></figure>
<p><strong>进阶:</strong></p>
<ul>
<li>给出时间复杂度为**O(n*sizeof(integer))<strong>的解答非常容易。但你可以在线性时间</strong>O(n)**内用一趟扫描做到吗？</li>
<li>要求算法的空间复杂度为<strong>O(n)</strong>。</li>
<li>你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 <strong>__builtin_popcount</strong>）来执行此操作。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>动态规划，参考官方题解。</p>
<p>以 7 为例，它的二进制形式为 111，一共 3 个 1，也就是比 6 多了个末尾的 1。</p>
<p>由此可以联想到，对于<strong>奇数</strong>来说，它们的二进制 1 的个数都比它们的前一个数字多一个，即最后一个 0 =&gt; 1。</p>
<p>由此得到递推式1：<code>res[i] = res[i-1] + 1</code></p>
<p>再次思考偶数的递推方式，对于 12 的二进制 1100，它的 1 的个数和 6 的二进制 110 相同，因为 12 是 6 的两倍，即左移一位。</p>
<p>因此，对于<strong>偶数</strong>来说，它们的二进制位数和它们除以二之后的数字相同。</p>
<p>由此得到递推式2：<code>res[i] = res[i//2]</code></p>
<p>本题的 Base case 为 <code>res[0] = 0</code>，因为 0 的二进制还是 0，没有1。</p>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">num</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> countBits = <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">new</span> <span class="title class_">Array</span>(num + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">            res[i] = res[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[i] = res[i/<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countBits</span>(<span class="params">self, num: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = [<span class="number">0</span>]*(num+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,num+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                res[i] = res[i-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res[i] = res[i//<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>3.2</strong></p>
<p>真就准备前缀和月呗。</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="304-二维区域和检索-矩阵不可变"><a href="https://leetcode-cn.com/problems/range-sum-query-2d-immutable/">304. 二维区域和检索 - 矩阵不可变</a></h4>
<p>难度中等</p>
<p>给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (<em>row</em>1, <em>col</em>1) ，右下角为 (<em>row</em>2, <em>col</em>2)。</p>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/images/304.png" alt="Range Sum Query 2D" style="zoom:50%;" />
上图子矩阵左上角 (row1, col1) = **(2, 1)** ，右下角(row2, col2) = **(4, 3)，**该子矩形内元素的总和为 8。
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定 matrix = [</span><br><span class="line">  [3, 0, 1, 4, 2],</span><br><span class="line">  [5, 6, 3, 2, 1],</span><br><span class="line">  [1, 2, 0, 1, 5],</span><br><span class="line">  [4, 1, 0, 1, 7],</span><br><span class="line">  [1, 0, 3, 0, 5]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">sumRegion(2, 1, 4, 3) -&gt; 8</span><br><span class="line">sumRegion(1, 1, 2, 2) -&gt; 11</span><br><span class="line">sumRegion(1, 2, 2, 4) -&gt; 12</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ol>
<li>你可以假设矩阵不可变。</li>
<li>会多次调用 <em>sumRegion</em> 方法*。*</li>
<li>你可以假设 <em>row</em>1 ≤ <em>row</em>2 且 <em>col</em>1 ≤ <em>col</em>2。</li>
</ol>
</blockquote>
<p><strong>思路</strong></p>
<p>是昨天题目的二维版本，很明显有两种解法。</p>
<ol>
<li>看作是多行的一维前缀和数组，构造函数时间复杂度为 <code>O(mn)</code>， 查询区域和的时间复杂度为 <code>O(N)</code></li>
<li>直接看作二维的前缀和数组，即每一个位置的数代表的是从左上角加到这个位置的总和。构造函数时间复杂度 <code>O(mn)</code>，查询区域和的时间复杂度 <code>O(1)</code></li>
</ol>
<p>我为了继续熟悉 JS 语法，就使用了简单的第一种方法。</p>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">matrix</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">NumMatrix</span> = <span class="keyword">function</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> m = matrix.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">if</span>(m&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> n = matrix[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">allSums</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(m).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>;j&lt;n+<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="variable language_">this</span>.<span class="property">allSums</span>[i][j] = <span class="variable language_">this</span>.<span class="property">allSums</span>[i][j-<span class="number">1</span>] + matrix[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; row1 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; col1 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; row2 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">col2</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">NumMatrix</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sumRegion</span> = <span class="keyword">function</span>(<span class="params">row1, col1, row2, col2</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = row1; i &lt;= row2; i++)&#123;</span><br><span class="line">        res += <span class="variable language_">this</span>.<span class="property">allSums</span>[i][col2+<span class="number">1</span>]-<span class="variable language_">this</span>.<span class="property">allSums</span>[i][col1];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumMatrix object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new NumMatrix(matrix)</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.sumRegion(row1,col1,row2,col2)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p><strong>3.1</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="303-区域和检索-数组不可变"><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/">303. 区域和检索 - 数组不可变</a></h4>
<p>难度简单</p>
<p>给定一个整数数组  <code>nums</code>，求出数组从索引 <code>i</code> 到 <code>j</code><em>（</em><code>i ≤ j</code>）范围内元素的总和，包含 <code>i</code>、<code>j </code>两点。</p>
<p>实现 <code>NumArray</code> 类：</p>
<ul>
<li><code>NumArray(int[] nums)</code> 使用数组 <code>nums</code> 初始化对象</li>
<li><code>int sumRange(int i, int j)</code> 返回数组 <code>nums</code> 从索引 <code>i</code> 到 <code>j</code><em>（</em><code>i ≤ j</code>）范围内元素的总和，包含 <code>i</code>、<code>j </code>两点（也就是 <code>sum(nums[i], nums[i + 1], ... , nums[j])</code>）</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]</span><br><span class="line">[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]</span><br><span class="line">输出：</span><br><span class="line">[null, 1, -1, -3]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);</span><br><span class="line">numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)</span><br><span class="line">numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) </span><br><span class="line">numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 104</code></li>
<li><code>-105 &lt;= nums[i] &lt;= 105</code></li>
<li><code>0 &lt;= i &lt;= j &lt; nums.length</code></li>
<li>最多调用 <code>104</code> 次 <code>sumRange</code> 方法</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>前缀和数组，利用一个数组来记录数组前n项的和。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        sums = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            sums.append(i+sums[-<span class="number">1</span>])</span><br><span class="line">        self.sums = sums</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumRange</span>(<span class="params">self, i: <span class="built_in">int</span>, j: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.sums[j+<span class="number">1</span>]-self.sums[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = NumArray(nums)</span></span><br><span class="line"><span class="comment"># param_1 = obj.sumRange(i,j)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">NumArray</span> = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = nums.<span class="property">length</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sums</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(nums.<span class="property">length</span>+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>;i&lt;n+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">sums</span>[i] = <span class="variable language_">this</span>.<span class="property">sums</span>[i-<span class="number">1</span>] + nums[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; i </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">j</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">NumArray</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sumRange</span> = <span class="keyword">function</span>(<span class="params">i, j</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">sums</span>[j+<span class="number">1</span>]-<span class="variable language_">this</span>.<span class="property">sums</span>[i];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new NumArray(nums)</span></span><br><span class="line"><span class="comment"> * var param_1 = obj.sumRange(i,j)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题日志</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>微软暑期实习面筋</title>
    <url>/post/2021-02-28-Weber/%E5%BE%AE%E8%BD%AF%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E9%9D%A2%E7%BB%8F/</url>
    <content><![CDATA[<h2 id="2-28-笔试">2.28 笔试</h2>
<h3 id="笔试成绩">笔试成绩</h3>
<p><img src="https://cdn.ethanloo.cn/img/20210228213614.png" alt="image-20210228213614246"></p>
<p>这是最后的测试结果，算比较满意的一个结果吧，至少中等题（难度应该在中下）拿到分数了。</p>
<p>简单总结一下这次的考题吧。</p>
<h3 id="Task1">Task1</h3>
<p>由于我没有截图题目，所以就简单复述一下。</p>
<p><strong>题目要求</strong>：删除字符串 <code>S</code> 中的一个字符，使得最后的字符串的字典序尽可能小。</p>
<p>例如 <code>acb</code>，删除一个字符可以得到 <code>ac, ab, cb</code>，我们得到的结果应该是 <code>ab</code>，因为它的字典序最小。</p>
<p>属于之前在 Leetcode 上经常遇到的简单题了，实际上就是让字符串在头部尽可能递增，用到的数据结构算是递增数组吧。</p>
<p>具体算法流程见代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">S</span>):</span><br><span class="line">    <span class="comment"># 尽量保证字符串的开头为递增</span></span><br><span class="line">    res = []</span><br><span class="line">    n = <span class="built_in">len</span>(S)</span><br><span class="line">    <span class="keyword">for</span> i, s <span class="keyword">in</span> <span class="built_in">enumerate</span>(S):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">or</span> res[-<span class="number">1</span>] &lt;= s:</span><br><span class="line">            res.append(s)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 若出现递减</span></span><br><span class="line">            res.pop()</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">                res.append(S[j])</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(res) == n:</span><br><span class="line">        res.pop()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(res)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(solution(<span class="string">&#x27;acb&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h3 id="Task2">Task2</h3>
<p><strong>题目要求</strong>：针对数组 <code>S</code>，找出等和子数组的最大个数，要求子数组的为相邻的两个数且子数组之间不能有重叠部分。</p>
<p>以 <code>[10, 1, 3, 1, 2, 2, 1, 0, 4]</code> 为例，最大的等和子数组数为3，即 <code>[1, 3], [2, 2],[0, 4]</code> 或者 <code>[3, 1], [2, 2], [0, 4]</code></p>
<p>卡了我蛮久的，我花了大概四十分钟才发现这道题很简单。</p>
<p>用到的数据结构就是哈希表（字典），用字典 <code>dic</code> 来计算出现的和的个数。</p>
<p>假设每个数都只能和它左侧的数组合起来（和右侧数结合等价于右侧数和它左侧数结合），遍历数组。</p>
<p>若当前的数组和同上一个和不同，则说明可能出现该组合。例如，假设数组为  <code>[10, 1, 3]</code>，上一次的和是11，这一次的和是4，则令 <code>dic[4] += 1</code>。</p>
<p>反之，若当前的和同上一次的和相同，则不应该重复计数。例如 <code>[1, 3, 1]</code>，上一次的和是4，这一次的也是4，但是这个4是不可能出现两次的，所以这时不能使 <code>dic[4] += 1</code>。</p>
<p>但是还有一个情况要注意，<code>[1, 3, 1, 3]</code>，此时<code>1 + 3 = 4</code>， <code>3 + 1 = 4</code>，<code>1 + 3 =4</code>，虽然三次的和都相等，但是这种组合是允许出现两个4的，即分割成两个 <code>[1,3]</code>。为了区分这种情况，我是使用了 <code>flag</code> 变量来确认的，强大的读者应该可以想到更好的办法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">S</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(S)</span><br><span class="line">    dic = collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line">    last_sum = <span class="number">0</span></span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        cur_sum = S[i] + S[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> last_sum != cur_sum:</span><br><span class="line">            dic[cur_sum] += <span class="number">1</span></span><br><span class="line">            flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">                dic[cur_sum] += <span class="number">1</span></span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line">        last_sum = cur_sum</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dic.values())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(solution([<span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>]))</span><br></pre></td></tr></table></figure>
<h3 id="Task3">Task3</h3>
<p>很尴尬，这道题我提交的时候就知道我拿不了满分了，但是我确实无法想出时间复杂度为O(N)的解法了。👶</p>
<p><strong>题目要求</strong>：给定一个字符串 <code>S</code>，字符串的格式为 <code>aa?b?a</code>，要做的是把其中的 <code>?</code> 替换成 <code>a</code> 或者 <code>b</code>，而且要保证最后结果中不能有连续的三个 <code>a</code> 或者 <code>b</code>。</p>
<p>我的想法比较纯粹，深搜。就搜索各种可能的路径，将 <code>?</code> 替换成 <code>a</code> 或者 <code>b</code>，直到找到可能的解。</p>
<p>很可惜，题目的 N 限制的是小于 500,000，所以只拿到50分也是意料之中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solution</span>(<span class="params">S</span>):</span><br><span class="line">    res = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">houses, no, cnt_a, cnt_b</span>):</span><br><span class="line">        <span class="keyword">if</span> res:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> cnt_a == <span class="number">3</span> <span class="keyword">or</span> cnt_b == <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> no == <span class="built_in">len</span>(houses):</span><br><span class="line">            res.append(houses)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> houses[no] == <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            dfs(houses, no + <span class="number">1</span>, cnt_a+<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">elif</span> houses[no] == <span class="string">&#x27;b&#x27;</span>:</span><br><span class="line">            dfs(houses, no + <span class="number">1</span>, <span class="number">0</span>, cnt_b+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">elif</span> houses[no] == <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">            tmp = copy.deepcopy(houses)</span><br><span class="line">            tmp[no] = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">            dfs(tmp, no + <span class="number">1</span>, cnt_a + <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">            tmp = copy.deepcopy(houses)</span><br><span class="line">            tmp[no] = <span class="string">&#x27;b&#x27;</span></span><br><span class="line">            dfs(tmp, no + <span class="number">1</span>, <span class="number">0</span>, cnt_b + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    houses = <span class="built_in">list</span>(S)</span><br><span class="line">    dfs(houses, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(res[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(solution(<span class="string">&#x27;a?ab?b?b??b?b?ba??a?bb&#x27;</span>))</span><br></pre></td></tr></table></figure>
<h2 id="3-10-一面">3.10 一面</h2>
<p>3.9 号面试官突然约我明天面试，我吓一跳，原以为会拖得比较后面的。</p>
<p>自我介绍 =&gt; 为什么选择前端 =&gt; 询问博客相关技术（后来因为面试官的内网无法访问就略过了）</p>
<p>继续询问我的项目相关，然而无论是实验报告模块还是会议预约及门机管理模块，其实和前端相关的技术沾边很少，因此也只是草草略过。</p>
<p>在做页面展示的时候，面试官问我怎么解决缩放导致的字体位置和图标大小问题，我只能说改成以 <code>rem</code> 为单位来描述 <code>font-size</code> 或许对页面有优化。后因面试官也无法调试成功遂跳过。</p>
<h3 id="CSS">CSS</h3>
<p>问：盒模型？</p>
<p>答：关于盒模型答的马马虎虎，大概讲了由哪几部分组成，在 Chrome 中计算长宽和 IE 中计算长宽有什么区别。</p>
<p>问：<code>flex</code> 布局是否了解过？</p>
<p>答：我暂时还没有去了解过。</p>
<h3 id="JS">JS</h3>
<p>问：JS 了解到什么程度？</p>
<p>答：学习了 ES6 的语法。</p>
<p>问：<code>let, const, var</code> 区别？</p>
<p>答：<code>let</code> 定义变量，<code>const</code> 定义常量，<code>var</code> 定义全局变量。……</p>
<p>问：怎么确认语法的浏览器适配性？</p>
<p>答：查询 MDN 网站文档。</p>
<p>问：了解过闭包吗？</p>
<p>答：（刚看过就忘了）……</p>
<h3 id="算法">算法</h3>
<ol>
<li>
<p>确认链表是否有环</p>
<p>快慢指针，如果两个指针相遇就说明有环</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, value</span>):</span><br><span class="line">        self.val = value</span><br><span class="line">        self.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">head</span>):</span><br><span class="line">    slow, fast = head, head.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">        <span class="keyword">if</span> fast == slow:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    nums = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">2</span>, <span class="number">8</span>))</span><br><span class="line">    head = Node(<span class="number">1</span>)</span><br><span class="line">    nodes = [head]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        node = Node(i)</span><br><span class="line">        head.<span class="built_in">next</span> = node</span><br><span class="line">        nodes.append(node)</span><br><span class="line">        head = node</span><br><span class="line">    nodes[<span class="number">6</span>].<span class="built_in">next</span> = nodes[<span class="number">2</span>]</span><br><span class="line">    <span class="built_in">print</span>(func(nodes[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>找到有环链表中环的起始节点</p>
<blockquote>
<p>因为只讲出解法，没写出证明，还被面试官问是当场想出来的吗，我只能回答说做过题 😅</p>
</blockquote>
<p>思路和上题类似，快慢指针从链表头部出发，在第一次相遇之后，将快指针退回头部，重新出发，速度设为1，第二次相遇位置就是环的起始位置。</p>
</li>
</ol>
<h2 id="3-17-二面">3.17 二面</h2>
<p>上次面完第二天就约了我二面，为了巩固一下基础知识，我约在了一面的一周之后。</p>
<p>开局依然是自我介绍 =&gt; 介绍项目 =&gt; 项目难点？（真的讲不出）</p>
<h3 id="CSS-2">CSS</h3>
<p>问：讲一下 flex 布局吧</p>
<p>答：一个更加现代的布局方式，完美适配手机端，唯一问题是不兼容 IE。一般我们用的时候就使用 <code>.container &#123; flex: true &#125;</code>，来使用 flex 布局，然后内部元素如果都设置为 <code>flex: 1</code>，就会依次平均分配容器内区域。</p>
<p>问：<code>flex</code> 的两个参数是什么？</p>
<p>答：应该是三个参数吧，一般默认是 <code>1 1 auto</code>，第一个参数越大占比越大，第二个参数越大占比越小，第三个参数没有做深入了解。</p>
<h3 id="JS-2">JS</h3>
<p>问：可以简单介绍一下 ES6 中的 Promise吗？</p>
<p>答：一个用来进行异步处理的模块，可以有效解决回调地狱的问题。允许我们把异步操作写成链式调用，使代码更加优雅。</p>
<p>问：具体处理成功和失败的参数是什么？什么情况下会返回失败呢？</p>
<p>答：实际开发中没有正式用过，记不太清了…（正确答案应该是 <code>resolve</code> 和 <code>reject</code>，在 <code>Promise</code> 对象中，调用 <code>resolve()</code> 就是成功，<code>reject()</code> 就是拒绝）</p>
<p>然后又回到了我的项目上，先让我介绍了一下什么叫 MVC 框架，其中模型，视图，控制器各负责什么工作，如何交互。</p>
<p>问：如果一个表格的某一格的文字太长了该如何处理？</p>
<p>答：添加 CSS 属性 <code>&#123;overflow: hidden; text-overflow: ellipse; white-space: no-wrap&#125;</code></p>
<blockquote>
<p>这边一时间没想起来 <code>white-space</code>，面试官允许我搜了一下。</p>
</blockquote>
<h3 id="算法-2">算法</h3>
<p>问：能讲解一下搜索二叉树是什么，怎么实现的吗？</p>
<p>答：画出了一个图，然后演示了二叉树是怎么进行搜索（中间卡壳了，面试官引导了一下）。</p>
<blockquote>
<p>面试官应该是知道我答不出怎么实现的二叉搜索树，所以把问题换了个方向</p>
</blockquote>
<p>问：什么是平衡二叉树？怎么把非平衡二叉树转换成平衡二叉树？</p>
<p>答：平衡二叉树就是叶子的深度差小于等于 1 的树，不太确定该怎么平衡</p>
<blockquote>
<p>又在面试官的引导下，学会了怎么平衡二叉树</p>
</blockquote>
<p>问：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">最长递增子序列</a>（一开始是它的困难版，要求返回的是最长子序列本身）</p>
<p>我仍然是在面试官引导下，花了二十几分钟写出了个动归。一开始以为遍历一遍就能得到答案，一直没转过来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_longest</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="comment"># 最长非递减子序列</span></span><br><span class="line">    n = <span class="built_in">len</span>(nums)</span><br><span class="line">    dp = [<span class="number">1</span>] * (n)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">            <span class="keyword">if</span> nums[j] &lt;= nums[i]:</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[j] + <span class="number">1</span>, dp[i])</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp)</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">10</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(find_longest(nums))</span><br></pre></td></tr></table></figure>
<p>感觉有点悬，自己的算法和基础仍然不稳定。</p>
<h2 id="3-18-三面">3.18 三面</h2>
<p>项目 =&gt; <code>Vue</code> 框架和我之前使用的 <code>Laravel</code> 有什么区别 =&gt; 两道设计题</p>
<h3 id="设计题">设计题</h3>
<ol>
<li>
<p>如果现在我们拥有微信所有公众号的推送的阅读量数据，怎么获取某一天的阅读量的中位数</p>
<p>一开始我的思路是，根据阅读量的数据的出现频率先把所有的阅读量分成十个部分（各个堆里的数据量需要尽可能接近），比如我把 0-100 的数据放到第一个堆，101-300 的放到第二个堆…，最后大于 10000 的放到第十个堆。通过这个方法我能快速确认每个堆的数据量是多少，然后根据我的总数据量，首先确认中位数在哪一堆，再根据这个堆里的数据，确认中位数。</p>
<p>后来我又发现这样子计算的话最后还是需要 <code>O(NlogN)</code> 的时间复杂度对堆数据进行排序，不如直接用哈希表。</p>
<p>最后我就说新建一个哈希表，以 <code>阅读量=&gt;出现次数</code> 的键值对形式来存取所有的阅读量数据。我如果需要确定中位数，就从 <code>dic[0]</code> 开始加，一直加到数据量的一半的时候根据 <code>key</code> 的大小，就能确定中位数。</p>
<blockquote>
<p>由于阅读量的出现频率是随着阅读量的增加而减小的（宏观上），比如阅读量 100 的文章数必然是会比阅读量 100000 的文章多得多，所以我最后应该很快就能找到中位数所在的 <code>key</code></p>
</blockquote>
</li>
<li>
<p>怎么样优化网站，才能使用户下滑页面，异步加载更多新闻的时候体验更加流畅。</p>
<p>由于我没有实际做过这种开发，所以我只能回答出大概的思路：在用户的滚动条滑动到一定位置的时候，让用户提前开始加载他很可能即将访问到的数据，然后确保用户在滑到最底下之前，所需的数据全部传输完毕，最后开始渲染。我们可以收集一些数据并且对用户的网络速度进行一个假设，来确认这个开始传输数据的滚动条的位置。</p>
<blockquote>
<p>我真觉得我就跟讲故事一样，越讲越玄乎。</p>
</blockquote>
</li>
</ol>
<h3 id="算法-3">算法</h3>
<p>一道简单题直接把我脑子卡宕机了，在一个小 <code>trick</code> 上浪费了半个小时。</p>
<h4 id="168-Excel表列名称"><a href="https://leetcode-cn.com/problems/excel-sheet-column-title/">168. Excel表列名称</a></h4>
<h2 id="3-19">3.19</h2>
<p>内推学长告知等 offer 🤯</p>
<h2 id="4-6-Offer！">4.6 Offer！</h2>
<p>GET 💡</p>
<img src="https://cdn.ethanloo.cn/img/20210420130845.png" alt="image-20210410140356593" style="zoom:50%;" />]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>笔试</tag>
        <tag>实习</tag>
        <tag>微软</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery 基础</title>
    <url>/post/2021-02-27-Weber/jQuery%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="jQuery">jQuery</h2>
<p>引入 jQuery 的原因：</p>
<ul>
<li><code>window.onload</code> 有覆盖问题，只能写一个事件</li>
<li>代码容错性差</li>
<li>浏览器兼容性问题</li>
<li>代码量多</li>
<li>代码杂乱</li>
<li>动画实现繁琐</li>
</ul>
<p>jQuery 是 JS 的一个库，封装了一些常用的功能，方便调用，提高效率。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;zh-CN&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>EthanLoo&#x27;s<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./test.css&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">background-color</span>: <span class="number">#891</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">display</span>: none;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">1000px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">2000px</span>;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://ajax.googleapis.com/ajax/libs/jquery/1.8.0/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;test.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> btn = $(<span class="string">&quot;button&quot;</span>); <span class="comment">// 根据标签获取按钮</span></span><br><span class="line">  <span class="keyword">var</span> div = $(<span class="string">&quot;div&quot;</span>); <span class="comment">// 根据标签获取矩形</span></span><br><span class="line">  btn.<span class="title function_">click</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    div.<span class="title function_">show</span>(<span class="number">300</span>); <span class="comment">// 300ms 渐变出现</span></span><br><span class="line">    div.<span class="title function_">html</span>(<span class="string">&quot;233&quot;</span>); <span class="comment">// 标签内文本</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="jQuery-特点">jQuery 特点</h3>
<ul>
<li>链式编程，可以把 <code>div.show(300)</code> 和 <code>div.html('233')</code> 连写成 <code>div.show(300).html('233')</code></li>
<li>隐式迭代，在方法的内部为匹配到的所有元素进行循环遍历。</li>
</ul>
<h3 id="jQuery-使用步骤">jQuery 使用步骤</h3>
<ol>
<li>引包：<code>&lt;script src='jqery-1.*.min.js&gt;&lt;/script&gt;'</code></li>
<li>入口函数：<code>$(document).ready(function()&#123;&#125;)</code></li>
<li>事件处理</li>
</ol>
<p>开发版本一般用 1.10 以上</p>
<h3 id="入口函数">入口函数</h3>
<p>原生 JS 的入口函数为 <code>window.onload = function() &#123;&#125;</code>，作用是等页面上的所有内容加载完毕才执行函数。</p>
<p>jQuery 的入口函数写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 文档加载完毕，图片不加载的时候就会执行</span></span><br><span class="line">$(doument).<span class="title function_">ready</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">233</span>); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 文档加载完毕，图片不加载的时候会执行</span></span><br><span class="line">$(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">233</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 文档加载完毕，图片加载完毕的时候执行</span></span><br><span class="line">$(<span class="variable language_">window</span>).<span class="title function_">ready</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">233</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>jQuery 的入口函数和原生的区别：</p>
<ul>
<li>原生的入口函数只能出现一次，jQuery 的入口函数可以出现任意多次</li>
<li>JS 的入口函数只能在页面所有文件资源加载完成后执行，jQuery 的入口函数是在文档，即 DOM 树加载完成。</li>
</ul>
<h3 id="符号"><code>$</code> 符号</h3>
<p>jQuery 中使用的两个变量 <code>$</code> 和 <code>jQuery</code>，两者等价，都相当于一个函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="variable language_">document</span>).<span class="title function_">ready</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;); <span class="comment">// 调用入口函数</span></span><br><span class="line">$(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;); <span class="comment">// 调用入口函数</span></span><br><span class="line">$(<span class="string">&#x27;#ethalu&#x27;</span>); <span class="comment">// 获取id为ethanlu的元素</span></span><br><span class="line">$(<span class="string">&#x27;div&#x27;</span>); <span class="comment">// 获取所有的div标签</span></span><br></pre></td></tr></table></figure>
<p>假设当前 DOM 树如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>原生 JS 获取元素结点（数组）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;box&#x27;</span>); <span class="comment">// 通过id获取单个元素</span></span><br><span class="line"><span class="keyword">var</span> boxArr = <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&#x27;box&#x27;</span>); <span class="comment">// 通过class获取数组</span></span><br><span class="line"><span class="keyword">var</span> divArr = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;div&#x27;</span>); <span class="comment">// 通过标签获取数组</span></span><br></pre></td></tr></table></figure>
<p>jQuery 获取元素结点数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> box1 = $(<span class="string">&quot;#box&quot;</span>); <span class="comment">// 通过id获取</span></span><br><span class="line"><span class="keyword">var</span> box2 = $(<span class="string">&quot;.box&quot;</span>); <span class="comment">// 通过class获取</span></span><br><span class="line"><span class="keyword">var</span> box3 = $(<span class="string">&quot;div&quot;</span>); <span class="comment">// 通过标签获取</span></span><br></pre></td></tr></table></figure>
<p>二者转换</p>
<ol>
<li>
<p>JS 对象转 jQuery 对象：<code>$(JS对象)</code></p>
</li>
<li>
<p>jQuery 对象转 JS 对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">jQuery对象[index]; <span class="comment">// 1</span></span><br><span class="line">jQuery对象.<span class="title function_">get</span>(index); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="jQuery-选择器">jQuery 选择器</h3>
<ol>
<li>基本选择器</li>
</ol>
<p><img src="https://cdn.ethanloo.cn/img/20210227131524.png" alt="img"></p>
<ol start="2">
<li>层级选择器</li>
</ol>
<p><img src="https://cdn.ethanloo.cn/img/20210227131903.png" alt=""></p>
<ol start="3">
<li>基本过滤选择器</li>
</ol>
<p><img src="https://cdn.ethanloo.cn/img/20210227131901.png" alt=""></p>
<ol start="4">
<li>属性选择器</li>
</ol>
<p><img src="https://cdn.ethanloo.cn/img/20210227131858.png" alt=""></p>
<ol start="5">
<li>筛选选择器</li>
</ol>
<p><img src="https://cdn.ethanloo.cn/img/20210227131859.png" alt=""></p>
<h2 id="jQuery-动画">jQuery 动画</h2>
<p>类似 PPT</p>
<h3 id="显示动画">显示动画</h3>
<ol>
<li><code>$('div').show()</code>：直接显示</li>
<li><code>$('div').show(2000)</code>：2000ms 渐变显示</li>
<li><code>$('div').show('slow')</code>：slow: 600ms, normal: 400ms, fast: 200ms</li>
<li><code>$('div').show(2000, function()&#123;&#125;)</code>：动画执行完之后运行回调函数</li>
</ol>
<h3 id="隐藏动画">隐藏动画</h3>
<ol>
<li>
<p><code>$('div').hide()</code></p>
</li>
<li>
<p><code>$('div').show(2000)</code></p>
</li>
<li>
<p><code>$('div').show('fast')</code></p>
</li>
<li>
<p><code>$('div').show(2000, function()&#123;&#125;)</code></p>
</li>
<li>
<p><code>$(&quot;div&quot;).toggle(speed, callback)</code>：显示和隐藏的切换</p>
</li>
</ol>
<h3 id="滑入和滑出">滑入和滑出</h3>
<ol>
<li><code>$('div').slideDown(speed, callback)</code>：下滑显示</li>
<li><code>$('div').slideUp(speed, callback)</code>：上滑隐藏</li>
<li><code>$('div').slideToggle(speed, callback)</code>：上滑和下滑切换</li>
</ol>
<h3 id="淡入和淡出">淡入和淡出</h3>
<ol>
<li><code>$('div').fadeIn(speed, callback)</code>：淡入</li>
<li><code>$('div').fadeOut(speed, callback)</code>：淡出</li>
<li><code>$('div').fadeToggle(speed, callback)</code>：淡入和淡出的切换</li>
</ol>
<h3 id="自定义动画">自定义动画</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;div&#x27;</span>).<span class="title function_">animate</span>(&#123;params&#125;, speed, callback);</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>参数1：执行动画的 CSS 属性</p>
</li>
<li>
<p>参数2：动画时长</p>
</li>
<li>
<p>参数3：回调函数</p>
</li>
</ul>
<h3 id="停止动画">停止动画</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;div&#x27;</span>).<span class="title function_">stop</span>(<span class="literal">true</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>参数1：<code>true=&gt;</code> 后续动画不执行，<code>false=&gt; </code>后续动画执行</li>
<li>参数2：<code>true=&gt;</code> 立即执行完成当前动画，<code>false=&gt;</code> 立即停止当前动画</li>
</ul>
<blockquote>
<p>不写参数默认为 <code>false</code>，实际开发中，直接用 <code>stop()</code> 比较多</p>
</blockquote>
<h2 id="jQuery-操作-DOM">jQuery 操作 DOM</h2>
<h3 id="样式操作">样式操作</h3>
<ol>
<li><code>$('div').css('background-color', 'red')</code>：设置单个样式</li>
<li><code>$('div').css(&#123;'width':100, 'height': 200&#125;)</code>：设置多个样式（json格式）</li>
<li><code>$('div').css('width')</code>：获取样式</li>
</ol>
<h3 id="类操作">类操作</h3>
<ol>
<li>
<p><code>$('div').addClass('nav')</code>：为指定元素添加 <code>className</code></p>
</li>
<li>
<p><code>$('div').removeClass('nav')</code>：为指定元素删除 <code>className</code>，不指定参数直接移除所有类</p>
</li>
<li>
<p><code>$('div').hasClass('nav')</code>：判断元素是否包含类</p>
</li>
<li>
<p><code>$('div').toggleClass('nav')</code>：有类就移除，无类就添加</p>
</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 基础（三）</title>
    <url>/post/2021-02-25-Weber/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="高阶函数">高阶函数</h2>
<p><strong>参数 中包含 函数</strong> 或者 <strong>返回值是 函数</strong> 的 函数，叫做高阶函数。</p>
<p>参数中包含函数的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fc</span>(<span class="params">a, b, callback</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b);</span><br><span class="line">  callback &amp;&amp; <span class="title function_">callback</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fc</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;execution.&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">30</span></span><br><span class="line">execution.</span><br></pre></td></tr></table></figure>
<p>返回值是函数的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="title function_">fc</span>();</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>
<h2 id="闭包">闭包</h2>
<p>闭包 closure：指有权访问另一个函数作用域中的变量的<strong>函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fc1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">233</span>;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fc2</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">fc2</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fc1</span>();</span><br></pre></td></tr></table></figure>
<h2 id="面向对象">面向对象</h2>
<p>JS 中的面向对象，是基于原型的面向对象。在 ES6 中，引入了类和继承。</p>
<p>JS 中的对象 Object 是依靠构造器 constructor 和 原型 prototype 构造出来的。</p>
<h3 id="创建对象">创建对象</h3>
<ol>
<li>
<p>对象字面量</p>
<p>就是一个<code>&#123;&#125;</code>，以键值对形式存储属性和方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;ethan&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">    <span class="attr">eat</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;eating...&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>工厂模式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, gender</span>)&#123;</span><br><span class="line">	<span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    obj.<span class="property">name</span> = name;</span><br><span class="line">    obj.<span class="property">age</span> = age;</span><br><span class="line">    obj.<span class="property">gender</span> = gender;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ethan = <span class="title function_">createPerson</span>(<span class="string">&#x27;ethan&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> echo = <span class="title function_">createPerson</span>(<span class="string">&#x27;echo&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;女&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>构造函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">eat</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; is eating...&#x27;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ethan = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;ethan&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> echo = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;echo&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>利用构造函数 <code>new</code> 对象的过程如下：</p>
<ul>
<li>开辟内存空间，在内存中创建一个新的空对象</li>
<li>让 <code>this</code> 指向这个新的对象</li>
<li>执行构造函数里面的代码，为对象添加属性和方法</li>
<li>返回新的对象</li>
</ul>
</li>
</ol>
<h3 id="JSON">JSON</h3>
<p>JavaScript Object Notation</p>
<p>和对象字面量的区别体现在，JSON 的属性够必须用双引号，对象字面量可以省略</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ethan&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">21</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eat&quot;</span><span class="punctuation">:</span> function() <span class="punctuation">&#123;</span></span><br><span class="line">        console.log(&#x27;eating...&#x27;);</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>JSON 的遍历方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ethan = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&#x27;ethan&#x27;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">21</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(key <span class="keyword">in</span> ethan)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(ethan[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>for of</code>：ES6 中遍历数组的好方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> arr)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以避免新的内存空间，增加运行效率</p>
</blockquote>
<h3 id="浅拷贝">浅拷贝</h3>
<p>只拷贝最外面一层数据</p>
<ol>
<li>
<p><code>for in</code> 方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ethan&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">  <span class="attr">info</span>: &#123;</span><br><span class="line">    <span class="attr">state</span>: <span class="string">&quot;hungry&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj1) &#123;</span><br><span class="line">  obj2[key] = obj1[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj2)); <span class="comment">// &#123;&quot;name&quot;:&quot;ethan&quot;,&quot;age&quot;:21,&quot;info&quot;:&#123;&quot;state&quot;:&quot;hungry&quot;&#125;&#125;</span></span><br><span class="line">obj1.<span class="property">info</span>.<span class="property">state</span> = <span class="string">&quot;full&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj2)); <span class="comment">// &#123;&quot;name&quot;:&quot;ethan&quot;,&quot;age&quot;:21,&quot;info&quot;:&#123;&quot;state&quot;:&quot;full&quot;&#125;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Object.assign()</code> 方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ethan&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">  <span class="attr">info</span>: &#123;</span><br><span class="line">    <span class="attr">state</span>: <span class="string">&quot;hungry&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, obj1);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj2)); <span class="comment">// &#123;&quot;name&quot;:&quot;ethan&quot;,&quot;age&quot;:21,&quot;info&quot;:&#123;&quot;state&quot;:&quot;hungry&quot;&#125;&#125;</span></span><br><span class="line">obj1.<span class="property">info</span>.<span class="property">state</span> = <span class="string">&quot;full&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj2)); <span class="comment">// &#123;&quot;name&quot;:&quot;ethan&quot;,&quot;age&quot;:21,&quot;info&quot;:&#123;&quot;state&quot;:&quot;full&quot;&#125;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="深拷贝">深拷贝</h3>
<p>用 <code>for in</code> 递归实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ethan&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">  <span class="attr">info</span>: &#123;</span><br><span class="line">    <span class="attr">state</span>: <span class="string">&quot;hungry&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">deepCopy</span>(<span class="params">newObj, oldObj</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> oldObj)&#123;</span><br><span class="line">        <span class="keyword">let</span> item = oldObj[key];</span><br><span class="line">        <span class="keyword">if</span> (item <span class="keyword">instanceof</span> <span class="title class_">Array</span>) &#123;</span><br><span class="line">            newObj[key] = [];</span><br><span class="line">            <span class="title function_">deepCopy</span>(newObj[key], item);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item <span class="keyword">instanceof</span> <span class="title class_">Object</span>) &#123;</span><br><span class="line">            newObj[key] = &#123;&#125;;</span><br><span class="line">            <span class="title function_">deepCopy</span>(newObj[key], item);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            newObj[key] = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="冻结对象">冻结对象</h3>
<p><code>Object.freeze(obj)</code>：冻结对象 <code>obj</code>，不能修改属性。</p>
<h2 id="正则表达式">正则表达式</h2>
<p>用于定义字符串规则</p>
<h3 id="创建正则对象">创建正则对象</h3>
<ol>
<li>使用构造函数</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg1 = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;i&#x27;</span>); <span class="comment">// 第二个参数表示匹配模式，i意味着忽略大小写</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg1.<span class="title function_">test</span>(<span class="string">&#x27;ABC&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg2.<span class="title function_">test</span>(<span class="string">&#x27;ABC&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用字面量创建</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/a/</span>;</span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/A/i</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg1.<span class="title function_">test</span>(<span class="string">&#x27;ABC&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(reg2.<span class="title function_">test</span>(<span class="string">&#x27;ABC&#x27;</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="简单正则">简单正则</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/a|b/</span>; <span class="comment">// 包含a或b</span></span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/[ab]/</span>; <span class="comment">// 等价</span></span><br><span class="line"><span class="keyword">var</span> reg3 = <span class="regexp">/[^ab]/</span>; <span class="comment">// 是否包含a和b以外的字符</span></span><br></pre></td></tr></table></figure>
<h3 id="String-对象的正则方法">String 对象的正则方法</h3>
<ol>
<li>
<p><code>split()</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;1a2b3c4d5e&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> res = s.<span class="title function_">split</span>(<span class="regexp">/[A-z]/</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>match()</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;1a2b3c4d5e&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> res1 = s.<span class="title function_">match</span>(<span class="regexp">/[a-z]/</span>); <span class="comment">// 第一个结果</span></span><br><span class="line"><span class="keyword">var</span> res2 = s.<span class="title function_">match</span>(<span class="regexp">/[a-z]/g</span>); <span class="comment">// 全局匹配</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res1); <span class="comment">// [&#x27;a&#x27;]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res2); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>search()</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello ethan&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> res = s.<span class="title function_">search</span>(<span class="regexp">/e[tbc]han/</span>); <span class="comment">// 查找第一次出现ethan/ebhan/echan的位置</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>replace()</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello ethan, ethan is good!&#x27;</span>;</span><br><span class="line">s.<span class="title function_">replace</span>(<span class="regexp">/ethan/gi</span>, <span class="string">&#x27;echo&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="事件">事件</h2>
<p>JS 以事件驱动为核心，<strong>事件</strong>是指 document 发生一些特定的交互瞬间。</p>
<p><strong>事件三要素</strong>：事件源，事件，事件驱动程序</p>
<ul>
<li>
<p>事件源：引发事件的 html 标签</p>
</li>
<li>
<p>事件：JS 定义的事件，例如鼠标单击，关闭网页</p>
</li>
<li>
<p>事件驱动程序：对样式和 html 的操作，即 DOM</p>
</li>
</ul>
<p><strong>代码书写步骤</strong></p>
<ol>
<li>获取事件源：<code>document.getElementById('box')</code></li>
<li>绑定事件：<code>box.onclick = function()&#123;&#125;</code></li>
<li>书写驱动程序</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>&gt;</span>233<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;box&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        div.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;233&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="获取事件源">获取事件源</h3>
<ol>
<li><code>document.getElementById('box')</code>：通过id获取单个标签</li>
<li><code>document.getElementsByTagName('div')</code>：通过标签名获取标签组</li>
<li><code>document.getElementsByClassName('content')</code>：通过类名获得标签数组</li>
</ol>
<h3 id="绑定事件">绑定事件</h3>
<ol>
<li>
<p>绑定匿名函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;box&#x27;</span>);</span><br><span class="line">div.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;233&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>先定义函数再绑定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;box&#x27;</span>);</span><br><span class="line">div.<span class="property">onclick</span> = fc;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;233&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>行内绑定</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;fc()&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">fc</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;我是弹出的内容&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="事件驱动程序">事件驱动程序</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>&gt;</span>233<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;box&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        div.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            div.<span class="property">style</span>.<span class="property">width</span> = <span class="string">&quot;200px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">            div.<span class="property">style</span>.<span class="property">height</span> = <span class="string">&quot;200px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">            div.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&quot;red&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>onload</code> 事件：当页面加载完的时候触发</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">233</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DOM">DOM</h2>
<p>结点 Node：构成 HTML 网页的最基本单元，网页的每个部分都是一个结点。</p>
<p>文档对象模型 DOM (Document Object Model)：提供结构化表示，并定义如何通过脚本访问文档结构。DOM 就是由结点组成的。</p>
<p>HTML 加载完毕，渲染引擎会在内存中根据 document 生成一个 DOM 树，<code>getElementById</code> 就是获取 DOM 树上的结点。</p>
<p>DOM 树结构如下图所示</p>
<p><img src="https://www.w3school.com.cn/i/ct_htmltree.gif" alt="HTML DOM Node Tree"></p>
<h3 id="DOM-访问关系">DOM 访问关系</h3>
<p>获取父节点：<code>node.parentNode</code></p>
<h4 id="获取兄弟结点">获取兄弟结点</h4>
<ul>
<li>下一个结点
<ul>
<li>IE678：<code>nextSibling</code>
<ul>
<li>在新版中获取的前一个结点包括标签，空文档和换行</li>
</ul>
</li>
<li>火狐谷歌IE9+：<code>nextElementSibling</code></li>
</ul>
</li>
<li>前一个结点
<ul>
<li>IE678：<code>previousSibling</code></li>
<li>火狐谷歌IE9+：<code>perviousElementSibling</code></li>
</ul>
</li>
</ul>
<h4 id="获取单个子节点">获取单个子节点</h4>
<ul>
<li>第一个结点
<ul>
<li>IE678：<code>firstChild</code></li>
<li>火狐谷歌IE9+：<code>firstElementChild</code></li>
</ul>
</li>
<li>最后一个结点
<ul>
<li>IE678：<code>lastChild</code></li>
<li>火狐谷歌IE9+：<code>lastElementChild</code></li>
</ul>
</li>
</ul>
<h4 id="获取所有子节点">获取所有子节点</h4>
<p><code>node.childNodes</code>：标准属性，返回指定元素的子节点的集合，包括结点，属性，文本</p>
<p><code>node.children</code>：非标准属性，返回指定元素的子元素结点的集合，只返回 HTML 结点，不返回文本节点</p>
<h3 id="DOM-结点操作">DOM 结点操作</h3>
<ol>
<li>创建结点：<code>document.createElement('div')</code></li>
<li>插入节点
<ul>
<li><code>node.appendChild(newNode)</code>：在父结点的最后插入一个新结点</li>
<li><code>node.insertBefore(newNode, oldNode)</code>：在父节点的参考结点 <code>oldNode</code> 前面插入一个新的结点。如果参考结点为空，则默认为父节点最后。</li>
</ul>
</li>
<li>删除节点
<ul>
<li><code>parentNode.removeChild(childNode)</code></li>
<li>删除自己：<code>node.parentNode.removeChild(node)</code></li>
</ul>
</li>
<li>复制节点
<ul>
<li><code>node.cloneNode()</code>：只复制结点本身，不复制子结点</li>
<li><code>node.cloneNode(true)</code>：复制包括子结点在内的所有结点</li>
</ul>
</li>
</ol>
<h3 id="DOM-结点属性操作">DOM 结点属性操作</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;1.jpg&quot;</span> <span class="attr">class</span>=<span class="string">&quot;image-box&quot;</span> <span class="attr">title</span>=<span class="string">&quot;ethanloo&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;portrait&quot;</span> <span class="attr">id</span>=<span class="string">&quot;port&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>获取结点属性</p>
<ul>
<li>方式1</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;img&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">src</span>); <span class="comment">// http://127.0.0.1:5500/1.jpg</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(node[<span class="string">&#x27;src&#x27;</span>]); <span class="comment">// http://127.0.0.1:5500/1.jpg</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="property">className</span>); <span class="comment">// image-box</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(node[<span class="string">&#x27;className&#x27;</span>]); <span class="comment">// imgae-box</span></span><br></pre></td></tr></table></figure>
<ul>
<li>方式2</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;img&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="title function_">getAttribute</span>(<span class="string">&#x27;src&#x27;</span>)); <span class="comment">// 1.jpg</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(node.<span class="title function_">getAttribute</span>(<span class="string">&#x27;class&#x27;</span>)); <span class="comment">// image-box</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改结点属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;img&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">node.<span class="property">src</span> = <span class="string">&#x27;2.jpg&#x27;</span>;</span><br><span class="line">node.<span class="title function_">setAttribute</span>(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;portrait&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除结点属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> node = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;img&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">node.<span class="title function_">removeAttribute</span>(<span class="string">&#x27;class&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="DOM-结点属性">DOM 结点属性</h3>
<ol>
<li>
<p><code>innerHTML</code> 和 <code>innerText</code></p>
<p><code>innerHTML</code>：获取双闭合标签里面的内容，包含标签</p>
<p><code>innerText</code>：获取双闭合标签里面的内容，不包含标签</p>
</li>
<li>
<p>元素结点，属性结点，文本结点</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;box&#x27;</span> <span class="attr">value</span>=<span class="string">&#x27;ethan&#x27;</span>&gt;</span></span><br><span class="line">    EthanLoo</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;box&#x27;</span>); <span class="comment">// 获取元素结点</span></span><br><span class="line"><span class="keyword">var</span> attribute = element.<span class="title function_">getAttributeNode</span>(<span class="string">&#x27;id&#x27;</span>); <span class="comment">// 获取属性结点</span></span><br><span class="line"><span class="keyword">var</span> txt = element.<span class="property">firstChild</span>; <span class="comment">// 获取文本结点</span></span><br><span class="line"><span class="keyword">var</span> value = element.<span class="title function_">getAttribute</span>(<span class="string">&#x27;id&#x27;</span>); <span class="comment">// 获取id属性</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(element.<span class="property">nodeType</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(attribute.<span class="property">nodeType</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(txt.<span class="property">nodeType</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(element.<span class="property">nodeName</span>); <span class="comment">// div</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(attribute.<span class="property">nodeName</span>); <span class="comment">// id</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(txt.<span class="property">nodeName</span>); <span class="comment">// #text</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(element.<span class="property">nodeValue</span>); <span class="comment">// null</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(element.<span class="property">nodeValue</span>); <span class="comment">// box</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(txt.<span class="property">nodeValue</span>); <span class="comment">// EthanLoo</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="行内样式操作">行内样式操作</h2>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;myBox&#x27;</span> <span class="attr">id</span> =<span class="string">&#x27;box&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;width: 200px; hieght: 100px; background-color: green;&#x27;</span></span></span><br></pre></td></tr></table></figure>
<h3 id="JS-修改行内样式">JS 修改行内样式</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;box&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li><code>element.style.width</code></li>
<li><code>element.style['width']</code>，该方法优点是可以给属性传递参数</li>
</ol>
<h3 id="注意事项">注意事项</h3>
<ol>
<li><code>style</code> 属性只在样式少的时候使用</li>
<li><code>style</code> 是对象</li>
<li>值是字符串，没有值时设置为 <code>&quot;&quot;</code></li>
<li>驼峰命名规则</li>
<li>只能获取行内样式</li>
<li><code>element.style.cssText</code> 可以用字符串格式直接设置 <code>style</code> 的值</li>
</ol>
<h3 id="JS-获取显示样式">JS 获取显示样式</h3>
<p><code>element.style.className</code> 只能获取元素的<strong>行内样式</strong>，通过其他方法可以获取元素当前显示样式，包括<strong>内嵌样式和外链样式</strong>。</p>
<ol>
<li>W3C 做法：<code>window.getComputedStyle('元素', '伪元素');</code> （第二个参数一般传<code>null</code>）</li>
<li>IE 和 Opera 做法：<code>obj.currentStyle;</code></li>
</ol>
<p>兼容性写法如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getStyle</span>(<span class="params">ele, attr</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">getComputedStyle</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">window</span>.<span class="title function_">getComputedStyle</span>(ele, <span class="literal">null</span>)[attr];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ele.<span class="property">currentStyle</span>[attr];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JS-动画">JS 动画</h2>
<p>JS 动画的三大组成：<code>offset</code>，<code>scroll</code>，<code>client</code></p>
<h3 id="offset">offset</h3>
<ol>
<li>
<p><code>offsetWidth</code> 和 <code>offsetHeight</code>： 元素的宽高 + padding + border</p>
<ul>
<li><code>offsetWidth = width + padding + border</code></li>
<li><code>offsetHeight = height + padding + border</code></li>
</ul>
</li>
<li>
<p><code>offsetParent</code>：获取当前元素的定位父元素</p>
<ul>
<li>如果当前元素的父元素有 <strong>CSS定位</strong>，即 <code>position</code> 为 <code>absolute, relative, fixed</code>，那么获取的就是最近的父元素</li>
<li>如果当前元素的父元素没有 CSS定位，那么获取的就是 <code>body</code></li>
</ul>
</li>
<li>
<p><code>offsetLeft</code>：当前元素相对于<strong>定位父元素</strong>的水平偏移量；<code>offsetTop</code>：当前元素相对于定位父元素的垂直偏移量；只计算 <code>padding</code>，不计算 <code>border</code></p>
</li>
</ol>
<p>平移动画</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>EthanLoo&#x27;s<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./test.css&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#891</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;button&quot;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&quot;div&quot;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="language-javascript">        btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 定时器</span></span></span><br><span class="line"><span class="language-javascript">            <span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                div.<span class="property">style</span>.<span class="property">left</span> = div.<span class="property">offsetLeft</span> + <span class="number">100</span> + <span class="string">&quot;px&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">            &#125;, <span class="number">500</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="scroll">scroll</h3>
<p>用鼠标滚动页面，会触发 <code>window.onscroll()</code> 方法</p>
<ul>
<li><code>scrollWidth</code> 和 <code>scrollHeight</code> 分别代表滚动区域的宽和高，包括 <code>width</code> 和 <code>padding</code>，不包括 <code>border</code> 和 <code>margin</code>。</li>
<li><code>scrollLeft</code>：水平滚动条滚动的距离；<code>scrollTop</code>：垂直滚动条滚动的距离
<ul>
<li>当某个元素满足 <code>scrollHight - scrollTop == clientHeight</code>，说明垂直滚动条距离到底了。</li>
<li>当某个元素满足 <code>scrollWidth - scrollLeft == clientWidth</code>，说明水平滚动条滚动到底了。</li>
</ul>
</li>
</ul>
<h3 id="获取-HTML-文档的方法">获取 HTML 文档的方法</h3>
<ul>
<li><code>documet.title</code>：文档标题</li>
<li><code>document.head</code>：文档投标签</li>
<li><code>document.body</code>：文档的 <code>body</code> 标签</li>
<li><code>document.documentElement</code>：文档的 <code>html</code> 标签</li>
</ul>
<h3 id="client">client</h3>
<ul>
<li>
<p><code>clientWidth</code>：获取元素的可见宽度（<code>width + padding</code>），只读</p>
</li>
<li>
<p><code>clientHieght</code>：获取元素的可见高度（<code>hieght + padding</code>），只读</p>
</li>
<li>
<p><code>clientX</code>：鼠标距离可视区域左侧的距离</p>
</li>
<li>
<p><code>clientY</code>：鼠标距离可视区域上侧距离</p>
</li>
<li>
<p><code>clientTop</code>：盒子的上 <code>border</code></p>
</li>
<li>
<p><code>clientLeft</code>：盒子的左 <code>boder</code></p>
</li>
</ul>
<h2 id="事件绑定">事件绑定</h2>
<ol>
<li>
<p><code>element.onclick = function()&#123;&#125;</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;button&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;clicked&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个元素的一个事件只能绑定一个响应函数。</p>
</li>
<li>
<p><code>element.addEventListener('click', function()&#123;&#125;, false)</code></p>
<p>参数一：事件名的字符串；参数二：回调函数；参数三：<code>true</code> 表示捕获阶段触发，<code>false</code> 表示冒泡阶段触发（默认）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;button&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, fc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fc</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;clicked!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个元素的一个事件可以绑定多个响应函数。</p>
</li>
</ol>
<h2 id="事件对象">事件对象</h2>
<p>事件的响应函数被触发的时候，会产生事件对象 <code>event</code>，浏览器将事件对象作为实参传进之前的响应函数。</p>
<p><code>event</code> 会包含和事件相关的一些信息，例如鼠标的位置，按下的键，鼠标滚轮的方向等。</p>
<h3 id="获取事件对象的方法">获取事件对象的方法</h3>
<ul>
<li>普通浏览器：<code>event</code></li>
<li>IE678：<code>window.event</code></li>
</ul>
<h3 id="事件对象的属性">事件对象的属性</h3>
<ul>
<li><code>timeStamp</code>：事件生成的日期和时间</li>
<li><code>bubbles</code>：返回布尔值，指明事件是否是气泡事件</li>
<li><code>button</code>：返回事件被触发时，哪个鼠标按钮被点击</li>
<li><code>pageX</code>：光标相对于该网页的水平位置</li>
<li><code>pageY</code>：光标相对于该网页的垂直位置</li>
</ul>
<h3 id="DOM-事件流">DOM 事件流</h3>
<p>事件传播三个阶段：事件捕获，事件冒泡，事件目标。</p>
<ol>
<li>
<p>事件捕获，利用 <code>addEventListener</code> 函数。</p>
<p>捕获顺序：<code>window-&gt;document-&gt;html-&gt;body-&gt;父元素，子元素，目标元素</code></p>
</li>
<li>
<p>事件冒泡，一个元素上的事件被触发的时候，同样的事件会在所有祖先元素上触发，一直冒泡到 DOM 树上的最上层。</p>
<p>冒泡顺序：<code>div-&gt;body-&gt;html-&gt;document-&gt;window</code></p>
</li>
</ol>
<h3 id="事件委托">事件委托</h3>
<p>事件委托，即把一个元素响应事件的函数委托到另一个元素上去。</p>
<p>利用冒泡机制，减少事件绑定的次数，减少内存消耗，提高性能。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&#x27;parent-list&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;javascript:;&#x27;</span> <span class="attr">class</span>=<span class="string">&#x27;link&#x27;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;javascript:;&#x27;</span> <span class="attr">class</span>=<span class="string">&#x27;link&#x27;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;javascript:;&#x27;</span> <span class="attr">class</span>=<span class="string">&#x27;link&#x27;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>想要实现的效果是单击 <code>a</code> 标签时，会输出信息。因此可以把点击事件绑定到父元素 <code>ul</code> 上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> parList = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;parent-list&#x27;</span>);</span><br><span class="line">    parList.<span class="title function_">addEventListener</span>(<span class="string">&#x27;ciick&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line">		event = event || <span class="variable language_">window</span>.<span class="property">event</span>;</span><br><span class="line">        <span class="keyword">if</span> (event.<span class="property">target</span> &amp;&amp; event.<span class="property">target</span>.<span class="property">className</span> == <span class="string">&#x27;link&#x27;</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;clicked&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="鼠标拖拽事件">鼠标拖拽事件</h3>
<ol>
<li><code>onmousedown</code>：当鼠标在被拖拽元素上按下时，开始拖拽；</li>
<li><code>onmousemove</code>：当鼠标移动时，被拖拽元素跟鼠标移动；</li>
<li><code>onmouseup</code>：当鼠标松开时，被拖拽元素固定在当前位置。</li>
</ol>
<h3 id="鼠标的滚轮事件">鼠标的滚轮事件</h3>
<p><code>onmousewheel</code>：鼠标滚轮滚动事件。</p>
<h3 id="键盘事件">键盘事件</h3>
<p><code>onkeydown</code>：按键被按下；</p>
<p><code>onkeyup</code>：按键被松开；</p>
<p>一般键盘按下的事件会被绑定给 <code>document</code>。</p>
<p>通过 <code>event</code> 事件对象的 <code>keyCode</code> 来获取按键的编码。</p>
<h2 id="BOM">BOM</h2>
<p>浏览器对象模型 Browser Object Model，操作浏览器部分功能的 API。</p>
<h3 id="常见-BOM-对象">常见 BOM 对象</h3>
<ol>
<li><code>Window</code>：整个浏览器窗口</li>
<li><code>Navigator</code>：当前浏览器的信息</li>
<li><code>Location</code>：浏览器的地址栏信息</li>
<li><code>History</code>：浏览器的历史记录</li>
<li><code>Screen</code>：用户的显示器信息</li>
</ol>
<h3 id="Navigator">Navigator</h3>
<p>一般只使用 <code>navigator.userAgent</code> 来获取浏览器的细信息。</p>
<h3 id="History">History</h3>
<p>用来操作浏览器的向前或向后翻页</p>
<ol>
<li><code>history.length</code>：浏览器历史记录的 URL 数量，浏览器重启的时候会置为1。</li>
<li><code>history.back()</code>：回退上一个页面。</li>
<li><code>history.forward()</code>：前进到下一个页面。</li>
<li><code>history.go(x)</code>：x=0 表示刷新页面，1表示向前跳转一个页面，-1表示向后跳转一个页面</li>
</ol>
<h3 id="Location">Location</h3>
<ol>
<li>
<p><code>location.href</code>：获取当前页面的 URL。</p>
</li>
<li>
<p><code>location.href = 'xxxx'</code>：跳转到指定的页面链接。</p>
</li>
<li>
<p><code>location.assign(str)</code>：跳转到其他页面。</p>
</li>
<li>
<p><code>location.reload()</code>：用于重新加载当前页面。<code>location.reload(true)</code> 会强制清空缓存刷新页面。</p>
</li>
<li>
<p><code>location.replace()</code>：使用一个新的页面替换当前页面，不会生成历史记录，不能使用前进后退。</p>
</li>
</ol>
<h2 id="定时器">定时器</h2>
<p><code>setInterval()</code>：<strong>循环调用</strong>，一段代码每隔一段时间执行一次。</p>
<p><code>setTimeout()</code>：<strong>延时调用</strong>，等待一段事件之后执行一次。</p>
<ol>
<li>
<p>每间隔一秒，变量加一</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(cnt);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>清除定时器</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(cnt);</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="keyword">if</span> (cnt===<span class="number">5</span>)&#123;</span><br><span class="line">        <span class="built_in">clearInterval</span>(timer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>延时调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> timer = <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">clearTimeout</span>(timer);</span><br></pre></td></tr></table></figure>
<p>延时5s关闭广告栏</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ad = <span class="variable language_">document</span>.<span class="title function_">getElementsByTagName</span>(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(fc, <span class="number">5000</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fc</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ad[<span class="number">0</span>].<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    ad[<span class="number">1</span>].<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 基础（二）</title>
    <url>/post/2021-02-20-Weber/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="内置对象">内置对象</h2>
<p>JS 的三类对象：自定义对象，内置对象，浏览器对象</p>
<p>内置对象是指语言自带的对象，供开发者使用。</p>
<table>
<thead>
<tr>
<th style="text-align:left">内置对象</th>
<th style="text-align:left">对象说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Arguments</td>
<td style="text-align:left">函数参数集合</td>
</tr>
<tr>
<td style="text-align:left">Array</td>
<td style="text-align:left">数组</td>
</tr>
<tr>
<td style="text-align:left">Boolean</td>
<td style="text-align:left">布尔对象</td>
</tr>
<tr>
<td style="text-align:left">Math</td>
<td style="text-align:left">数学对象</td>
</tr>
<tr>
<td style="text-align:left">Date</td>
<td style="text-align:left">日期时间</td>
</tr>
<tr>
<td style="text-align:left">Error</td>
<td style="text-align:left">异常对象</td>
</tr>
<tr>
<td style="text-align:left">Function</td>
<td style="text-align:left">函数构造器</td>
</tr>
<tr>
<td style="text-align:left">Number</td>
<td style="text-align:left">数值对象</td>
</tr>
<tr>
<td style="text-align:left">Object</td>
<td style="text-align:left">基础对象</td>
</tr>
<tr>
<td style="text-align:left">RegExp</td>
<td style="text-align:left">正则表达式对象</td>
</tr>
<tr>
<td style="text-align:left">String</td>
<td style="text-align:left">字符串对象</td>
</tr>
</tbody>
</table>
<h2 id="字符串">字符串</h2>
<h3 id="查找子串">查找子串</h3>
<ol>
<li>
<p><code>indexOf()</code> 或 <code>lastIndefOf()</code> ：获取字符串中指定内容的索引</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;ethane&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">indexOf</span>(<span class="string">&#x27;e&#x27;</span>)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>还以用第二个参数，来指定开始查找的位置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;ethane&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">indexOf</span>(<span class="string">&#x27;e&#x27;</span>,<span class="number">2</span>)); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>search()</code>：获取字符串中指定内容的索引</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;ethan&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">search</span>(<span class="string">&#x27;th&#x27;</span>)); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">search</span>(<span class="regexp">/\th/i</span>)); <span class="comment">// 1，正则表达式</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>includes()</code>：判断字符串中是否包含指定的内容，第二个可选参数，用于指定检索的起始位置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;ethan&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="title function_">inclueds</span>(<span class="string">&#x27;than&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="title function_">includes</span>(<span class="string">&#x27;than&#x27;</span>, <span class="number">2</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>startsWith()</code>：判断字符串是否以指定的内容开头，也可以用第二个参数指定起始位置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;ethan&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="title function_">startsWith</span>(<span class="string">&#x27;e&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="title function_">startsWith</span>(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="title function_">startsWith</span>(<span class="string">&#x27;th&#x27;</span>, <span class="number">1</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>endsWith()</code>：判断字符串是否以指定的内容结尾</p>
</li>
</ol>
<h3 id="获取指定位置的字符">获取指定位置的字符</h3>
<ol>
<li><code>charAt(index)</code>：获取字符串指定位置的字符。</li>
<li><code>str[index]</code>：和上一个效果一样，是 H5 特性。</li>
<li><code>charCodeAt(index)</code>：返回字符串指定位置的 Unicode 编码。</li>
</ol>
<h3 id="字符串截取">字符串截取</h3>
<ol>
<li>
<p><code>slice(start, end)</code>：截取字符串子串内容。</p>
<ul>
<li>
<p><code>slice(3)</code>：表示从第三个截到最后</p>
</li>
<li>
<p><code>slice(-2)</code>：从倒数第二个截到最后</p>
</li>
<li>
<p><code>slice(1, -1)</code>：表示从第一个截取到倒数第一个。</p>
</li>
</ul>
</li>
<li>
<p><code>substring(start, end)</code>：和上一个类似，不同之处在于：</p>
<ul>
<li>不能接受负数作为参数，负数直接看作是0</li>
<li>会自动调整参数的位置，如果第二个参数小于第一个，就自动交换</li>
</ul>
</li>
<li>
<p><code>substr(start, length)</code>：指定位置和长度，截取子串</p>
</li>
</ol>
<h3 id="其他常用">其他常用</h3>
<ol>
<li>
<p><code>String.fromCharCode()</code>：根据字符的 Unicode 编码获取字符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="number">72</span>); <span class="comment">// H</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>concat()</code>：字符串连接</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;ethan&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;lu&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> name = a.<span class="title function_">concat</span>(b); <span class="comment">// &#x27;ethanlu&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>split()</code>：指定分隔符，字符串转换成数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;ethan,lu&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> res = a.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>); <span class="comment">// [&#x27;ethan&#x27;, &#x27;lu&#x27;]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>replace()</code>：替换指定内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;ethanlu&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> b = a.<span class="title function_">replace</span>(<span class="string">&#x27;lu&#x27;</span>, <span class="string">&#x27;loo&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>repeat()</code>：重复字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;1891234567&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> b = a.<span class="title function_">slice</span>(<span class="number">0</span>,-<span class="number">4</span>) + <span class="string">&#x27;*&#x27;</span>.<span class="title function_">repeat</span>(<span class="number">4</span>); <span class="comment">// 模糊手机号后四位</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>trim()</code>：去除字符串前后的空白</p>
</li>
<li>
<p><code>toLowerCase();toUpperCase()</code>：大小写转换</p>
</li>
</ol>
<h3 id="HTML-方法">HTML 方法</h3>
<ol>
<li>
<p><code>anchor()</code>：创建 a 链接</p>
</li>
<li>
<p><code>sub()</code></p>
</li>
<li>
<p><code>sup()</code></p>
</li>
<li>
<p><code>big()</code></p>
</li>
<li>
<p><code>link()</code></p>
</li>
<li>
<p><code>bold()</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;ethan&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">big</span>()); <span class="comment">// &lt;big&gt;ethan&lt;/big&gt;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">anchor</span>()); <span class="comment">// &lt;a name=&#x27;undefined&#x27;&gt;ethan&lt;/a&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Number">Number</h2>
<ol>
<li><code>Number.isInteger(num)</code>：判断数字是否是整数</li>
<li><code>num.toFixed(n)</code>：小数点后保留n位</li>
</ol>
<h2 id="Math">Math</h2>
<table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>Math.PI</code></td>
<td style="text-align:left">圆周率</td>
</tr>
<tr>
<td style="text-align:left"><code>Math.abs()</code></td>
<td style="text-align:left"><strong>返回绝对值</strong></td>
</tr>
<tr>
<td style="text-align:left"><code>Math.random()</code></td>
<td style="text-align:left">生成0-1之间的<strong>随机浮点数</strong></td>
</tr>
<tr>
<td style="text-align:left"><code>Math.floor()</code></td>
<td style="text-align:left"><strong>向下取整</strong>（往小取值）</td>
</tr>
<tr>
<td style="text-align:left"><code>Math.ceil()</code></td>
<td style="text-align:left"><strong>向上取整</strong>（往大取值）</td>
</tr>
<tr>
<td style="text-align:left"><code>Math.round()</code></td>
<td style="text-align:left">四舍五入取整（正数四舍五入，负数五舍六入）</td>
</tr>
<tr>
<td style="text-align:left"><code>Math.max(x, y, z)</code></td>
<td style="text-align:left">返回多个数中的最大值</td>
</tr>
<tr>
<td style="text-align:left"><code>Math.min(x, y, z)</code></td>
<td style="text-align:left">返回多个数中的最小值</td>
</tr>
<tr>
<td style="text-align:left"><code>Math.pow(x,y)</code></td>
<td style="text-align:left">乘方：返回 x 的 y 次幂</td>
</tr>
<tr>
<td style="text-align:left"><code>Math.sqrt()</code></td>
<td style="text-align:left">开方：对一个数进行开方运算</td>
</tr>
</tbody>
</table>
<h2 id="Date">Date</h2>
<p>Date 是一个构造函数，需要实例化之后使用。</p>
<h3 id="创建-Date-对象">创建 Date 对象</h3>
<p>有两种写法</p>
<ol>
<li><code>Date()</code>：返回当前时间对象</li>
<li><code>Date(时间字符串)</code>：返回指定的时间对象</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> curDate = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="keyword">var</span> bithday = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;1000-10-05&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(curDate); <span class="comment">// Wed Feb 03 2021 16:48:12 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(birthday); <span class="comment">// Sun Oct 05 1000 08:05:43 GMT+0805 (中国标准时间)</span></span><br></pre></td></tr></table></figure>
<h3 id="日期格式化">日期格式化</h3>
<table>
<thead>
<tr>
<th>方法名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>getFullYear()</code></td>
<td>获取年份</td>
</tr>
<tr>
<td><code>getMonth()</code></td>
<td><strong>获取月： 0-11</strong></td>
</tr>
<tr>
<td><code>getDate()</code></td>
<td><strong>获取日：1-31</strong></td>
</tr>
<tr>
<td><code>getDay()</code></td>
<td><strong>获取星期：0-6</strong></td>
</tr>
<tr>
<td><code>getHours()</code></td>
<td>获取小时：0-23</td>
</tr>
<tr>
<td><code>getMinutes()</code></td>
<td>获取分钟：0-59</td>
</tr>
<tr>
<td><code>getSeconds()</code></td>
<td>获取秒：0-59</td>
</tr>
<tr>
<td><code>getMilliseconds()</code></td>
<td>获取毫秒</td>
</tr>
</tbody>
</table>
<h3 id="时间戳">时间戳</h3>
<p>格林威治时间：1970年1月1日，0时0分0秒</p>
<p>时间戳是指从格林威治时间到当前日期所花费的毫秒数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;1970/01/01 0:0:0&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(d.<span class="title function_">getTime</span>()); <span class="comment">// -28800000，之所以不是0是因为中文环境下是按照北京时区</span></span><br></pre></td></tr></table></figure>
<p>获取 Date 对象时间戳的方法</p>
<ol>
<li><code>const t = +new Date()</code></li>
<li><code>const  t = new Date().getTime()</code></li>
<li><code>const t  = new Date().valueOf()</code></li>
<li><code>const t = new Date()*1</code></li>
<li><code>const t = Number(new Date())</code></li>
</ol>
<p>H5 中新增的获取当前的时间戳的方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> t = <span class="title class_">Date</span>().<span class="title function_">now</span>();</span><br></pre></td></tr></table></figure>
<h2 id="数组">数组</h2>
<h3 id="创建数组">创建数组</h3>
<ol>
<li>
<p>使用字面量创建数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用构造函数创建数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"><span class="keyword">var</span> arr2 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;arr1 = &#x27;</span> + <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr2)); <span class="comment">// 打印数组的方法</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="数组操作">数组操作</h3>
<ol>
<li>
<p>通过索引，访问数组元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">2</span>]); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr[<span class="number">4</span>]); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>向数组中添加元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(arr)); <span class="comment">// [1, null, 3]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取数组长度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="property">length</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改数组长度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.<span class="property">length</span> = <span class="number">5</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">stringfy</span>(arr)); <span class="comment">// [1, 2, 3, null, null]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>遍历数组的基本方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;arr.<span class="property">length</span>;i++)&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="数组的常用方法">数组的常用方法</h3>
<h4 id="数组类方法">数组类方法</h4>
<ol>
<li>
<p><code>Array.isArray(arr)</code>：判断变量是否为数组</p>
</li>
<li>
<p><code>arr.toString()</code>：把数组转换成字符串</p>
<p>同样效果还有</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(arr));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr.<span class="title function_">join</span>(<span class="string">&#x27;,&#x27;</span>));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>Array.from(arr)</code>：将<strong>伪数组</strong>或者<strong>可遍历对象</strong>转换成<strong>真数组</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;ethan&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(name)); <span class="comment">// [&#x27;e&#x27;, &#x27;t&#x27;, &#x27;h&#x27;,&#x27; a&#x27;, &#x27;n&#x27;]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在使用形如 <code>buttons = document.getElementByTagName('button')</code> 的函数的时候的返回值 <code>buttons</code> 就是伪数组，需要通过 <code>Array.from(buttons)</code> 转换成真数组</p>
</blockquote>
</li>
</ol>
<h4 id="创建数组-2">创建数组</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// [1, &quot;2&quot;, false]</span></span><br></pre></td></tr></table></figure>
<h4 id="元素的添加和删除">元素的添加和删除</h4>
<ol>
<li>对数组尾部的操作：<code>arr.push(x)</code> ，<code>arr.pop()</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> l1 = arr.<span class="title function_">push</span>(<span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// [1, 2, 3, 4, 0]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(l1); <span class="comment">// 5 (数组的长度)</span></span><br><span class="line"><span class="keyword">var</span> l2 = arr.<span class="title function_">pop</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(l2); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>对数组首部的操作：<code>arr.unshift(x)</code>，<code>arr.shift()</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> r1 = arr.<span class="title function_">unshift</span>(<span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r1); <span class="comment">// [0, 1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r2 = arr.<span class="title function_">shift</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(r2); <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>从数组中删除指定的一个或多个元素：<code>arr.splice(x)</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> res = arr.<span class="title function_">splice</span>(<span class="number">1</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// [1]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// [2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>填充数组：<code>arr.fill(x)</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">4</span>);</span><br><span class="line">arr.<span class="title function_">fill</span>(<span class="number">2</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr); <span class="comment">// [2, 2, 2, 2]</span></span><br></pre></td></tr></table></figure>
<h3 id="数组的合并和拆分">数组的合并和拆分</h3>
<ol>
<li><code>arr1.concat(arr2)</code>：拼接两个或多个数组</li>
<li><code>arr.join('-')</code>：将数组转换成一个字符串</li>
<li><code>arr = str.split('-')</code>：把字符串拆分成一个数组</li>
</ol>
<h3 id="数组元素顺序改变">数组元素顺序改变</h3>
<ol>
<li>
<p><code>r = arr.reverse()</code>：将数组倒置，会改变原数组</p>
</li>
<li>
<p><code>r = arr.sort()</code>：对数组进行排序，会改变原数组</p>
<p>也可以自定义排序规则</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> r = arr.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> a - b; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>ES6 的优雅写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> r = arr.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>)=&gt;</span> a - b);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="数组遍历">数组遍历</h3>
<ol>
<li>
<p><code>every()</code>：对数组中的每一项运行回调函数，如果都真就返回<code>true</code>，否则返回<code>false</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> b = a.<span class="title function_">every</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item % <span class="number">2</span> == <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>filter()</code>：对原数组进行过滤，返回一个成功过滤的新数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> b = a.<span class="title function_">filter</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item % <span class="number">2</span> == <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// [1, 3]</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>forEach()</code>：使用回调函数遍历数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>];</span><br><span class="line">a.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span>&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;item:&#x27;</span>+item);</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;index:&#x27;</span>+index);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;arr:&#x27;</span> + arr);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>map()</code>：对数组中的每一项运行回调函数，返回加工过的新数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> b = a.<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">item, index, arr</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> item+index; </span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// [&quot;apple0&quot;, &quot;orange1&quot;, &quot;banana2&quot;]</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="函数">函数</h2>
<p>函数本质也是个对象，可以将一些功能进行封装，在需要的时候调用。</p>
<h3 id="函数的声明">函数的声明</h3>
<ol>
<li>
<p>利用函数关键字定义函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSqrt</span>(<span class="params">num</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> num*num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>匿名函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func2 = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>构造函数（不常用）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fun3 = <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;console.log(&quot;我是函数内部的内容&quot;);  console.log(a + b);&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">fun3</span>(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 调用函数</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="函数的调用">函数的调用</h3>
<ol>
<li>
<p>普通函数的调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getSqrt</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">9</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">getSqrt</span>(); <span class="comment">// 9</span></span><br><span class="line">getSqrt.<span class="title function_">call</span>(); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通过对象的方法来调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">	<span class="attr">a</span>: <span class="string">&#x27;ethan&#x27;</span>,</span><br><span class="line">    <span class="attr">func</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello world&#x27;</span>);  </span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">func</span>();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>立即执行函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;halo&quot;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通过构造函数来调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title function_">fc</span>();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>绑定事件函数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>button<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;test.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定时器函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  num++;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="函数名和函数体">函数名和函数体</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title function_">alert</span>(<span class="number">233</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fn); <span class="comment">// fn() &#123;alert(233);&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="方法">方法</h3>
<p>函数也可以成为<strong>对象的属性</strong>，如果函数是作为<strong>对象的属性</strong>，就成为对象的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fu</span>(); <span class="comment">// 调用函数</span></span><br><span class="line">obj.<span class="title function_">fn</span>(); <span class="comment">// 调用方法</span></span><br></pre></td></tr></table></figure>
<h2 id="作用域">作用域</h2>
<h3 id="分类">分类</h3>
<p>ES6 之前的两种作用域</p>
<ul>
<li>全局作用域
<ul>
<li>作用在 script 标签内部，或者独立的 JS 文件中</li>
</ul>
</li>
<li>局部作用域（函数作用域）
<ul>
<li>作用在函数内的代码环境</li>
</ul>
</li>
</ul>
<h3 id="全局作用域">全局作用域</h3>
<p>直接写在 <code>script</code> 标签中的 JS 代码，都在全局作用域。</p>
<p>全局作用域在页面打开时创建，在关闭时销毁。全局作用域有一个全局对象 <code>window</code>，代表浏览器的窗口，由浏览器创建，我们来使用。</p>
<ul>
<li>创建的<strong>变量</strong>都作为 <code>window</code> 对象的属性来保存</li>
<li>创建的<strong>函数</strong>都作为 <code>window</code> 对象的方法来保存</li>
</ul>
<h3 id="变量的声明提前">变量的声明提前</h3>
<p>使用 <code>var</code> 关键字声明的变量，会在所有代码执行之前被声明，若不写，则不会提前声明。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">233</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 报错 a is not defined</span></span><br><span class="line">a = <span class="number">233</span>;</span><br></pre></td></tr></table></figure>
<h3 id="函数的声明提前">函数的声明提前</h3>
<p>使用函数声明的形式创建的函数会被声明提前。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用函数表达式创建的函数，不会提前声明，所以会报错。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="函数作用域">函数作用域</h3>
<p>函数中使用 <code>var</code> 声明的变量，会在函数代码执行前被声明。</p>
<p>没有 <code>var</code> 声明的变量都是全局变量，而且不会提前声明。</p>
<p>形参代表着在函数作用域中声明了变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">b</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 3</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 5</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="作用域链">作用域链</h3>
<p>内部函数访问外部函数的变量，采取链式查找的方式决定取值，依据<strong>就近原则</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 外部函数</span></span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 内部函数</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">fun</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<h2 id="预编译">预编译</h2>
<p><strong>JavaScript 运行三部曲</strong>：语法分析，预编译，解释执行</p>
<h3 id="预编译规律">预编译规律</h3>
<ol>
<li>未经声明就赋值的变量，属于 <code>window</code> 的属性。</li>
<li>在全局作用域内声明的变量，全是 <code>window</code> 的属性。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = b = <span class="number">100</span>; <span class="comment">// 连续赋值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">b</span>); <span class="comment">// 在全局范围内访问 b</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 在全局范围内访问 b，但是前面没有加 window 这个关键字</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">a</span>); <span class="comment">// 在全局范围内访问 a</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 在全局范围内访问 a，但是前面没有加 window 这个关键字</span></span><br></pre></td></tr></table></figure>
<p>代码的执行顺序为</p>
<ul>
<li><code>b = 100</code></li>
<li><code>var a</code></li>
<li><code>a = b</code></li>
</ul>
<p>打印结果为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Uncaught</span> <span class="title class_">ReferenceError</span>: a is not defined</span><br></pre></td></tr></table></figure>
<p><code>b</code> 是未经声明的变量，因此属于 <code>window.b</code>，是一个全局变量。</p>
<p><code>a</code> 是一个局部变量，只作用于函数内部。</p>
<h3 id="预编译步骤">预编译步骤</h3>
<ol>
<li>创建 AO(Activation Object 活跃对象)，即<strong>执行期上下文</strong></li>
<li>找形参和变量声明，将形参名和变量作为 AO 的属性名，值为 <code>undefined</code></li>
<li>将实参值和形参统一，实参的值赋给形参</li>
<li>查找函数声明，函数名作为 AO 对象的属性名，值为整个函数体</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">666</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">  <span class="keyword">var</span> b = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(b);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>打印结果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ƒ <span class="title function_">a</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="number">666</span></span><br><span class="line"><span class="number">666</span></span><br><span class="line">ƒ () &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行期上下文">执行期上下文</h3>
<p>在预编译函数的时候，会创建一个执行期上下文的内部对象，一个执行器上下文定义了一个函数执行的环境。</p>
<p>每调用一次函数，就会创建一个新的执行期上下文对象，它们之间独立。函数执行完之后，这个对象就会被销毁。</p>
<h3 id="this">this</h3>
<p>解析器在调用函数的时候，会向函数内部传递一个隐含的参数，即 <code>this</code>，它指向的就是上下文对象。</p>
<p>根据函数的调用方式不同，<code>this</code> 会指向不同的对象</p>
<ol>
<li>
<p>以函数的形式调用，<code>this</code> 指向的是 <code>window</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// Window</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// loo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ethan&quot;</span>,</span><br><span class="line">  <span class="attr">getName</span>: fc,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;loo&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fc</span>();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>以方法的形式调用，<code>this</code> 指向调用方法的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fc</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// &#123;name: &quot;ethan&quot;, getName: ƒ&#125;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// ethan</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ethan&quot;</span>,</span><br><span class="line">  <span class="attr">getName</span>: fc,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;loo&quot;</span>;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">getName</span>();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>ES6 中的箭头函数不会遵循这个原则，而是会继承外层函数调用的 <code>this</code> 绑定。</p>
</blockquote>
<h3 id="改变-this-指向">改变 this 指向</h3>
<ol>
<li>
<p><code>call()</code></p>
<ul>
<li>可以调用一个函数，并改变函数内部的 <code>this</code> 指向</li>
<li>可以实现继承</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fc</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// obj</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// ethan</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b); <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ethan&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fc.<span class="title function_">call</span>(obj, <span class="number">2</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>apply()</code>：可以调用一个函数，并改变这个函数内部的 <code>this</code> 指向</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fc</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// obj</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); <span class="comment">// ethan</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// [&#x27;hello&#x27;]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;ethan&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">21</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fc.<span class="title function_">call</span>(obj, [<span class="string">&quot;hello&quot;</span>]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>bind()</code>：不会调用函数，但是改变函数内部的 <code>this</code> 指向</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">新函数 = fc.<span class="title function_">bind</span>(想要将<span class="variable language_">this</span>指向哪里, 函数实参<span class="number">1</span>, 函数实参<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id=""></h2>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>JS 基础（一）</title>
    <url>/post/2021-02-10-Weber/JS%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="JavaScript-背景">JavaScript 背景</h2>
<p>首先要明白 Web 前端的三层结构：</p>
<ul>
<li>HTML：语义角度，描述页面结构</li>
<li>CSS：审美角度，描述具体样式</li>
<li>JavaScript：交互角度，描述实现行为</li>
</ul>
<p>JavaScript 作为一门<strong>前端语言</strong>，用于页面的交互，不能直接操作数据库。</p>
<p>JavaScript 基础包括三个部分：</p>
<ul>
<li>ECMAScript：JS 的语法标准</li>
<li>DOM：Document Object Model 文档对象模型，操作<strong>页面上的元素</strong>的 API</li>
<li>BOM：Browser Object Model 浏览器对象模型，操作<strong>浏览器部分功能</strong>的 API</li>
</ul>
<h3 id="第一行-JS-代码">第一行 JS 代码</h3>
<ol>
<li>
<p>行内式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> =<span class="string">&quot;button&quot;</span> <span class="attr">value</span> =<span class="string">&quot;0&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;hello ethan&#x27;)&quot;</span>  /&gt;</span></span><br></pre></td></tr></table></figure>
<p>不推荐使用，可读性差</p>
<blockquote>
<p>关于引号，HTML 标签中推荐使用双引号，JS 中推荐使用单引号</p>
</blockquote>
</li>
<li>
<p>内嵌式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    	<span class="title function_">alert</span>(<span class="string">&#x27;hello ethan!&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>text 表示纯文本，因为 JS 是一个纯文本的语言，学习时常用</p>
</li>
<li>
<p>引入外部 JS 文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span> = <span class="string">&quot;test.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>开发中经常使用，确保 HTML 和 JS 文件分开</p>
</li>
</ol>
<h3 id="常用语句">常用语句</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;hello&#x27;</span>); <span class="comment">// 弹出警告框</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;damn&#x27;</span>); <span class="comment">// 控制台输出</span></span><br></pre></td></tr></table></figure>
<h2 id="JS-变量">JS 变量</h2>
<h3 id="常量">常量</h3>
<p>字面量，也叫做常量，是固定值，分为三类</p>
<ul>
<li>数字 <code>alert(233);</code></li>
<li>字符串 <code>alert('233')</code></li>
<li>布尔值 <code>if (true)</code></li>
</ul>
<h3 id="变量">变量</h3>
<p>ES6 之前使用 <code>var</code> 定义一个变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name;</span><br></pre></td></tr></table></figure>
<p>ES6 语法及以后，使用 <code>const</code>，<code>let</code> 关键字来声明一个变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name;</span><br><span class="line"><span class="keyword">let</span> age;</span><br></pre></td></tr></table></figure>
<p>变量初始化，即声明一个变量并赋值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;ethan&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>同时声明多个变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;ethan&#x27;</span>, age = <span class="number">21</span>;</span><br></pre></td></tr></table></figure>
<h3 id="变量命名规范">变量命名规范</h3>
<p>建议使用驼峰命名规则，长度不超过255个字符</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getElementById, matherAndFather, ethanLu</span><br></pre></td></tr></table></figure>
<h3 id="变量的数据类型">变量的数据类型</h3>
<p>JavaScript 是一种<strong>弱类型语言</strong>，也可以说是<strong>动态语言</strong>，不需要提前对变量类型声明。</p>
<p>所以 JavaScript 的变量数据类型，是在程序运行的过程中，根据等号右边的值确定的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;ethan&#x27;</span>;</span><br><span class="line">name = <span class="number">233</span>; <span class="comment">// 此时变量被强制修改为数字类型</span></span><br></pre></td></tr></table></figure>
<h4 id="JS-中的六种数据类型">JS 中的六种数据类型</h4>
<ul>
<li>基本数据类型（值类型）
<ol>
<li>String 字符串</li>
<li>Number 数值</li>
<li>Boolean 布尔值</li>
<li>Null 空值</li>
<li>Undefined 未定义</li>
</ol>
</li>
<li>引用数据类型（引用类型）<br>
6. Object 对象</li>
</ul>
<blockquote>
<p>内置对象 Function, array, Date, Error 都是 Object 类型</p>
</blockquote>
<p>基本数据类型赋值的时候，传数值；引用数据类型赋值的时候，传地址</p>
<h3 id="栈内存和堆内存">栈内存和堆内存</h3>
<p>JS 中，所有变量都是保存在栈内存中。</p>
<ul>
<li><strong>基本数据类型</strong>的值，直接保存在<strong>栈内存</strong>中，值和值之间都是独立的</li>
<li><strong>引用数据类型</strong>的对象，保存到<strong>堆内存</strong>中。每次创建一个新的对象，就会在堆内存中开辟一个新的空间，变量保存的是对象的内存地址，保存在<strong>栈内存</strong>中。</li>
</ul>
<h2 id="String-字符串">String 字符串</h2>
<p>双引号或者单引号的任意文本，双引号里可以嵌套单引号，单引号里可以嵌套双引号。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> t = <span class="string">&#x27;She said:&quot;hello&quot;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>利用<code>\</code>作为转义字符，使得字符串中能够存放一些特殊的符号。</p>
<ul>
<li><code>\&quot;</code> 表示 <code>&quot;</code> 双引号</li>
<li><code>\'</code> 表示 <code>'</code> 单引号</li>
<li><code>\\</code> 表示<code>\</code></li>
<li><code>\r</code> 表示回车</li>
<li><code>\n</code> 表示换行。n 的意思是 newline。</li>
<li><code>\t</code> 表示缩进。t 的意思是 tab。</li>
<li><code>\b</code> 表示空格。b 的意思是 blank。</li>
</ul>
<p>通过字符串的 <code>length</code> 属性，可以获取字符串的长度。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">out</span>(s.<span class="property">length</span>);</span><br></pre></td></tr></table></figure>
<h3 id="字符串拼接">字符串拼接</h3>
<p><strong>传统方法</strong>：用➕可以把字符串和任意数据类型进行拼接。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;ethan&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="string">&#x27;21&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;name:&#x27;</span>+name+<span class="string">&#x27;,age:&#x27;</span>+age); <span class="comment">// 传统写法</span></span><br></pre></td></tr></table></figure>
<p><strong>模板字符串</strong>：ES6 中引入的字符串拼接的新方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;ethan&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="string">&#x27;21&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`name:<span class="subst">$&#123;name&#125;</span>,age:<span class="subst">$&#123;age&#125;</span>`</span>); <span class="comment">// ES6新写法</span></span><br></pre></td></tr></table></figure>
<p>这里使用的不是单引号，是反引号，即 TAB 键上方的符号。</p>
<p>用这个方法也可以很方便地插入表达式。（模板字符串不用手动输入回车符号就可以直接换行）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="number">7</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;we got &#x27;</span>+(a-b)+<span class="string">&#x27;,\ninstead of &#x27;</span>+(a*b)+<span class="string">&#x27;.&#x27;</span>); <span class="comment">// 传统写法</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`we got <span class="subst">$&#123;a-b&#125;</span>,</span></span><br><span class="line"><span class="string">instead of <span class="subst">$&#123;a*b&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>
<p><img src="../../../AppData/Roaming/Typora/typora-user-images/image-20210126175153391.png" alt="image-20210126175153391"></p>
<h4 id="模板字符串的嵌套使用">模板字符串的嵌套使用</h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> names = [<span class="string">&#x27;Ethan&#x27;</span>, <span class="string">&#x27;Echo&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">outputNames</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">`&lt;ul&gt;</span></span><br><span class="line"><span class="string">	<span class="subst">$&#123;name</span></span></span><br><span class="line"><span class="subst"><span class="string">        .map((item) =&gt; <span class="string">`&lt;li&gt;<span class="subst">$&#123;item&#125;</span>&lt;/li&gt;`</span>)</span></span></span><br><span class="line"><span class="subst"><span class="string">		.join(<span class="string">&#x27; &#x27;</span>)&#125;</span></span></span><br><span class="line"><span class="string">	&lt;/ul&gt;`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">innerHTML</span> = <span class="title function_">outputNames</span>();</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.ethanloo.cn/img/20210126180820.png" alt="image-20210126180820044"></p>
<h4 id="模板字符串中调用函数">模板字符串中调用函数</h4>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;ethanloo&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`www.<span class="subst">$&#123;getName()&#125;</span>.com`</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Boolean-布尔值">Boolean 布尔值</h2>
<p>ture 和 false</p>
<h2 id="Number-数值型">Number 数值型</h2>
<p>在 JS 中，无论是整数、浮点数，无论大小、正负，都是 Number 类型的。</p>
<p>内存限制了 ECMAScript 的最大值和最小值。</p>
<ul>
<li>最大值：<code>Number.MAX_VALUE</code>，这个值为： 1.7976931348623157e+308</li>
<li>最小值：<code>Number.MIN_VALUE</code>，这个值为： 5e-324</li>
</ul>
<p><strong>NaN</strong>，是一个特殊的数字，表示 Not a Number，非数值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;abs&#x27;</span> / <span class="number">3</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;abc&#x27;</span> * <span class="string">&#x27;cba&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="隐式转换">隐式转换</h3>
<p>程序会对<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>这几个符号进行隐式转换。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;2&#x27;</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;2&#x27;</span> - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="string">&#x27;9&#x27;</span> / <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 21</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h3 id="运算精度问题">运算精度问题</h3>
<p>使用<code>toFix()</code>方法可以对小数进行截取。</p>
<p>实际开发中，使用这两个开源的库：<a href="https://github.com/MikeMcl/decimal.js/">decimal.js</a>、 <a href="https://github.com/josdejong/mathjs">Math.js</a>，前者轻量，后者全面。</p>
<h2 id="Null-空对象">Null 空对象</h2>
<p>使用 <code>let a = null</code> ，来定义一个空的对象。</p>
<blockquote>
<p>用来对没想好的对象初始化的时候使用</p>
</blockquote>
<h2 id="Undefined">Undefined</h2>
<p>以下几种情况，均会导致打印结果为 <code>undefined</code></p>
<ol>
<li>
<p>变量已经声明，未赋值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>变量未声明的时候</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 直接打印是报错</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a); <span class="comment">// 打印类型会输出undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>没有返回值的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>调用函数的时候未传参</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>();</span><br></pre></td></tr></table></figure>
<p>实际开发中可以设置默认值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  a = a || <span class="string">&quot;ethan&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a = <span class="string">&quot;ethan&quot;</span></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>null 和 undefined 的相似和区别</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> == <span class="literal">undefined</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">null</span> === <span class="literal">undefined</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">10</span> + <span class="literal">null</span>); <span class="comment">// 10</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">10</span> + <span class="literal">undefined</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>任何数据类型和 undefined 运算都是 NaN</p>
</li>
<li>
<p>任何值和 null 运算，null 可以看作是 0 运算。</p>
</li>
</ul>
<h2 id="数据类型转换">数据类型转换</h2>
<p><code>typeof</code> 用来获取变量的数据类型，返回的是字符串。</p>
<p>有两种写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> 变量;</span><br><span class="line"><span class="title function_">typeof</span>(变量);</span><br></pre></td></tr></table></figure>
<p>类型的转换分为两种：显式类型转换，隐式类型转换</p>
<h3 id="显式类型转换">显式类型转换</h3>
<h4 id="String">=&gt; String</h4>
<ol>
<li>
<p>变量+“”(任意字符串)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>+<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>toString()</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> b = a.<span class="title function_">toString</span>();</span><br><span class="line"><span class="keyword">var</span> c = a.<span class="title function_">toString</span>(<span class="number">2</span>); <span class="comment">// 将a转换成2进制数字的字符串格式</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>String()</code></p>
<ul>
<li>
<p>对于 Number 和 Boolean 类型的变量而言，就是调用 <code>toString()</code> 方法</p>
</li>
<li>
<p>对于 null 和 undefined，则直接转换成 ‘null’ 和 ‘undefined’</p>
</li>
</ul>
</li>
</ol>
<h4 id="Number">=&gt; Number</h4>
<ol>
<li>
<p><code>Number()</code> 函数</p>
<ul>
<li>
<p>字符串 =&gt; 数字</p>
<ul>
<li>
<p>如果字符串里面是纯数字，就转换成数字</p>
</li>
<li>
<p>如果字符串是空串或者全是空格，就转换成0</p>
</li>
<li>
<p>字符串中包含的是非数字内容，就转换为 <code>NaN</code></p>
</li>
</ul>
</li>
<li>
<p>布尔 =&gt; 数字</p>
<ul>
<li>true =&gt; 1</li>
<li>false =&gt;0</li>
</ul>
</li>
<li>
<p>null =&gt; 数字</p>
<ul>
<li>0</li>
</ul>
</li>
<li>
<p>undefined =&gt; 数字</p>
<ul>
<li><code>NaN</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>parseInt()</code>  转换为整数，带有截断小数的功能</p>
<ul>
<li>字符串 =&gt; 数字
<ul>
<li>只保留字符串最开头的数字，后面的中文自动消失</li>
<li>字符串是以非数字开头，转换为 <code>NaN</code></li>
<li>字符串是空串或者全是空格，会报错</li>
</ul>
</li>
<li>布尔值 =&gt; 数字
<ul>
<li><code>NaN</code></li>
</ul>
</li>
<li>Null =&gt; 数字
<ul>
<li><code>NaN</code></li>
</ul>
</li>
<li>Undefined =&gt; 数字
<ul>
<li><code>NaN</code></li>
</ul>
</li>
</ul>
<blockquote>
<p><code>number()</code> 和 <code>parseInt()</code> 的区别在于</p>
<p>前者是千方百计转换数字；</p>
<p>后者是先转换为字符串，再尝试提取最前面的数字部分，没尝试出来就返回 <code>NaN</code></p>
</blockquote>
<p>使用 <code>parseInt()</code> 还可以通过第二个参数实现进制的转换</p>
<p>例如，尝试把 <code>2</code> 进制的数字 <code>11110001</code> 转换成 <code>10</code> 进制的数字</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(<span class="string">&quot;11110001&quot;</span>, <span class="number">2</span>)); <span class="comment">// 241</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>parseFloat()</code> 函数</p>
<p>把字符串转换为浮点数，和 <code>parseInt()</code> 的区别在于 <code>parseFloat()</code> 可以获得有效的小数部分</p>
</li>
</ol>
<h4 id="Boolean">=&gt; Boolean</h4>
<ul>
<li>数字 =&gt; 布尔
<ul>
<li>只有0和 <code>NaN</code> ，<code>Boolean()</code> 的结果是 <code>false</code></li>
<li>其他数字都是 <code>true</code></li>
</ul>
</li>
<li>字符串  =&gt; 布尔
<ul>
<li>只有空串是 false</li>
<li>其他的都是 true</li>
</ul>
</li>
<li>null, undefined =&gt; false</li>
<li>引用数据类型 =&gt; true
<ul>
<li>包括空数数组 <code>[]</code> 和空对象 <code>&#123;&#125;</code> 都是 <code>true</code></li>
</ul>
</li>
</ul>
<h4 id="隐式转-Boolean">隐式转 Boolean</h4>
<p>用非布尔类型的数值和布尔值比较时，会先转换为布尔类型然后对比</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> == <span class="literal">true</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span> == <span class="literal">true</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="显式转-Boolean">显式转 Boolean</h4>
<ol>
<li>
<p>使用 <code>!!</code> 可以显式地转换为布尔类型</p>
<p>比如 <code>!!3 == true</code></p>
</li>
<li>
<p>使用 <code>Boolean()</code> 函数显示地转换为布尔类型</p>
</li>
</ol>
<h3 id="隐式类型转换">隐式类型转换</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>();</span><br></pre></td></tr></table></figure>
<p>判断参数是否为 <code>NaN</code> ，返回结果是布尔值，即任何不能被转换为数值的参数，返回值都是 true</p>
<p>执行过程：先调用 <code>Number()</code> 函数，再把返回结果和 <code>NaN</code> 进行比较。</p>
<ol>
<li>
<p>自增/自减运算符： <code>–-</code> / <code>++</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;444&#x27;</span>;</span><br><span class="line">a++;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a); <span class="comment">// number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">// 445</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>正号/符号：<code>+a</code> / <code>-a</code></p>
<p>内部调用了 <code>Number()</code> 函数</p>
</li>
<li>
<p>加号：<code>+</code></p>
<ul>
<li>字符串 + 数字：会调用 <code>String()</code> 函数把数字转换成字符串，然后字符串拼接。</li>
<li>布尔值 + 数字：会调用 <code>Number()</code> 函数把布尔值转换成数字(true =&gt; 1, false =&gt; 0)，再和数字相加</li>
<li>null + 数字：相当于 0 + 数字</li>
<li>undefined + 数字：NaN</li>
</ul>
</li>
<li>
<p>运算符：<code>-</code> / <code>*</code> / <code>/</code></p>
<p>非数值型做这些运算的时候，内部调用 <code>Number()</code> 函数转换成数字再进行计算</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">result1 = <span class="literal">true</span> + <span class="number">1</span>;  <span class="comment">// 2 = 1+ 1</span></span><br><span class="line">result2 = <span class="literal">true</span> + <span class="literal">false</span>; <span class="comment">// 1 = 1+ 0</span></span><br><span class="line">result3 = <span class="number">1</span> + <span class="literal">null</span>; <span class="comment">// 1 = 1+ 0</span></span><br><span class="line">result4 = <span class="number">100</span> - <span class="string">&#x27;1&#x27;</span> <span class="comment">// 99</span></span><br></pre></td></tr></table></figure>
<p>任何的值和字符串做加法运算，都会先转换成字符串，然后做字符串连接。</p>
</li>
<li>
<p>逻辑运算符：<code>&amp;&amp;</code> / <code>||</code> / <code>!</code></p>
</li>
<li>
<p>关系运算符：<code>&lt;</code> / <code>&gt;</code> / <code>&gt;=</code> / <code>&lt;=</code></p>
</li>
</ol>
<h2 id="运算符">运算符</h2>
<p><code>+</code>、<code>*</code>、<code>/</code>、<code>(</code> 都是<strong>运算符</strong>，而 <code>(3+5)/2</code> 则是<strong>表达式</strong>。</p>
<h3 id="算数运算符">算数运算符</h3>
<p>用于执行两个变量或值的算术运算。</p>
<p><code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code></p>
<p><strong>运算进度问题</strong></p>
<p>在进行算数计算时，会丢失精度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.1</span> + <span class="number">0.2</span>); <span class="comment">// 0.30000000000000004</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0.07</span> * <span class="number">100</span>); <span class="comment">// 7.000000000000001</span></span><br></pre></td></tr></table></figure>
<h3 id="自增和自减">自增和自减</h3>
<p><code>a++</code> 和 <code>++a</code></p>
<p><code>a--</code> 和 <code>--a</code></p>
<p>都会对变量进行更改，区别在于左边的表达式的值是变更前的 <code>a</code>，右边的表达式的值是变更后的<code>a</code></p>
<h3 id="一元运算符">一元运算符</h3>
<ol>
<li><code>typeof</code></li>
<li><code>+</code> 正号</li>
<li><code>-</code> 负号</li>
</ol>
<h3 id="逻辑运算符">逻辑运算符</h3>
<ul>
<li><code>&amp;&amp;</code> 与运算</li>
<li><code>||</code> 或运算</li>
<li><code>!</code> 否运算</li>
</ul>
<p>非布尔值进行与运算的时候，会转换成布尔值再运算，但是返回结果是某个原值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="number">3</span> &amp;&amp; <span class="number">4</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>与运算的结果</p>
<ul>
<li>如果第一个值是 false，就执行第一条语句，并返回第一个值</li>
<li>如果第一个值是 true，就继续执行第二条语句，并返回第二个值</li>
</ul>
<p>与运算的结果</p>
<ul>
<li>
<p>如果第一个值是 true，就执行第一条语句，并返回第一个值</p>
</li>
<li>
<p>如果第一个值是 false，就继续执行第二条语句，并返回第二个值</p>
</li>
</ul>
<p>以实际开发中的容错处理为例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (result.<span class="property">resultCode</span> == <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> a = result &amp;&amp; result.<span class="property">data</span> &amp;&amp; result.<span class="property">data</span>.<span class="property">imgUrl</span> || <span class="string">&#x27;https://cdn.ethanloo.cn/img/20210127092655.png&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="赋值运算符">赋值运算符</h3>
<ul>
<li><code>=</code></li>
<li><code>+=</code></li>
<li><code>-=</code></li>
<li><code>*=</code></li>
<li><code>/=</code></li>
<li><code>%=</code></li>
</ul>
<h3 id="比较运算符">比较运算符</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;	大于号</span><br><span class="line">&lt;	小于号</span><br><span class="line">&gt;= 	大于或等于</span><br><span class="line">&lt;=  小于或等于</span><br><span class="line">== 	等于</span><br><span class="line">=== 全等于</span><br><span class="line">!=	不等于</span><br><span class="line">!== 不全等于</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>非数值的比较</p>
<ul>
<li>
<p>对于非数值的进行比较，会转换成数字再进行比较</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> &gt; <span class="literal">true</span>); <span class="comment">// false，因为true == 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">10</span> &gt; <span class="literal">null</span> ); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">10</span> &lt; <span class="title class_">NaN</span>); <span class="comment">// false，任何值和NaN比较都是false</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果两边都是字符串，不会转换成数字，比较的是字符串的 Unicode编码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;33&#x27;</span> &gt; <span class="string">&#x27;123&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>关于 <code>==</code></p>
<ul>
<li>
<p>可以用于验证字符串是否相等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ethan&#x27;</span> == <span class="string">&#x27;ehtan&#x27;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>但是这个符号并不严谨，在比较不同类型的数据时，会进行隐式转换</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;6&#x27;</span> == <span class="number">6</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>undefined</code> 衍生自 <code>null</code>，因此两个值相等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span> == <span class="literal">null</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>NaN</code> 不和任何值相等</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> == <span class="number">3</span>); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">NaN</span> == <span class="title class_">NaN</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>因此使用 <code>isNaN()</code> 函数来判断某个值是否为 <code>NaN</code></p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>关于<code>===</code></p>
<ul>
<li>
<p>全等在比较时，不会进行类型转换</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;6&#x27;</span> === <span class="number">6</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>相等的否定形式为<code>!=</code>，全等的否定形式为 <code>!==</code></p>
</li>
</ul>
</li>
</ol>
<h3 id="三元运算符">三元运算符</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">条件表达式 ? 语句<span class="number">1</span> : 语句<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>若表达式为真就执行语句1，否则执行语句2</p>
<h3 id="Unicode-编码">Unicode 编码</h3>
<ol>
<li>
<p>在字符串中可以使用转义字符输入 Unicode 编码</p>
<p>格式：<code>\u四位编码</code>，这里的编码使用的是 16 进制的。</p>
<p>例如：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;\u2600&#x27;</span>); <span class="comment">// 2600是16进制数</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在 HTML 中也可以直接使用  Unicode编码</p>
<p>格式：<code>&amp;#四位编码</code>，这里的编码要使用 10 进制的。</p>
<p>例如：</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="symbol">&amp;#9860;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="选择结构">选择结构</h2>
<ol>
<li>
<p><code>if</code> 语句</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>switch</code> 语句</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span>(a) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>使用 <code>switch</code> 优雅地替换掉多分支判断语句。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> day = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (day) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;work&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 在这里放一个 break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;relax&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 在这里放一个 break</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环语句">循环语句</h2>
<h3 id="for-循环">for 循环</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">13</span>; i++)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="while-循环">while 循环</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i++&lt;=<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(j);</span><br><span class="line">&#125; <span class="keyword">while</span> (j++&lt;=<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h3 id="小练习">小练习</h3>
<blockquote>
<p>好家伙，有大一刚学 python 内味了</p>
</blockquote>
<ol>
<li>
<p>在页面中接收一个用户输入的数字<code>N</code>，并输出所有<code>[0,N]</code>范围内的质数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="built_in">parseInt</span>(<span class="title function_">prompt</span>(<span class="string">&quot;请输入一个正整数N:&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">2</span>; j &lt; i; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % j == <span class="number">0</span>) &#123;</span><br><span class="line">      flag = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>输出九九乘法表</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="string">&quot;&quot;</span> + j + <span class="string">&quot;*&quot;</span> + i + <span class="string">&quot;=&quot;</span> + i * j;</span><br><span class="line">    res += tmp + <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  res += <span class="string">&quot;&lt;br/&gt;&quot;</span>;</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">write</span>(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="对象">对象</h2>
<ul>
<li>对象的属性值，可以是一个函数（方法）</li>
<li>对象的属性值，也可以是一个对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">person.<span class="property">name</span> = <span class="string">&#x27;ethan&#x27;</span>;</span><br><span class="line">person.<span class="property">age</span> = <span class="number">233</span>;</span><br><span class="line">person.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;I am Ethan.&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对象的分类">对象的分类</h3>
<p>1.内置对象：</p>
<ul>
<li>
<p>由ES标准中定义的对象，在任何的ES的实现中都可以使用</p>
</li>
<li>
<p>比如：Object、Math、Date、String、Array、Number、Boolean、Function等。</p>
</li>
</ul>
<p>2.宿主对象：</p>
<ul>
<li>
<p>由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象。</p>
</li>
<li>
<p>比如 BOM DOM。比如<code>console</code>、<code>document</code>。</p>
</li>
</ul>
<p>3.自定义对象：</p>
<ul>
<li>由开发人员自己创建的对象</li>
</ul>
<h3 id="基本包装类型">基本包装类型</h3>
<p>属性和方法只能给对象添加，基本数据类型无法拥有属性和方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;ethan&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;ethan&#x27;</span>);</span><br><span class="line">a.<span class="property">Age</span> = <span class="number">13</span>;</span><br><span class="line">b.<span class="property">Age</span> = <span class="number">21</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">Age</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">Age</span>); <span class="comment">// 21</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a); <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> b); <span class="comment">// Object</span></span><br></pre></td></tr></table></figure>
<p>JS 提供的三个包装类，可以把基本数据类型转换为对象。</p>
<ul>
<li><code>String()</code></li>
<li><code>Number()</code></li>
<li><code>Boolean()</code></li>
</ul>
<p>当调用基本数据类型的属性的时候，实际上就是临时使用了包装类。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;ethan&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">length</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>内部的执行流程如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> temp = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;ethan&#x27;</span>);</span><br><span class="line">a = tmp;</span><br><span class="line">tmp = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>在底层，字符串是以字符数组的形式保存的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;ethan&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[<span class="number">1</span>]); <span class="comment">// &#x27;t&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>2021美赛建模小记</title>
    <url>/post/2021-02-09-Diaries/2021%E7%BE%8E%E8%B5%9B%E5%BB%BA%E6%A8%A1%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<p>早上十点多睡到晚上五点多，刚醒，趁记忆新鲜先对刚刚结束的美赛做个小结吧。🤗</p>
<p>四天建模就已经让人头大，最后甚至经历了一波官方邮箱服务器爆炸论文交不了的危机。🤕</p>
<p>最后一天甚至最后接近连续28个小时没有睡觉（除去半小时午觉）。</p>
<p>也算是硬写完了一篇看起来还可以但是实际上是在胡言乱语的论文。</p>
<img src="https://cdn.ethanloo.cn/img/20210209181044.png" alt="image-20210209181037733" style="zoom: 67%;" />
<p>2.5号早上6点比赛正式开始，真是好久没有起这么早了。早上起来看题，讨论，选题，最后大概花了一个多小时就确定了题目，A：Fungi，可以简单理解为养真菌。</p>
<p>比赛其实对我而言并不是这个时间开始的，正式开始前的两个星期，由于学校的要求和我们小组自身的严格要求，我们练习了大概2道多的往年的建模题，每道题目都花了四五天时间去完成。这是为了提前熟悉比赛，也是为了掌握一些基础的算法，让我们知道O奖论文能成为O奖论文的原因。我担任的我们队的编程手和资料手，本身我去年托福考了104，对自己的找资料能力还是挺自信的，结果这次比赛深受打击。</p>
<p>时间再回到2.5号上午，我们选A题的原因有两个方面</p>
<ol>
<li>我们小组的建模手对连续性问题比较熟悉，所以之前也练习了2019和2020年的A题，一个是养龙一个是捕鱼。</li>
<li>这次比赛的A题和前两年的A题而言感觉难度差不多，对比BC两题而言，感觉实现的可能性更大。</li>
</ol>
<p>确定选题之后，就是一通搜，从题目中给的一篇参考论文出发，再找这篇论文它的 Reference（这些论文人均引用50篇，是真滴夸张）。经历了大概一天的搜索时间，事实上我们搜到的资料很少，真菌的具体数据也不够全。不过最后还是由建模手初步确定了模型（玄学建模嘛），我们套用了 Logistic Growth Model，把真菌的群落的繁衍用人口数量增长模型去类比。然后这种方程就是自己定参数，调参数，以图好看为出发点，以有理有据为其次，大概的图片画出来如下：</p>
<img src="https://cdn.ethanloo.cn/img/20210209183142.png" alt="image-20210209183142905" style="zoom: 67%;" />
<p>接下来几天，就是每天15小时的腾讯会议，痛苦地经历了资料不够用，玄学建模，面向画图建模……，分别也是把接下来几道题写完了。偷偷说一句，语雀真好用，分享图片，文档真比QQ群快多了。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210209183943.png" alt="image-20210209183943272"></p>
<p>最后一天晚上，由于论文手写得实在太慢，而且实际上论文有很大一部分都是我在写，导致我们的进度非常慢。通宵整晚之后，在早上八点五十左右我们准备投递我们的论文，结果似乎是官方邮箱服务器崩溃了，导致退信。</p>
<p><img src="https://cdn.ethanloo.cn/img/20210209184102.png" alt="image-20210209184102501"></p>
<p>于是，整个小组就开始疯狂投递，就怕在十点截止前投不进去。我们用了各种邮箱，网易，腾讯，新浪，谷歌，微软，真是无所不尽其能，就为了能赶紧去睡觉。然而花了一个半小时才投递成功，最后的赢家是QQ邮箱！</p>
<p>总之是一段值得纪念的经历，一场在我现在看来或许是最辛苦的比赛，或许对未来的我而言这只是一场普遍的通宵加班而已。</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>美赛</tag>
        <tag>数学建模</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年2月刷题日志</title>
    <url>/post/2021-02-01-Algorithm/2021%E5%B9%B42%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p><strong>2.28</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="896-单调数列"><a href="https://leetcode-cn.com/problems/monotonic-array/">896. 单调数列</a></h4>
<p>难度简单89</p>
<p>如果数组是单调递增或单调递减的，那么它是<em>单调的</em>。</p>
<p>如果对于所有 <code>i &lt;= j</code>，<code>A[i] &lt;= A[j]</code>，那么数组 <code>A</code> 是单调递增的。 如果对于所有 <code>i &lt;= j</code>，<code>A[i]&gt; = A[j]</code>，那么数组 <code>A</code> 是单调递减的。</p>
<p>当给定的数组 <code>A</code> 是单调数组时返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,2,2,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[6,5,4,4]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,3,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,2,4,5]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,1,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 50000</code></li>
<li><code>-100000 &lt;= A[i] &lt;= 100000</code></li>
</ol>
</blockquote>
<p><strong>思路</strong></p>
<p>遍历数组，利用<code>flag</code>记录下当前的趋势（递增 1，递减 -1，或者全都一样 0）</p>
<p>若当前的趋势和<code>flag</code>的趋势相反，即之前为递增现在递减，或者之前递减现在递增，就说明不单调。</p>
<p>反之，到最后没有出现不同趋势，则说明单调。</p>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">A</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isMonotonic = <span class="keyword">function</span>(<span class="params">A</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="property">length</span>&lt;=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i&lt;=A.<span class="property">length</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> diff = A[i]-A[i-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(diff*flag&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(diff&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(diff&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            flag = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>2.26</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="395-至少有K个重复字符的最长子串"><a href="https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/">395. 至少有K个重复字符的最长子串</a></h4>
<p>难度中等</p>
<p>找到给定字符串（由小写字符组成）中的最长子串 *<strong>T*</strong> ， 要求 *<strong>T*</strong> 中的每一字符出现次数都不少于 <em>k</em> 。输出 *<strong>T*</strong> 的长度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;aaabb&quot;, k = 3</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">最长子串为 &quot;aaa&quot; ，其中 &#x27;a&#x27; 重复了 3 次。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;ababbc&quot;, k = 2</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">最长子串为 &quot;ababb&quot; ，其中 &#x27;a&#x27; 重复了 2 次， &#x27;b&#x27; 重复了 3 次。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p><strong>分治法</strong>，根据字母的出现次数，找到出现次数小于k的字母，将字符串进行分割。</p>
<p>例如<code>s = 'aaabbbbccbaaaadbbb', k = 3</code>，第一次会把<code>s</code>分割成三段<code>'aaabbbb','baaaa'(事实上),'bbb'</code>。</p>
<p>然后需要对子串也进行同样地切割，保证子串中所有字母的出现次数大于等于<code>k</code>，例如上面的<code>baaaa</code>就会被分割成<code>aaaa</code>。</p>
<p>最后就能知道最大字串长度为<code>7</code>，即<code>aaabbbb</code>子串的长度。</p>
<p><strong>代码</strong></p>
<p>参考的一个大佬的分治法代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">set</span>(s):</span><br><span class="line">            <span class="keyword">if</span> s.count(c) &lt; k:</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(self.longestSubstring(t, k) <span class="keyword">for</span> t <span class="keyword">in</span> s.split(c))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br></pre></td></tr></table></figure>
<p><strong>2.25</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="867-转置矩阵"><a href="https://leetcode-cn.com/problems/transpose-matrix/">867. 转置矩阵</a></h4>
<p>难度简单163</p>
<p>给你一个二维整数数组 <code>matrix</code>， 返回 <code>matrix</code> 的 <strong>转置矩阵</strong> 。</p>
<p>矩阵的 <strong>转置</strong> 是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。</p>
<p><img src="https://assets.leetcode.com/uploads/2021/02/10/hint_transpose.png" alt="img"></p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[1,4,7],[2,5,8],[3,6,9]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6]]</span><br><span class="line">输出：[[1,4],[2,5],[3,6]]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 1000</code></li>
<li><code>1 &lt;= m * n &lt;= 105</code></li>
<li><code>-109 &lt;= matrix[i][j] &lt;= 109</code></li>
</ul>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transpose</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        m, n = <span class="built_in">len</span>(matrix), <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        res = [[<span class="number">0</span>]*m <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]  </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">                res[i][j] = matrix[j][i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">matrix</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> transpose = <span class="keyword">function</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> m = matrix.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">var</span> n = matrix[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="keyword">new</span> <span class="title class_">Array</span>(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        res[i] = <span class="keyword">new</span> <span class="title class_">Array</span>(m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            res[i][j] = matrix[j][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>2.24</strong></p>
<p>拿到驾照啦，嘿嘿👶</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="832-翻转图像"><a href="https://leetcode-cn.com/problems/flipping-an-image/">832. 翻转图像</a></h4>
<p>难度简单</p>
<p>给定一个二进制矩阵 <code>A</code>，我们想先水平翻转图像，然后反转图像并返回结果。</p>
<p>水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 <code>[1, 1, 0]</code> 的结果是 <code>[0, 1, 1]</code>。</p>
<p>反转图片的意思是图片中的 <code>0</code> 全部被 <code>1</code> 替换， <code>1</code> 全部被 <code>0</code> 替换。例如，反转 <code>[0, 1, 1]</code> 的结果是 <code>[1, 0, 0]</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[[1,1,0],[1,0,1],[0,0,0]]</span><br><span class="line">输出：[[1,0,0],[0,1,0],[1,1,1]]</span><br><span class="line">解释：首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；</span><br><span class="line">     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]</span><br><span class="line">输出：[[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br><span class="line">解释：首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；</span><br><span class="line">     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= A.length = A[0].length &lt;= 20</code></li>
<li><code>0 &lt;= A[i][j] &lt;= 1</code></li>
</ul>
</blockquote>
<p><strong>代码</strong></p>
<p>一行 Python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">flipAndInvertImage</span>(<span class="params">self, A: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">return</span> [[j ^ <span class="number">1</span> <span class="keyword">for</span> j <span class="keyword">in</span> i[::-<span class="number">1</span>]] <span class="keyword">for</span> i <span class="keyword">in</span> A]</span><br></pre></td></tr></table></figure>
<p><strong>2.23</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1052-爱生气的书店老板"><a href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/">1052. 爱生气的书店老板</a></h4>
<p>难度中等</p>
<p>今天，书店老板有一家店打算试营业 <code>customers.length</code> 分钟。每分钟都有一些顾客（<code>customers[i]</code>）会进入书店，所有这些顾客都会在那一分钟结束后离开。</p>
<p>在某些时候，书店老板会生气。 如果书店老板在第 <code>i</code> 分钟生气，那么 <code>grumpy[i] = 1</code>，否则 <code>grumpy[i] = 0</code>。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。</p>
<p>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 <code>X</code> 分钟不生气，但却只能使用一次。</p>
<p>请你返回这一天营业下来，最多有多少客户能够感到满意的数量。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3</span><br><span class="line">输出：16</span><br><span class="line">解释：</span><br><span class="line">书店老板在最后 3 分钟保持冷静。</span><br><span class="line">感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16.</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= X &lt;= customers.length == grumpy.length &lt;= 20000</code></li>
<li><code>0 &lt;= customers[i] &lt;= 1000</code></li>
<li><code>0 &lt;= grumpy[i] &lt;= 1</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>首先可以计算出在老板原本不生气情况下，可以满足的顾客数，同时我们将满足的某分钟顾客数置为0，以便后续减少判断。</p>
<p>接下来，考虑老板应该用哪 <code>X</code> 分钟不生气，来使自己能满足的顾客数最大化，很简单，<strong>滑动窗口</strong>。</p>
<p>可以理解为一个大小为 X 的窗口，从左滑到右，找到最大新增满足顾客数即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSatisfied</span>(<span class="params">self, customers: <span class="type">List</span>[<span class="built_in">int</span>], grumpy: <span class="type">List</span>[<span class="built_in">int</span>], X: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(customers)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>: <span class="keyword">return</span> customers[<span class="number">0</span>]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> grumpy[i]:</span><br><span class="line">                res += customers[i]</span><br><span class="line">                customers[i] = <span class="number">0</span></span><br><span class="line">        tmp = []</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(X-<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> i == X-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(X-<span class="number">1</span>):</span><br><span class="line">                    cnt += customers[j]</span><br><span class="line">            cnt += customers[i]</span><br><span class="line">            tmp.append(cnt)</span><br><span class="line">            cnt -= customers[i-X+<span class="number">1</span>]</span><br><span class="line">        res += <span class="built_in">max</span>(tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>2.22</strong></p>
<p>美丽的周一</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="766-托普利茨矩阵"><a href="https://leetcode-cn.com/problems/toeplitz-matrix/">766. 托普利茨矩阵</a></h4>
<p>难度简单</p>
<p>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code> 。如果这个矩阵是托普利茨矩阵，返回 <code>true</code> ；否则，返回 <code>false</code> <em>。</em></p>
<p>如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是 <strong>托普利茨矩阵</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/04/ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">在上述矩阵中, 其对角线为: </span><br><span class="line">&quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;。 </span><br><span class="line">各条对角线上的所有元素均相同, 因此答案是 True 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/11/04/ex2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2],[2,2]]</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">对角线 &quot;[1, 2]&quot; 上的元素不同。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>m == matrix.length</code></li>
<li><code>n == matrix[i].length</code></li>
<li><code>1 &lt;= m, n &lt;= 20</code></li>
<li><code>0 &lt;= matrix[i][j] &lt;= 99</code></li>
</ul>
</blockquote>
<p>简单的语言语法熟悉题</p>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">matrix</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isToeplitzMatrix = <span class="keyword">function</span>(<span class="params">matrix</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> row = matrix.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">var</span> col = matrix[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i&lt;row;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">1</span>;j&lt;col;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i-<span class="number">1</span>][j-<span class="number">1</span>] != matrix[i][j])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>2.21</strong></p>
<p>好家伙直接延迟一周开学，白嫖一周自习时间，爽到</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1438-绝对差不超过限制的最长连续子数组"><a href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">1438. 绝对差不超过限制的最长连续子数组</a></h4>
<p>难度中等</p>
<p>给你一个整数数组 <code>nums</code> ，和一个表示限制的整数 <code>limit</code>，请你返回最长连续子数组的长度，该子数组中的任意两个元素之间的绝对差必须小于或者等于 <code>limit</code> <em>。</em></p>
<p>如果不存在满足条件的子数组，则返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [8,2,4,7], limit = 4</span><br><span class="line">输出：2 </span><br><span class="line">解释：所有子数组如下：</span><br><span class="line">[8] 最大绝对差 |8-8| = 0 &lt;= 4.</span><br><span class="line">[8,2] 最大绝对差 |8-2| = 6 &gt; 4. </span><br><span class="line">[8,2,4] 最大绝对差 |8-2| = 6 &gt; 4.</span><br><span class="line">[8,2,4,7] 最大绝对差 |8-2| = 6 &gt; 4.</span><br><span class="line">[2] 最大绝对差 |2-2| = 0 &lt;= 4.</span><br><span class="line">[2,4] 最大绝对差 |2-4| = 2 &lt;= 4.</span><br><span class="line">[2,4,7] 最大绝对差 |2-7| = 5 &gt; 4.</span><br><span class="line">[4] 最大绝对差 |4-4| = 0 &lt;= 4.</span><br><span class="line">[4,7] 最大绝对差 |4-7| = 3 &lt;= 4.</span><br><span class="line">[7] 最大绝对差 |7-7| = 0 &lt;= 4. </span><br><span class="line">因此，满足题意的最长子数组的长度为 2 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [10,1,2,4,7,2], limit = 5</span><br><span class="line">输出：4 </span><br><span class="line">解释：满足题意的最长子数组是 [2,4,7,2]，其最大绝对差 |2-7| = 5 &lt;= 5 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,2,2,2,4,4,2,2], limit = 0</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>
<li><code>1 &lt;= nums[i] &lt;= 10^9</code></li>
<li><code>0 &lt;= limit &lt;= 10^9</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>滑动窗口 + 双端队列</p>
<p>右指针遍历整个数组，左指针根据右指针的位置不断右移</p>
<p>用两个双端队列，来记录当前窗口内的最大值和最小值</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestSubarray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], limit: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        min_que, max_que = deque(), deque()</span><br><span class="line">        left = right = res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right &lt; n:</span><br><span class="line">            <span class="keyword">while</span> min_que <span class="keyword">and</span> nums[right] &lt; min_que[-<span class="number">1</span>]:</span><br><span class="line">                min_que.pop()</span><br><span class="line">            <span class="keyword">while</span> max_que <span class="keyword">and</span> nums[right] &gt; max_que[-<span class="number">1</span>]:</span><br><span class="line">                max_que.pop()</span><br><span class="line">                </span><br><span class="line">            min_que.append(nums[right])</span><br><span class="line">            max_que.append(nums[right])</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> min_que <span class="keyword">and</span> max_que <span class="keyword">and</span> max_que[<span class="number">0</span>]-min_que[<span class="number">0</span>] &gt; limit:</span><br><span class="line">                <span class="keyword">if</span> max_que[<span class="number">0</span>] == nums[left]:</span><br><span class="line">                    max_que.popleft()</span><br><span class="line">                <span class="keyword">if</span> min_que[<span class="number">0</span>] == nums[left]:</span><br><span class="line">                    min_que.popleft()</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, right-left+<span class="number">1</span>)</span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>2.20</strong></p>
<p>再过一个礼拜就要回校啦，美好的寒假生活终于可以结束了。</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="697-数组的度"><a href="https://leetcode-cn.com/problems/degree-of-an-array/">697. 数组的度</a></h4>
<p>难度简单229</p>
<p>给定一个非空且只包含非负数的整数数组 <code>nums</code>，数组的度的定义是指数组里任一元素出现频数的最大值。</p>
<p>你的任务是在 <code>nums</code> 中找到与 <code>nums</code> 拥有相同大小的度的最短连续子数组，返回其长度。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1, 2, 2, 3, 1]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">输入数组的度是2，因为元素1和2的出现频数最大，均为2.</span><br><span class="line">连续子数组里面拥有相同度的有如下所示:</span><br><span class="line">[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]</span><br><span class="line">最短连续子数组[2, 2]的长度为2，所以返回2.</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,2,2,3,1,4,2]</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>用一个哈希表，记录每个数字的 <code>[出现次数，第一次出现的位置，最后一次出现的位置]</code></p>
<p>确认出现次数最多有多少次，再次遍历数组，找到最短的子数组长度</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findShortestSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dic = <span class="built_in">dict</span>()</span><br><span class="line">        targets = []</span><br><span class="line">        max_cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> dic: dic[num] = [<span class="number">0</span>, <span class="built_in">len</span>(nums)+<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">            dic[num][<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">            dic[num][<span class="number">1</span>] = <span class="built_in">min</span>(dic[num][<span class="number">1</span>], i)</span><br><span class="line">            dic[num][<span class="number">2</span>] = <span class="built_in">max</span>(dic[num][<span class="number">2</span>], i)</span><br><span class="line">            max_cnt = <span class="built_in">max</span>(max_cnt, dic[num][<span class="number">0</span>])</span><br><span class="line">        res = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dic.keys():</span><br><span class="line">            <span class="keyword">if</span> dic[i][<span class="number">0</span>] == max_cnt:</span><br><span class="line">                left, right = dic[i][<span class="number">1</span>], dic[i][<span class="number">2</span>]</span><br><span class="line">                res = <span class="built_in">min</span>(res, right-left+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>2.19</strong></p>
<p>昨日约会💑，鸽了一天</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1004-最大连续1的个数-III"><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/">1004. 最大连续1的个数 III</a></h4>
<p>难度中等</p>
<p>给定一个由若干 <code>0</code> 和 <code>1</code> 组成的数组 <code>A</code>，我们最多可以将 <code>K</code> 个值从 0 变成 1 。</p>
<p>返回仅包含 1 的最长（连续）子数组的长度。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2</span><br><span class="line">输出：6</span><br><span class="line">解释： </span><br><span class="line">[1,1,1,0,0,1,1,1,1,1,1]</span><br><span class="line">粗体数字从 0 翻转到 1，最长的子数组长度为 6。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3</span><br><span class="line">输出：10</span><br><span class="line">解释：</span><br><span class="line">[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]</span><br><span class="line">粗体数字从 0 翻转到 1，最长的子数组长度为 10。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 20000</code></li>
<li><code>0 &lt;= K &lt;= A.length</code></li>
<li><code>A[i]</code> 为 <code>0</code> 或 <code>1</code></li>
</ol>
</blockquote>
<p><strong>思路</strong></p>
<p>滑动窗口，设置两个指针从左滑到右，将窗口设计为不能减小（令K只减不增实现）</p>
<p>滑动的时候计算出现的0的个数</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestOnes</span>(<span class="params">self, A: <span class="type">List</span>[<span class="built_in">int</span>], K: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        left = right = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> right&lt;<span class="built_in">len</span>(A):</span><br><span class="line">            <span class="keyword">if</span> A[right] == <span class="number">0</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt&gt;K:</span><br><span class="line">                <span class="keyword">if</span> A[left]==<span class="number">0</span>:</span><br><span class="line">                    cnt -= <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right - left</span><br></pre></td></tr></table></figure>
<p><strong>2.17</strong></p>
<p>最近开始简单题就用 JS 写了</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="566-重塑矩阵"><a href="https://leetcode-cn.com/problems/reshape-the-matrix/">566. 重塑矩阵</a></h4>
<p>难度简单</p>
<p>在MATLAB中，有一个非常有用的函数 <code>reshape</code>，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。</p>
<p>给出一个由二维数组表示的矩阵，以及两个正整数<code>r</code>和<code>c</code>，分别表示想要的重构的矩阵的行数和列数。</p>
<p>重构后的矩阵需要将原始矩阵的所有元素以相同的<strong>行遍历顺序</strong>填充。</p>
<p>如果具有给定参数的<code>reshape</code>操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 1, c = 4</span><br><span class="line">输出: </span><br><span class="line">[[1,2,3,4]]</span><br><span class="line">解释:</span><br><span class="line">行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">nums = </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">r = 2, c = 4</span><br><span class="line">输出: </span><br><span class="line">[[1,2],</span><br><span class="line"> [3,4]]</span><br><span class="line">解释:</span><br><span class="line">没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ol>
<li>给定矩阵的宽和高范围在 [1, 100]。</li>
<li>给定的 r 和 c 都是正数。</li>
</ol>
</blockquote>
<p><strong>思路</strong></p>
<p>创建矩阵，遍历原矩阵，用 <code>cnt</code> 来计数（当然也可以边遍历边计算）</p>
<ul>
<li>通过 <code>cnt//c</code> 来求出当前目标矩阵中的行</li>
<li>通过 <code>cnt%c</code> 来求出当前目标矩阵中的列</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">r</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">c</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> matrixReshape = <span class="keyword">function</span> (<span class="params">nums, r, c</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> rows = nums.<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">var</span> cols = nums[<span class="number">0</span>].<span class="property">length</span>;</span><br><span class="line">  <span class="keyword">if</span> (rows * cols != r * c) &#123;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">new</span> <span class="title class_">Array</span>(r);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">    res[i] = <span class="keyword">new</span> <span class="title class_">Array</span>(c);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">      <span class="keyword">var</span> curR = <span class="title class_">Math</span>.<span class="title function_">floor</span>(cnt / c);</span><br><span class="line">      <span class="keyword">var</span> curC = cnt % c;</span><br><span class="line">      res[curR][curC] = nums[i][j];</span><br><span class="line">      cnt += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>2.16</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="561-数组拆分-I"><a href="https://leetcode-cn.com/problems/array-partition-i/">561. 数组拆分 I</a></h4>
<p>难度简单</p>
<p>给定长度为 <code>2n</code> 的整数数组 <code>nums</code> ，你的任务是将这些数分成 <code>n</code> 对, 例如 <code>(a1, b1), (a2, b2), ..., (an, bn)</code> ，使得从 <code>1</code> 到 <code>n</code> 的 <code>min(ai, bi)</code> 总和最大。</p>
<p>返回该 <strong>最大总和</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,4,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：所有可能的分法（忽略元素顺序）为：</span><br><span class="line">1. (1, 4), (2, 3) -&gt; min(1, 4) + min(2, 3) = 1 + 2 = 3</span><br><span class="line">2. (1, 3), (2, 4) -&gt; min(1, 3) + min(2, 4) = 1 + 2 = 3</span><br><span class="line">3. (1, 2), (3, 4) -&gt; min(1, 2) + min(3, 4) = 1 + 3 = 4</span><br><span class="line">所以最大总和为 4</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [6,2,6,5,1,2]</span><br><span class="line">输出：9</span><br><span class="line">解释：最优的分法为 (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 104</code></li>
<li><code>nums.length == 2 * n</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>排序，计算 <code>index</code> 为偶数的数字和</p>
<p><strong>代码</strong></p>
<p>现学现用 JS</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> arrayPairSum = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;nums.<span class="property">length</span>;i+=<span class="number">2</span>)&#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>2.15</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="485-最大连续1的个数"><a href="https://leetcode-cn.com/problems/max-consecutive-ones/">485. 最大连续1的个数</a></h4>
<p>难度简单</p>
<p>给定一个二进制数组， 计算其中最大连续1的个数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,1,0,1,1,1]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>输入的数组只包含 <code>0</code> 和<code>1</code>。</li>
<li>输入数组的长度是正整数，且不超过 10,000。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>非常简单的一道初学者题目，遍历一遍数组即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxConsecutiveOnes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res = <span class="built_in">max</span>(cnt, res)</span><br><span class="line">                cnt = <span class="number">0</span></span><br><span class="line">        res = <span class="built_in">max</span>(res, cnt)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>2.14</strong></p>
<p>情人节 Leetcode 也虐狗，可惜我不是🐕</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="765-情侣牵手"><a href="https://leetcode-cn.com/problems/couples-holding-hands/">765. 情侣牵手</a></h4>
<p>难度困难144</p>
<p>N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 <em>一</em>次交换可选择任意两人，让他们站起来交换座位。</p>
<p>人和座位用 <code>0</code> 到 <code>2N-1</code> 的整数表示，情侣们按顺序编号，第一对是 <code>(0, 1)</code>，第二对是 <code>(2, 3)</code>，以此类推，最后一对是 <code>(2N-2, 2N-1)</code>。</p>
<p>这些情侣的初始座位 <code>row[i]</code> 是由最初始坐在第 i 个座位上的人决定的。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: row = [0, 2, 1, 3]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 我们只需要交换row[1]和row[2]的位置即可。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: row = [3, 2, 0, 1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 无需交换座位，所有的情侣都已经可以手牵手了。</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ol>
<li><code>len(row)</code> 是偶数且数值在 <code>[4, 60]</code>范围内。</li>
<li>可以保证<code>row</code> 是序列 <code>0...len(row)-1</code> 的一个全排列。</li>
</ol>
</blockquote>
<p><strong>思路</strong></p>
<p>虽然是困难题，但我用的是简单题的方法（偷懒了），时间复杂度是O(N²)</p>
<p>标准解法应该使用官方题解的并查集思路，时间复杂度是O(N²)</p>
<p>我纯粹地假设位置0，2，4…这些偶数位置的 index 位置上的人都不会移动，只判断 ta 右边的人是否正确，然后进行交换即可</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minSwapsCouples</span>(<span class="params">self, row: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find_another</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">if</span> x%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> x+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> x-<span class="number">1</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(row)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n,<span class="number">2</span>):</span><br><span class="line">            partner = find_another(row[i])</span><br><span class="line">            <span class="keyword">if</span> row[i+<span class="number">1</span>] == partner:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = row.index(partner)</span><br><span class="line">                row[i+<span class="number">1</span>], row[j] = row[j], row[i+<span class="number">1</span>]</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>
<p><strong>2.13</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="448-找到所有数组中消失的数字"><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/">448. 找到所有数组中消失的数字</a></h4>
<p>难度简单</p>
<p>给定一个范围在 1 ≤ a[i] ≤ <em>n</em> ( <em>n</em> = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p>
<p>找到所有在 [1, <em>n</em>] 范围之间没有出现在数组中的数字。</p>
<p>您能在不使用额外空间且时间复杂度为*O(n)*的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[4,3,2,7,8,2,3,1]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[5,6]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDisappearedNumbers</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            nums[(num-<span class="number">1</span>)%n] += n</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> num&lt;=n:</span><br><span class="line">                res.append(i+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>2.12</strong></p>
<p>牛年大吉！</p>
<p><strong>题目</strong></p>
<blockquote>
<p>杨辉三角第k行</p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getRow</span>(<span class="params">self, rowIndex: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        nums = [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rowIndex):</span><br><span class="line">            cur = [<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">                cur.append(nums[i]+nums[i+<span class="number">1</span>])</span><br><span class="line">            cur.append(<span class="number">1</span>)</span><br><span class="line">            nums = cur</span><br><span class="line">        <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>
<p><strong>2.11</strong></p>
<p>美赛结束已经两天了，其实昨天的每日一题也刷了，不过懒得写题解</p>
<p>今天开始恢复写刷题日志，除夕快乐！</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="703-数据流中的第-K-大元素"><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/">703. 数据流中的第 K 大元素</a></h4>
<p>难度简单</p>
<p>设计一个找到数据流中第 <code>k</code> 大元素的类（class）。注意是排序后的第 <code>k</code> 大元素，不是第 <code>k</code> 个不同的元素。</p>
<p>请实现 <code>KthLargest</code> 类：</p>
<ul>
<li><code>KthLargest(int k, int[] nums)</code> 使用整数 <code>k</code> 和整数流 <code>nums</code> 初始化对象。</li>
<li><code>int add(int val)</code> 将 <code>val</code> 插入数据流 <code>nums</code> 后，返回当前数据流中第 <code>k</code> 大的元素。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;KthLargest&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;]</span><br><span class="line">[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]</span><br><span class="line">输出：</span><br><span class="line">[null, 4, 5, 5, 8, 8]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">KthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);</span><br><span class="line">kthLargest.add(3);   // return 4</span><br><span class="line">kthLargest.add(5);   // return 5</span><br><span class="line">kthLargest.add(10);  // return 5</span><br><span class="line">kthLargest.add(9);   // return 8</span><br><span class="line">kthLargest.add(4);   // return 8</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= k &lt;= 104</code></li>
<li><code>0 &lt;= nums.length &lt;= 104</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>-104 &lt;= val &lt;= 104</code></li>
<li>最多调用 <code>add</code> 方法 <code>104</code> 次</li>
<li>题目数据保证，在查找第 <code>k</code> 大元素时，数组中至少有 <code>k</code> 个元素</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>之所以难度是简单嘛，因为可以调用 python 的包，用小顶堆的优先队列形式实现增删改查</p>
<p>小顶堆，顾名思义，就是一个二叉树，这个二叉树的根节点是最小的</p>
<p><code>init</code> 步骤</p>
<ul>
<li>
<p>我们维护一个小顶堆，在初始化的时候，把<code>nums</code>里的数字全放到小顶堆里</p>
</li>
<li>
<p>可以理解为做了一个排序，在堆的顶部是最小的数，然后越往下越大</p>
</li>
<li>
<p>因为我们最终的目标只需要找到第<code>k</code>大的数字，所以我们只需要保留小顶堆底部的<code>k</code>个数字，把顶部的数字依次<code>pop</code>出去</p>
</li>
</ul>
<p><code>add</code> 步骤</p>
<ul>
<li>每次往小顶堆里加一个数字，这个数据结构会自动找到合适的位置插入这个数字，所以不需要担心插入后是否有序</li>
<li>现在的小顶堆多了一个数字，如果堆的大小比<code>k</code>大，就需要扔掉多余的数字</li>
<li>最后范围堆顶的数字，就是我们需要的当前第<code>k</code>大的是数字</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KthLargest</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, k: <span class="built_in">int</span>, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">        self.pool = nums</span><br><span class="line">        heapq.heapify(self.pool)</span><br><span class="line">        self.k = k</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(self.pool) &gt; k:</span><br><span class="line">            heapq.heappop(self.pool)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, val: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(self.pool) &lt; self.k:</span><br><span class="line">            heapq.heappush(self.pool, val)</span><br><span class="line">        <span class="keyword">elif</span> val &gt; self.pool[<span class="number">0</span>]:</span><br><span class="line">            heapq.heapreplace(self.pool, val)</span><br><span class="line">        <span class="keyword">return</span> self.pool[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p><strong>2.4</strong></p>
<p>美赛前的最后一天寒假了</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="643-子数组最大平均数-I"><a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/">643. 子数组最大平均数 I</a></h4>
<p>难度简单</p>
<p>给定 <code>n</code> 个整数，找出平均数最大且长度为 <code>k</code> 的连续子数组，并输出该最大平均数。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,12,-5,-6,50,3], k = 4</span><br><span class="line">输出：12.75</span><br><span class="line">解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= <code>k</code> &lt;= <code>n</code> &lt;= 30,000。</li>
<li>所给数据范围 [-10,000，10,000]。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>没啥花里胡哨的，用滑动窗口模拟就行</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxAverage</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>: </span><br><span class="line">        cur_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>):</span><br><span class="line">            cur_sum += nums[i]</span><br><span class="line">        cur_max = -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            cur_sum += nums[i]</span><br><span class="line">            cur_max = <span class="built_in">max</span>(cur_max, cur_sum)</span><br><span class="line">            cur_sum -= nums[i-k+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> cur_max/k</span><br></pre></td></tr></table></figure>
<p><strong>2.3</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="480-滑动窗口中位数"><a href="https://leetcode-cn.com/problems/sliding-window-median/">480. 滑动窗口中位数</a></h4>
<p>难度困难</p>
<p>中位数是有序序列最中间的那个数。如果序列的大小是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。</p>
<p>例如：</p>
<ul>
<li><code>[2,3,4]</code>，中位数是 <code>3</code></li>
<li><code>[2,3]</code>，中位数是 <code>(2 + 3) / 2 = 2.5</code></li>
</ul>
<p>给你一个数组 <em>nums</em>，有一个大小为 <em>k</em> 的窗口从最左端滑动到最右端。窗口中有 <em>k</em> 个数，每次窗口向右移动 <em>1</em> 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。</p>
<p><strong>示例：</strong></p>
<p>给出 <em>nums</em> = <code>[1,3,-1,-3,5,3,6,7]</code>，以及 <em>k</em> = 3。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">窗口位置                      中位数</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       1</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7      -1</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7      -1</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       3</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       5</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      6</span><br></pre></td></tr></table></figure>
<p>因此，返回该滑动窗口的中位数数组 <code>[1,-1,-1,3,5,6]</code>。</p>
<p><strong>提示：</strong></p>
<ul>
<li>你可以假设 <code>k</code> 始终有效，即：<code>k</code> 始终小于输入的非空数组的元素个数。</li>
<li>与真实值误差在 <code>10 ^ -5</code> 以内的答案将被视作正确答案。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>暴力法</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">medianSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-k+<span class="number">1</span>):</span><br><span class="line">            tmp = nums[i:i+k]</span><br><span class="line">            tmp.sort()</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(tmp)%<span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                res.append(tmp[k//<span class="number">2</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append((tmp[k//<span class="number">2</span>]+tmp[k//<span class="number">2</span>-<span class="number">1</span>])/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>2.2</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="424-替换后的最长重复字符"><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/">424. 替换后的最长重复字符</a></h4>
<p>难度中等</p>
<p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 <em>k</em> 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p>
<p>**注意：**字符串长度 和 <em>k</em> 不会超过 104。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ABAB&quot;, k = 2</span><br><span class="line">输出：4</span><br><span class="line">解释：用两个&#x27;A&#x27;替换为两个&#x27;B&#x27;,反之亦然。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;AABABBA&quot;, k = 1</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">将中间的一个&#x27;A&#x27;替换为&#x27;B&#x27;,字符串变为 &quot;AABBBBA&quot;。</span><br><span class="line">子串 &quot;BBBB&quot; 有最长重复字母, 答案为 4。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>双指针，滑动窗口，遍历字符串，用一个数组来维护窗口中字母的出现次数</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">characterReplacement</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cnts =  [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line">        left = right = maxn = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">while</span> right &lt; n:</span><br><span class="line">            cnts[<span class="built_in">ord</span>(s[right]) - <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">            maxn = <span class="built_in">max</span>(maxn, cnts[<span class="built_in">ord</span>(s[right]) - <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)])</span><br><span class="line">            <span class="keyword">if</span> right - left + <span class="number">1</span> - maxn &gt; k:</span><br><span class="line">                cnts[<span class="built_in">ord</span>(s[left]) - <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right - left</span><br></pre></td></tr></table></figure>
<p><strong>2.1</strong></p>
<p>今日简单题，刷完吃寿喜烧去咯</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="888-公平的糖果棒交换"><a href="https://leetcode-cn.com/problems/fair-candy-swap/">888. 公平的糖果棒交换</a></h4>
<p>难度简单99</p>
<p>爱丽丝和鲍勃有不同大小的糖果棒：<code>A[i]</code> 是爱丽丝拥有的第 <code>i</code> 根糖果棒的大小，<code>B[j]</code> 是鲍勃拥有的第 <code>j</code> 根糖果棒的大小。</p>
<p>因为他们是朋友，所以他们想交换一根糖果棒，这样交换后，他们都有相同的糖果总量。<em>（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）</em></p>
<p>返回一个整数数组 <code>ans</code>，其中 <code>ans[0]</code> 是爱丽丝必须交换的糖果棒的大小，<code>ans[1]</code> 是 Bob 必须交换的糖果棒的大小。</p>
<p>如果有多个答案，你可以返回其中任何一个。保证答案存在。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：A = [1,1], B = [2,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：A = [1,2], B = [2,3]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：A = [2], B = [1,3]</span><br><span class="line">输出：[2,3]</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：A = [1,2,5], B = [2,4]</span><br><span class="line">输出：[5,4]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>1 &lt;= B.length &lt;= 10000</code></li>
<li><code>1 &lt;= A[i] &lt;= 100000</code></li>
<li><code>1 &lt;= B[i] &lt;= 100000</code></li>
<li>保证爱丽丝与鲍勃的糖果总量不同。</li>
<li>答案肯定存在。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>traversing and binary search.</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fairCandySwap</span>(<span class="params">self, A: <span class="type">List</span>[<span class="built_in">int</span>], B: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        sum_a = <span class="built_in">sum</span>(A)</span><br><span class="line">        sum_b = <span class="built_in">sum</span>(B)</span><br><span class="line">        diff = sum_a-sum_b</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">            j = <span class="built_in">int</span>(i-diff/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">in</span> B:</span><br><span class="line">                <span class="keyword">return</span> [i,j]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题日志</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS 知识点总结</title>
    <url>/post/2021-01-10-Weber/CSS%20%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<blockquote>
<p>期末也要抽空学，给我卷！</p>
<p>所有学习笔记已开源上传至 <a href="https://github.com/EthanLuu/Weber">github</a>，欢迎Star和PR！</p>
</blockquote>
<h2 id="样式表和选择器">样式表和选择器</h2>
<p>Cascading Style Sheet，层叠样式表，用于给 HTML 页面标签添加各种样式，定义网页的显示效果</p>
<p>CSS 将网页内容和显示样式进行分离，增强了显示功能。</p>
<p><strong>HTML 的缺陷</strong></p>
<ol>
<li>不能够适应多种设备</li>
<li>要求浏览器必须智能化足够庞大</li>
<li>数据和显示没有分开</li>
<li>功能不够强大</li>
</ol>
<p><strong>CSS 优点</strong></p>
<ol>
<li>使数据和显示分开</li>
<li>降低网络流量</li>
<li>使整个网站视觉效果一致</li>
<li>使开发效率提高了</li>
</ol>
<h3 id="CSS-语法">CSS 语法</h3>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">选择器 &#123;</span><br><span class="line">    k: v;</span><br><span class="line">    k: v;</span><br><span class="line">    k: v;</span><br><span class="line">    k: v;</span><br><span class="line">&#125;</span><br><span class="line">选择器 &#123;</span><br><span class="line">    k: v;</span><br><span class="line">    k: v;</span><br><span class="line">    k: v;</span><br><span class="line">    k: v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CSS-和-HTML-结合的方式">CSS 和 HTML 结合的方式</h3>
<ol>
<li>
<p>行内样式：某个特定标签内使用 style 属性</p>
</li>
<li>
<p>内嵌样式表：在页面的 head 里采用 style 标签</p>
</li>
<li>
<p>引入外部 css 文件的方式</p>
<ul>
<li>采用 link 标签</li>
<li>采用 import</li>
</ul>
<blockquote>
<p>两种引入方式的区别：外部样式表中不能写 link 标签，但是可以写 import 语句</p>
</blockquote>
</li>
</ol>
<h3 id="CSS-选择器">CSS 选择器</h3>
<p>指定 CSS 作用的标签</p>
<p>选择器总共两大类：基本选择器和扩展选择器</p>
<p>常用的三种器的区别</p>
<ul>
<li>标签选择器针对的是页面上的一类标签</li>
<li>ID 选择器针对特定的一个标签</li>
<li>类选择器可以被多种标签使用</li>
</ul>
<h4 id="基本选择器">基本选择器</h4>
<p><strong>标签选择器</strong></p>
<p>选择所有某种类型的标签，用于描述<strong>共性</strong></p>
<ul>
<li>所有的标签，都可以是选择器</li>
<li>选择的是所有，而不是一个</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123; <span class="attribute">font-size</span>:<span class="number">14px</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>p 标签内的文字都是 14px</p>
<p><strong>ID 选择器</strong></p>
<p>针对某一个特定的标签来使用，以<code>#</code>来定义</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#mytitle</span>&#123; <span class="attribute">border</span>:<span class="number">3px</span> dashed green;&#125;</span><br></pre></td></tr></table></figure>
<p>任何的 HTML 标签都可以有 id 属性。表示这个标签的名字。</p>
<p>这个标签的名字，可以任取，但是：</p>
<ul>
<li>只能有字母、数字、下划线</li>
<li>必须以字母开头</li>
<li>不能和标签同名</li>
<li>HTML 页面不能出现相同的 ID</li>
</ul>
<blockquote>
<p>一个标签可以被多个 css 选择器选择，共同作用</p>
</blockquote>
<h4 id="类选择器">类选择器</h4>
<p>用<code>.</code>来定义某一个类的标签</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.eat</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">900</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不要试图用一个类写完所有标签的样式，多写几个类</li>
<li>每一个类尽可能小，有公共的概念，让更多的标签使用</li>
<li>到底用 id 还是 class？
<ul>
<li>尽可能用 class</li>
<li>因为 id 是给 js 使用的，js 通过 id 来获取标签，所以 css 层面尽可能不用 id</li>
<li>另一方面，我们认为一个有 id 的元素，有动态效果</li>
</ul>
</li>
<li>类上样式，id 上行为</li>
</ul>
<h4 id="通用选择器">通用选择器</h4>
<p><code>*</code>，匹配任何标签，效率低，不使用</p>
<h3 id="CSS-的高级选择器">CSS 的高级选择器</h3>
<h4 id="后代选择器">后代选择器</h4>
<p>如果选择的是<code>E F</code>，表示所有属于 E 元素的后代的 F 元素</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">19px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">span</span>&#123;</span><br><span class="line">    <span class="attribute">font-family</span>: 微软雅黑;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">3em</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;<span class="selector-tag">div</span>&gt; &lt;<span class="selector-tag">p</span>&gt; wtf &lt;/<span class="selector-tag">p</span>&gt; &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">div</span>&gt; &lt;<span class="selector-tag">span</span>&gt; omg &lt;/<span class="selector-tag">span</span>&gt; &lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>
<h4 id="交集选择器">交集选择器</h4>
<p>两个选择器紧密相连，以标签名开头</p>
<p>如果后一个是类选择器，就写成<code>div.food</code>，如果后一个是 id 选择器，就写成<code>div#food</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.food</span>&#123;</span><br><span class="line">    <span class="attribute">font-family</span>: 微软雅黑;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">3em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="并集选择器">并集选择器</h4>
<p>简单来说就是多选</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>,</span><br><span class="line"><span class="selector-tag">h1</span>,</span><br><span class="line"><span class="selector-id">#mytitle</span>,</span><br><span class="line"><span class="selector-class">.one</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CSS3-的一些选择器">CSS3 的一些选择器</h3>
<h4 id="子代选择器">子代选择器</h4>
<p><code>&gt;</code>，只有是儿子的时候才能被选择</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &gt; <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只能选择</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是div的儿子<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不能选择</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是div的孙子<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="序选择器">序选择器</h4>
<p>设置无序列表<code>&lt;ul&gt;</code>中的第一个<code>&lt;li&gt;</code>为红色：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:first</span>-child &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置无序列表<code>&lt;ul&gt;</code>中的最后一个<code>&lt;li&gt;</code>为红色：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:last-child</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="下一个兄弟选择器">下一个兄弟选择器</h4>
<p><code>+</code> 表示选择下一个兄弟</p>
<p>把 h3 元素后面的一个 p 标签变成红色</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h3</span> + <span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单位">单位</h2>
<p>HTML 的单位只有一种，即像素<code>px</code>，所以单位可省略</p>
<p>CSS中必须要写单位，因为没有默认单位</p>
<h3 id="绝对单位">绝对单位</h3>
<ul>
<li><code>in</code>：英寸Inches (1 英寸 = 2.54 厘米)</li>
<li><code>cm</code>：厘米Centimeters</li>
<li><code>mm</code>：毫米Millimeters</li>
<li><code>pt</code>：点Points，或者叫英镑 (1点 = 1/72英寸)</li>
<li><code>pc</code>：皮卡Picas (1 皮卡 = 12 点)</li>
</ul>
<p>换算规则</p>
<p><code>1 in</code> = <code>2.54 cm</code> = <code>25.4 mm</code> = <code>72 pt</code> = <code>6 pc</code></p>
<h3 id="相对单位">相对单位</h3>
<p><code>px</code>：像素<br>
<code>em</code>：印刷单位相当于12个点<br>
<code>%</code>：百分比，相对周围的文字的大小</p>
<h2 id="字体属性">字体属性</h2>
<p>常见字体属性</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">50px</span>; 		<span class="comment">/*字体大小*/</span></span><br><span class="line">	<span class="attribute">line-height</span>: <span class="number">30px</span>;      <span class="comment">/*行高*/</span></span><br><span class="line">	<span class="attribute">font-family</span>: 幼圆,黑体; 	<span class="comment">/*字体类型：如果没有幼圆就显示黑体，没有黑体就显示默认*/</span></span><br><span class="line">	<span class="attribute">font-style</span>: italic ;		<span class="comment">/*italic表示斜体，normal表示不倾斜*/</span></span><br><span class="line">	<span class="attribute">font-weight</span>: bold;	<span class="comment">/*粗体*/</span></span><br><span class="line">	<span class="attribute">font-variant</span>: small-caps;  <span class="comment">/*小写变大写*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了严格保证字在行里面居中，我们的工程师有一个约定： <strong>行高、字号，一般都是偶数</strong>。这样可以保证，它们的差一定偶数，就能够被2整除。</p>
<h3 id="如何让单行文本居中">如何让单行文本居中</h3>
<p>如果文本只有一行，那么将<strong>行高</strong>和<strong>盒子高</strong>设置成一样大，就可以保证单行文本垂直居中。</p>
<p>如果需要多行文本居中就需要根据总行高自己算 top-margin</p>
<p>也可以使用<code>vertical-algin</code>属性来使指定<strong>行内元素</strong>（inline）、<strong>行内块元素</strong>（inline-block）、<strong>表格的单元格</strong>（table-cell）的垂直对齐方式。主要是用于图片、表格、文本的对齐。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">vertical-align</span>: middle; <span class="comment">/*指定行级元素的垂直对齐方式。*/</span></span><br></pre></td></tr></table></figure>
<h3 id="字号-行高-字体">字号 行高 字体</h3>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line"><span class="attribute">line-height</span>: <span class="number">24px</span>;</span><br><span class="line"><span class="attribute">font-family</span>: <span class="string">&quot;宋体&quot;</span>;</span><br><span class="line"><span class="comment">/* 将字体属性连写 (字体粗细 字号/行高 字体) */</span></span><br><span class="line"><span class="attribute">font</span>: <span class="number">400</span> <span class="number">14px</span>/<span class="number">24px</span> <span class="string">&quot;宋体&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>一般将英文字体放在最前面，这样做到中英文字体分离</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">font-family</span>: <span class="string">&quot;Times New Roman&quot;</span>,<span class="string">&quot;微软雅黑&quot;</span>,<span class="string">&quot;宋体&quot;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="文本属性">文本属性</h2>
<ul>
<li><code>letter-spacing: 0.5cm ;</code>  单个字母之间的间距</li>
<li><code>word-spacing: 1cm;</code>   单词之间的间距</li>
<li><code>text-decoration: none;</code> 字体修饰：none 去掉下划线、<strong>underline 下划线</strong>、line-through 中划线、overline 上划线</li>
<li><code>text-transform: lowercase;</code>  单词字体大小写。uppercase大写、lowercase小写</li>
<li><code>color:red;</code> 字体颜色</li>
<li><code>text-align: center;</code> 在当前容器中的对齐方式。属性值可以是：left、right、center（<strong>居中</strong>）、justify</li>
<li><code>text-transform: lowercase;</code> 单词的字体大小写。属性值可以是：<code>uppercase</code>（单词大写）、<code>lowercase</code>（单词小写）、<code>capitalize</code>（每个单词的首字母大写）</li>
</ul>
<h3 id="列表属性">列表属性</h3>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span>&#123;</span><br><span class="line">	<span class="attribute">list-style-image</span>:<span class="built_in">url</span>(<span class="string">images/2.gif</span>) ;  <span class="comment">/*列表项前设置为图片*/</span></span><br><span class="line">	<span class="attribute">margin-left</span>:<span class="number">80px</span>;  <span class="comment">/*公有属性*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="overflow-属性">overflow 属性</h3>
<p>用来处理超出范围的内容</p>
<p><code>overflow</code>属性的属性值可以是：</p>
<ul>
<li><code>visible</code>：默认值。多余的内容不剪切也不添加滚动条，会全部显示出来。</li>
<li><code>hidden</code>：不显示超过对象尺寸的内容。</li>
<li><code>auto</code>：如果内容不超出，则不显示滚动条；如果内容超出，则显示滚动条。</li>
<li><code>scroll</code>：Windows 平台下，无论内容是否超出，总是显示滚动条。Mac 平台下，和 <code>auto</code> 属性相同。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>EthanLoo&#x27;s<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">margin-right</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-id">#div1</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">overflow</span>: auto; <span class="comment">/*超出的部分浏览器解决*/</span> </span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">      <span class="selector-id">#div2</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">overflow</span>: visible; <span class="comment">/*超出的部分显示*/</span> </span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">      </span></span><br><span class="line"><span class="language-css">      <span class="selector-id">#div3</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">overflow</span>: hidden; <span class="comment">/*超出的部分隐藏*/</span> </span></span><br><span class="line"><span class="language-css">      &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;div1&#x27;</span>&gt;</span></span><br><span class="line">      什么是前端工程师？总而言之前端工程师就是运用HTML/CSS/JavaScript等Web技术，在工作中配合设计师实现用户界面，和后端工程师进行数据对接，完成Web应用开发的职位。</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;div2&#x27;</span>&gt;</span></span><br><span class="line">      什么是前端工程师？总而言之前端工程师就是运用HTML/CSS/JavaScript等Web技术，在工作中配合设计师实现用户界面，和后端工程师进行数据对接，完成Web应用开发的职位。</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;div3&#x27;</span>&gt;</span></span><br><span class="line">      什么是前端工程师？总而言之前端工程师就是运用HTML/CSS/JavaScript等Web技术，在工作中配合设计师实现用户界面，和后端工程师进行数据对接，完成Web应用开发的职位。</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="背景属性">背景属性</h2>
<h3 id="background-color-背景颜色">background-color 背景颜色</h3>
<p>css2.1 中的三种表示方法</p>
<ol>
<li>单词</li>
<li>RGB 表示法</li>
<li>16进制表示法</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-color</span>: red;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#ff0000</span>;</span><br></pre></td></tr></table></figure>
<p>css3 中新增的颜色表示方法</p>
<ol>
<li>RGBA 表示法
<ul>
<li>红 绿 蓝 透明度</li>
</ul>
</li>
<li>HSLA 表示法
<ul>
<li>色调 饱和度 亮度 透明度</li>
</ul>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">0.3</span>);</span><br><span class="line"><span class="attribute">background-color</span>: <span class="built_in">hsla</span>(<span class="number">240</span>,<span class="number">50%</span>,<span class="number">50%</span>,<span class="number">0.4</span>);</span><br></pre></td></tr></table></figure>
<h3 id="background-repeat">background-repeat</h3>
<ul>
<li>
<p><code>repeat</code> 默认值，平铺满</p>
</li>
<li>
<p><code>no-repeat</code>（不要平铺）</p>
</li>
<li>
<p><code>repeat-x</code>（横向平铺）</p>
</li>
<li>
<p><code>repeat-y</code>（纵向平铺）</p>
</li>
</ul>
<h3 id="background-position">background-position</h3>
<ul>
<li>背景定位</li>
</ul>
<ol>
<li>
<p>用像素描述</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-position</span>:向右偏移量 向下偏移量;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>用单词描述</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-position</span>: 描述左右的词 描述上下的词;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="background-attachment">background-attachment</h3>
<ul>
<li>控制背景是否固定
<ul>
<li>fixed 固定</li>
<li>scroll 不固定</li>
</ul>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-attachment</span>:fixed;</span><br></pre></td></tr></table></figure>
<h3 id="background-综合属性">background 综合属性</h3>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>:red <span class="built_in">url</span>(<span class="string">1.jpg</span>) no-repeat <span class="number">100px</span> <span class="number">100px</span> fixed;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-color</span>:red;</span><br><span class="line"><span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">1.jpg</span>);</span><br><span class="line"><span class="attribute">background-repeat</span>:no-repeat;</span><br><span class="line"><span class="attribute">background-position</span>:<span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">background-attachment</span>:fixed;</span><br></pre></td></tr></table></figure>
<h3 id="background-size">background-size</h3>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 宽、高的具体数值 */</span></span><br><span class="line"><span class="attribute">background-size</span>: <span class="number">500px</span> <span class="number">500px</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 宽高的百分比（相对于容器的大小） */</span></span><br><span class="line"><span class="attribute">background-size</span>: <span class="number">50%</span> <span class="number">50%</span>;   // 如果两个属性值相同，可以简写成：<span class="attribute">background-size</span>: <span class="number">50%</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">background-size</span>: <span class="number">100%</span> auto;  //这个属性可以自己试验一下。</span><br><span class="line"></span><br><span class="line"><span class="comment">/* cover：图片始终填充满容器，且保证长宽比不变。图片如果有超出部分，则超出部分会被隐藏。 */</span></span><br><span class="line"><span class="attribute">background-size</span>: cover;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* contain：将图片完整地显示在容器中，且保证长宽比不变。可能会导致容器的部分区域为空白。  */</span></span><br><span class="line"><span class="attribute">background-size</span>: contain;</span><br></pre></td></tr></table></figure>
<h3 id="background-origin">background-origin</h3>
<p>控制从什么位置开始显示背景</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* 从 padding-box 内边距开始显示背景图 */</span></span><br><span class="line"><span class="attribute">background-origin</span>: padding-box;           //默认值</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从 border-box 边框开始显示背景图  */</span></span><br><span class="line"><span class="attribute">background-origin</span>: border-box;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从 content-box 内容区域开始显示背景图  */</span></span><br><span class="line"><span class="attribute">background-origin</span>: content-box;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="background-clip">background-clip</h3>
<p>设置元素的背景是否延伸到边框下面</p>
<ul>
<li>
<p><code>border-box</code> 超出 border-box 的部分，将裁剪掉</p>
</li>
<li>
<p><code>padding-box</code> 超出 padding-box 的部分，将裁剪掉</p>
</li>
<li>
<p><code>content-box</code> 超出 content-box 的部分，将裁剪掉</p>
</li>
</ul>
<h3 id="background-image">background-image</h3>
<ol>
<li>线性渐变：沿着某条直线朝一个方向产生渐变效果。</li>
<li>径向渐变：从一个<strong>中心点</strong>开始沿着<strong>四周</strong>产生渐变效果。</li>
<li>重复渐变</li>
</ol>
<p><img src="https://cdn.ethanloo.cn/img/20201224225320.png" alt=""></p>
<h4 id="线性渐变">线性渐变</h4>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(方向, 起始颜色, 终止颜色);</span><br><span class="line"></span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to right, yellow, green);</span><br></pre></td></tr></table></figure>
<h4 id="径向渐变">径向渐变</h4>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(辐射的半径大小, 中心的位置, 起始颜色, 终止颜色);</span><br><span class="line"></span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">radial-gradient</span>(<span class="number">100px</span> at center,yellow ,green);</span><br></pre></td></tr></table></figure>
<h3 id="Clip-path">Clip-path</h3>
<p><code>clip-path</code>属性可以创建一个只有元素的部分区域可以显示的剪切区域。区域内的部分显示，区域外的隐藏。</p>
<p>鼠标悬停放大图片</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.div1</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">320px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">320px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">http://img.smyhvae.com/20191006_1410.png</span>) no-repeat;</span><br><span class="line">    <span class="attribute">background-size</span>: cover;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 裁剪出圆形区域 */</span></span><br><span class="line">    <span class="attribute">clip-path</span>: <span class="built_in">circle</span>(<span class="number">50px</span> at <span class="number">100px</span> <span class="number">100px</span>);</span><br><span class="line">    <span class="attribute">transition</span>: clip-path .<span class="number">4s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.div1</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">    <span class="comment">/* 鼠标悬停时，裁剪出更大的圆形 */</span></span><br><span class="line">    <span class="attribute">clip-path</span>: <span class="built_in">circle</span>(<span class="number">80px</span> at <span class="number">100px</span> <span class="number">100px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="伪类选择器">伪类选择器</h2>
<p>伪类是用来添加一些选择器的特殊效果。</p>
<p>比如 div 是属于 box 类的，这很明确，但是 a 属于什么类是不明确的，需要看用户点击前的状态和点击后的状态。</p>
<h3 id="静态伪类和动态伪类">静态伪类和动态伪类</h3>
<h4 id="静态伪类">静态伪类</h4>
<p>只能用于超链接的样式</p>
<ul>
<li><code>:link</code> 超链接点击之前</li>
<li><code>:visited</code> 链接被访问过之后</li>
</ul>
<h4 id="动态伪类">动态伪类</h4>
<p>针对所有标签都适用的样式</p>
<ul>
<li><code>:hover</code> “悬停”：鼠标放到标签上的时候</li>
<li><code>:active</code>	“激活”： 鼠标点击标签，但是不松手时。</li>
<li><code>:focus</code> 是某个标签获得焦点时的样式（比如某个输入框获得焦点）</li>
</ul>
<h3 id="a-标签">a 标签</h3>
<p>超链接的四种状态</p>
<ul>
<li><code>:link</code>  	“链接”：超链接点击之前</li>
<li><code>:visited</code> “访问过的”：链接被访问过之后</li>
<li><code>:hover</code>	“悬停”：鼠标放到标签上的时候</li>
<li><code>:active</code>	“激活”： 鼠标点击标签，但是不松手时。</li>
</ul>
<p>在 CSS 中，这四种状态必须按照固定的顺序写</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: antiquewhite;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: salmon;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: skyblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>制作一个导航</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">nav</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>谷歌<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>雅虎<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>bilibili<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">100px</span> auto;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid black;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to right, <span class="number">#C9D6FF</span>, <span class="number">#E2E2E2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:link</span>,</span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;</span><br><span class="line">  <span class="attribute">text-decoration</span>: none;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">nav</span> <span class="selector-tag">li</span> <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to right, <span class="number">#acb6e5</span>, <span class="number">#acb6e5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.ethanloo.cn/img/20201226154801.png" alt="image-20201226154801929"></p>
<p>标准写法是 link，visited 和 hover 这三个伪类都需要写。</p>
<p>一般开发的时候 <code>a:link, a:visited</code> 都可以省略，简写在 <code>a</code> 标签里。</p>
<h3 id="动态伪类-2">动态伪类</h3>
<ul>
<li><code>:hover</code> 悬停</li>
<li><code>:active</code> 激活</li>
<li><code>:focus</code> 获得焦点</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;test-input&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    麻烦点我一下</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: purple;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:focus</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: purple;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CSS-继承性和层叠性">CSS 继承性和层叠性</h2>
<h3 id="CSS-的继承性">CSS 的继承性</h3>
<ul>
<li>关于文字样式的属性，都具有继承性。
<ul>
<li>这些属性包括：color、 text-开头的、line-开头的、font-开头的。</li>
</ul>
</li>
<li>关于盒子、定位、布局的属性，都不能继承。</li>
</ul>
<h3 id="CSS-的层叠性">CSS 的层叠性</h3>
<p>当多个选择器，选择了某个元素的时候，要按照如下顺序统计权重：</p>
<ul>
<li>id 选择器</li>
<li>类选择器、属性选择器、伪类选择器</li>
<li>标签选择器、伪元素选择器</li>
</ul>
<ol>
<li>
<p>计算权重</p>
<p>统计各个选择器的数量，优先级高的胜出，图中的 p 标签是红色</p>
<p><img src="http://img.smyhvae.com/20170725_2138.png" alt="img"></p>
</li>
<li>
<p>权重相同时</p>
<p>就近原则，以后一个样式为准</p>
</li>
<li>
<p>尝试实现</p>
<p><img src="https://cdn.ethanloo.cn/img/20201226161151.png" alt="image-20201226161151085"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sr&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;ssr&quot;</span>&gt;</span>word<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>word<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>word<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>word<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>word<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>word<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>word<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>错误写法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.sr</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.ssr</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样写的话第一个的选择器的权重为 0 1 2，第二个选择器的权重为 0 1 0</p>
</blockquote>
<p>正确写法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.sr</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sr</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-class">.ssr</span>&#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>继承性的说明</p>
<p>如果不能直接选中某个元素，通过继承性影响的计算的权重为0，最后显示的颜色为 blue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sr&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ssr&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>666<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="comment">/* 权重0,0,1 */</span></span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.ssr</span> &#123;</span><br><span class="line">  <span class="comment">/* 权重0,0,0 */</span></span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sr</span> &#123;</span><br><span class="line">  <span class="comment">/* 权重0,0,0 */</span></span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="层叠性权重计算总结">层叠性权重计算总结</h3>
<p><img src="http://img.smyhvae.com/20170727_2050.png" alt=""></p>
<ol>
<li>对于相同权重的选择器，其排序为：行级样式 &gt; 内嵌样式表 &gt; 外部样式表</li>
<li>对于相同类型的样式表，其选择器排序为：ID选择器 &gt; 类选择器 &gt; 标签选择器</li>
<li>外部样式表的 ID 选择器 &gt; 内嵌样式表的标签选择</li>
</ol>
<h3 id="important-标记">!important 标记</h3>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">font-size</span>:<span class="number">60px</span> <span class="meta">!important</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>!important</code> 提升的是一个属性，不是选择器</li>
<li><code>!important</code> 无法提升继承的权重，该是0还是0</li>
<li><code>!important</code> 无法影响就近原则</li>
</ol>
<blockquote>
<p>尽量不要用</p>
</blockquote>
<h2 id="盒模型">盒模型</h2>
<p>包括 div, span, a</p>
<p><strong>一个盒子的五个主要属性</strong></p>
<ul>
<li>width和height：<strong>内容</strong>的宽度、高度（不是盒子的宽度、高度）</li>
<li>padding：内边距</li>
<li>border：边框</li>
<li>margin：外边距</li>
</ul>
<p><img src="http://img.smyhvae.com/20170727_2326.png" alt=""></p>
<blockquote>
<p>上面这个盒子实际上是 302*202，因为有边框</p>
</blockquote>
<h3 id="padding">padding</h3>
<p>padding 就是内边距，padding 实际上也会有背景颜色</p>
<p>有四个方向的 padding</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">padding-top</span>: <span class="number">30px</span>;</span><br><span class="line"><span class="attribute">padding-right</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">padding-bottom</span>: <span class="number">40px</span>;</span><br><span class="line"><span class="attribute">padding-left</span>: <span class="number">100px</span>;</span><br></pre></td></tr></table></figure>
<p>综合属性的写法是：上 右 下 左</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">padding</span>:<span class="number">30px</span> <span class="number">20px</span> <span class="number">40px</span> <span class="number">100px</span>;</span><br></pre></td></tr></table></figure>
<p>如果只写三个值，顺序是：上  右 下  // 左和右相等</p>
<p>如果只写了两个值：顺序是：上 右 // 下和上相等，左和右相等</p>
<h3 id="border">border</h3>
<p>border 本身是一个综合属性</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid red;</span><br></pre></td></tr></table></figure>
<p>两种拆的方式</p>
<ol>
<li>
<p>按三要素拆</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border-width</span>:<span class="number">10px</span>;    //边框宽度</span><br><span class="line"><span class="attribute">border-style</span>:solid;   //线型</span><br><span class="line"><span class="attribute">border-color</span>:red;     //颜色。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>按方向拆</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border-top</span>:<span class="number">10px</span> solid red;</span><br><span class="line"><span class="attribute">border-right</span>:<span class="number">10px</span> solid red;</span><br><span class="line"><span class="attribute">border-bottom</span>:<span class="number">10px</span> solid red;</span><br><span class="line"><span class="attribute">border-left</span>:<span class="number">10px</span> solid red;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当然也可以全部拆开，写成12行</p>
</li>
</ol>
<p>利用 border 画一个🔺</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">30px</span> solid red;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">20px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">20px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.ethanloo.cn/img/20201226193840.png" alt="image-20201226193840228"></p>
<h2 id="浮动">浮动</h2>
<h3 id="标准文档流">标准文档流</h3>
<p><strong>特性</strong></p>
<ol>
<li>
<p>空白折叠现象</p>
<p>无论多少空格，换行，都会折叠成一个空格。</p>
</li>
<li>
<p>高矮不齐，底边对齐</p>
</li>
<li>
<p>自动换行，一行写不满，换行写</p>
</li>
</ol>
<h4 id="行内元素和块级元素">行内元素和块级元素</h4>
<p>标签分为两种等级</p>
<ul>
<li>行内元素</li>
<li>块级元素</li>
</ul>
<p><strong>两者区别</strong></p>
<ul>
<li>行内元素
<ul>
<li>与其他行内元素并排</li>
<li>不能设置宽、高，默认宽度就是文字的宽度</li>
</ul>
</li>
<li>块级元素
<ul>
<li>霸占一行，不能与其他元素并列</li>
<li>能设置宽、高，如果不设置宽度，宽度默认是父类的100%</li>
</ul>
</li>
</ul>
<p><strong>两者分类</strong></p>
<p>HTML 角度</p>
<ul>
<li>文本级标签：p、span、a、b、i、u、em</li>
<li>容器级标签：div、h系列、li、dt、dd</li>
</ul>
<p>CSS 角度</p>
<ul>
<li>
<p>行内元素：span、a、b、i、u、em</p>
</li>
<li>
<p>块级元素：<strong>p</strong>、div、h系列、li、dt、dd</p>
</li>
</ul>
<blockquote>
<p>只有 p 变了个位置</p>
</blockquote>
<h4 id="行内和块级的转换">行内和块级的转换</h4>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">display</span>: inline;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br></pre></td></tr></table></figure>
<h3 id="实现浮动">实现浮动</h3>
<blockquote>
<p>css 里布局用的最多的属性</p>
</blockquote>
<p>div 本身是一个块级元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.ssr&#123;</span><br><span class="line">  height: 200px;</span><br><span class="line">  width: 300px;</span><br><span class="line">  background-color: aquamarine;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.sr&#123;</span><br><span class="line">  height: 200px;</span><br><span class="line">  width: 200px;</span><br><span class="line">  background-color: cadetblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://cdn.ethanloo.cn/img/20201226195415.png" alt="image-20201226195415524" style="zoom: 33%;" />
<p>但是加上浮动之后就可以并排了</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.ssr</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: aquamarine;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sr</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: cadetblue;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="https://cdn.ethanloo.cn/img/20201226195443.png" alt="image-20201226195442936" style="zoom: 33%;" />
<ul>
<li>
<p>浮动的元素脱离标准流</p>
<p>一旦一个元素浮动了，就能够并排和设置宽高了，所有标签浮动之后不区分行内和块级</p>
</li>
<li>
<p>浮动的元素互相贴靠</p>
<p>当改变窗口的时候，设置浮动的元素会根据次序和空间自动贴近，如果贴不下就换到下一行去</p>
</li>
<li>
<p>浮动的元素周围的字会像水一样</p>
<p>标准流中的文字不会被浮动的盒子遮挡住</p>
<blockquote>
<p>永远不是一个东西单独浮动，浮动都是一起浮动</p>
</blockquote>
</li>
<li>
<p>收缩</p>
<p>一个浮动的元素如果没有设置width，将自动收缩为内容的宽度</p>
</li>
</ul>
<h4 id="作业">作业</h4>
<p><img src="https://cdn.ethanloo.cn/img/20201226204341.png" alt="image-20201226204341675"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>EthanLoo&#x27;s<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./test.css&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left-content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right-content&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;news&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;news1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;news2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;news3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hot&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;links&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">header</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">103px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">970px</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header1</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">103px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">277px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header2</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">49px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">137px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: greenyellow;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">8px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.header3</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">46px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">679px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: greenyellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">435px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">970px</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.left-content</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">435px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">310px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: orange;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">650px</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.news</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">450px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.news1</span>,</span><br><span class="line"><span class="selector-class">.news2</span>,</span><br><span class="line"><span class="selector-class">.news3</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">450px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: skyblue;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.news1</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">240px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.news2</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">110px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.news3</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hot</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">background-color</span>: purple;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">190px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.links</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">650px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">25px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">35px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">970px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: darkblue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="清除浮动">清除浮动</h3>
<p>指清除浮动和浮动之间的影响</p>
<ol>
<li>
<p>加高法</p>
<p>给浮动元素的祖先元素增加高度</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>     //设置height</span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>    //设置height</span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>给父类加个 <code>clear:both</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">	&lt;p&gt;&lt;/p&gt;</span><br><span class="line">	&lt;p&gt;&lt;/p&gt;</span><br><span class="line">	&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;   //clear:both;</span><br><span class="line">	&lt;p&gt;&lt;/p&gt;</span><br><span class="line">	&lt;p&gt;&lt;/p&gt;</span><br><span class="line">	&lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>隔墙法</p>
<p>在两个浮动元素中间建一个墙（内墙可以让父类自动被撑高）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;cl h10&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>overflow:hidden</code></p>
<p>针对每个需要撑高的元素加上该属性</p>
</li>
</ol>
<h3 id="margin">margin</h3>
<p><strong>margin 塌陷</strong></p>
<p>标准文档流中，竖直方向的 margin 不叠加，取最大值</p>
<p><strong>盒子居中</strong></p>
<p>将 margin 的值设为 auto，表示自动。</p>
<p>当 left, right 都是 auto 的时候，盒子就居中了</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">margin-left</span>: auto;</span><br><span class="line"><span class="attribute">margin-right</span>: auto;</span><br></pre></td></tr></table></figure>
<p>简写为</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">margin</span>:<span class="number">0</span> auto;</span><br></pre></td></tr></table></figure>
<p>注意点</p>
<ol>
<li>只有标准流的盒子才能使用这个居中方法</li>
<li>使用<code>margin: 0 auto;</code>的盒子，必须有 width，否则相当于霸占了一行</li>
<li><code>margin: 0 auto;</code>只是让盒子居中，文本居中需要使用<code>text-align: center;</code></li>
</ol>
<p><strong>善用外层的 padding 而不是里层的margin</strong></p>
<h2 id="定位属性">定位属性</h2>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;  &lt;!-- 绝对定位 --&gt;</span><br><span class="line"></span><br><span class="line"><span class="attribute">position</span>: relative;  &lt;!-- 相对定位 --&gt;</span><br><span class="line"></span><br><span class="line"><span class="attribute">position</span>: fixed;     &lt;!-- 固定定位 --&gt;</span><br></pre></td></tr></table></figure>
<h3 id="相对定位">相对定位</h3>
<p>可以用于盒子的位置的微调</p>
<ul>
<li>
<p>left：盒子右移</p>
</li>
<li>
<p>right：盒子左移</p>
</li>
<li>
<p>top：盒子下移</p>
</li>
<li>
<p>bottom：盒子上移</p>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: relative;</span><br><span class="line"><span class="attribute">left</span>: <span class="number">50px</span>;</span><br><span class="line"><span class="attribute">top</span>: <span class="number">50px</span>;</span><br></pre></td></tr></table></figure>
<p>相对定位不脱离标准文档流，因此不会被其他元素挤掉</p>
<p><strong>用途</strong></p>
<ol>
<li>微调元素</li>
<li>做绝对定位的参考</li>
</ol>
<h3 id="绝对定位">绝对定位</h3>
<p>定义横纵坐标，原点在父容器的左上角或左下角。横坐标用left表示，纵坐标用top或者bottom表示。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">position</span>: absolute;  <span class="comment">/*绝对定位*/</span></span><br><span class="line"><span class="attribute">left</span>: <span class="number">10px</span>;  <span class="comment">/*横坐标*/</span></span><br><span class="line"><span class="attribute">top</span>/<span class="attribute">bottom</span>: <span class="number">20px</span>;  <span class="comment">/*纵坐标*/</span></span><br></pre></td></tr></table></figure>
<p>绝对定位脱离了标准文档流，所以它可以直接设置宽和高</p>
<p><strong>参考点</strong></p>
<ol>
<li>如果用 top 描述，那么参考点就是<strong>页面的左上角</strong>，不是浏览器的左上角</li>
<li>如果用 bottom 描述，参考点就是<strong>浏览器首屏尺寸对应的左下角</strong></li>
</ol>
<p>子绝父相（子元素是绝对定位，父元素是相对定位）是有意义的，可以保证父亲没有脱标，儿子脱标在父亲的范围内移动。</p>
<blockquote>
<p>工程上会让父亲浮动，相对定位，0偏移，让儿子使用绝对定位</p>
</blockquote>
<p>绝对定位的儿子会忽略父类盒子的padding</p>
<h3 id="固定定位">固定定位</h3>
<p>相对浏览器窗口进行定位，无论页面如何滚动，这个盒子显示的位置不变</p>
<ol>
<li>返回到顶部</li>
<li>顶部导航栏</li>
</ol>
<h3 id="z-index">z-index</h3>
<p>定位后的元素可以使用的图层位置，值越大越上层</p>
<h2 id="CSS3-选择器">CSS3 选择器</h2>
<p><strong>渐进增强策略</strong></p>
<p>让低版本浏览器能正常访问页面，高版本的浏览器用户体验更好</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> 标签选择器</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span> 类名选择器</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#box</span>　id选择器</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">p</span> 后代选择器</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-class">.box</span> 交集选择器</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span>,<span class="selector-tag">p</span>,<span class="selector-tag">span</span> 并集选择器</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span>&gt;<span class="selector-tag">p</span> 子代选择器</span><br><span class="line"></span><br><span class="line">* : 通配符</span><br><span class="line"></span><br><span class="line">div+p: 选中div后面相邻的第一个p</span><br><span class="line"></span><br><span class="line">div~p: 选中的div后面所有的p</span><br></pre></td></tr></table></figure>
<h3 id="属性选择器">属性选择器</h3>
<p>属性选择器的标志性符号是<code>[]</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E[属性名=值]</span><br><span class="line">^：开头  $：结尾  *：包含</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>E[title]</code> 选中页面的E元素，并且E存在 title 属性即可。</p>
</li>
<li>
<p><code>E[title=&quot;abc&quot;]</code>选中页面的E元素，并且E需要带有title属性，且属性值<strong>完全等于</strong>abc。</p>
</li>
<li>
<p><code>E[attr~=val]</code>  选择具有 att 属性且属性值为：用空格分隔的字词列表，其中一个等于 val 的E元素。</p>
</li>
<li>
<p><code>E[attr|=val]</code> 表示要么是一个单独的属性值，要么这个属性值是以“-”分隔的。</p>
</li>
<li>
<p><code>E[title^=&quot;abc&quot;]</code> 选中页面的E元素，并且E需要带有 title 属性,属性值以 abc 开头。</p>
</li>
<li>
<p><code>E[title$=&quot;abc&quot;]</code> 选中页面的E元素，并且E需要带有 title 属性,属性值以 abc 结尾。</p>
</li>
<li>
<p><code>E[title*=&quot;abc&quot;]</code> 选中页面的E元素，并且E需要带有 title 属性,属性值任意位置包含abc。</p>
</li>
</ul>
<h3 id="结构伪类选择器">结构伪类选择器</h3>
<p>CSS 中已经有的动态伪类选择器</p>
<p><code>:link</code>、<code>:active</code>、<code>:visited</code>、<code>:hover</code></p>
<p>CSS3 新增了其他的伪类选择器，其中有通过结构来进行筛选的选择器</p>
<ul>
<li>
<p><code>E:first-child</code> 匹配父元素的第一个子元素E。</p>
</li>
<li>
<p><code>E:last-child</code> 匹配父元素的最后一个子元素E。</p>
</li>
<li>
<p><code>E:nth-child(n)</code> 匹配父元素的第n个子元素E。</p>
<blockquote>
<p><strong>注意</strong>，盒子的编号是从<code>1</code>开始算起，不是从<code>0</code>开始算起。</p>
</blockquote>
</li>
<li>
<p><code>E:nth-child(odd)</code> 匹配奇数</p>
</li>
<li>
<p><code>E:nth-child(even)</code> 匹配偶数</p>
</li>
<li>
<p><code>E:nth-last-child(n)</code> 匹配父元素的倒数第n个子元素E。</p>
</li>
</ul>
<hr>
<ul>
<li><code>E:first-of-type</code> 匹配同类型中的第一个同级兄弟元素E。</li>
<li><code>E:last-of-type</code> 匹配同类型中的最后一个同级兄弟元素E。</li>
<li><code>E:nth-of-type(n)</code> 匹配同类型中的第n个同级兄弟元素E。</li>
<li><code>E:nth-last-of-type(n)</code> 匹配同类型中的倒数第n个同级兄弟元素E。</li>
</ul>
<hr>
<ul>
<li>
<p><code>E:empty</code> 匹配没有任何子节点（包括空格等text节点）的元素E。</p>
</li>
<li>
<p><code>E:target</code> 匹配相关URL指向的E元素。要配合锚点使用。</p>
</li>
</ul>
<h3 id="伪元素选择器">伪元素选择器</h3>
<p>伪元素选择器的标志性符号是 <code>::</code></p>
<p><code>E:after</code>、<code>E:before </code>在旧版本里是伪类。CSS3 里，<code>E:after</code>、<code>E:before</code>会被自动识别为<code>E::after</code>、<code>E::before</code>，按伪元素来对待，这样做的目的是用来做兼容处理。</p>
<ul>
<li>
<p><code>E::before</code> 设置在 元素E 前面（依据对象树的逻辑结构）的内容，配合content属性一起使用。</p>
</li>
<li>
<p><code>E::after</code> 设置在 元素E 后面（依据对象树的逻辑结构）的内容，配合content属性一起使用。</p>
</li>
</ul>
<p>使用伪元素选择器，可以添加出类似 span 标签的效果，同时这两个属性添加伪元素是行内元素，需要转换成块元素才能设置宽高。</p>
<hr>
<ul>
<li>
<p><code>E::first-letter</code> 设置元素 E 里面的<strong>第一个字符</strong>的样式。</p>
</li>
<li>
<p><code>E::first-line</code> 设置元素 E 里面的<strong>第一行</strong>的样式。</p>
</li>
<li>
<p><code>E::selection</code> 设置元素 E 里面被鼠标选中的区域的样式（一般设置颜色和背景色）。</p>
</li>
</ul>
<h2 id="CSS3-属性">CSS3 属性</h2>
<h3 id="文本">文本</h3>
<p><strong>text-shadow：设置文本的阴影</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">text-shadow: 20px 27px 22px pink;</span><br></pre></td></tr></table></figure>
<p>水平位移 垂直位移 模糊程度 阴影颜色</p>
<h3 id="box-sizing">box-sizing</h3>
<p><strong>外加模式</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">box-sizing</span>: content-box;</span><br></pre></td></tr></table></figure>
<p>此时设置的 width 和 height 是内容区域的宽高，盒子实际的宽度 = width + padding + border</p>
<p><strong>内减模式</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">box-sizing</span>: border-box;</span><br></pre></td></tr></table></figure>
<p>此时设置的 width 和 height 是盒子的总宽高，盒子实际的宽度 = width</p>
<h3 id="私有前缀">私有前缀</h3>
<p>如果直接这么写，浏览器是不会显示的 🙅‍</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(left, green, yellow);</span><br></pre></td></tr></table></figure>
<p>需要根据浏览器的不同添加前缀</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background</span>: <span class="built_in">-webkit-linear-gradient</span>(left, green, yellow);</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">-moz-linear-gradient</span>(left, green, yellow);</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">-ms-linear-gradient</span>(left, green, yellow);</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">-o-linear-gradient</span>(left, green, yellow);</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(left, green, yellow);</span><br></pre></td></tr></table></figure>
<h3 id="边框">边框</h3>
<p><strong>边框圆角</strong></p>
<p>四个角</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border-radius</span>: <span class="number">60px</span>;</span><br></pre></td></tr></table></figure>
<p>单个属性写法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border-top-left-radius</span>: <span class="number">60px</span> <span class="number">120px</span>;        //参数解释：水平半径   垂直半径</span><br><span class="line"></span><br><span class="line"><span class="attribute">border-top-right-radius</span>: <span class="number">60px</span> <span class="number">120px</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border-bottom-left-radius</span>: <span class="number">60px</span> <span class="number">120px</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border-bottom-right-radius</span>: <span class="number">60px</span> <span class="number">120px</span>;</span><br></pre></td></tr></table></figure>
<p>画圆形的两个方式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*画圆形的方式一*/</span></span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:nth-child</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*画圆形的方式二*/</span></span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:nth-child</span>(<span class="number">2</span>) &#123;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>边框阴影</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>: 水平偏移 垂直偏移 模糊程度 阴影大小 阴影颜色</span><br><span class="line"></span><br><span class="line">box-shadow: <span class="number">15px</span> <span class="number">21px</span> <span class="number">48px</span> -<span class="number">2px</span> <span class="number">#666</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>水平偏移：正值向右 负值向左。</p>
</li>
<li>
<p>垂直偏移：正值向下 负值向上。</p>
</li>
<li>
<p>模糊程度：不能为负值。</p>
</li>
</ul>
<p><strong>边框图片</strong></p>
<p>单独写</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 边框图片的路径*/</span></span><br><span class="line"><span class="attribute">border-image-source</span>: <span class="built_in">url</span>(<span class="string">&quot;images/border.png&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 图片边框的裁剪*/</span></span><br><span class="line"><span class="attribute">border-image-slice</span>: <span class="number">27</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*图片边框的宽度*/</span></span><br><span class="line"><span class="attribute">border-image-width</span>: <span class="number">27px</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*边框图片的平铺*/</span></span><br><span class="line"><span class="comment">/* repeat :正常平铺 但是可能会显示不完整*/</span></span><br><span class="line"><span class="comment">/*round: 平铺 但是保证 图片完整*/</span></span><br><span class="line"><span class="comment">/*stretch: 拉伸显示*/</span></span><br><span class="line"><span class="attribute">border-image-repeat</span>: stretch;</span><br></pre></td></tr></table></figure>
<p>综合属性</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">&quot;images/border.png&quot;</span>) <span class="number">27</span>/<span class="number">20px</span> round;</span><br></pre></td></tr></table></figure>
<h2 id="CSS3-动画">CSS3 动画</h2>
<h3 id="过渡">过渡</h3>
<ul>
<li>
<p><code>transition-property: all;</code>  如果希望所有的属性都发生过渡，就使用all。</p>
</li>
<li>
<p><code>transition-duration: 1s;</code> 过渡的持续时间。</p>
</li>
<li>
<p><code>transition-timing-function: linear;</code>  运动曲线。属性值可以是：</p>
<ul>
<li><code>linear</code> 线性</li>
<li><code>ease</code>  减速</li>
<li><code>ease-in</code> 加速</li>
<li><code>ease-out</code> 减速</li>
<li><code>ease-in-out</code>  先加速后减速</li>
</ul>
</li>
<li>
<p><code>transition-delay: 1s;</code> 过渡延迟。多长时间后再执行这个过渡动画。</p>
</li>
</ul>
<p><strong>综合属性</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transition</span>: 让哪些属性进行过度 过渡的持续时间 运动曲线 延迟时间;</span><br><span class="line"></span><br><span class="line"><span class="attribute">transition</span>: all <span class="number">3s</span> linear <span class="number">0s</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2D转换">2D转换</h3>
<p><strong>缩放</strong><code>scale</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">scale</span>(x, y);</span><br><span class="line"></span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>, <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure>
<p>参数解释： x：表示水平方向的缩放倍数。y：表示垂直方向的缩放倍数。如果只写一个值就是等比例缩放。y大于1表示放大，小于1表示缩小。</p>
<p><strong>位移</strong><code>translate</code></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate</span>(水平位移, 垂直位移);</span><br><span class="line"></span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>参数为百分比，相对于自身移动。</p>
</li>
<li>
<p>正值：向右和向下。 负值：向左和向上。</p>
</li>
</ul>
<p><strong>位移的应用：让绝对定位中的盒子在父亲里居中</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: red;</span><br><span class="line">    <span class="attribute">position</span>: absolute;       绝对定位的盒子</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;               首先，让左边线居中</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>);    然后，利用translate，往左走自己宽度的一半【推荐写法】</span><br></pre></td></tr></table></figure>
<p><strong>旋转</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(角度);</span><br><span class="line"></span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span><br></pre></td></tr></table></figure>
<p>参数解释：正值 顺时针；负值：逆时针。</p>
<h3 id="3D-旋转">3D 旋转</h3>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotateX</span>(<span class="number">360deg</span>);    //绕 X 轴旋转<span class="number">360</span>度</span><br><span class="line"></span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotateY</span>(<span class="number">360deg</span>);    //绕 Y 轴旋转<span class="number">360</span>度</span><br><span class="line"></span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotateZ</span>(<span class="number">360deg</span>);    //绕 Z 轴旋转<span class="number">360</span>度</span><br></pre></td></tr></table></figure>
<h2 id="项目实战">项目实战</h2>
<p>还原了半个豆瓣首页，纯HTML+CSS，代码还很不成熟。</p>
<p>在线展示：<a href="https://lab.ethanloo.cn/douban">https://lab.ethanloo.cn/douban</a></p>
<p><img src="https://cdn.ethanloo.cn/img/20210110114536.png" alt=""></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年1月刷题日志</title>
    <url>/post/2021-01-01-Algorithm/2021%E5%B9%B41%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p><strong>2.4</strong></p>
<p>美赛前的最后一天寒假了</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="643-子数组最大平均数-I"><a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/">643. 子数组最大平均数 I</a></h4>
<p>难度简单</p>
<p>给定 <code>n</code> 个整数，找出平均数最大且长度为 <code>k</code> 的连续子数组，并输出该最大平均数。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,12,-5,-6,50,3], k = 4</span><br><span class="line">输出：12.75</span><br><span class="line">解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>1 &lt;= <code>k</code> &lt;= <code>n</code> &lt;= 30,000。</li>
<li>所给数据范围 [-10,000，10,000]。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>没啥花里胡哨的，用滑动窗口模拟就行</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxAverage</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>: </span><br><span class="line">        cur_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>):</span><br><span class="line">            cur_sum += nums[i]</span><br><span class="line">        cur_max = -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            cur_sum += nums[i]</span><br><span class="line">            cur_max = <span class="built_in">max</span>(cur_max, cur_sum)</span><br><span class="line">            cur_sum -= nums[i-k+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> cur_max/k</span><br></pre></td></tr></table></figure>
<p><strong>2.3</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="480-滑动窗口中位数"><a href="https://leetcode-cn.com/problems/sliding-window-median/">480. 滑动窗口中位数</a></h4>
<p>难度困难</p>
<p>中位数是有序序列最中间的那个数。如果序列的大小是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。</p>
<p>例如：</p>
<ul>
<li><code>[2,3,4]</code>，中位数是 <code>3</code></li>
<li><code>[2,3]</code>，中位数是 <code>(2 + 3) / 2 = 2.5</code></li>
</ul>
<p>给你一个数组 <em>nums</em>，有一个大小为 <em>k</em> 的窗口从最左端滑动到最右端。窗口中有 <em>k</em> 个数，每次窗口向右移动 <em>1</em> 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。</p>
<p><strong>示例：</strong></p>
<p>给出 <em>nums</em> = <code>[1,3,-1,-3,5,3,6,7]</code>，以及 <em>k</em> = 3。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">窗口位置                      中位数</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       1</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7      -1</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7      -1</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       3</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       5</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      6</span><br></pre></td></tr></table></figure>
<p>因此，返回该滑动窗口的中位数数组 <code>[1,-1,-1,3,5,6]</code>。</p>
<p><strong>提示：</strong></p>
<ul>
<li>你可以假设 <code>k</code> 始终有效，即：<code>k</code> 始终小于输入的非空数组的元素个数。</li>
<li>与真实值误差在 <code>10 ^ -5</code> 以内的答案将被视作正确答案。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>暴力法</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">medianSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-k+<span class="number">1</span>):</span><br><span class="line">            tmp = nums[i:i+k]</span><br><span class="line">            tmp.sort()</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(tmp)%<span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                res.append(tmp[k//<span class="number">2</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append((tmp[k//<span class="number">2</span>]+tmp[k//<span class="number">2</span>-<span class="number">1</span>])/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>2.2</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="424-替换后的最长重复字符"><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/">424. 替换后的最长重复字符</a></h4>
<p>难度中等</p>
<p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 <em>k</em> 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p>
<p>**注意：**字符串长度 和 <em>k</em> 不会超过 104。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ABAB&quot;, k = 2</span><br><span class="line">输出：4</span><br><span class="line">解释：用两个&#x27;A&#x27;替换为两个&#x27;B&#x27;,反之亦然。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;AABABBA&quot;, k = 1</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">将中间的一个&#x27;A&#x27;替换为&#x27;B&#x27;,字符串变为 &quot;AABBBBA&quot;。</span><br><span class="line">子串 &quot;BBBB&quot; 有最长重复字母, 答案为 4。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>双指针，滑动窗口，遍历字符串，用一个数组来维护窗口中字母的出现次数</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">characterReplacement</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cnts =  [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line">        left = right = maxn = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">while</span> right &lt; n:</span><br><span class="line">            cnts[<span class="built_in">ord</span>(s[right]) - <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">            maxn = <span class="built_in">max</span>(maxn, cnts[<span class="built_in">ord</span>(s[right]) - <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)])</span><br><span class="line">            <span class="keyword">if</span> right - left + <span class="number">1</span> - maxn &gt; k:</span><br><span class="line">                cnts[<span class="built_in">ord</span>(s[left]) - <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right - left</span><br></pre></td></tr></table></figure>
<p><strong>2.1</strong></p>
<p>今日简单题，刷完吃寿喜烧去咯</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="888-公平的糖果棒交换"><a href="https://leetcode-cn.com/problems/fair-candy-swap/">888. 公平的糖果棒交换</a></h4>
<p>难度简单99</p>
<p>爱丽丝和鲍勃有不同大小的糖果棒：<code>A[i]</code> 是爱丽丝拥有的第 <code>i</code> 根糖果棒的大小，<code>B[j]</code> 是鲍勃拥有的第 <code>j</code> 根糖果棒的大小。</p>
<p>因为他们是朋友，所以他们想交换一根糖果棒，这样交换后，他们都有相同的糖果总量。<em>（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）</em></p>
<p>返回一个整数数组 <code>ans</code>，其中 <code>ans[0]</code> 是爱丽丝必须交换的糖果棒的大小，<code>ans[1]</code> 是 Bob 必须交换的糖果棒的大小。</p>
<p>如果有多个答案，你可以返回其中任何一个。保证答案存在。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：A = [1,1], B = [2,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：A = [1,2], B = [2,3]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：A = [2], B = [1,3]</span><br><span class="line">输出：[2,3]</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：A = [1,2,5], B = [2,4]</span><br><span class="line">输出：[5,4]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>1 &lt;= B.length &lt;= 10000</code></li>
<li><code>1 &lt;= A[i] &lt;= 100000</code></li>
<li><code>1 &lt;= B[i] &lt;= 100000</code></li>
<li>保证爱丽丝与鲍勃的糖果总量不同。</li>
<li>答案肯定存在。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>traversing and binary search.</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fairCandySwap</span>(<span class="params">self, A: <span class="type">List</span>[<span class="built_in">int</span>], B: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        sum_a = <span class="built_in">sum</span>(A)</span><br><span class="line">        sum_b = <span class="built_in">sum</span>(B)</span><br><span class="line">        diff = sum_a-sum_b</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">            j = <span class="built_in">int</span>(i-diff/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">in</span> B:</span><br><span class="line">                <span class="keyword">return</span> [i,j]</span><br></pre></td></tr></table></figure>
<p><strong>1.31</strong></p>
<p>可恶啊，昨天看到是困难题，甚至CV都给忘了</p>
<p>今天又是并查集</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="839-相似字符串组"><a href="https://leetcode-cn.com/problems/similar-string-groups/">839. 相似字符串组</a></h4>
<p>难度困难</p>
<p>如果交换字符串 <code>X</code> 中的两个不同位置的字母，使得它和字符串 <code>Y</code> 相等，那么称 <code>X</code> 和 <code>Y</code> 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。</p>
<p>例如，<code>&quot;tars&quot;</code> 和 <code>&quot;rats&quot;</code> 是相似的 (交换 <code>0</code> 与 <code>2</code> 的位置)； <code>&quot;rats&quot;</code> 和 <code>&quot;arts&quot;</code> 也是相似的，但是 <code>&quot;star&quot;</code> 不与 <code>&quot;tars&quot;</code>，<code>&quot;rats&quot;</code>，或 <code>&quot;arts&quot;</code> 相似。</p>
<p>总之，它们通过相似性形成了两个关联组：<code>&#123;&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;&#125;</code> 和 <code>&#123;&quot;star&quot;&#125;</code>。注意，<code>&quot;tars&quot;</code> 和 <code>&quot;arts&quot;</code> 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。</p>
<p>给你一个字符串列表 <code>strs</code>。列表中的每个字符串都是 <code>strs</code> 中其它所有字符串的一个字母异位词。请问 <code>strs</code> 中有多少个相似字符串组？</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：strs = [&quot;tars&quot;,&quot;rats&quot;,&quot;arts&quot;,&quot;star&quot;]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：strs = [&quot;omv&quot;,&quot;ovm&quot;]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= strs.length &lt;= 100</code></li>
<li><code>1 &lt;= strs[i].length &lt;= 1000</code></li>
<li><code>sum(strs[i].length) &lt;= 2 * 104</code></li>
<li><code>strs[i]</code> 只包含小写字母。</li>
<li><code>strs</code> 中的所有单词都具有相同的长度，且是彼此的字母异位词。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>题目难度虽然是困难，但是其实具体的实现还是很简单的。</p>
<p>参考了官方题解之后豁然开朗，这道题目其实还是一个传统的并查集题目。</p>
<p>首先看到了我们的最终目标是求相似字符串组，其实就是抽象成并查集里的连通情况。</p>
<p>两个字符串相似，就说明是两个字符串相连（union）。</p>
<p>所以我们只需要维护一个并查集，遍历不同字符串组合确认是否连通，最后输出连通分量的个数即可。</p>
<p>维护并查集很简单，就是纯粹的最简单的模板。</p>
<p>确认字符串的相似性也不难，实现方法应该有很多，我这边就比较随意地写了一个。</p>
<ul>
<li>我们手上有两个字符串 <code>str1</code>,  <code>str2</code></li>
<li>题目的条件是已知这两个字符串长度相等，因此我们直接按照位置来遍历字符串即可</li>
<li>新建一个数组 <code>diff_chars</code>，用来存放不同这两个字符串中的同一个位置上的不同的字符对 <code>(x_i, y_i)</code>，表示第 <code>i</code> 个位置上的两个不同字符。</li>
<li>同时遍历完两个字符串之后，我们去判断<code>diff_chars</code>的长度，只有当长度为的2 的时候，我们才能确认两个字符串有可能相似（在一开始的时候我们就提前判断字符串是否相等）</li>
<li>相似还需要确认字符对调之后是相同，因此对比一下数组中的两个字符对即可</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">        self.parents = <span class="built_in">list</span>(<span class="built_in">range</span>(n))</span><br><span class="line">        self.cnt = n</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">if</span> self.parents[x] != x:</span><br><span class="line">            self.parents[x] = self.find(self.parents[x])</span><br><span class="line">        <span class="keyword">return</span> self.parents[x]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        f_x, f_y = self.find(x), self.find(y)</span><br><span class="line">        <span class="keyword">if</span> f_x != f_y:</span><br><span class="line">            self.parents[f_x] = f_y</span><br><span class="line">            self.cnt -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numSimilarGroups</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(strs)</span><br><span class="line">        uf = UnionFind(n)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">is_similar</span>(<span class="params">str1, str2</span>):</span><br><span class="line">            <span class="comment"># 对比两个字符串是否相似</span></span><br><span class="line">            <span class="keyword">if</span> str1 == str2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            diff_chars = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(str1)):</span><br><span class="line">                <span class="keyword">if</span> str1[i] != str2[i]:</span><br><span class="line">                    diff_chars.append((str1[i], str2[i]))</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(diff_chars)!=<span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            a, b = diff_chars[<span class="number">0</span>]</span><br><span class="line">            c, d = diff_chars[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> a==d <span class="keyword">and</span> b==c:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                <span class="comment"># 两两对比 确认相似</span></span><br><span class="line">                str1, str2 = strs[i], strs[j]</span><br><span class="line">                <span class="keyword">if</span> uf.find(i) != uf.find(j):</span><br><span class="line">                    <span class="keyword">if</span> is_similar(str1, str2):</span><br><span class="line">                        uf.union(i,j)</span><br><span class="line">        <span class="keyword">return</span> uf.cnt</span><br></pre></td></tr></table></figure>
<p><strong>1.29</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1631-最小体力消耗路径"><a href="https://leetcode-cn.com/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a></h4>
<p>难度中等</p>
<p>你准备参加一场远足活动。给你一个二维 <code>rows x columns</code> 的地图 <code>heights</code> ，其中 <code>heights[row][col]</code> 表示格子 <code>(row, col)</code> 的高度。一开始你在最左上角的格子 <code>(0, 0)</code> ，且你希望去最右下角的格子 <code>(rows-1, columns-1)</code> （注意下标从 <strong>0</strong> 开始编号）。你每次可以往 <strong>上</strong>，<strong>下</strong>，<strong>左</strong>，<strong>右</strong> 四个方向之一移动，你想要找到耗费 <strong>体力</strong> 最小的一条路径。</p>
<p>一条路径耗费的 <strong>体力值</strong> 是路径上相邻格子之间 <strong>高度差绝对值</strong> 的 <strong>最大值</strong> 决定的。</p>
<p>请你返回从左上角走到右下角的最小 <strong>体力消耗值</strong> 。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex1.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：heights = [[1,2,2],[3,8,2],[5,3,5]]</span><br><span class="line">输出：2</span><br><span class="line">解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。</span><br><span class="line">这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：heights = [[1,2,3],[3,8,4],[5,3,5]]</span><br><span class="line">输出：1</span><br><span class="line">解释：路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex3.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]</span><br><span class="line">输出：0</span><br><span class="line">解释：上图所示路径不需要消耗任何体力。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>rows == heights.length</code></li>
<li><code>columns == heights[i].length</code></li>
<li><code>1 &lt;= rows, columns &lt;= 100</code></li>
<li><code>1 &lt;= heights[i][j] &lt;= 106</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>需要抽象成图，每个格子代表一个结点，格子与格子之间的差值的绝对值就是边的权值。</p>
<p>题解中提供了三种思路</p>
<ul>
<li>二分法</li>
<li>并查集</li>
<li>Dijkstra 最短路径</li>
</ul>
<p>学习了一下 Dijkstra 最短路径算法，简单来说就是启发式搜索，一个利用启发函数的 BFS</p>
<p>维护一个小顶堆 <code>q</code>，维护一个遍历过的结点集合 <code>visited</code>，维护一个最短路径长度表 <code>dist</code>。</p>
<ul>
<li>
<p>每次遍历的时候找到当前小顶堆中代价最小的，即所需消耗体力最少的。</p>
</li>
<li>
<p>向四周遍历，假设从当前结点出发到达下一个结点的代价比<code>dist</code>的中的值小，则替换，并加入小顶堆，以便下一次可以遍历</p>
</li>
<li>
<p>遍历的时候需要确保当前结点未被遍历过</p>
</li>
<li>
<p>直到走到终点，即可退出遍历</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumEffortPath</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># dijkstra</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(heights), <span class="built_in">len</span>(heights[<span class="number">0</span>])</span><br><span class="line">        dist = [<span class="number">0</span>]+[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)]*(m*n-<span class="number">1</span>)</span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        q = [(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            d, x, y = heapq.heappop(q)</span><br><span class="line">            node = x*n + y</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> (x,y) == (m-<span class="number">1</span>,n-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            visited.add(node)</span><br><span class="line">            <span class="keyword">for</span> nx, ny <span class="keyword">in</span> [(x-<span class="number">1</span>,y),(x+<span class="number">1</span>,y),(x,y-<span class="number">1</span>),(x,y+<span class="number">1</span>)]:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=nx&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=ny&lt;n <span class="keyword">and</span> <span class="built_in">max</span>(d, <span class="built_in">abs</span>(heights[x][y]-heights[nx][ny]))&lt;=dist[nx*n+ny]:</span><br><span class="line">                    dist[nx*n+ny] = <span class="built_in">max</span>(d, <span class="built_in">abs</span>(heights[x][y]-heights[nx][ny]))</span><br><span class="line">                    heapq.heappush(q, (dist[nx * n + ny], nx, ny))</span><br><span class="line">        <span class="keyword">return</span> dist[m*n - <span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>1.28</strong></p>
<p>昨日困难题又CV了，惭愧</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="724-寻找数组的中心索引"><a href="https://leetcode-cn.com/problems/find-pivot-index/">724. 寻找数组的中心索引</a></h4>
<p>难度简单</p>
<p>给定一个整数类型的数组 <code>nums</code>，请编写一个能够返回数组 <strong>“中心索引”</strong> 的方法。</p>
<p>我们是这样定义数组 <strong>中心索引</strong> 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。</p>
<p>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">nums = [1, 7, 3, 6, 5, 6]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">索引 3 (nums[3] = 6) 的左侧数之和 (1 + 7 + 3 = 11)，与右侧数之和 (5 + 6 = 11) 相等。</span><br><span class="line">同时, 3 也是第一个符合要求的中心索引。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">nums = [1, 2, 3]</span><br><span class="line">输出：-1</span><br><span class="line">解释：</span><br><span class="line">数组中不存在满足此条件的中心索引。</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li><code>nums</code> 的长度范围为 <code>[0, 10000]</code>。</li>
<li>任何一个 <code>nums[i]</code> 将会是一个范围在 <code>[-1000, 1000]</code>的整数。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>维护一个当前求得的和，遍历数组找中心索引</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pivotIndex</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cur_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        tot = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            target = tot-cur_sum-nums[i]</span><br><span class="line">            <span class="keyword">if</span> cur_sum == target:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            cur_sum += num</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><strong>1.26</strong></p>
<p>简单题，好耶（然而我却WA了）</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1128-等价多米诺骨牌对的数量"><a href="https://leetcode-cn.com/problems/number-of-equivalent-domino-pairs/">1128. 等价多米诺骨牌对的数量</a></h4>
<p>难度简单</p>
<p>给你一个由一些多米诺骨牌组成的列表 <code>dominoes</code>。</p>
<p>如果其中某一张多米诺骨牌可以通过旋转 <code>0</code> 度或 <code>180</code> 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。</p>
<p>形式上，<code>dominoes[i] = [a, b]</code> 和 <code>dominoes[j] = [c, d]</code> 等价的前提是 <code>a==c</code> 且 <code>b==d</code>，或是 <code>a==d</code> 且 <code>b==c</code>。</p>
<p>在 <code>0 &lt;= i &lt; j &lt; dominoes.length</code> 的前提下，找出满足 <code>dominoes[i]</code> 和 <code>dominoes[j]</code> 等价的骨牌对 <code>(i, j)</code> 的数量。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：dominoes = [[1,2],[2,1],[3,4],[5,6]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= dominoes.length &lt;= 40000</code></li>
<li><code>1 &lt;= dominoes[i][j] &lt;= 9</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>用数组模拟哈希表进行计数</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numEquivDominoPairs</span>(<span class="params">self, dominoes: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums = [<span class="number">0</span>]*<span class="number">100</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> dominoes:</span><br><span class="line">            k = i*<span class="number">10</span>+j <span class="keyword">if</span> i&gt;j <span class="keyword">else</span> j*<span class="number">10</span>+i</span><br><span class="line">            cnt += nums[k]</span><br><span class="line">            nums[k] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
<p><strong>1.25</strong></p>
<p>我的天，原来我鸽了4天吗</p>
<p>新的建模题太折磨了🤕</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="959-由斜杠划分区域"><a href="https://leetcode-cn.com/problems/regions-cut-by-slashes/">959. 由斜杠划分区域</a></h4>
<p>难度中等</p>
<p>在由 1 x 1 方格组成的 N x N 网格 <code>grid</code> 中，每个 1 x 1 方块由 <code>/</code>、<code>\</code> 或空格构成。这些字符会将方块划分为一些共边的区域。</p>
<p>（请注意，反斜杠字符是转义的，因此 <code>\</code> 用 <code>&quot;\\&quot;</code> 表示。）。</p>
<p>返回区域的数目。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  &quot; /&quot;,</span><br><span class="line">  &quot;/ &quot;</span><br><span class="line">]</span><br><span class="line">输出：2</span><br><span class="line">解释：2x2 网格如下：</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  &quot; /&quot;,</span><br><span class="line">  &quot;  &quot;</span><br><span class="line">]</span><br><span class="line">输出：1</span><br><span class="line">解释：2x2 网格如下：</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  &quot;\\/&quot;,</span><br><span class="line">  &quot;/\\&quot;</span><br><span class="line">]</span><br><span class="line">输出：4</span><br><span class="line">解释：（回想一下，因为 \ 字符是转义的，所以 &quot;\\/&quot; 表示 \/，而 &quot;/\\&quot; 表示 /\。）</span><br><span class="line">2x2 网格如下：</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  &quot;/\\&quot;,</span><br><span class="line">  &quot;\\/&quot;</span><br><span class="line">]</span><br><span class="line">输出：5</span><br><span class="line">解释：（回想一下，因为 \ 字符是转义的，所以 &quot;/\\&quot; 表示 /\，而 &quot;\\/&quot; 表示 \/。）</span><br><span class="line">2x2 网格如下：</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  &quot;//&quot;,</span><br><span class="line">  &quot;/ &quot;</span><br><span class="line">]</span><br><span class="line">输出：3</span><br><span class="line">解释：2x2 网格如下：</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= grid.length == grid[0].length &lt;= 30</code></li>
<li><code>grid[i][j]</code> 是 <code>'/'</code>、<code>'\'</code>、或 <code>' '</code>。</li>
</ol>
</blockquote>
<p><strong>思路</strong></p>
<p>参考了官方题解，是很巧妙的并查集解法</p>
<p>本身用并查集求连通度不难，但是要发现怎么去划分区域就有点…</p>
<p>借用官方的图来说，每个格子划分成4块，分别对应0, 1, 2, 3</p>
<img src="https://pic.leetcode-cn.com/1611302894-vmBtyK-image.png" alt="image.png" style="zoom:50%;" />
<p>我们可以把整个大的正方形抽象成一个<code>4*N*N</code>的数组，数组的每个元素代表的是四分之一个小正方形</p>
<p>因此，我们的并查集大小也是<code>4*N*N</code>，一开始假设都不是连通的</p>
<p>遍历<code>grid</code>的矩阵，相当于我们每次对一个小正方形内的四块进行操作</p>
<p>每次要进行的有两个操作</p>
<ol>
<li>小正方形内合并</li>
<li>小正方形间合并</li>
</ol>
<p>针对正方形内合并</p>
<ul>
<li>如果遍历到的是空格，即<code>‘ ’</code>，就把方块内四个格子全部连通</li>
<li>如果遍历到的是<code>/</code>，就把1和2连通，0和3连通</li>
<li>如果遍历到的是<code>\\</code>，就把0和1连通，2和3连通</li>
</ul>
<p>针对正方形间合并</p>
<ul>
<li>右侧合并
<ul>
<li>将当前块的1和右侧块的3合并</li>
</ul>
</li>
<li>下侧合并
<ul>
<li>将当前块的2和下侧块的0合并</li>
</ul>
</li>
</ul>
<p><strong>1.20</strong></p>
<p>不知不觉都20号了</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="628-三个数的最大乘积"><a href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/">628. 三个数的最大乘积</a></h4>
<p>难度简单242</p>
<p>给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: 24</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ol>
<li>给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。</li>
<li>输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。</li>
</ol>
</blockquote>
<p><strong>思路</strong></p>
<p>今天的题可太简单了，先排序，然后最大的乘积只可能是以下两个乘积之一</p>
<ol>
<li>最大的三个数的乘积</li>
<li>最小的两个数和最大的一个数的乘积</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumProduct</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort()</span><br><span class="line">        res =[]</span><br><span class="line">        res.append(nums[<span class="number">0</span>]*nums[<span class="number">1</span>]*nums[-<span class="number">1</span>])</span><br><span class="line">        res.append(nums[-<span class="number">1</span>]*nums[-<span class="number">2</span>]*nums[-<span class="number">3</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res)</span><br></pre></td></tr></table></figure>
<p><strong>1.19</strong></p>
<p>龙妈的三条龙可太折磨了。</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1584-连接所有点的最小费用"><a href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/">1584. 连接所有点的最小费用</a></h4>
<p>难度中等</p>
<p>给你一个<code>points</code> 数组，表示 2D 平面上的一些点，其中 <code>points[i] = [xi, yi]</code> 。</p>
<p>连接点 <code>[xi, yi]</code> 和点 <code>[xj, yj]</code> 的费用为它们之间的 <strong>曼哈顿距离</strong> ：<code>|xi - xj| + |yi - yj|</code> ，其中 <code>|val|</code> 表示 <code>val</code> 的绝对值。</p>
<p>请你返回将所有点连接的最小总费用。只有任意两点之间 <strong>有且仅有</strong> 一条简单路径时，才认为所有点都已连接。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/08/26/d.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：points = [[0,0],[2,2],[3,10],[5,2],[7,0]]</span><br><span class="line">输出：20</span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">我们可以按照上图所示连接所有点得到最小总费用，总费用为 20 。</span><br><span class="line">注意到任意两个点之间只有唯一一条路径互相到达。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：points = [[3,12],[-2,5],[-4,1]]</span><br><span class="line">输出：18</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：points = [[0,0],[1,1],[1,0],[-1,1]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：points = [[-1000000,-1000000],[1000000,1000000]]</span><br><span class="line">输出：4000000</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：points = [[0,0]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= points.length &lt;= 1000</code></li>
<li><code>-106 &lt;= xi, yi &lt;= 106</code></li>
<li>所有点 <code>(xi, yi)</code> 两两不同。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>关键词：并查集，Kruskal算法，最小生成树</p>
<ol>
<li>确定N个点之间所有可能的边</li>
<li>对所有边排序，升序排序</li>
<li>从最小的边开始遍历
<ul>
<li>如果遍历到的边连接到的是两个未连通的结点，则生成该条边</li>
<li>直到所有的点都连通</li>
</ul>
</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minCostConnectPoints</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(points)</span><br><span class="line">        parents = <span class="built_in">list</span>(<span class="built_in">range</span>(n))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">if</span> x != parents[x]:</span><br><span class="line">                parents[x] = find(parents[x])</span><br><span class="line">            <span class="keyword">return</span> parents[x]</span><br><span class="line">        </span><br><span class="line">        dist = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">            x1,y1 = points[i]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n):</span><br><span class="line">                x2,y2 = points[j]</span><br><span class="line">                dist.append([i,j,<span class="built_in">abs</span>(x2-x1)+<span class="built_in">abs</span>(y2-y1)])</span><br><span class="line">        dist.sort(key = <span class="keyword">lambda</span> x: x[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建最小生成树</span></span><br><span class="line">        edge, cost = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i,j,d <span class="keyword">in</span> dist:</span><br><span class="line">            a, b = find(i), find(j)</span><br><span class="line">            <span class="keyword">if</span> a != b:</span><br><span class="line">                <span class="comment"># 两个点不连通</span></span><br><span class="line">                edge += <span class="number">1</span></span><br><span class="line">                cost += d</span><br><span class="line">                parents[b] = a</span><br><span class="line">            <span class="keyword">if</span> edge == n-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> cost</span><br><span class="line">        <span class="keyword">return</span> cost</span><br></pre></td></tr></table></figure>
<p><strong>1.18</strong></p>
<p>怎么寒假了还要这么头秃</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="721-账户合并"><a href="https://leetcode-cn.com/problems/accounts-merge/">721. 账户合并</a></h4>
<p>难度中等</p>
<p>给定一个列表 <code>accounts</code>，每个元素 <code>accounts[i]</code> 是一个字符串列表，其中第一个元素 <code>accounts[i][0]</code> 是 <em>名称 (name)</em>，其余元素是 <em>emails</em> 表示该账户的邮箱地址。</p>
<p>现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。</p>
<p>合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是按顺序排列的邮箱地址。账户本身可以以任意顺序返回。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">accounts = [[&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john00@mail.com&quot;], [&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john_newyork@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]</span><br><span class="line">输出：</span><br><span class="line">[[&quot;John&quot;, &#x27;john00@mail.com&#x27;, &#x27;john_newyork@mail.com&#x27;, &#x27;johnsmith@mail.com&#x27;],  [&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]</span><br><span class="line">解释：</span><br><span class="line">第一个和第三个 John 是同一个人，因为他们有共同的邮箱地址 &quot;johnsmith@mail.com&quot;。 </span><br><span class="line">第二个 John 和 Mary 是不同的人，因为他们的邮箱地址没有被其他帐户使用。</span><br><span class="line">可以以任何顺序返回这些列表，例如答案 [[&#x27;Mary&#x27;，&#x27;mary@mail.com&#x27;]，[&#x27;John&#x27;，&#x27;johnnybravo@mail.com&#x27;]，</span><br><span class="line">[&#x27;John&#x27;，&#x27;john00@mail.com&#x27;，&#x27;john_newyork@mail.com&#x27;，&#x27;johnsmith@mail.com&#x27;]] 也是正确的。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>accounts</code>的长度将在<code>[1，1000]</code>的范围内。</li>
<li><code>accounts[i]</code>的长度将在<code>[1，10]</code>的范围内。</li>
<li><code>accounts[i][j]</code>的长度将在<code>[1，30]</code>的范围内。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>我以为是单纯的两个哈希表能解决，结果一看题解又是并查集</p>
<ul>
<li>
<p>一个哈希表存储：邮箱-&gt;index</p>
</li>
<li>
<p>另一个哈希表存储：邮箱-&gt;人名</p>
</li>
</ul>
<p>利用第一个哈希表，把同一个人的邮箱用并查集连通在一起</p>
<p>比如  <code>x@x.com</code> 如果和   <code>y@y.com</code> 是同一个人的，那么就连结到一个公共的父节点上去（这里用<code>index</code>表示父节点）</p>
<p>连接完之后，它们的<code>index</code>就相同了</p>
<p>最后利用第二个哈希表，把<code>index</code>相同的邮箱，放到同一个人名下，即可</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">accountsMerge</span>(<span class="params">self, accounts: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        email_to_index = <span class="built_in">dict</span>()</span><br><span class="line">        email_to_name = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> account <span class="keyword">in</span> accounts:</span><br><span class="line">            name = account[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> email <span class="keyword">in</span> account[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> email <span class="keyword">not</span> <span class="keyword">in</span> email_to_index:</span><br><span class="line">                    email_to_index[email] = <span class="built_in">len</span>(email_to_index)</span><br><span class="line">                    email_to_name[email] = name</span><br><span class="line">        n = <span class="built_in">len</span>(email_to_index)</span><br><span class="line">        parents = <span class="built_in">list</span>(<span class="built_in">range</span>(n))</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">if</span> parents[x] != x:</span><br><span class="line">                parents[x] = find(parents[x])</span><br><span class="line">            <span class="keyword">return</span> parents[x]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">x,y</span>):</span><br><span class="line">            f_x, f_y = find(x), find(y)</span><br><span class="line">            <span class="keyword">if</span> f_x != f_y:</span><br><span class="line">                parents[f_x] = f_y</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 开始合并同一个人的邮箱</span></span><br><span class="line">        <span class="keyword">for</span> account <span class="keyword">in</span> accounts:</span><br><span class="line">            first_index = email_to_index[account[<span class="number">1</span>]]</span><br><span class="line">            <span class="keyword">for</span> email <span class="keyword">in</span> account[<span class="number">2</span>:]:</span><br><span class="line">                union(first_index, email_to_index[email])</span><br><span class="line">        </span><br><span class="line">        index_to_emails = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> email, index <span class="keyword">in</span> email_to_index.items():</span><br><span class="line">            index = find(index)</span><br><span class="line">            index_to_emails[index].append(email)</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> emails <span class="keyword">in</span> index_to_emails.values(): </span><br><span class="line">            res.append([email_to_name[emails[<span class="number">0</span>]]] + <span class="built_in">sorted</span>(emails))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>1.17</strong></p>
<p>赶紧刷完题建模去了（这次培训竟然第一道就是对龙妈的三条🐉去建模）</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1232-缀点成线"><a href="https://leetcode-cn.com/problems/check-if-it-is-a-straight-line/">1232. 缀点成线</a></h4>
<p>难度简单</p>
<p>在一个 XY 坐标系中有一些点，我们用数组 <code>coordinates</code> 来分别记录它们的坐标，其中 <code>coordinates[i] = [x, y]</code> 表示横坐标为 <code>x</code>、纵坐标为 <code>y</code> 的点。</p>
<p>请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 <code>true</code>，否则请返回 <code>false</code>。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/untitled-diagram-2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/untitled-diagram-1.jpg" alt="img"></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= coordinates.length &lt;= 1000</code></li>
<li><code>coordinates[i].length == 2</code></li>
<li><code>-10^4 &lt;= coordinates[i][0], coordinates[i][1] &lt;= 10^4</code></li>
<li><code>coordinates</code> 中不含重复的点</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>啥技巧都没用，就直接算斜率</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkStraightLine</span>(<span class="params">self, coordinates: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        x0, y0 = coordinates[<span class="number">0</span>]</span><br><span class="line">        x1, y1 = coordinates[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> x1 == x0:</span><br><span class="line">            <span class="keyword">for</span> x,y <span class="keyword">in</span> coordinates[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> x!=x0:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = (y1-y0)/(x1-x0)</span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> coordinates[<span class="number">2</span>:]:</span><br><span class="line">            <span class="keyword">if</span> x==x0: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> (y-y0)/(x-x0) != k:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><strong>1.16</strong></p>
<p>打砖块，并查集，困难，放假，CV</p>
<p><strong>1.15</strong></p>
<p>放 假 啦！</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="947-移除最多的同行或同列石头"><a href="https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/">947. 移除最多的同行或同列石头</a></h4>
<p>难度中等</p>
<p><code>n</code> 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。</p>
<p>如果一块石头的 <strong>同行或者同列</strong> 上有其他石头存在，那么就可以移除这块石头。</p>
<p>给你一个长度为 <code>n</code> 的数组 <code>stones</code> ，其中 <code>stones[i] = [xi, yi]</code> 表示第 <code>i</code> 块石头的位置，返回 <strong>可以移除的石子</strong> 的最大数量。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]</span><br><span class="line">输出：5</span><br><span class="line">解释：一种移除 5 块石头的方法如下所示：</span><br><span class="line">1. 移除石头 [2,2] ，因为它和 [2,1] 同行。</span><br><span class="line">2. 移除石头 [2,1] ，因为它和 [0,1] 同列。</span><br><span class="line">3. 移除石头 [1,2] ，因为它和 [1,0] 同行。</span><br><span class="line">4. 移除石头 [1,0] ，因为它和 [0,0] 同列。</span><br><span class="line">5. 移除石头 [0,1] ，因为它和 [0,0] 同行。</span><br><span class="line">石头 [0,0] 不能移除，因为它没有与另一块石头同行/列。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]</span><br><span class="line">输出：3</span><br><span class="line">解释：一种移除 3 块石头的方法如下所示：</span><br><span class="line">1. 移除石头 [2,2] ，因为它和 [2,0] 同行。</span><br><span class="line">2. 移除石头 [2,0] ，因为它和 [0,0] 同列。</span><br><span class="line">3. 移除石头 [0,2] ，因为它和 [0,0] 同行。</span><br><span class="line">石头 [0,0] 和 [1,1] 不能移除，因为它们没有与另一块石头同行/列。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：stones = [[0,0]]</span><br><span class="line">输出：0</span><br><span class="line">解释：[0,0] 是平面上唯一一块石头，所以不可以移除它。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= stones.length &lt;= 1000</code></li>
<li><code>0 &lt;= xi, yi &lt;= 104</code></li>
<li>不会有两块石头放在同一个坐标点上</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>利用并查集，确定最后需要保留的点的个数</p>
<p>如果两个石头的行或者列相同，我们就可以认为它们是连通的</p>
<p>连通的石头意味着只需要留一块就够了</p>
<p>为了区分行和列，将行的值+10001</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n</span>):</span><br><span class="line">        self.dic = <span class="built_in">dict</span>()</span><br><span class="line">        self.cnt = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, i</span>):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> self.dic:</span><br><span class="line">            self.dic[i] = i</span><br><span class="line">            self.cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.dic[i] != i:</span><br><span class="line">            self.dic[i] = self.find(self.dic[i])</span><br><span class="line">        <span class="keyword">return</span> self.dic[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        f_x, f_y = self.find(x), self.find(y)</span><br><span class="line">        <span class="keyword">if</span> f_x == f_y:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.dic[f_x] = f_y</span><br><span class="line">        self.cnt -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeStones</span>(<span class="params">self, stones: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(stones)</span><br><span class="line">        uf = UnionFind(n)</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> stones:</span><br><span class="line">            uf.union(i+<span class="number">10001</span>, j)</span><br><span class="line">        <span class="keyword">return</span> n - uf.cnt</span><br></pre></td></tr></table></figure>
<p><strong>1.14</strong></p>
<p>最后一门OS，给爷🐛！</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1018-可被-5-整除的二进制前缀"><a href="https://leetcode-cn.com/problems/binary-prefix-divisible-by-5/">1018. 可被 5 整除的二进制前缀</a></h4>
<p>难度简单</p>
<p>给定由若干 <code>0</code> 和 <code>1</code> 组成的数组 <code>A</code>。我们定义 <code>N_i</code>：从 <code>A[0]</code> 到 <code>A[i]</code> 的第 <code>i</code> 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。</p>
<p>返回布尔值列表 <code>answer</code>，只有当 <code>N_i</code> 可以被 <code>5</code> 整除时，答案 <code>answer[i]</code> 为 <code>true</code>，否则为 <code>false</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[0,1,1]</span><br><span class="line">输出：[true,false,false]</span><br><span class="line">解释：</span><br><span class="line">输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为真。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,1,1]</span><br><span class="line">输出：[false,false,false]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[0,1,1,1,1,1]</span><br><span class="line">输出：[true,false,false,false,true,false]</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,1,1,0,1]</span><br><span class="line">输出：[false,false,false,false,false]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 30000</code></li>
<li><code>A[i]</code> 为 <code>0</code> 或 <code>1</code></li>
</ol>
</blockquote>
<p><strong>思路</strong></p>
<p>全程只算余数即可</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prefixesDivBy5</span>(<span class="params">self, A: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">bool</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">            tmp *= <span class="number">2</span></span><br><span class="line">            tmp += i</span><br><span class="line">            tmp %= <span class="number">5</span></span><br><span class="line">            <span class="keyword">if</span> tmp == <span class="number">0</span>:</span><br><span class="line">                res.append(<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>1.13</strong></p>
<p>又是并查集😓</p>
<p>明天考OS，紧张到起飞</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="684-冗余连接"><a href="https://leetcode-cn.com/problems/redundant-connection/">684. 冗余连接</a></h4>
<p>难度中等</p>
<p>在本问题中, 树指的是一个连通且无环的<strong>无向</strong>图。</p>
<p>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p>
<p>结果图是一个以<code>边</code>组成的二维数组。每一个<code>边</code>的元素是一对<code>[u, v]</code> ，满足 <code>u &lt; v</code>，表示连接顶点<code>u</code> 和<code>v</code>的<strong>无向</strong>图的边。</p>
<p>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 <code>[u, v]</code> 应满足相同的格式 <code>u &lt; v</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [[1,2], [1,3], [2,3]]</span><br><span class="line">输出: [2,3]</span><br><span class="line">解释: 给定的无向图为:</span><br><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2 - 3</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]</span><br><span class="line">输出: [1,4]</span><br><span class="line">解释: 给定的无向图为:</span><br><span class="line">5 - 1 - 2</span><br><span class="line">    |   |</span><br><span class="line">    4 - 3</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ul>
<li>输入的二维数组大小在 3 到 1000。</li>
<li>二维数组中的整数在1到N之间，其中N是输入数组的大小。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>用并查集确认两个结点是否连通（parent相同），如果在已经连通的情况下又有一条边将其相连，则说明产生了环路，返回这条边即可</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findRedundantConnection</span>(<span class="params">self, edges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 并查集</span></span><br><span class="line">        n = <span class="built_in">len</span>(edges)</span><br><span class="line">        parents = <span class="built_in">list</span>(<span class="built_in">range</span>(n+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">i</span>):</span><br><span class="line">            <span class="keyword">if</span> parents[i] != i:</span><br><span class="line">                parents[i] = find(parents[i])</span><br><span class="line">            <span class="keyword">return</span> parents[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">x,y</span>):</span><br><span class="line">            fx, fy = find(x), find(y)</span><br><span class="line">            <span class="keyword">if</span> fx!=fy:</span><br><span class="line">                parents[fx] = fy</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> edges:</span><br><span class="line">            <span class="keyword">if</span> find(x) == find(y):</span><br><span class="line">                <span class="keyword">return</span> [x,y]</span><br><span class="line">            union(x,y)</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p><strong>1.12</strong></p>
<p>图论，拓扑排序，困难题，cv</p>
<p><strong>1.11</strong></p>
<p>a lovely Monday.</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1202-交换字符串中的元素"><a href="https://leetcode-cn.com/problems/smallest-string-with-swaps/">1202. 交换字符串中的元素</a></h4>
<p>难度中等</p>
<p>给你一个字符串 <code>s</code>，以及该字符串中的一些「索引对」数组 <code>pairs</code>，其中 <code>pairs[i] = [a, b]</code> 表示字符串中的两个索引（编号从 0 开始）。</p>
<p>你可以 <strong>任意多次交换</strong> 在 <code>pairs</code> 中任意一对索引处的字符。</p>
<p>返回在经过若干次交换后，<code>s</code> 可以变成的按字典序最小的字符串。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;dcab&quot;, pairs = [[0,3],[1,2]]</span><br><span class="line">输出：&quot;bacd&quot;</span><br><span class="line">解释： </span><br><span class="line">交换 s[0] 和 s[3], s = &quot;bcad&quot;</span><br><span class="line">交换 s[1] 和 s[2], s = &quot;bacd&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;dcab&quot;, pairs = [[0,3],[1,2],[0,2]]</span><br><span class="line">输出：&quot;abcd&quot;</span><br><span class="line">解释：</span><br><span class="line">交换 s[0] 和 s[3], s = &quot;bcad&quot;</span><br><span class="line">交换 s[0] 和 s[2], s = &quot;acbd&quot;</span><br><span class="line">交换 s[1] 和 s[2], s = &quot;abcd&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;cba&quot;, pairs = [[0,1],[1,2]]</span><br><span class="line">输出：&quot;abc&quot;</span><br><span class="line">解释：</span><br><span class="line">交换 s[0] 和 s[1], s = &quot;bca&quot;</span><br><span class="line">交换 s[1] 和 s[2], s = &quot;bac&quot;</span><br><span class="line">交换 s[0] 和 s[1], s = &quot;abc&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 10^5</code></li>
<li><code>0 &lt;= pairs.length &lt;= 10^5</code></li>
<li><code>0 &lt;= pairs[i][0], pairs[i][1] &lt; s.length</code></li>
<li><code>s</code> 中只含有小写英文字母</li>
</ul>
</blockquote>
<p><strong>题目</strong></p>
<p>初步复习了一下并查集（没有跟官方题解一样用按秩优化）</p>
<p>根据题目要求可以很快发现有一个连通子集的问题，比如<code>[0,1]</code>和<code>[1,3]</code>可以理解为在一个连通集合里</p>
<p>因此考虑用并查集实现快速地查询哪些元素是在一个集合里的</p>
<p>具体思路见代码，以及<a href="https://leetcode-cn.com/problems/number-of-provinces/solution/python-duo-tu-xiang-jie-bing-cha-ji-by-m-vjdr/">模板题解</a></p>
<p>代码实现使用的是递归的路径压缩（我还发现直接把并查集写在Solution里会报递归深度错误）</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DSU</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n:<span class="built_in">int</span></span>):</span><br><span class="line">        self.p = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, x: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="keyword">if</span> x != self.p[x]:</span><br><span class="line">            self.p[x] = self.find(self.p[x])</span><br><span class="line">        <span class="keyword">return</span> self.p[x]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, x:<span class="built_in">int</span> , y:<span class="built_in">int</span></span>):</span><br><span class="line">        fx, fy = self.find(x), self.find(y)</span><br><span class="line">        <span class="keyword">if</span> fx == fy: <span class="keyword">return</span></span><br><span class="line">        self.p[fx] = self.p[fy]</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smallestStringWithSwaps</span>(<span class="params">self, s: <span class="built_in">str</span>, pairs: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 构造并查集</span></span><br><span class="line">        length = <span class="built_in">len</span>(s)</span><br><span class="line">        dsu = DSU(length)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> pairs:</span><br><span class="line">            dsu.merge(i,j)</span><br><span class="line">        </span><br><span class="line">        dic = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            dic[dsu.find(i)].append(i)</span><br><span class="line">        res = <span class="built_in">list</span>(<span class="built_in">range</span>(length))</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> dic.values():</span><br><span class="line">            words = [s[i] <span class="keyword">for</span> i <span class="keyword">in</span> v]</span><br><span class="line">            words.sort()</span><br><span class="line">            cnt = <span class="number">0</span> </span><br><span class="line">            v.sort()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> v:</span><br><span class="line">                res[i] = words[cnt]</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(res)</span><br></pre></td></tr></table></figure>
<p><strong>1.10</strong></p>
<blockquote>
<h4 id="228-汇总区间"><a href="https://leetcode-cn.com/problems/summary-ranges/">228. 汇总区间</a></h4>
<p>难度简单</p>
<p>给定一个无重复元素的有序整数数组 <code>nums</code> 。</p>
<p>返回 <strong>恰好覆盖数组中所有数字</strong> 的 <strong>最小有序</strong> 区间范围列表。也就是说，<code>nums</code> 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 <code>nums</code> 的数字 <code>x</code> 。</p>
<p>列表中的每个区间范围 <code>[a,b]</code> 应该按如下格式输出：</p>
<ul>
<li><code>&quot;a-&gt;b&quot;</code> ，如果 <code>a != b</code></li>
<li><code>&quot;a&quot;</code> ，如果 <code>a == b</code></li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,2,4,5,7]</span><br><span class="line">输出：[&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,2] --&gt; &quot;0-&gt;2&quot;</span><br><span class="line">[4,5] --&gt; &quot;4-&gt;5&quot;</span><br><span class="line">[7,7] --&gt; &quot;7&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,2,3,4,6,8,9]</span><br><span class="line">输出：[&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,0] --&gt; &quot;0&quot;</span><br><span class="line">[2,4] --&gt; &quot;2-&gt;4&quot;</span><br><span class="line">[6,6] --&gt; &quot;6&quot;</span><br><span class="line">[8,9] --&gt; &quot;8-&gt;9&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1]</span><br><span class="line">输出：[&quot;-1&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[&quot;0&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 20</code></li>
<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
<li><code>nums</code> 中的所有值都 <strong>互不相同</strong></li>
<li><code>nums</code> 按升序排列</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>没有技术可言，就是遍历一遍数组，把所有连续的子数组转换成<code>x-&gt;y</code>的字符串即可</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">summaryRanges</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">str</span>(nums[<span class="number">0</span>])]</span><br><span class="line">        first, last = nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums[<span class="number">1</span>:]):</span><br><span class="line">            <span class="keyword">if</span> num != last + <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> first == last:</span><br><span class="line">                    res.append(<span class="built_in">str</span>(first))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append(<span class="built_in">str</span>(first)+<span class="string">&quot;-&gt;&quot;</span>+<span class="built_in">str</span>(last))</span><br><span class="line">                first = num</span><br><span class="line">            last = num</span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(nums)-<span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> first == last:</span><br><span class="line">                    res.append(<span class="built_in">str</span>(last))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append(<span class="built_in">str</span>(first)+<span class="string">&quot;-&gt;&quot;</span>+<span class="built_in">str</span>(last))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>1.9</strong></p>
<p>@labuladong！yyds！</p>
<p><strong>题解</strong></p>
<blockquote>
<h4 id="123-买卖股票的最佳时机-III"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h4>
<p>难度困难</p>
<p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p>
<p>**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [3,3,5,0,0,3,1,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。</span><br><span class="line">     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   </span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   </span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1] </span><br><span class="line">输出：0 </span><br><span class="line">解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 105</code></li>
<li><code>0 &lt;= prices[i] &lt;= 105</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>考完五门，还剩两门，计网和OS，还有四天，算是有空写题解了</p>
<p>看完东哥的算法小抄，真就直接秒杀动归呗。</p>
<p>一般来说，如果不限交易次数，只需要设置两个变量<code>dp0</code>和<code>dp1</code>分别表示当天未持有股票的状态和持有股票的状态。</p>
<p>这道题要求最多只能交易两次，所以我们的两个变量变成了两个数组</p>
<p><strong>DP Table</strong></p>
<ul>
<li>
<p><code>dp0[i]</code> 表示当天未持有股票的最大利润，且已进行了<code>i</code>次交易（卖出过<code>i</code>次股票）</p>
</li>
<li>
<p><code>dp1[i]</code> 表示当天持有股票的最大利润，且进行了<code>i</code>次交易</p>
</li>
</ul>
<p><strong>Base case</strong></p>
<ul>
<li><code>dp0 = [0,0,0]</code>，因为一开始未持有股票，所以第一天无论是交易了几次，最大利润都是0</li>
<li><code>dp1 = [-float('inf'),-float('inf')]</code>，因为一开始不可能持有股票，所以我们初始化最大利润为负无穷（避免第一天就能卖股票）</li>
</ul>
<p><strong>状态转移方程</strong></p>
<ul>
<li>针对<code>dp0</code>而言
<ul>
<li>要么就是当天卖出了股票，要么就是本来就没有股票</li>
<li><code>dp0[0]</code>永远为0，因为交易次数为0且未持有股票，说明从未购入股票</li>
<li><code>dp0[1]</code> 为前一天未持有股票的最大收益，或者前一天持有股票且当天卖出股票的最大收益
<ul>
<li>注意这里如果是保持未持有股票，则交易次数是不会变的</li>
<li>如果是卖出股票，那必定是根据<code>dp1[0]</code>去更新的，因为更新后才变成<code>dp0[1]</code>所表示的1次交易</li>
</ul>
</li>
<li><code>dp0[2]</code>和<code>dp0[1]</code>同理</li>
</ul>
</li>
<li>针对<code>dp1</code>而言
<ul>
<li>要么就是当天买入了股票，要么就是之前就持有了股票，还没卖</li>
<li><code>dp1[0]</code> 就是根据前一天已经持有股票的最大利润<code>dp1[0]</code>，和当天买入股票的最大利润<code>dp0[0]-price</code></li>
<li><code>dp1[1]</code> 同理，需要考虑交易次数</li>
</ul>
</li>
</ul>
<blockquote>
<p>最后一天未持有股票，且交易次数为2的情况下必然是最大利益，即<code>dp0[2]</code></p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp0 = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] <span class="comment"># 表示当天未持有股票的情况 </span></span><br><span class="line">        dp1 = [-<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>), -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] <span class="comment"># 表示当天持有股票的情况</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            dp0[<span class="number">1</span>] = <span class="built_in">max</span>(dp1[<span class="number">0</span>]+price, dp0[<span class="number">1</span>])</span><br><span class="line">            dp0[<span class="number">2</span>] = <span class="built_in">max</span>(dp1[<span class="number">1</span>]+price, dp0[<span class="number">2</span>])</span><br><span class="line">            dp1[<span class="number">0</span>] = <span class="built_in">max</span>(dp0[<span class="number">0</span>]-price, dp1[<span class="number">0</span>])</span><br><span class="line">            dp1[<span class="number">1</span>] = <span class="built_in">max</span>(dp0[<span class="number">1</span>]-price, dp1[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp0[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p><strong>1.8</strong></p>
<p>软测老师捞捞我</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="189-旋转数组"><a href="https://leetcode-cn.com/problems/rotate-array/">189. 旋转数组</a></h4>
<p>难度中等</p>
<p>给定一个数组，将数组中的元素向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [-1,-100,3,99] 和 k = 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li>
<li>要求使用空间复杂度为 O(1) 的 <strong>原地</strong> 算法。</li>
</ul>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        k %= n</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">i,j</span>):</span><br><span class="line">            <span class="comment"># 翻转数组的[i:j]</span></span><br><span class="line">            left, right = i, j-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left&lt;right:</span><br><span class="line">                nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        reverse(<span class="number">0</span>,n)</span><br><span class="line">        reverse(<span class="number">0</span>,k)</span><br><span class="line">        reverse(k,n)</span><br></pre></td></tr></table></figure>
<p><strong>1.7</strong></p>
<p>真的复习不完了兄弟萌</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="547-省份数量"><a href="https://leetcode-cn.com/problems/number-of-provinces/">547. 省份数量</a></h4>
<p>难度中等</p>
<p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市 <code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code> 与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市 <code>c</code> 间接相连。</p>
<p><strong>省份</strong> 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>
<p>给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中 <code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第 <code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code> 表示二者不直接相连。</p>
<p>返回矩阵中 <strong>省份</strong> 的数量。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= n &lt;= 200</code></li>
<li><code>n == isConnected.length</code></li>
<li><code>n == isConnected[i].length</code></li>
<li><code>isConnected[i][j]</code> 为 <code>1</code> 或 <code>0</code></li>
<li><code>isConnected[i][i] == 1</code></li>
<li><code>isConnected[i][j] == isConnected[j][i]</code></li>
</ul>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findCircleNum</span>(<span class="params">self, isConnected: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> isConnected[i][j] == <span class="number">1</span> <span class="keyword">and</span> j <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    visited.add(j)</span><br><span class="line">                    dfs(j)</span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        circle = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(isConnected)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                dfs(i)</span><br><span class="line">                circle += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> circle</span><br></pre></td></tr></table></figure>
<p><strong>题目</strong></p>
<p><strong>1.6</strong></p>
<p>cv的，没空复习并查集了</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="399-除法求值"><a href="https://leetcode-cn.com/problems/evaluate-division/">399. 除法求值</a></h4>
<p>难度中等293</p>
<p>给你一个变量对数组 <code>equations</code> 和一个实数值数组 <code>values</code> 作为已知条件，其中 <code>equations[i] = [Ai, Bi]</code> 和 <code>values[i]</code> 共同表示等式 <code>Ai / Bi = values[i]</code> 。每个 <code>Ai</code> 或 <code>Bi</code> 是一个表示单个变量的字符串。</p>
<p>另有一些以数组 <code>queries</code> 表示的问题，其中 <code>queries[j] = [Cj, Dj]</code> 表示第 <code>j</code> 个问题，请你根据已知条件找出 <code>Cj / Dj = ?</code> 的结果作为答案。</p>
<p>返回 <strong>所有问题的答案</strong> 。如果存在某个无法确定的答案，则用 <code>-1.0</code> 替代这个答案。</p>
<p>**注意：**输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]</span><br><span class="line">输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]</span><br><span class="line">解释：</span><br><span class="line">条件：a / b = 2.0, b / c = 3.0</span><br><span class="line">问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?</span><br><span class="line">结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values = [1.5,2.5,5.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]</span><br><span class="line">输出：[3.75000,0.40000,5.00000,0.20000]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：equations = [[&quot;a&quot;,&quot;b&quot;]], values = [0.5], queries = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]</span><br><span class="line">输出：[0.50000,2.00000,-1.00000,-1.00000]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= equations.length &lt;= 20</code></li>
<li><code>equations[i].length == 2</code></li>
<li><code>1 &lt;= Ai.length, Bi.length &lt;= 5</code></li>
<li><code>values.length == equations.length</code></li>
<li><code>0.0 &lt; values[i] &lt;= 20.0</code></li>
<li><code>1 &lt;= queries.length &lt;= 20</code></li>
<li><code>queries[i].length == 2</code></li>
<li><code>1 &lt;= Cj.length, Dj.length &lt;= 5</code></li>
<li><code>Ai, Bi, Cj, Dj</code> 由小写英文字母与数字组成</li>
</ul>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calcEquation</span>(<span class="params">self, equations: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]], values: <span class="type">List</span>[<span class="built_in">float</span>], queries: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">        <span class="comment"># 构造图，equations的第一项除以第二项等于value里的对应值，第二项除以第一项等于其倒数</span></span><br><span class="line">        graph = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> (x, y), v <span class="keyword">in</span> <span class="built_in">zip</span>(equations, values):</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> graph:</span><br><span class="line">                graph[x][y] = v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                graph[x] = &#123;y: v&#125;</span><br><span class="line">            <span class="keyword">if</span> y <span class="keyword">in</span> graph:</span><br><span class="line">                graph[y][x] = <span class="number">1</span>/v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                graph[y] = &#123;x: <span class="number">1</span>/v&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># dfs找寻从s到t的路径并返回结果叠乘后的边权重即结果</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">s, t</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> graph:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> t == s:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> graph[s].keys():</span><br><span class="line">                <span class="keyword">if</span> node == t:</span><br><span class="line">                    <span class="keyword">return</span> graph[s][node]</span><br><span class="line">                <span class="keyword">elif</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    visited.add(node)  <span class="comment"># 添加到已访问避免重复遍历</span></span><br><span class="line">                    v = dfs(node, t)</span><br><span class="line">                    <span class="keyword">if</span> v != -<span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">return</span> graph[s][node]*v</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 逐个计算query的值</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> qs, qt <span class="keyword">in</span> queries:</span><br><span class="line">            visited = <span class="built_in">set</span>()</span><br><span class="line">            res.append(dfs(qs, qt))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>1.5</strong></p>
<p>学校的课堂知识明明以后都用不上，却还是要为了绩点去复习</p>
<p>能直接快进到寒假不，我想快点开始学 JS 了</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="830-较大分组的位置"><a href="https://leetcode-cn.com/problems/positions-of-large-groups/">830. 较大分组的位置</a></h4>
<p>难度简单</p>
<p>在一个由小写字母构成的字符串 <code>s</code> 中，包含由一些连续的相同字符所构成的分组。</p>
<p>例如，在字符串 <code>s = &quot;abbxxxxzyy&quot;</code> 中，就含有 <code>&quot;a&quot;</code>, <code>&quot;bb&quot;</code>, <code>&quot;xxxx&quot;</code>, <code>&quot;z&quot;</code> 和 <code>&quot;yy&quot;</code> 这样的一些分组。</p>
<p>分组可以用区间 <code>[start, end]</code> 表示，其中 <code>start</code> 和 <code>end</code> 分别表示该分组的起始和终止位置的下标。上例中的 <code>&quot;xxxx&quot;</code> 分组用区间表示为 <code>[3,6]</code> 。</p>
<p>我们称所有包含大于或等于三个连续字符的分组为 <strong>较大分组</strong> 。</p>
<p>找到每一个 <strong>较大分组</strong> 的区间，<strong>按起始位置下标递增顺序排序后</strong>，返回结果。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abbxxxxzzy&quot;</span><br><span class="line">输出：[[3,6]]</span><br><span class="line">解释：&quot;xxxx&quot; 是一个起始于 3 且终止于 6 的较大分组。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：[]</span><br><span class="line">解释：&quot;a&quot;,&quot;b&quot; 和 &quot;c&quot; 均不是符合要求的较大分组。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abcdddeeeeaabbbcd&quot;</span><br><span class="line">输出：[[3,5],[6,9],[12,14]]</span><br><span class="line">解释：较大分组为 &quot;ddd&quot;, &quot;eeee&quot; 和 &quot;bbb&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aba&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 1000</code></li>
<li><code>s</code> 仅含小写英文字母</li>
</ul>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largeGroupPositions</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        last, cnt = <span class="string">&quot;&quot;</span>, <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i, word <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> word == last:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> cnt&gt;=<span class="number">3</span>:</span><br><span class="line">                    res.append([i-cnt,i-<span class="number">1</span>])</span><br><span class="line">                cnt = <span class="number">1</span></span><br><span class="line">                last = word</span><br><span class="line">        <span class="keyword">if</span> cnt&gt;=<span class="number">3</span>:</span><br><span class="line">            res.append([<span class="built_in">len</span>(s)-cnt,<span class="built_in">len</span>(s)-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>1.4</strong></p>
<p>考试周开始了 🙌</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="509-斐波那契数"><a href="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数</a></h4>
<p>难度简单</p>
<p><strong>斐波那契数</strong>，通常用 <code>F(n)</code> 表示，形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F(0) = 0，F(1) = 1</span><br><span class="line">F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span><br></pre></td></tr></table></figure>
<p>给你 <code>n</code> ，请计算 <code>F(n)</code> 。</p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">self, N: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N):</span><br><span class="line">            dp.append(dp[-<span class="number">1</span>]+dp[-<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[N]</span><br></pre></td></tr></table></figure>
<p><strong>1.3</strong></p>
<p>还挺简单的，俺复习去了</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="86-分隔链表"><a href="https://leetcode-cn.com/problems/partition-list/">86. 分隔链表</a></h4>
<p>难度中等</p>
<p>给你一个链表和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有小于 <code>x</code> 的节点都出现在大于或等于 <code>x</code> 的节点之前。</p>
<p>你应当保留两个分区中每个节点的初始相对位置。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3</span><br><span class="line">输出：1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, head: ListNode, x: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        node = head</span><br><span class="line">        dummy_small, dummy_large = ListNode(<span class="number">0</span>), ListNode(<span class="number">0</span>)</span><br><span class="line">        node_small, node_large = dummy_small, dummy_large</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            nxt_node = node.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> node.val&lt;x:</span><br><span class="line">                <span class="keyword">if</span> node_small==dummy_small:</span><br><span class="line">                    node_small = node</span><br><span class="line">                    dummy_small.<span class="built_in">next</span> = node_small</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node_small.<span class="built_in">next</span> = node</span><br><span class="line">                    node_small = node</span><br><span class="line">                node_small.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> node_large == dummy_large:</span><br><span class="line">                    node_large = node</span><br><span class="line">                    dummy_large.<span class="built_in">next</span> = node_large</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node_large.<span class="built_in">next</span> = node</span><br><span class="line">                    node_large = node</span><br><span class="line">                node_large.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            node = nxt_node</span><br><span class="line">        node_small.<span class="built_in">next</span> = dummy_large.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_small.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<p><strong>1.2</strong></p>
<p>好家伙，昨天做完题直接忘记写了</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="239-滑动窗口最大值"><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h4>
<p>难度困难</p>
<p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p>
<p>返回滑动窗口中的最大值。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1], k = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,-1], k = 1</span><br><span class="line">输出：[1,-1]</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [9,11], k = 2</span><br><span class="line">输出：[11]</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,-2], k = 2</span><br><span class="line">输出：[4]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-104 &lt;= nums[i] &lt;= 104</code></li>
<li><code>1 &lt;= k &lt;= nums.length</code></li>
</ul>
</blockquote>
<p><strong>代码</strong></p>
<p>堆栈：时间复杂度O(NlogN)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums, k</span>):</span><br><span class="line">        </span><br><span class="line">        heap = [(-nums[i], i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)]</span><br><span class="line">        heapq.heapify(heap)</span><br><span class="line">        res = [-heap[<span class="number">0</span>][<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k,<span class="built_in">len</span>(nums)):</span><br><span class="line">            heapq.heappush(heap, (-nums[i], i))</span><br><span class="line">            <span class="keyword">while</span> heap[<span class="number">0</span>][<span class="number">1</span>] &lt;= i - k:</span><br><span class="line">                heapq.heappop(heap)</span><br><span class="line">            res.append(-heap[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>双向队列：时间复杂度O(N)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums, k</span>):</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        q = deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> nums[i] &gt;= nums[q[-<span class="number">1</span>]]:</span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(i)</span><br><span class="line">        res = [nums[q[<span class="number">0</span>]]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, n):</span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> nums[i] &gt;= nums[q[-<span class="number">1</span>]]:</span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(i)</span><br><span class="line">            <span class="keyword">while</span> q[<span class="number">0</span>] &lt;= i - k:</span><br><span class="line">                q.popleft()</span><br><span class="line">            res.append(nums[q[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>1.1</strong></p>
<p>因为太简单而忘记更新 😓</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="605-种花问题"><a href="https://leetcode-cn.com/problems/can-place-flowers/">605. 种花问题</a></h4>
<p>难度简单</p>
<p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p>
<p>给你一个整数数组 <code>flowerbed</code> 表示花坛，由若干 <code>0</code> 和 <code>1</code> 组成，其中 <code>0</code> 表示没种植花，<code>1</code> 表示种植了花。另有一个数 <code>n</code> ，能否在不打破种植规则的情况下种入 <code>n</code> 朵花？能则返回 <code>true</code> ，不能则返回 <code>false</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：flowerbed = [1,0,0,0,1], n = 1</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：flowerbed = [1,0,0,0,1], n = 2</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= flowerbed.length &lt;= 2 * 104</code></li>
<li><code>flowerbed[i]</code> 为 <code>0</code> 或 <code>1</code></li>
<li><code>flowerbed</code> 中不存在相邻的两朵花</li>
<li><code>0 &lt;= n &lt;= flowerbed.length</code></li>
</ul>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canPlaceFlowers</span>(<span class="params">self, flowerbed: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        size = <span class="built_in">len</span>(flowerbed)</span><br><span class="line">        <span class="keyword">while</span> index&lt;size:</span><br><span class="line">            <span class="keyword">if</span> flowerbed[index] == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 该位置有花</span></span><br><span class="line">                index += <span class="number">2</span></span><br><span class="line">            <span class="keyword">elif</span> index+<span class="number">1</span>&lt;size <span class="keyword">and</span> flowerbed[index+<span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 后一个位置有花</span></span><br><span class="line">                index += <span class="number">3</span></span><br><span class="line">            <span class="keyword">elif</span> index-<span class="number">1</span>&gt;=<span class="number">0</span> <span class="keyword">and</span> flowerbed[index-<span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 前一个位置有花</span></span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 前中后均无花</span></span><br><span class="line">                flowerbed[index] = <span class="number">1</span></span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                index += <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> cnt&gt;=n</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题日志</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5 知识点总结</title>
    <url>/post/2020-12-24-Weber/HTML5/</url>
    <content><![CDATA[<h2 id="Web-技术发展时间线">Web 技术发展时间线</h2>
<ul>
<li>
<p>1991 HTML</p>
</li>
<li>
<p>1994 HTML2</p>
</li>
<li>
<p>1996 CSS1 + JavaScript</p>
</li>
<li>
<p>1997 HTML4</p>
</li>
<li>
<p>1998 CSS2</p>
</li>
<li>
<p>2000 XHTML1（严格的html）</p>
</li>
<li>
<p>2002 Tableless Web Design（表格布局）</p>
</li>
<li>
<p>2005 AJAX</p>
</li>
<li>
<p>2009 HTML5</p>
</li>
<li>
<p>2014 HTML5 Finalized</p>
</li>
</ul>
<h2 id="什么是-HTML5">什么是 HTML5</h2>
<p><strong><code>HTML5</code>的广义概念</strong>：HTML5代表浏览器端技术的一个发展阶段。在这个阶段，浏览器的呈现技术得到了飞跃发展和广泛支持，它包括：HTML5、CSS3、Javascript API在内的一套技术组合。</p>
<p><strong>总结</strong>：<code>HTML5</code>是新一代开发 <strong>Web 富客户端</strong>应用程序整体<strong>解决方案</strong>。包括：HTML5，CSS3，Javascript API在内的一套<strong>技术组合</strong>。</p>
<p><strong>富客户端</strong>：具有很强的<strong>交互性</strong>和体验的客户端程序。比如说，浏览博客，是比较简单的客户端；一个在线听歌的网站、即时聊天网站就是富客户端。</p>
<h2 id="HTML5-的应用场景">HTML5 的应用场景</h2>
<ol>
<li>
<p>极具表现力的网页：内容简约而不简单。</p>
</li>
<li>
<p>网页应用程序：</p>
<ul>
<li>代替PC端的软件：iCloud、百度脑图、Office 365等。</li>
<li>APP端的网页：淘宝、京东、美团等。</li>
<li>微信端：公众号、小程序等。</li>
</ul>
</li>
<li>
<p>混合式本地应用。</p>
</li>
<li>
<p>简单的游戏。</p>
</li>
</ol>
<h2 id="语义化的标签">语义化的标签</h2>
<p>HTML 的职责是描述这一块内容是什么。</p>
<h3 id="标签语义化的作用">标签语义化的作用</h3>
<ul>
<li>能够便于开发者阅读和写出更优雅的代码。</li>
<li>同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容。</li>
<li>更好地搜索引擎优化。</li>
</ul>
<h3 id="HTML5-在语义上的改进">HTML5 在语义上的改进</h3>
<p>我们常见的 css+div 布局是：</p>
<p><img src="http://img.smyhvae.com/20180206_1546.png" alt=""></p>
<p>在html5中，我们可以这样写：</p>
<p><img src="http://img.smyhvae.com/20180206_1550.png" alt=""></p>
<p><strong>传统网页布局</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 头部 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 主体部分 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 文章 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 侧边栏 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;aside&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 底部 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>H5 的经典网页布局</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 头部 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 主体部分 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 文章 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 侧边栏 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aside</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 底部 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="H5-新增的语义标签">H5 新增的语义标签</h2>
<ul>
<li>
<p><code>&lt;section&gt;</code> 表示区块</p>
</li>
<li>
<p><code>&lt;article&gt;</code> 表示文章。如文章、评论、帖子、博客</p>
</li>
<li>
<p><code>&lt;header&gt;</code> 表示页眉</p>
</li>
<li>
<p><code>&lt;footer&gt;</code> 表示页脚</p>
</li>
<li>
<p><code>&lt;nav&gt;</code> 表示导航</p>
</li>
<li>
<p><code>&lt;aside&gt;</code> 表示侧边栏。如文章的侧栏</p>
</li>
<li>
<p><code>&lt;figure&gt;</code> 表示媒介内容分组。</p>
</li>
<li>
<p><code>&lt;mark&gt;</code> 表示标记 (用得少)</p>
</li>
<li>
<p><code>&lt;progress&gt;</code> 表示进度 (用得少)</p>
</li>
<li>
<p><code>&lt;time&gt;</code> 表示日期</p>
</li>
</ul>
<h3 id="兼容性处理">兼容性处理</h3>
<p>IE8 及以下版本的浏览器不支持 H5 和 CSS3。解决办法：引入<code>html5shiv.js</code>文件。</p>
<p>引入时，需要做if判断，具体代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--  条件注释 只有ie能够识别--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--[if lte ie 8]&gt;</span></span><br><span class="line"><span class="comment">    &lt;script src=&quot;html5shiv.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure>
<p>上方代码是<strong>条件注释</strong>：虽然是注释，但是IE浏览器可以识别出来。解释一下：</p>
<ul>
<li>
<p>l：less 更小</p>
</li>
<li>
<p>t：than 比</p>
</li>
<li>
<p>e：equal等于</p>
</li>
<li>
<p>g：great 更大</p>
</li>
</ul>
<p>PS:我们在测试 IE 浏览器的兼容的时候，可以使用软件 ietest，模拟IE6-IE11。</p>
<p>在不支持HTML5新标签的浏览器，会将这些新的标签解析成行内元素(inline)对待，所以我们只需要将其转换成块元素(block)即可使用。</p>
<p>但是在IE9版本以下，并不能正常解析这些新标签，但是可以识别通过document.createElement(‘tagName’)创建的自定义标签。于是我们的解决方案就是：将HTML5的新标签全部通过document.createElement(‘tagName’)来创建一遍，这样IE低版本也能正常解析HTML5新标签了。</p>
<p>当然，在实际开发中我们更多采用的办法是：检测IE浏览器的版本，来加载第三方的JS库来解决兼容问题（如上方代码所示）。</p>
<h2 id="H5-的表单">H5 的表单</h2>
<ul>
<li><code>email</code> 只能输入email格式。自动带有验证功能。</li>
<li><code>tel</code> 手机号码。</li>
<li><code>url</code> 只能输入url格式。</li>
<li><code>number</code> 只能输入数字。</li>
<li><code>search</code> 搜索框</li>
<li><code>range</code> 滑动条</li>
<li><code>color</code> 拾色器</li>
<li><code>time</code> 时间</li>
<li><code>date</code> 日期</li>
<li><code>datetime</code> 时间日期</li>
<li><code>month</code> 月份</li>
<li><code>week</code> 星期</li>
</ul>
<h3 id="表单元素">表单元素</h3>
<ol>
<li>
<p>datalist</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">list</span>=<span class="string">&quot;myData&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;myData&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>本科<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>研究生<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>不明<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>keygen</p>
<p>keygen 元素是密钥对生成器（key-pair generator）。</p>
<p>当提交表单时，会生成两个键：一个公钥，一个私钥。</p>
<p>私钥（private key）存储于客户端，公钥（public key）则被发送到服务器。</p>
<p>公钥可用于之后验证用户的客户端证书（client certificate）。</p>
</li>
<li>
<p>meter</p>
<ul>
<li>low：低于该值后警告</li>
<li>high：高于该值后警告</li>
<li>value：当前值</li>
<li>max：最大值</li>
<li>min：最小值。</li>
</ul>
</li>
</ol>
<h3 id="表单属性">表单属性</h3>
<ul>
<li>
<p><code>placeholder</code> 占位符（提示文字）</p>
</li>
<li>
<p><code>autofocus</code> 自动获取焦点</p>
</li>
<li>
<p><code>multiple</code> 文件上传多选或多个邮箱地址</p>
</li>
<li>
<p><code>autocomplete</code> 自动完成（填充的）。on 开启（默认），off 取消。用于表单元素，也可用于表单自身(on/off)</p>
</li>
<li>
<p><code>form</code> 指定表单项属于哪个form，处理复杂表单时会需要</p>
</li>
<li>
<p><code>novalidate</code> 关闭默认的验证功能（只能加给form）</p>
</li>
<li>
<p><code>required</code> 表示必填项</p>
</li>
<li>
<p><code>pattern</code> 自定义正则，验证表单</p>
</li>
</ul>
<h3 id="表单事件">表单事件</h3>
<ul>
<li>
<p><code>oninput()</code>：用户输入内容时触发，可用于输入字数统计。</p>
</li>
<li>
<p><code>oninvalid()</code>：验证不通过时触发。比如，如果验证不通过时，想弹出一段提示文字，就可以用到它。</p>
</li>
</ul>
<h2 id="多媒体">多媒体</h2>
<p>在HTML5之前，在网页上播放音频/视频的通用方法是利用Flash来播放。但是大多情况下，并非所有用户的浏览器都安装了Flash插件，由此使得音频、视频播放的处理变得非常复杂；并且移动设备的浏览器并不支持Flash插件。</p>
<h3 id="音频">音频</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;music/yinyue.mp3&quot;</span> <span class="attr">autoplay</span> <span class="attr">controls</span>&gt;</span> <span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>autoplay</code> 自动播放。写成<code>autoplay</code> 或者 <code>autoplay = &quot;&quot;</code>，都可以。</p>
</li>
<li>
<p><code>controls</code> 控制条。（建议把这个选项写上，不然都看不到控件在哪里）</p>
</li>
<li>
<p><code>loop</code> 循环播放。</p>
</li>
<li>
<p><code>preload</code> 预加载 同时设置 autoplay 时，此属性将失效。</p>
</li>
</ul>
<p><strong>兼容性写法</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--推荐的兼容写法：--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span> <span class="attr">loop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;music/yinyue.mp3&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;music/yinyue.ogg&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;music/yinyue.wav&quot;</span>/&gt;</span></span><br><span class="line">    抱歉，你的浏览器暂不支持此音频格式</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="视频">视频</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;video/movie.mp4&quot;</span> <span class="attr">controls</span> <span class="attr">autoplay</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>autoplay</code> 自动播放。写成<code>autoplay</code> 或者 <code>autoplay = &quot;&quot;</code>，都可以。</p>
</li>
<li>
<p><code>controls</code> 控制条。（建议把这个选项写上，不然都看不到控件在哪里）</p>
</li>
<li>
<p><code>loop</code> 循环播放。</p>
</li>
<li>
<p><code>preload</code> 预加载 同时设置 autoplay 时，此属性将失效。</p>
</li>
<li>
<p><code>width</code>：设置播放窗口宽度。</p>
</li>
<li>
<p><code>height</code>：设置播放窗口的高度。</p>
</li>
</ul>
<p><strong>兼容性写法</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--&lt;video src=&quot;video/movie.mp4&quot; controls  autoplay &gt;&lt;/video&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  行内块 display:inline-block --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">autoplay</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;video/movie.mp4&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;video/movie.ogg&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;video/movie.webm&quot;</span>/&gt;</span></span><br><span class="line">    抱歉，不支持此视频</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="DOM-操作">DOM 操作</h2>
<h3 id="获取元素">获取元素</h3>
<ul>
<li>
<p><code>document.querySelector(&quot;selector&quot;)</code> 通过CSS选择器获取符合条件的第一个元素。</p>
</li>
<li>
<p><code>document.querySelectorAll(&quot;selector&quot;)</code>  通过CSS选择器获取符合条件的所有元素，以类数组形式存在。</p>
</li>
</ul>
<h3 id="类名操作">类名操作</h3>
<ul>
<li><code>Node.classList.add(&quot;class&quot;)</code> 添加class</li>
<li><code>Node.classList.remove(&quot;class&quot;)</code> 移除class</li>
<li><code>Node.classList.toggle(&quot;class&quot;)</code> 切换class，有则移除，无则添加</li>
<li><code>Node.classList.contains(&quot;class&quot;)</code> 检测是否存在class</li>
</ul>
<h3 id="自定义属性">自定义属性</h3>
<p>H5可以直接在标签里添加自定义属性，<strong>但必须以 <code>data-</code> 开头</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 给标签添加自定义属性 必须以data-开头 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span> <span class="attr">title</span>=<span class="string">&quot;盒子&quot;</span> <span class="attr">data-my-name</span>=<span class="string">&quot;smyhvae&quot;</span> <span class="attr">data-content</span>=<span class="string">&quot;我是一个div&quot;</span>&gt;</span>div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//自定义的属性 需要通过 dateset[]方式来获取</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(box.<span class="property">dataset</span>[<span class="string">&quot;content&quot;</span>]);  <span class="comment">//打印结果：我是一个div</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(box.<span class="property">dataset</span>[<span class="string">&quot;myName&quot;</span>]);    <span class="comment">//打印结果：smyhvae</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//设置自定义属性的值</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> num = <span class="number">100</span>;</span></span><br><span class="line"><span class="language-javascript">    num.<span class="property">index</span> = <span class="number">10</span>;</span></span><br><span class="line"><span class="language-javascript">    box.<span class="property">index</span> = <span class="number">100</span>;</span></span><br><span class="line"><span class="language-javascript">    box.<span class="property">dataset</span>[<span class="string">&quot;content&quot;</span>] = <span class="string">&quot;aaaa&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="拖拽">拖拽</h2>
<p>在HTML5的规范中，我们可以通过为元素增加 <code>draggable=&quot;true&quot;</code> 来设置此元素是否可以进行拖拽操作，其中图片、链接默认是开启拖拽的。</p>
<p><strong>拖拽元素的事件监听</strong></p>
<ul>
<li><code>ondragstart</code> 当拖拽开始时调用</li>
<li><code>ondragleave</code> 当<strong>鼠标离开拖拽元素时</strong>调用</li>
<li><code>ondragend</code>      当拖拽结束时调用</li>
<li><code>ondrag</code>          整个拖拽过程都会调用</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>EthanLoo&#x27;s<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;image&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">height</span>=<span class="string">&quot;200&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">src</span>=<span class="string">&quot;https://cdn.ethanloo.cn/img/20201221150756.png&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> image = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.image&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  image.<span class="property">ondrag</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;666&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果把元素 A 拖拽到元素 B 里，那么元素 B 就是<strong>目标元素</strong>，页面中任何一个元素都可以成为目标元素</p>
<p><strong>目标元素的事件监听</strong></p>
<ul>
<li>
<p><code>ondragenter</code> 当拖拽元素进入时调用</p>
</li>
<li>
<p><code>ondragover</code> 当拖拽元素停留在目标元素上时，就会连续一直触发（不管拖拽元素此时是移动还是不动的状态）</p>
</li>
<li>
<p><code>ondrop</code>  当在目标元素上松开鼠标时调用</p>
</li>
<li>
<p><code>ondragleave</code> 当鼠标离开目标元素时调用</p>
</li>
</ul>
<h2 id="历史">历史</h2>
<p>界面上的所有JS操作不会被浏览器记住，就无法回到之前的状态。</p>
<p>在HTML5中可以通过 <code>window.history</code> 操作访问历史状态，让一个页面可以有多个历史状态</p>
<p><code>window.history</code>对象可以让我们管理历史记录，可用于单页面应用，Single Page Application，可以无刷新改变网页内容。</p>
<ul>
<li>
<p>window.history.forward(); // 前进</p>
</li>
<li>
<p>window.history.back(); // 后退</p>
</li>
<li>
<p>window.history.go(); // 刷新</p>
</li>
<li>
<p>window.history.go(n); //n=1 表示前进；n=-1 后退；n=0s 刷新。如果移动的位置超出了访问历史的边界，会静默失败，但不会报错。</p>
</li>
<li>
<p>通过JS可以加入一个访问状态</p>
</li>
<li>
<p>history.pushState; //放入历史中的状态数据, 设置title(现在浏览器不支持改变历史状态)</p>
</li>
</ul>
<h2 id="地理定位">地理定位</h2>
<p>在HTML规范中，增加了获取用户地理信息的API，这样使得我们可以基于用户位置开发互联网应用，即<strong>基于位置服务 LBS</strong> (Location Base Service)。</p>
<p><strong>获取地理信息的方式</strong></p>
<ol>
<li>IP地址</li>
<li>三维地址
<ul>
<li>GPS</li>
<li>Wi-Fi</li>
<li>手机信号</li>
</ul>
</li>
<li>用户自定义数据</li>
</ol>
<p>浏览器会<strong>自动以最优方式</strong>去获取用户地理信息</p>
<h3 id="API">API</h3>
<ul>
<li>获取当前地理信息
<ul>
<li><code>navigator.getCurrentPosition(successCallback, errorCallback, options)</code></li>
</ul>
</li>
<li>重复获取当前地理信息
<ul>
<li><code>navigator.watchPosition(successCallback, errorCallback, options)</code></li>
</ul>
</li>
</ul>
<ol>
<li>
<p>当成功获取地理信息后，会调用succssCallback，并返回一个包含位置信息的对象position：（Coords即坐标）</p>
<ul>
<li>position.coords.latitude纬度</li>
<li>position.coords.longitude经度</li>
</ul>
</li>
<li>
<p>当获取地理信息失败后，会调用errorCallback，并返回错误信息error。</p>
</li>
<li>
<p>可选参数 options 对象可以调整位置信息数据收集方式</p>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>EthanLoo&#x27;s<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">if</span>(navigator.<span class="property">geolocation</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 尝试获取用户的位置</span></span></span><br><span class="line"><span class="language-javascript">    navigator.<span class="property">geolocation</span>.<span class="title function_">getCurrentPosition</span>(successCallback,errorCallback);</span></span><br><span class="line"><span class="language-javascript">  &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 浏览器不支持</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;fail&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">successCallback</span>(<span class="params">position</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 获取位置成功时的回调函数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> wd = position.<span class="property">coords</span>.<span class="property">latitude</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> jd = position.<span class="property">coords</span>.<span class="property">longtitude</span>;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;纬度:&quot;</span>+wd+<span class="string">&quot;,经度:&quot;</span>+jd);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">errorCallback</span>(<span class="params">error</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">// 获取位置失败时的回调函数</span></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(error);</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;no&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="全屏">全屏</h3>
<p>HTML5规范允许用户自定义网页上<strong>任一元素</strong>全屏显示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">requestFullscreen</span>()   <span class="comment">// 让元素开启全屏显示</span></span><br><span class="line"><span class="title function_">cancleFullscreen</span>()    <span class="comment">// 让元素关闭全屏显示</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">fullScreen</span>   <span class="comment">// 检测是否全屏</span></span><br></pre></td></tr></table></figure>
<h2 id="Web-存储">Web 存储</h2>
<p>传统是以 <code>document.cookie</code> 来进行存储，大小只有 4K，且解析复杂。</p>
<h3 id="H5-的两种存储方式">H5 的两种存储方式</h3>
<ol>
<li>
<p><code>window.sessionStorage</code> 会话存储</p>
<ul>
<li>
<p>保存在内存</p>
</li>
<li>
<p><strong>生命周期</strong>为关闭浏览器窗口。也就是说，当窗口关闭时数据销毁。</p>
</li>
<li>
<p>在同一个窗口下数据可以共享。</p>
</li>
</ul>
</li>
<li>
<p><code>window.localStorage</code> 本地存储</p>
<ul>
<li>有可能保存在浏览器内存里，有可能在硬盘里。</li>
<li>永久生效，除非手动删除（比如清理垃圾的时候）。</li>
<li>可以多窗口共享。</li>
</ul>
</li>
</ol>
<h3 id="Web-存储特性">Web 存储特性</h3>
<ol>
<li>设置、读取方便</li>
<li>容量大（sessionStorage 约5M，localStorage 约20M）</li>
<li>只能存储字符串，可以将对象 JSON.stringfy() 编码后存储</li>
</ol>
<h3 id="常用-API">常用 API</h3>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setItem</span>(key, value); <span class="comment">// 设置存储内容</span></span><br><span class="line"><span class="title function_">getItem</span>(key); <span class="comment">// 读取存储内容</span></span><br><span class="line"><span class="title function_">removeItem</span>(key); <span class="comment">// 删除存储内容</span></span><br><span class="line"><span class="title function_">clear</span>(); <span class="comment">// 清空所有存储</span></span><br><span class="line"><span class="title function_">key</span>(n); <span class="comment">// 根据索引值来获取内容</span></span><br></pre></td></tr></table></figure>
<p>Session 举例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>EthanLoo&#x27;s<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>sesssion存储<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>sesssion获取<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> txt = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;input&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> btns = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;button&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;userName&quot;</span>, txt.<span class="property">value</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;pwd&quot;</span>, <span class="string">&quot;2333&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">sessionStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;age&quot;</span>, <span class="number">21</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">      btns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        txt.<span class="property">value</span> = <span class="variable language_">window</span>.<span class="property">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;pwd&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>LocalStorage 举例 （可以用来记录登录名和密码）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>EthanLoo&#x27;s<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>localStorage存储<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>localStorage获取<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> txt = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;input&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">var</span> btns = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&quot;button&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      btns[<span class="number">0</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;userName&quot;</span>, txt.<span class="property">value</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;pwd&quot;</span>, <span class="string">&quot;2333&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">setItem</span>(<span class="string">&quot;age&quot;</span>, <span class="number">21</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">      btns[<span class="number">1</span>].<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        txt.<span class="property">value</span> = <span class="variable language_">window</span>.<span class="property">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;pwd&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="网络状态">网络状态</h2>
<p>我们可以通过 <code>window.onLine</code> 来检测用户当前的网络状况，返回一个布尔值。另外：</p>
<ul>
<li>
<p><code>window.online</code>：用户网络连接时被调用。</p>
</li>
<li>
<p><code>window.offline</code>：用户网络断开时被调用（拔掉网线或者禁用以太网）。</p>
</li>
</ul>
<p>网络状态监听的代码举例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;online&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&#x27;网络连接建立！&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;offline&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&#x27;网络连接断开！&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="应用缓存">应用缓存</h2>
<p>HTML5 中我们可以轻松的构建一个离线（无网络状态）应用，只需要创建一个 <code>cache manifest</code> 缓存清单文件。</p>
<p><strong>优点</strong></p>
<ol>
<li>可配置需要缓存的资源</li>
<li>网络无连接时应用仍可用</li>
<li>本地读取缓存资源，提升访问速度，增强用户体验</li>
<li>减少请求，缓解服务器负担</li>
</ol>
<h3 id="cache-manifest">cache manifest</h3>
<p>缓存清单文件中列出了浏览器应缓存，以供离线访问的资源。</p>
<p><strong>内容</strong></p>
<ol>
<li>顶行写 <code>CACHE MANIFEST</code></li>
<li><code>CACHE:</code> 换行后指定需要缓存的静态资源，如 css, image, js</li>
<li><code>NETWORK:</code> 换行后指定需要在线访问的资源</li>
<li><code>FALLBACK:</code> 换行后指定当被缓存的文件找不到时用的备用资源</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"></span><br><span class="line"><span class="comment">#要缓存的文件</span></span><br><span class="line">CACHE:</span><br><span class="line">    images/img1.jpg</span><br><span class="line">    images/img2.jpg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定必须联网才能访问的文件</span></span><br><span class="line">NETWORK:</span><br><span class="line">     images/img3.jpg</span><br><span class="line">     images/img4.jpg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#当前页面无法访问是回退的页面</span></span><br><span class="line">FALLBACK:</span><br><span class="line">    404.html</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML 知识点总结</title>
    <url>/post/2020-12-22-Weber/HTML%20%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="开发环境">开发环境</h2>
<ul>
<li>编译器：VSC
<ul>
<li>插件：beautify（格式化代码），Live Sever（动态编译和调试HTML页面）</li>
</ul>
</li>
<li>浏览器：Chrome</li>
</ul>
<h2 id="初识-HTML">初识 HTML</h2>
<p>打开 VSC，新建一个 <code>test.html</code>文件。</p>
<p>在文件里输入，<code>html:5</code>，自动生成了 html 页面的骨架。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="html骨架标签分类">html骨架标签分类</h3>
<p>针对骨架里的一些标签进行说明。</p>
<table>
<thead>
<tr>
<th>标签名</th>
<th style="text-align:center">定义</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;html&gt;&lt;/html&gt;</code></td>
<td style="text-align:center">HTML标签</td>
<td style="text-align:left">页面中最大的标签，我们成为根标签</td>
</tr>
<tr>
<td><code>&lt;head&gt;&lt;/head&gt;</code></td>
<td style="text-align:center">文档的头部</td>
<td style="text-align:left">注意在head标签中我们必须要设置的标签是title</td>
</tr>
<tr>
<td><code>&lt;titile&gt;&lt;/title&gt;</code></td>
<td style="text-align:center">文档的标题</td>
<td style="text-align:left">让页面拥有一个属于自己的网页标题</td>
</tr>
<tr>
<td><code>&lt;body&gt;&lt;/body&gt;</code></td>
<td style="text-align:center">文档的主体</td>
<td style="text-align:left">元素包含文档的所有内容，页面内容 基本都是放到body里面的</td>
</tr>
</tbody>
</table>
<h3 id="文档声明头-DOCTYPE">文档声明头 DOCTYPE</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>HTML页面的第一行，就是文档的声明头，即 DocType Declaration，DTD。</p>
<p>现在流行使用的就是我们生成的这个 DTD ，即 HTML5 的规范。</p>
<p>原本的大规范有 HTML4.01 和 XHTML1.0 ，两者相比，后者会更加严格一些。</p>
<h3 id="页面语言-lang">页面语言 lang</h3>
<p>下面这行标签，用于指定页面的语言类型：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最常见的语言类型有两种：</p>
<ul>
<li>en：定义页面语言为英语。</li>
<li>zh-CN：定义页面语言为中文。</li>
</ul>
<h3 id="head-标签"><code>&lt;head&gt;</code> 标签</h3>
<p>填充一下骨架，让它变得完整。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;EthanLuu&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;博客,前端&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;好好学习，好好吃饭，好好睡觉。&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>EthanLoo&#x27;s<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>面试题：</p>
<ul>
<li>问：网页的head标签里面，表示的是页面的配置，有什么配置？</li>
<li>答：字符集、关键词、页面描述、页面标题、IE适配、视口、iPhone小图标等等。</li>
</ul>
<p><strong>头标签内部的常见标签</strong></p>
<ul>
<li><code>&lt;title&gt;</code>：指定整个网页的标题，在浏览器最上方显示。</li>
<li><code>&lt;base&gt;</code>：为页面上的所有链接规定默认地址或默认目标。</li>
<li><code>&lt;meta&gt;</code>：提供有关页面的基本信息</li>
<li><code>&lt;body&gt;</code>：用于定义HTML文档所要显示的内容，也称为主体标签。我们所写的代码必须放在此标签內。</li>
<li><code>&lt;link&gt;</code>：定义文档与外部资源的关系。</li>
</ul>
<p><strong>meta 标签</strong></p>
<p>meta 的翻译是 <strong>元</strong>，也就是元信息，即基本的配置信息。</p>
<p>常用的 meta 标签有</p>
<ol>
<li>
<p>字符集 charset</p>
<p>规定了浏览器编码的字符集，常用的字符集为 UTF-8，如果网页只有中文，可以设置成gb2312，节省大约4KB。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=UTF-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>视口 viewport</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>width=device-width</code> ：表示视口宽度等于屏幕宽度。</p>
</li>
<li>
<p>关键词 keywords</p>
<p>用来告诉搜索引擎，网站是干嘛的，提高搜索的命中率。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;博客,前端&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>页面描述 Description</p>
<p>通过百度的搜索结果里，会显示的内容。这个技术叫做 SEO (search engine opimization，搜索引擎优化)</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;好好学习，好好吃饭，好好睡觉。&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.ethanloo.cn/img/20201221184629.png" alt="image-20201221184530189"></p>
</li>
<li>
<p>用于跳转的meta标签</p>
<p>3秒之后跳转到百度页面。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;3;http://www.baidu.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>title标签</strong></p>
<p>用于设置网页的标题，也是SEO的一种方式。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>EthanLoo&#x27;s<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>base标签</strong></p>
<p>用于指定基础的路径，指定之后，所有的 a 链接都是以这个路径为基准。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="body-标签"><code>&lt;body&gt;</code> 标签</h3>
<p><code>&lt;body&gt;</code>标签的属性有：</p>
<ul>
<li><code>bgcolor</code>：设置整个网页的背景颜色。</li>
<li><code>background</code>：设置整个网页的背景图片。</li>
<li><code>text</code>：设置网页中的文本颜色。</li>
<li><code>leftmargin</code>：网页的左边距。IE浏览器默认是8个像素。</li>
<li><code>topmargin</code>：网页的上边距。</li>
<li><code>rightmargin</code>：网页的右边距。</li>
<li><code>bottommargin</code>：网页的下边距。</li>
</ul>
<h3 id="HTML-规范">HTML 规范</h3>
<ul>
<li>
<p>HTML 不区分大小写，但 HTML 的标签名、类名、标签属性、大部分属性值建议统一用小写。</p>
</li>
<li>
<p>所有标签必须闭合</p>
<ul>
<li>双标签：<code>&lt;span&gt;&lt;/span&gt;</code></li>
<li>单标签：<code>&lt;br&gt;</code> 建议写成 <code>&lt;br /&gt;</code>   <code>&lt;hr&gt;</code> 建议转成 <code>&lt;hr /&gt;</code>，还有<code>&lt;img src=“URL” /&gt;</code></li>
</ul>
</li>
<li>
<p>HTML 对换行不敏感，对 tab 不敏感</p>
<ul>
<li>HTML 中所有的文字之间，如果有空格，换行，tab，都会被折叠成一个空格</li>
</ul>
</li>
</ul>
<h2 id="HTML-排版标签">HTML 排版标签</h2>
<ul>
<li>
<p><code>&lt;h1&gt;</code></p>
</li>
<li>
<p><code>&lt;p&gt;</code></p>
</li>
<li>
<p><code>&lt;hr /&gt;</code></p>
</li>
<li>
<p><code>&lt;br /&gt;</code></p>
</li>
<li>
<p><code>&lt;div&gt;</code></p>
</li>
<li>
<p><code>&lt;span&gt;</code></p>
</li>
<li>
<p><code>&lt;center&gt;</code></p>
</li>
<li>
<p><code>&lt;pre&gt;</code></p>
</li>
</ul>
<h3 id="标题标签">标题标签</h3>
<p><code>&lt;h1&gt;</code>到<code>&lt;h6&gt;</code>，从大到小，具有align属性，属性可以是left, center, right</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>H1 EthanLoo<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>H2 EthanLoo<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>H3 EthanLoo<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h4</span>&gt;</span>H4 EthanLoo<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h5</span>&gt;</span>H5 EthanLoo<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h6</span>&gt;</span>H6 EthanLoo<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.ethanloo.cn/img/20201221190312.png" alt="image-20201221190312162"></p>
<blockquote>
<p>有点像在测视力</p>
</blockquote>
<h3 id="HTML-注释">HTML 注释</h3>
<p>HTML 注释的格式如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 我是 html 注释  --&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="p-段落标签"><code>&lt;p&gt;</code> 段落标签</h3>
<p>用来把文档分割成若干段落。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>my friend<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.ethanloo.cn/img/20201221190813.png" alt="image-20201221190813106"></p>
<p>如果加上了对应的 align 属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>my friend<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.ethanloo.cn/img/20201221190945.png" alt="image-20201221190945064"></p>
<p>HTML 标签是分等级的，HTML把所有的标签分为两种</p>
<ol>
<li><strong>文本级标签</strong>：p、span、a、b、i、u、em。文本级标签里只能放<strong>文字、图片、表单元素</strong>。（a标签里不能放a和input）</li>
<li><strong>容器级标签</strong>：div、h系列、li、dt、dd。容器级标签里可以放置任何东西。</li>
</ol>
<p>✨<strong>p</strong>是<strong>文本级标签</strong>，只能放文字，图片，表单元素。</p>
<p><strong>错误写法</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    我是一个小段落</span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="hr-水平线标签"><code>&lt;hr /&gt;</code> 水平线标签</h3>
<p>就和标签名一样，用来画一个水平线分隔文档。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>牛郎<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>织女<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.ethanloo.cn/img/20201221191753.png" alt="image-20201221191753310"></p>
<h3 id="br-换行标签"><code>&lt;br /&gt; </code>换行标签</h3>
<p>强制换行符</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  不要跑！<span class="tag">&lt;<span class="name">br</span> /&gt;</span> 886!</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.ethanloo.cn/img/20201221192032.png" alt="image-20201221192032213"></p>
<h3 id="div-和-span-标签"><code>&lt;div&gt;</code> 和 <code>&lt;span&gt;</code> 标签</h3>
<ul>
<li>
<p><strong>div标签</strong>：可以把标签中的内容分割为独立的区块。必须单独占据一行。</p>
</li>
<li>
<p><strong>span标签</strong>：和div的作用一致，但不换行。</p>
</li>
</ul>
<p>这两个元素是专门为定义 css 而生的。</p>
<p>两者区别在于，div 标签是容器级标签，可以放任何东西；span 标签是文本级的标签，之恩呢官方文字，图片和表单元素。</p>
<ul>
<li>
<p>div 举例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;logo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;guanggao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;dongxi&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种模式就叫做 <code>div+css</code>，div 标签负责布局，结构，分块，css 负责样式。</p>
</li>
<li>
<p>span 举例</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">	简介</span><br><span class="line">	<span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>详细信息<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>购买<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="center-内容居中标签"><code>&lt;center&gt;</code> 内容居中标签</h3>
<p>此时的 center 代表是一个标签，而不是一个属性值。</p>
<p>标签里的内容会在浏览器居中。</p>
<p>HTML5 中不推荐使用该标签，建议使用 css 布局来实现。</p>
<h2 id="HTML-字体标签">HTML 字体标签</h2>
<h3 id="特殊字符">特殊字符</h3>
<p>如果要直接在网页中显示<code>&lt;p&gt;</code>这个字符串，直接输入这三个字符是不行的，需要借助特殊字符（转义字符）来实现。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    教练，我想打印<span class="symbol">&amp;lt;</span>p<span class="symbol">&amp;gt;</span>标签</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.ethanloo.cn/img/20201221193459.png" alt="image-20201221193459238"></p>
<table>
<thead>
<tr>
<th style="text-align:left">特殊字符</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">字符的代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">空格符</td>
<td style="text-align:left"><code>&amp;nbsp;</code></td>
</tr>
<tr>
<td style="text-align:left">&lt;</td>
<td style="text-align:left">小于号</td>
<td style="text-align:left"><code>&amp;lt;</code></td>
</tr>
<tr>
<td style="text-align:left">&gt;</td>
<td style="text-align:left">大于号</td>
<td style="text-align:left"><code>&amp;gt;</code></td>
</tr>
<tr>
<td style="text-align:left">&amp;</td>
<td style="text-align:left">和号</td>
<td style="text-align:left"><code>&amp;amp;</code></td>
</tr>
<tr>
<td style="text-align:left">￥</td>
<td style="text-align:left">人民币</td>
<td style="text-align:left"><code>&amp;yen;</code></td>
</tr>
<tr>
<td style="text-align:left">©</td>
<td style="text-align:left">版权</td>
<td style="text-align:left"><code>&amp;copy;</code></td>
</tr>
<tr>
<td style="text-align:left">®</td>
<td style="text-align:left">注册商标</td>
<td style="text-align:left"><code>&amp;reg;</code></td>
</tr>
<tr>
<td style="text-align:left">°</td>
<td style="text-align:left">摄氏度</td>
<td style="text-align:left"><code>&amp;deg;</code></td>
</tr>
<tr>
<td style="text-align:left">±</td>
<td style="text-align:left">正负号</td>
<td style="text-align:left"><code>&amp;plusmn;</code></td>
</tr>
<tr>
<td style="text-align:left">×</td>
<td style="text-align:left">乘号</td>
<td style="text-align:left"><code>&amp;times;</code></td>
</tr>
<tr>
<td style="text-align:left">÷</td>
<td style="text-align:left">除号</td>
<td style="text-align:left"><code>&amp;divide;</code></td>
</tr>
<tr>
<td style="text-align:left">²</td>
<td style="text-align:left">平方2（上标2）</td>
<td style="text-align:left"><code>&amp;sup2;</code></td>
</tr>
<tr>
<td style="text-align:left">³</td>
<td style="text-align:left">立方3（上标3）</td>
<td style="text-align:left"><code>&amp;sup3;</code></td>
</tr>
</tbody>
</table>
<h3 id="下划线-删除线-斜体">下划线 删除线 斜体</h3>
<ul>
<li>
<p><code>&lt;u&gt;</code>：下划线标记</p>
</li>
<li>
<p><code>&lt;s&gt;</code>或<code>&lt;del&gt;</code>：中划线标记（删除线）</p>
</li>
<li>
<p><code>&lt;i&gt;</code>或<code>&lt;em&gt;</code>：斜体标记</p>
</li>
</ul>
<h3 id="sup-上标-sub-下标"><code>&lt;sup&gt;</code> 上标 <code>&lt;sub&gt;</code> 下标</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">O<span class="tag">&lt;<span class="name">sup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">sup</span>&gt;</span>    5<span class="tag">&lt;<span class="name">sub</span>&gt;</span>3<span class="tag">&lt;/<span class="name">sub</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.ethanloo.cn/img/20201221193903.png" alt="image-20201221193903562"></p>
<h2 id="超链接标签">超链接标签</h2>
<ol>
<li>
<p>外部链接</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;02页面.html&quot;</span>&gt;</span>点击进入另外一个文件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>锚链接</p>
<p>作用是在本页面或者其他页面的不同位置进行跳转。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;name1&quot;</span>&gt;</span>顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#name1&quot;</span>&gt;</span>回到顶部<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>邮件链接</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:952792901@qq.com&quot;</span>&gt;</span>点击进入我的邮箱<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="超链接的属性">超链接的属性</h3>
<ul>
<li><code>href</code>：目标URL。</li>
<li><code>title</code>：悬停文本。</li>
<li><code>name</code>：主要用于设置一个锚点的名称。</li>
<li><code>target</code>：告诉浏览器用什么方式来打开目标页面。
<ul>
<li><code>_self</code>：在同一个网页中显示（默认值）</li>
<li><code>_blank</code>：<strong>在新的窗口中打开</strong>。</li>
<li><code>_parent</code>：在父窗口中显示</li>
<li><code>_top</code>：在顶级窗口中显示</li>
</ul>
</li>
</ul>
<h3 id="备注">备注</h3>
<ol>
<li>
<p>分清楚 img 标签和 a 标签的各自的属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;1.jpg&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;1.html&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>a 是一个文本级标签</p>
<p>确保是 p 包裹的 a</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;www.ethanloo.cn&quot;</span>&gt;</span>点我<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="图片标签">图片标签</h2>
<h3 id="相对路径写法">相对路径写法</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当前目录中的图片 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;2.jpg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;.\2.jpg&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 上一级目录中的图片 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;..\2.jpg&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- html页面所在文件夹中有一个并列的文件夹images --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;images/1.jpg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>面试题</strong></p>
<p><img src="https://cdn.ethanloo.cn/img/20201222224939.png" alt=""></p>
<p>问题：</p>
<ul>
<li>如果想在index.html中插入1.png，那么对应的img语句是？</li>
</ul>
<p>答案：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;../../photo/1.png&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="绝对路径写法">绝对路径写法</h3>
<p>（1）以盘符开始的绝对路径。举例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;C:\Users\xxx\Desktop\html\images\1.jpg&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>（2）网络路径。举例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.ethanloo.cn/img/20201222224939.png&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="两种路径对比">两种路径对比</h3>
<p><strong>相对路径的好处</strong></p>
<ul>
<li>站点不管拷贝到哪里，文件和图片的相对路径关系都是不变的</li>
</ul>
<p><strong>相对路径的前提</strong></p>
<ul>
<li>网页文件和你的图片，必须在一个服务器上</li>
</ul>
<p><strong>面试题</strong></p>
<p>问题：网页在C盘，图片在D盘，能否插入</p>
<p>答案：用相对路径不能，用绝对路径也不能。</p>
<blockquote>
<p>可以使用file://来插入，但是这种方法，没有任何意义！因为服务器上没有所谓c盘、d盘。</p>
<p>下面的方法是行的，但是没有任何工程上的意义，这是因为服务器没有盘符，linux系统没有盘符：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;file://C:\Users\xxx\Pictures\1.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="img-标签的属性">img 标签的属性</h3>
<ul>
<li>
<p><code>width</code>：图像的宽度。</p>
</li>
<li>
<p><code>height</code>：图像的高度。</p>
</li>
<li>
<p><code>alt</code>：当图片不可用（无法显示）的时候，代替图片显示的内容。</p>
</li>
<li>
<p><code>title</code>：<strong>提示性文本</strong>。鼠标悬停时出现的文本。</p>
</li>
<li>
<p><code>align</code>：<strong>图片和周围文字的相对位置</strong>。属性取值可以是：bottom（默认）、center、top、left、right。</p>
</li>
</ul>
<h2 id="HTML-常用标签">HTML 常用标签</h2>
<h3 id="列表标签">列表标签</h3>
<h4 id="无序列表-ul">无序列表 <code>&lt;ul&gt;</code></h4>
<p>无序列表中的每一项是<code>&lt;li&gt;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>默认1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>默认2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>默认3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>li 标签不能单独存在，必须包裹在 ul 内。</p>
<p>ul 的作用并不是给文字加小圆点，而是<strong>增加无序列表的语义</strong></p>
</blockquote>
<ul>
<li>
<p>属性</p>
<ul>
<li><code>type=&quot;属性值&quot;</code>。</li>
<li>属性值可以选： <code>disc</code>(实心原点，默认)，<code>square</code>(实心方点)，<code>circle</code>(空心圆)。</li>
</ul>
</li>
<li>
<p>常用场景：导航条</p>
</li>
<li>
<p><code>&lt;li&gt;</code>是一个容器级标签，什么都能放</p>
</li>
</ul>
<h4 id="有序列表-ol">有序列表 <code>&lt;ol&gt;</code></h4>
<p>有序列表里面的每一项是<code>&lt;li&gt;</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> &gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>呵呵哒1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>呵呵哒2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>呵呵哒3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>属性
<ul>
<li><code>type=&quot;属性值&quot;</code>。</li>
<li>属性值可以是：1(阿拉伯数字，默认)、a、A、i、I。</li>
<li><code>start</code>属性表示<code>从几开始</code>。</li>
</ul>
</li>
</ul>
<h4 id="定义列表-dl">定义列表 <code>&lt;dl&gt;</code></h4>
<p>dl的子元素只能是dt和dd。</p>
<ul>
<li><code>&lt;dt&gt;</code>：definition title 列表的标题，这个标签是必须的</li>
<li><code>&lt;dd&gt;</code>：definition description 列表的列表项，如果不需要它，可以不加</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>1.<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>好好吃饭<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>好好睡觉<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>2.<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>好好学习<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="表格标签">表格标签</h3>
<p>表格标签用<code>&lt;table&gt;</code>表示。<br>
一个表格<code>&lt;table&gt;</code>是由每行<code>&lt;tr&gt;</code>组成的，每行是由每个单元格<code>&lt;td&gt;</code>组成的。</p>
<h4 id="单元格的合并">单元格的合并</h4>
<p>单元格的属性</p>
<ul>
<li><code>colspan</code>：横向合并。例如<code>colspan=&quot;2&quot;</code>表示当前单元格在水平方向上要占据两个单元格的位置。</li>
<li><code>rowspan</code>：纵向合并。例如<code>rowspan=&quot;2&quot;</code>表示当前单元格在垂直方向上要占据两个单元格的位置。</li>
</ul>
<h4 id="表格的-thead-标签、-tbody-标签、-tfoot-标签">表格的<code>&lt;thead&gt;</code>标签、<code>&lt;tbody&gt;</code>标签、<code>&lt;tfoot&gt;</code>标签</h4>
<ul>
<li>1、如果写了，那么这三个部分的<strong>代码顺序可以任意</strong>，浏览器显示的时候还是按照thead、tbody、tfoot的顺序依次来显示内容。如果不写thead、tbody、tfoot，那么浏览器解析并显示表格内容的时候是从按照代码的从上到下的顺序来显示。</li>
<li>2、当表格非常大内容非常多的时候，如果用thead、tbody、tfoot标签的话，那么<strong>数据可以边获取边显示</strong>。如果不写，则必须等表格的内容全部从服务器获取完成才能显示出来。</li>
</ul>
<h3 id="内嵌框架">内嵌框架</h3>
<p>内嵌框架用<code>&lt;iframe&gt;</code>表示。<code>&lt;iframe&gt;</code>是<code>&lt;body&gt;</code>的子标记。</p>
<p><strong>属性：</strong></p>
<ul>
<li><code>src=&quot;subframe/the_second.html&quot;</code>：内嵌的那个页面</li>
<li><code>width=800</code>：宽度</li>
<li><code>height=“150</code>：高度</li>
<li><code>scrolling=&quot;no&quot;</code>：是否需要滚动条。默认值是true。</li>
<li><code>name=&quot;mainFrame&quot;</code>：窗口名称。公有属性。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.ethanloo.cn&quot;</span> <span class="attr">target</span>=<span class="string">&quot;myframe&quot;</span>&gt;</span>主页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://blog.ethanloo.cn&quot;</span> <span class="attr">target</span>=<span class="string">&quot;myframe&quot;</span>&gt;</span>博客<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span></span></span><br><span class="line"><span class="tag">    <span class="attr">src</span>=<span class="string">&quot;www.ethanloo.cn&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">width</span>=<span class="string">&quot;500&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">height</span>=<span class="string">&quot;400&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;myframe&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  ethanloo&#x27;s</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<img src="https://cdn.ethanloo.cn/img/20201222231800.png" alt="image-20201222231759603" style="zoom:50%;" />
<h3 id="表单标签">表单标签</h3>
<p><code>&lt;form&gt;</code> <strong>属性</strong></p>
<ul>
<li><code>name</code>：表单的名称，用于JS来操作或控制表单时使用；</li>
<li><code>id</code>：表单的名称，用于JS来操作或控制表单时使用；</li>
<li><code>action</code>：指定表单数据的处理程序，一般是PHP，如：<code>action=“login.php”</code></li>
<li><code>method</code>：表单数据的提交方式，一般取值：get(默认)和post</li>
</ul>
<h4 id="input-输入标签"><code>&lt;input&gt;</code> 输入标签</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>type</code>属性</p>
<ul>
<li><code>text</code>（默认）</li>
<li><code>password</code>：密码类型</li>
<li><code>radio</code>：单选按钮，名字相同的按钮作为一组进行单选（单选按钮，天生是不能互斥的，如果想互斥，必须要有相同的name属性。name就是“名字”。</li>
<li><code>checkbox</code>：多选按钮，<strong>name 属性值相同的按钮</strong>作为一组进行选择。</li>
<li><code>checked</code>：将单选按钮或多选按钮默认处于选中状态。当<code>&lt;input&gt;</code>标签设置为<code>type=&quot;radio&quot;</code>或者<code>type=checkbox</code>时，可以用这个属性。属性值也是checked，可以省略。</li>
<li><code>hidden</code>：隐藏框，在表单中包含不希望用户看见的信息</li>
<li><code>button</code>：普通按钮，结合js代码进行使用。</li>
<li><code>submit</code>：提交按钮，传送当前表单的数据给服务器或其他程序处理。这个按钮不需要写value自动就会有“提交”文字。这个按钮真的有提交功能。点击按钮后，这个表单就会被提交到form标签的action属性中指定的那个页面中去。</li>
<li><code>reset</code>：重置按钮，清空当前表单的内容，并设置为最初的默认值</li>
<li><code>image</code>：图片按钮，和提交按钮的功能完全一致，只不过图片按钮可以显示图片。</li>
<li><code>file</code>：文件选择框。</li>
</ul>
</li>
<li>
<p><strong><code>value=&quot;内容&quot;</code></strong>：文本框里的默认内容（已经被填好了的）</p>
</li>
<li>
<p><code>size=&quot;50&quot;</code>：表示文本框内可以显示<strong>五十个字符</strong>。一个英文或一个中文都算一个字符。<br>
注意<strong>size属性值的单位不是像素哦</strong>。</p>
</li>
<li>
<p><code>readonly</code>：文本框只读，不能编辑。因为它的属性值也是readonly，所以属性值可以不写。<br>
用了这个属性之后，在google浏览器中，光标点不进去；在IE浏览器中，光标可以点进去，但是文字不能编辑。</p>
</li>
<li>
<p><code>disabled</code>：文本框只读，不能编辑，光标点不进去。属性值可以不写。</p>
</li>
</ul>
<h4 id="select-下拉列表标签"><code>&lt;select&gt;</code> 下拉列表标签</h4>
<p><code>&lt;select&gt;</code>标签里面的每一项用<code>&lt;option&gt;</code>表示。</p>
<p><strong><code>&lt;select&gt;</code>标签的属性</strong></p>
<ul>
<li><code>multiple</code>：可以对下拉列表中的选项进行多选。属性值为 multiple，也可以没有属性值。也就是说，既可以写成 <code>multiple=&quot;&quot;</code>，也可以写成<code>multiple=&quot;multiple&quot;</code>。</li>
<li><code>size=&quot;3&quot;</code>：如果属性值大于1，则列表为滚动视图。默认属性值为1，即下拉视图。</li>
</ul>
<p><strong><code>&lt;option&gt;</code>标签的属性</strong></p>
<ul>
<li><code>selected</code>：预选中。没有属性值。</li>
</ul>
<h4 id="textarea-多行文本输入框"><code>&lt;textarea&gt;</code> 多行文本输入框</h4>
<p><strong>属性</strong></p>
<ul>
<li><code>rows=&quot;4&quot;</code>：指定文本区域的行数。</li>
<li><code>cols=&quot;20&quot;</code>：指定文本区域的列数。</li>
<li><code>readonly</code>：只读。</li>
</ul>
<h4 id="label-标签"><code>&lt;label&gt;</code> 标签</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> /&gt;</span> 男</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> /&gt;</span> 女</span><br></pre></td></tr></table></figure>
<p>如果写成这样，那在点击 “男”这个字的时候，并不能选中选项。</p>
<p>解决方法是利用 label 的 for 属性，把 label 和 input 绑定起来。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;nan&quot;</span> /&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;nan&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;nv&quot;</span>  /&gt;</span> <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;nv&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="多媒体标签">多媒体标签</h3>
<ul>
<li>
<p><code>&lt;bgsound&gt;</code>标签：播放背景音乐</p>
</li>
<li>
<p><code>&lt;embed&gt;</code>标签：播放多媒体文件（音频、视频等）</p>
</li>
<li>
<p><code>&lt;object&gt;</code>标签：播放多媒体文件（音频、视频等）</p>
</li>
<li>
<p><code>&lt;marquee&gt;</code>：滚动字幕标签</p>
</li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始的前端工程师生活</title>
    <url>/post/2020-12-21-Weber/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%94%9F%E6%B4%BB/</url>
    <content><![CDATA[<h1>前言 📕</h1>
<p>思来想去，最终还是毅然决然地走上前端这条路了，来这里简单分享一下自己的心路历程吧。</p>
<p>钱确实是我个人努力的动力，但并不能决定我努力的方向（本质上不管什么方向，只要足够努力，钱都不是问题）。</p>
<p>名也好，钱也好，我始终认为这些东西跟自己选择的方向是无关的，一个人只要足够有天赋并且足够努力，那么无论是前端开发，后端开发，甚至搞算法和学术，都能闯出自己的天下。</p>
<p>所以抛开功利主义不谈，在我看来，兴趣永远是自己坚持学下去的动力之一。</p>
<p>所以在选择道路之前，我需要的是看清自己，认识自己，了解自己的本质，找到自己的兴趣所在。</p>
<p>那问题就来了，我是怎么样的一个人呢？</p>
<p>一个看重外表，头脑简单，喜欢折腾，有些强迫症，甚至还闲得没事搞搞博客，对学术不感兴趣，只对有用的东西感兴趣的人。</p>
<p>即使现在有着不错的绩点，但与之相比，在实验室基于Laravel开发的csteaching平台以及自己搭建的博客对我来说更有成就感。</p>
<p>没错，<strong>实际</strong>这个词可能比较适合我。</p>
<p>那看到这里，或许你就明白我为什么会走前端这条路了。</p>
<p>我追求更加实际的东西，也就是能看到的东西，那么 <strong>Web</strong> ，或者说<strong>网站</strong>，对我来说再适合不过了。</p>
<p>没有一大段一大段的公式（就我目前的认知来讲），不用去学习一些可能根本转换不成生产力的技术。</p>
<p>而是把自己的所有的技术和知识通过一种可视化的方式展现出来，所学即所见，所见即所学。</p>
<h1>学习路线 🚗</h1>
<p>废话不多说了，直接开始学习吧，今天是 2020.12.21 ，一不小心挑了个这么好看的日期。</p>
<blockquote>
<p>虽然是期末复习时间阶段，但还是那句老话，<strong>海绵里的水嘛</strong>。</p>
</blockquote>
<p>虽然自己曾经有网站开发的相关经验，但是还是决定从0开始学起，毕竟当时做项目学习的基础知识还是太少了。</p>
<blockquote>
<p>感谢 <a href="https://github.com/qianguyihao/Web">https://github.com/qianguyihao/Web</a> 👍</p>
</blockquote>
<p><img src="https://cdn.ethanloo.cn/img/20201221145551.png" alt="Web"></p>
<h1>后续写作 ✍</h1>
<p>可能太基础的东西就不写了，博客里会记录一些学习路线中遇到的比较重要的知识点。</p>
<p>可能会面向就业一点，根据面试题来梳理一些知识点。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Astar算法求解迷宫最短路 | Python实现</title>
    <url>/post/2020-12-15-Algorithm/Astar%E6%B1%82%E8%A7%A3%E8%BF%B7%E5%AE%AB%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="实验内容">实验内容</h2>
<p>给定一个二维数组模拟迷宫，0表示允许通过，1表示有障碍无法通过。</p>
<p>给定一个起点<code>(x0, y0)</code>和终点<code>(x1, y1)</code>，设计两种不同估价函数的A*算法，找到从起点走到终点的路径。</p>
<h3 id="输入">输入</h3>
<p><code>Problem2.txt</code></p>
<ul>
<li>第一行给入口坐标<code>x0, y0</code></li>
<li>第二行给出口坐标<code>x1, y1</code></li>
<li>下面<code>n</code>行给一个<code>n*m</code>的0-1矩阵，表示迷宫</li>
</ul>
<blockquote>
<p>1,1</p>
<p>5,5</p>
<p>0 0 0 0 0</p>
<p>1 0 1 0 1</p>
<p>0 0 1 1 1</p>
<p>0 1 0 0 0</p>
<p>0 0 0 1 0</p>
</blockquote>
<h3 id="输出">输出</h3>
<p><code>Astar.txt</code></p>
<ul>
<li>共需要多少步</li>
<li>路径坐标序列</li>
</ul>
<blockquote>
<p>共需13步</p>
<p>(1,1)-(1,2)-(2,2)-(3,2)-(3,1)-(4,1)-(5,1)-(5,2)-(5,3)-(4,3)-(4,4)-(4,5)-(5,5)</p>
</blockquote>
<h2 id="Astar算法">Astar算法</h2>
<h3 id="原理简介">原理简介</h3>
<p>A*算法是一种求解最短路径的直接搜索方法，是许多其他问题的常用启发式算法。</p>
<p>算法的核心公式$f(n) = g(n) + h(n)$</p>
<ul>
<li>f(n)是从初始状态经由状态n到目标状态的代价估计，简写为F</li>
<li>g(n)是在状态空间中从初始状态到状态n的实际代价，简写为G</li>
<li>h(n)是从状态n到目标状态的最佳路径的估计代价，简写为H</li>
</ul>
<p>通过计算这三个值，我们可以找到更具有更高尝试价值的路径。</p>
<p>会有两个数组来存储一些结点</p>
<ul>
<li><code>open list</code>：待检查的结点列表，路径可能经过，也可能不经过</li>
<li><code>close list</code>：已经检查完毕的结点列表</li>
</ul>
<h3 id="搜索过程">搜索过程</h3>
<ol>
<li>把起点加入<code>open list</code></li>
<li>循环
<ul>
<li>遍历<code>open list</code>，查找F值最小的结点，把它作为当前要处理的结点</li>
<li>把这个结点移到<code>close list</code></li>
<li>遍历当前这个结点四周的八个结点
<ul>
<li>如果结点不可达或者它已经在<code>close list</code>中，就忽略</li>
<li>如果它不在<code>open list</code>中，就加入<code>open list</code>中，并且把当前的结点设置成它的父节点，记录该结点的F, G, H值</li>
<li>如果它已经在<code>open list</code>中，检查这条路径是否更好，以G值作为参考。G值越小表示路径越好。如果更好，就把它的父结点设置成当前的方格，并且重新计算G和F值。</li>
</ul>
</li>
<li>退出循环的情况
<ul>
<li>终点已经在<code>open list</code>中，说明已经找到了路径</li>
<li><code>open list</code>为空，表示已经没有路可以走了</li>
</ul>
</li>
</ul>
</li>
<li>保存路径</li>
</ol>
<h2 id="数据结构">数据结构</h2>
<p>为了方便记录每个点的父节点以及计算F, G, H值，需要自己定义一个结点类</p>
<p><code>class Node:</code></p>
<ol>
<li>
<p>定义结点类的构造方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">    self.pre = <span class="literal">None</span></span><br><span class="line">    self.x = x</span><br><span class="line">    self.y = y</span><br><span class="line">    self.update()</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>更新启发函数的值</p>
<ul>
<li>
<p>首先计算H的值，有两种方式</p>
<ol>
<li>
<p>当前结点到目标结点的曼哈顿距离</p>
<p><code>abs(node.x - target[0])+abs(node.y - target[1])</code></p>
</li>
<li>
<p>当前结点到目标结点的欧式距离</p>
<p><code>(node.x - target[0])**2+(node.y - target[1])**2</code></p>
</li>
</ol>
</li>
<li>
<p>再计算G的值，即深度，这里指当前走的步数</p>
</li>
<li>
<p>最后计算启发函数的值，F = G + H</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新启发函数的值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self</span>):</span><br><span class="line">    self.update_H()</span><br><span class="line">    self.update_G()</span><br><span class="line">    self.update_F()</span><br><span class="line"></span><br><span class="line"><span class="comment"># H值是和目标状态的距离之和</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_H</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># 用曼哈顿距离表示和目标的距离之和</span></span><br><span class="line">    x, y = self.x, self.y</span><br><span class="line">    self.H = <span class="built_in">abs</span>(x - target[<span class="number">0</span>]) + <span class="built_in">abs</span>(y - target[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># G值表示深度，即当前走的步数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_G</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> self.pre:</span><br><span class="line">        self.G = self.pre.G + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.G = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># F是启发函数 F = G + H</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_F</span>(<span class="params">self</span>):</span><br><span class="line">    self.F = self.G + self.H</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>输出路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出路径</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_path</span>(<span class="params">self</span>):</span><br><span class="line">    nodes = []</span><br><span class="line">    node = self</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        nodes.append(node)</span><br><span class="line">        node = node.pre</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nodes[::-<span class="number">1</span>]:</span><br><span class="line">        res.append(<span class="string">&quot;(&quot;</span> + <span class="built_in">str</span>(i.x) + <span class="string">&quot;,&quot;</span> + <span class="built_in">str</span>(i.y) + <span class="string">&quot;)&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>返回下一步可能所在的位置坐标</p>
<ul>
<li>
<p><code>directions</code>是我们自己定义的一个数组，用来快速向四个方向扩散</p>
<p><code>directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]</code></p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找到下一步可能所在的位置</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_next_positions</span>(<span class="params">self</span>):</span><br><span class="line">    next_positions = []</span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> directions:</span><br><span class="line">        next_x = i + self.x</span><br><span class="line">        next_y = j + self.y</span><br><span class="line">        <span class="keyword">if</span> next_x &gt;= <span class="number">0</span> <span class="keyword">and</span> next_x &lt; <span class="built_in">len</span>(maze) <span class="keyword">and</span> next_y &gt;= <span class="number">0</span> <span class="keyword">and</span> next_y &lt; <span class="built_in">len</span>(maze[<span class="number">0</span>]):</span><br><span class="line">            <span class="keyword">if</span> maze[next_x][next_y] == <span class="number">0</span>:</span><br><span class="line">                next_positions.append([next_x, next_y])</span><br><span class="line">    <span class="keyword">return</span> next_positions</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="I-O相关">I/O相关</h2>
<ol>
<li>
<p>从文件中读取文本</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_file</span>(<span class="params">file_name</span>):</span><br><span class="line">    lines = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">    <span class="keyword">return</span> lines</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>根据读取的文本生成迷宫</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_maze</span>(<span class="params">lines</span>):</span><br><span class="line">    matrix = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines[<span class="number">2</span>:]:</span><br><span class="line">        line = line.strip()</span><br><span class="line">        tmp = [<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> line.split(<span class="string">&quot; &quot;</span>)]</span><br><span class="line">        matrix.append(tmp)</span><br><span class="line">    <span class="keyword">return</span> matrix</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>写文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">write_file</span>(<span class="params">file_name, lines</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            f.write(<span class="built_in">str</span>(line))</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="Astar搜索函数">Astar搜索函数</h2>
<p>根据算法描述转换成代码实现即可</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a_star</span>(<span class="params">x0, y0</span>):</span><br><span class="line">    open_list, close_list = [], []</span><br><span class="line">    <span class="comment"># 初始化起点结点</span></span><br><span class="line">    node = Node(x0, y0)</span><br><span class="line">    open_list.append(node)</span><br><span class="line">    <span class="keyword">while</span> open_list:</span><br><span class="line">        <span class="comment"># 按照启发函数的值升序进行排列</span></span><br><span class="line">        open_list.sort(key = <span class="keyword">lambda</span> x: x.F)</span><br><span class="line">        <span class="comment"># 找到F值最小的结点，尝试扩展</span></span><br><span class="line">        cur_node = open_list[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 确认是否是终点</span></span><br><span class="line">        <span class="keyword">if</span> cur_node.H == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;wow, we find the path!&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> cur_node.get_path()</span><br><span class="line">        <span class="comment"># 对当前这个F值最小的结点尝试搜索</span></span><br><span class="line">        open_list.pop(<span class="number">0</span>)</span><br><span class="line">        close_list.append(cur_node)</span><br><span class="line">        <span class="comment"># 获取下一步可能的位置</span></span><br><span class="line">        next_positions = cur_node.get_next_positions()</span><br><span class="line">        <span class="keyword">for</span> next_position <span class="keyword">in</span> next_positions:</span><br><span class="line">            x, y = next_position</span><br><span class="line">            <span class="comment"># 把下一个位置初始化为一个结点next_node</span></span><br><span class="line">            next_node = Node(x, y)</span><br><span class="line">            <span class="comment"># 把cur_node设置成next_node结点的父节点</span></span><br><span class="line">            next_node.pre = cur_node</span><br><span class="line">            <span class="comment"># 更新一下F G H值</span></span><br><span class="line">            cur_node.update()</span><br><span class="line">            <span class="comment"># 判断next_node在close_list和open_list中的情况</span></span><br><span class="line">            open_res = in_list(next_node, open_list)</span><br><span class="line">            close_res = in_list(next_node, close_list)</span><br><span class="line">            open_idx = open_res[<span class="number">1</span>]</span><br><span class="line">            <span class="comment"># 如果在close_list中说明已经检查完毕，跳过即可</span></span><br><span class="line">            <span class="keyword">if</span> close_res[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 如果在open_list中，需要判断是否更优</span></span><br><span class="line">            <span class="keyword">if</span> open_res[<span class="number">0</span>] <span class="keyword">and</span> next_node.F &lt; (open_list[open_idx]).F:</span><br><span class="line">                open_list[open_idx] = next_node</span><br><span class="line">            <span class="comment"># next_node不在open_list也不在close_list中</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> open_res[<span class="number">0</span>] <span class="keyword">and</span> <span class="keyword">not</span> close_res[<span class="number">0</span>]:</span><br><span class="line">                open_list.append(next_node)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>main函数</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    lines = read_file(<span class="string">&quot;Problem2.txt&quot;</span>)</span><br><span class="line">    maze = get_maze(lines)</span><br><span class="line">    start, end = lines[<span class="number">0</span>].rstrip(), lines[<span class="number">1</span>].rstrip()</span><br><span class="line">    start = start.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    end = end.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    x0, y0, x1, y1 = <span class="built_in">int</span>(start[<span class="number">0</span>])-<span class="number">1</span>, <span class="built_in">int</span>(start[<span class="number">1</span>])-<span class="number">1</span>, <span class="built_in">int</span>(end[<span class="number">0</span>])-<span class="number">1</span>, <span class="built_in">int</span>(end[<span class="number">1</span>])-<span class="number">1</span></span><br><span class="line">    target[<span class="number">0</span>], target[<span class="number">1</span>] = x1, y1</span><br><span class="line">    path = a_star(x0, y0)</span><br><span class="line">    lines = []</span><br><span class="line">    lines.append(<span class="string">&quot;共需&quot;</span> + <span class="built_in">str</span>(<span class="built_in">len</span>(path)) + <span class="string">&quot;步\n&quot;</span>)</span><br><span class="line">    lines.append(<span class="string">&quot;-&quot;</span>.join(path))</span><br><span class="line">    write_file(<span class="string">&quot;Astar.txt&quot;</span>, lines)</span><br></pre></td></tr></table></figure>
<h2 id="运行结果">运行结果</h2>
<p>为了明显对比出两个启发函数的区别，我自己构造了一个2640*10的迷宫（没使用并查集，只是随便复制的）</p>
<ul>
<li>起点1，1</li>
<li>终点2639，10，图中圈出来的那个</li>
</ul>
<p><img src="https://cdn.ethanloo.cn/img/20201215214934.png" alt="image-20201215214934390"></p>
<ol>
<li>
<p>以曼哈顿距离作为启发函数</p>
<p><img src="https://cdn.ethanloo.cn/img/20201215215802.png" alt="image-20201215215802594"></p>
<p><img src="https://cdn.ethanloo.cn/img/20201215215656.png" alt="image-20201215215656531"></p>
</li>
<li>
<p>以欧式距离的平方作为启发函数</p>
<p><img src="https://cdn.ethanloo.cn/img/20201215215846.png" alt="image-20201215215846116"></p>
<p><img src="https://cdn.ethanloo.cn/img/20201215215901.png" alt="image-20201215215901203"></p>
</li>
</ol>
<p>多次实验发现，在当前迷宫中，曼哈顿距离的启发函数花的时间远超欧氏距离的启发函数。</p>
<blockquote>
<p>当然，这并不能直接的出哪个函数更优秀的结论，由于我本身只自定义了一个迷宫</p>
</blockquote>
]]></content>
      <categories>
        <category>实验报告</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>八数码问题的深搜和广搜解法 | Python实现</title>
    <url>/post/2020-12-12-Algorithm/%E5%85%AB%E6%95%B0%E7%A0%81/</url>
    <content><![CDATA[<h2 id="八数码问题简介">八数码问题简介</h2>
<p>在3×3的棋盘上，摆有八个棋子，每个棋子上标有1至8的某一数字。棋盘中留有一个空格，空格用0来表示。空格周围的棋子可以移到空格中。</p>
<p>要求解的问题是：给出一种初始布局（初始状态）和目标布局（为了使题目简单,设目标状态为123804765），找到一种最少步骤的移动方法，实现从初始布局到目标布局的转变。</p>
<p><img src="https://cdn.ethanloo.cn/img/20180116201941897" alt="img"></p>
<h2 id="数据结构">数据结构</h2>
<p>为了记录每个每一步走的状态，我们需要自己定义一个棋盘类<code>Board</code>（类似结点）。</p>
<p>我们主要用到的属性有两个：前驱棋盘<code>self.pre</code>和步数<code>self.steps</code>。</p>
<p><code>class Board:</code></p>
<ol>
<li>
<p>首先需要定义棋盘的构造方法</p>
<ul>
<li>初始化它的前驱为空</li>
<li>初始化它的棋盘矩阵</li>
<li>同时更新它的步数（在一开始实例化的时候步数为0，因为前驱结点为空）</li>
</ul>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化棋盘状态，matrix为棋盘的矩阵</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, matrix</span>):</span><br><span class="line">    self.pre = <span class="literal">None</span></span><br><span class="line">    self.matrix = matrix</span><br><span class="line">    self.update_steps()</span><br><span class="line"><span class="comment"># 根据父结点的步数来计算当前结点走的步数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_steps</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> self.pre:</span><br><span class="line">        self.steps = self.pre.steps + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.steps = <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定义打印棋盘结点的方式</p>
<ul>
<li>一行行打印即可</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印棋盘</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">self</span>):</span><br><span class="line">    res = []</span><br><span class="line">    res.append(<span class="string">&quot;第&quot;</span> + <span class="built_in">str</span>(self.steps)+<span class="string">&quot;步：\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        res.append(<span class="string">&quot; &quot;</span>.join([<span class="built_in">str</span>(j) <span class="keyword">for</span> j <span class="keyword">in</span> self.matrix[i]]) + <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    res.append(<span class="string">&quot;-&quot;</span> * <span class="number">20</span>+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>从当前整个路径的根节点开始打印</p>
<ul>
<li>不断找前驱结点，把每个棋盘的打印放入列表中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印从根节点开始到当前节点的路径</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_path</span>(<span class="params">self</span>):</span><br><span class="line">    path = []</span><br><span class="line">    node = self</span><br><span class="line">    <span class="keyword">while</span> node:</span><br><span class="line">        path = node.show()+path</span><br><span class="line">        node = node.pre</span><br><span class="line">    path = [<span class="string">&quot;共需要&quot;</span>+<span class="built_in">str</span>(self.steps)+<span class="string">&quot;步\n&quot;</span>] + path</span><br><span class="line">    <span class="keyword">return</span> path</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定位0的方法</p>
<ul>
<li>返回0所在横坐标和纵坐标</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 找到0当前在棋盘中的位置</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_zero</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> self.matrix[i][j] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i, j</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取下一步可能的所有棋盘矩阵</p>
<ul>
<li>先找到0的位置</li>
<li>然后尝试把0和上下左右的棋子交换位置，如果合法，就把可能的矩阵添加到数组中</li>
<li>最后返回一个三维的数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># directions数组用来记录0可能的走的四个方向</span></span><br><span class="line">directions = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, -<span class="number">1</span>], [-<span class="number">1</span>, <span class="number">0</span>]]</span><br><span class="line"><span class="comment"># 下一步可能的棋盘</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">next_possible_boards</span>(<span class="params">self</span>):</span><br><span class="line">    res = []</span><br><span class="line">    i, j = self.find_zero()</span><br><span class="line">    <span class="keyword">for</span> direction <span class="keyword">in</span> self.directions:</span><br><span class="line">        x, y = direction</span><br><span class="line">        <span class="keyword">if</span> i + x &gt;= <span class="number">0</span> <span class="keyword">and</span> i + x &lt;= <span class="number">2</span> <span class="keyword">and</span> j + y &gt;= <span class="number">0</span> <span class="keyword">and</span> j + y &lt;= <span class="number">2</span>:</span><br><span class="line">            next_board = copy.deepcopy(self.matrix)</span><br><span class="line">            next_board[i][j], next_board[i + x][j +y] = next_board[i + x][j + y], next_board[i][j]</span><br><span class="line">            res.append(next_board)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将棋盘序列化，即把棋盘的矩阵转成字符串</p>
<ul>
<li>这是为了在遍历的时候更加方便地实现去重</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将当前棋盘序列化，二维数组=&gt;字符串</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">serialize</span>(<span class="params">self</span>):</span><br><span class="line">    tmp = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> self.matrix:</span><br><span class="line">        tmp += <span class="string">&quot;&quot;</span>.join([<span class="built_in">str</span>(j) <span class="keyword">for</span> j <span class="keyword">in</span> i])</span><br><span class="line">        <span class="keyword">return</span> tmp</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>判断是否到达目标状态</p>
<ul>
<li>直接将当前棋盘序列化后和<code>123804765</code>对比</li>
</ul>
</li>
</ol>
<h2 id="文件I-O">文件I/O</h2>
<ol>
<li>
<p>读取文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_file</span>(<span class="params">file_name</span>):</span><br><span class="line">    lines = []</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">    <span class="keyword">return</span> lines</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将从文件中读取的内容转换成矩阵</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_matrix</span>(<span class="params">lines</span>):</span><br><span class="line">    matrix = []</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        line = line.strip()</span><br><span class="line">        tmp = [<span class="built_in">int</span>(i) <span class="keyword">for</span> i <span class="keyword">in</span> line.split(<span class="string">&quot; &quot;</span>)]</span><br><span class="line">        matrix.append(tmp)</span><br><span class="line">    <span class="keyword">return</span> matrix</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>写文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">write_file</span>(<span class="params">file_name, lines</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            f.write(<span class="built_in">str</span>(line))</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="BFS">BFS</h2>
<ul>
<li>整体流程</li>
</ul>
<p><img src="https://chengfeng96.com/blog/2018/05/26/%E5%88%A9%E7%94%A8BFS%EF%BC%8CDFS%EF%BC%8CA-%E8%A7%A3%E5%86%B3%E5%85%AB%E6%95%B0%E7%A0%81%E9%9A%BE%E9%A2%98/1.png" alt="undefined"></p>
<p><code>BFS_8puzzle.py</code></p>
<ul>
<li>算法实现
<ul>
<li>用一个数组去模拟队列，每一次遍历一层</li>
<li>遍历的时候，获取每个可能的棋盘的下一步棋盘，添加到下一次遍历的队列里</li>
<li>为了避免重复遍历，我们定义了一个<code>visited</code>集合，里面存储了已经遍历过的可能性的棋盘序列</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">b</span>):</span><br><span class="line">    <span class="comment"># visited数组用来取消一些</span></span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    queue = []</span><br><span class="line">    queue.append(b)</span><br><span class="line">    level = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        show_cur_level(queue, level)</span><br><span class="line">        <span class="comment"># 每次遍历一层</span></span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> board <span class="keyword">in</span> queue:</span><br><span class="line">            <span class="keyword">if</span> board.finished():</span><br><span class="line">                path = board.show_path()</span><br><span class="line">                write_file(<span class="string">&quot;bfs_output.txt&quot;</span>, path)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            next_boards = board.next_possible_boards()</span><br><span class="line">            <span class="keyword">for</span> matrix <span class="keyword">in</span> next_boards:</span><br><span class="line">                next_board = Board(matrix)</span><br><span class="line">                <span class="keyword">if</span> next_board.serialize() <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    visited.add(next_board.serialize())</span><br><span class="line">                    next_board.pre = board</span><br><span class="line">                    next_board.update_steps()</span><br><span class="line">                    tmp.append(next_board)</span><br><span class="line">        queue = tmp</span><br><span class="line">        level += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<img src="https://cdn.ethanloo.cn/img/image-20201212151853950.png" alt="image-20201212151853950" style="zoom:50%;" />
<p>我也定义了一个函数，较清晰地展示每一层的情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">show_cur_level</span>(<span class="params">queue, level</span>):</span><br><span class="line">    <span class="comment"># 打印某个层级的所有棋盘</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;level:&quot;</span> + <span class="built_in">str</span>(level))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(queue), <span class="number">10</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">min</span>(i+<span class="number">10</span>, <span class="built_in">len</span>(queue))):</span><br><span class="line">            <span class="built_in">print</span>(queue[j].matrix[<span class="number">0</span>], end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">min</span>(i+<span class="number">10</span>, <span class="built_in">len</span>(queue))):</span><br><span class="line">            <span class="built_in">print</span>(queue[j].matrix[<span class="number">1</span>], end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">min</span>(i+<span class="number">10</span>, <span class="built_in">len</span>(queue))):</span><br><span class="line">            <span class="built_in">print</span>(queue[j].matrix[<span class="number">2</span>], end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br></pre></td></tr></table></figure>
<img src="https://cdn.ethanloo.cn/img/image-20201212152829761.png" alt="image-20201212152829761" style="zoom: 50%;" />
<h2 id="DFS">DFS</h2>
<ul>
<li>整体流程</li>
</ul>
<p><img src="https://chengfeng96.com/blog/2018/05/26/%E5%88%A9%E7%94%A8BFS%EF%BC%8CDFS%EF%BC%8CA-%E8%A7%A3%E5%86%B3%E5%85%AB%E6%95%B0%E7%A0%81%E9%9A%BE%E9%A2%98/2.png" alt="undefined"></p>
<ul>
<li>算法实现
<ul>
<li>用一个递归函数来实现每次向下遍历</li>
<li>设定最大递归深度为10</li>
<li>同样的，利用<code>visited</code>集合来避免一条路上走回头路</li>
<li>向下遍历完之后运用回溯法的思想，消除回头路的证据</li>
</ul>
</li>
</ul>
<img src="https://cdn.ethanloo.cn/img/image-20201212151728247.png" alt="image-20201212151728247" style="zoom:50%;" />]]></content>
      <categories>
        <category>实验报告</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Java实现内存分配模拟</title>
    <url>/post/2020-12-11-Algorithm/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h1>内存分配实验</h1>
<h2 id="数据结构">数据结构</h2>
<p>本次实验一共定义了三个类</p>
<ol>
<li><code>MemoryAllocation</code> — 主类，负责初始化，分配内存的工作，主类中存放了三个链表
<ul>
<li>全部的内存空间链表</li>
<li>处于等待中的作业链表</li>
</ul>
</li>
<li><code>MemorySeg</code> — 内存块类，有4个属性
<ul>
<li>起始位置</li>
<li>块长度</li>
<li>状态，0代表空闲，1代表占用</li>
<li>分区编号</li>
</ul>
</li>
<li><code>Job</code> — 作业类，有2个属性
<ul>
<li>需要申请的内存</li>
<li>状态，0代表等待中，1代表运行中，2代表结束</li>
</ul>
</li>
</ol>
<h2 id="内存分配流程">内存分配流程</h2>
<ol>
<li>
<p>首先需要根据内存分区初始化所有内存块</p>
<blockquote>
<p>一开始的时候就是有多少分区，就有多少块</p>
<p>之后随着任务分配，块数会增加，分区数不会变</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initMemory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化内存空间</span></span><br><span class="line">    System.out.println(<span class="string">&quot;初始化内存空间...&quot;</span>);</span><br><span class="line">    memory = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 我们假设内存被拆分成 300KB, 600KB, 350KB, 200KB, 750KB和125KB这六段</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] sizes = &#123; <span class="number">300</span>, <span class="number">600</span>, <span class="number">350</span>, <span class="number">200</span>, <span class="number">750</span>, <span class="number">125</span> &#125;;</span><br><span class="line">    MemorySeg ms;</span><br><span class="line">    <span class="type">int</span> <span class="variable">no</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> size : sizes) &#123;</span><br><span class="line">        ms = <span class="keyword">new</span> <span class="title class_">MemorySeg</span>(no++, start, size, <span class="number">0</span>);</span><br><span class="line">        memory.add(ms);</span><br><span class="line">        start += size;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;内存空间初始化完成!&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------------------&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>初始化作业链表（写的比较无脑）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initJobs</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化所有作业</span></span><br><span class="line">    waitingJobs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 假设有5个作业</span></span><br><span class="line">    <span class="type">Job</span> <span class="variable">job1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Job</span>(<span class="number">115</span>);</span><br><span class="line">    <span class="type">Job</span> <span class="variable">job2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Job</span>(<span class="number">500</span>);</span><br><span class="line">    <span class="type">Job</span> <span class="variable">job3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Job</span>(<span class="number">358</span>);</span><br><span class="line">    <span class="type">Job</span> <span class="variable">job4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Job</span>(<span class="number">200</span>);</span><br><span class="line">    <span class="type">Job</span> <span class="variable">job5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Job</span>(<span class="number">375</span>);</span><br><span class="line">    waitingJobs.add(job1);</span><br><span class="line">    waitingJobs.add(job2);</span><br><span class="line">    waitingJobs.add(job3);</span><br><span class="line">    waitingJobs.add(job4);</span><br><span class="line">    waitingJobs.add(job5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定义给一个任务分配内存的方法</p>
<ul>
<li>首次适应算法
<ul>
<li>遍历内存块，找到空闲且满足作业需求的第一个内存块，直接分配即可</li>
<li>分配之后有两种情况
<ul>
<li>当前内存块仍有空余内存，则我们需要把这个空闲的块分割出来</li>
<li>当前内存块正好被分配完，则不需要进行分割</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">allocate</span><span class="params">(Job job)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 用来记录当前作业是否得到了内存</span></span><br><span class="line">    <span class="comment">// 假设现在采用的是首次适应算法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; memory.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历所有内存空间</span></span><br><span class="line">        <span class="type">MemorySeg</span> <span class="variable">mSeg</span> <span class="operator">=</span> memory.get(i);</span><br><span class="line">        <span class="comment">// 找到空闲且分区大小足够的内存块</span></span><br><span class="line">        <span class="keyword">if</span> (mSeg.status == <span class="number">0</span> &amp;&amp; mSeg.length &gt;= job.memo) &#123;</span><br><span class="line">            memory.remove(i);</span><br><span class="line">            <span class="comment">// 新建一段被占用的内存空间</span></span><br><span class="line">            <span class="type">MemorySeg</span> <span class="variable">occupied</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MemorySeg</span>(mSeg.no, mSeg.start, job.memo, <span class="number">1</span>);</span><br><span class="line">            memory.add(i, occupied);</span><br><span class="line">            <span class="comment">// 计算占用内存后的空闲分区</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> mSeg.length - job.memo;</span><br><span class="line">            <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果剩余空闲分区内存大于0</span></span><br><span class="line">                <span class="type">MemorySeg</span> <span class="variable">notOccupied</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MemorySeg</span>(mSeg.no, mSeg.start + job.memo, left, <span class="number">0</span>);</span><br><span class="line">                memory.add(i + <span class="number">1</span>, notOccupied);</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 说明p没有申请到内存，需要加入等待队列</span></span><br><span class="line">        waitingJobs.add(job);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最优适应算法
<ul>
<li>遍历内存块，找到空闲，能满足作业内存需要且尽可能小的内存块</li>
<li>分割过程同最先适应算法</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title function_">allocate</span><span class="params">(Job job)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 用来记录当前作业是否得到了内存</span></span><br><span class="line">    <span class="comment">// 假设现在采用的是最优适应算法</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">best</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; memory.size(); i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历所有内存空间</span></span><br><span class="line">        <span class="type">MemorySeg</span> <span class="variable">mSeg</span> <span class="operator">=</span> memory.get(i);</span><br><span class="line">        <span class="comment">// 找到空闲且分区大小足够且尽量小的内存块</span></span><br><span class="line">        <span class="keyword">if</span> (mSeg.status == <span class="number">0</span> &amp;&amp; mSeg.length &gt;= job.memo) &#123;</span><br><span class="line">            <span class="keyword">if</span> (best == -<span class="number">1</span>) &#123;</span><br><span class="line">                best = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSeg.length - job.memo &lt; memory.get(best).length - job.memo) &#123;</span><br><span class="line">                best = i;</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">MemorySeg</span> <span class="variable">bestSeg</span> <span class="operator">=</span> memory.get(best);</span><br><span class="line">        memory.remove(best);</span><br><span class="line">        <span class="comment">// 新建一段被占用的内存空间</span></span><br><span class="line">        <span class="type">MemorySeg</span> <span class="variable">occupied</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MemorySeg</span>(bestSeg.no, bestSeg.start, job.memo, <span class="number">1</span>);</span><br><span class="line">        memory.add(best, occupied);</span><br><span class="line">        <span class="comment">// 计算占用内存后的空闲分区</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> bestSeg.length - job.memo;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果剩余空闲分区内存大于0</span></span><br><span class="line">            <span class="type">MemorySeg</span> <span class="variable">notOccupied</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MemorySeg</span>(bestSeg.no, bestSeg.start + job.memo, left, <span class="number">0</span>);</span><br><span class="line">            memory.add(best + <span class="number">1</span>, notOccupied);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>给所有等待中的作业分配内存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">malloc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 为所有等待中的作业分配内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; allJobs.size(); i++) &#123;</span><br><span class="line">        <span class="type">Job</span> <span class="variable">job</span> <span class="operator">=</span> allJobs.get(i);</span><br><span class="line">        <span class="keyword">if</span> (job.status &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">Boolean</span> <span class="variable">res</span> <span class="operator">=</span> allocate(job);</span><br><span class="line">        <span class="keyword">if</span> (res) &#123;</span><br><span class="line">            job.status = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="分区回收流程">分区回收流程</h2>
<p>当一个作业结束之后要考虑对分区的回收操作</p>
<p>首先要明确的是每次的回收是针对某个分区而言，即只有同一个分区中的空闲块可以合并，不同分区的空闲块是不能合并的</p>
<p>回收流程</p>
<ul>
<li>
<p>首先取出对应这块内存，将状态设置为0，标明它现在是空闲状态</p>
</li>
<li>
<p>记录下这块回收的内存的分区号<code>freeNo</code></p>
</li>
<li>
<p>遍历所有内存块，每当找到两块连续的属于<code>freeNo</code>分区的块时，就需要尝试合并</p>
<ul>
<li>如果两块都是空闲状态，就把它们合并成一块</li>
</ul>
</li>
<li>
<p>遍历到结束即可实现对空闲分区的回收</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">free</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// 清空某一块内存并进行合并</span></span><br><span class="line">    System.out.println(<span class="string">&quot;正在尝试回收第&quot;</span>+index+<span class="string">&quot;块内存...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= memory.size()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;需要释放的内存块超过范围&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">MemorySeg</span> <span class="variable">ms</span> <span class="operator">=</span> memory.get(index);</span><br><span class="line">    <span class="keyword">if</span> (ms.status == <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;内存为空，无需释放&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ms.status = <span class="number">0</span>; <span class="comment">// 将内存块状态设为0，模拟已经清空了内存</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">no</span> <span class="operator">=</span> ms.no;</span><br><span class="line">    <span class="comment">// 接下去进行合并</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; memory.size() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">MemorySeg</span> <span class="variable">ms1</span> <span class="operator">=</span> memory.get(i);</span><br><span class="line">        <span class="type">MemorySeg</span> <span class="variable">ms2</span> <span class="operator">=</span> memory.get(i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (ms1.no != no || ms2.no != no || ms1.status == <span class="number">1</span> || ms2.status == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 确保合并的两个内存块都和刚刚释放的内存块都处于一个分区内</span></span><br><span class="line">            <span class="comment">// 同时要确保两个内存块都是空闲的</span></span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">MemorySeg</span> <span class="variable">msNew</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MemorySeg</span>(no, ms1.start, ms1.length + ms2.length, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 删除原来的两个内存块，替换为一个新的更大的内存块</span></span><br><span class="line">        memory.remove(i);</span><br><span class="line">        memory.remove(i);</span><br><span class="line">        memory.add(i, msNew);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;内存回收完毕&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;-----------------------------------&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="实验输入数据">实验输入数据</h2>
<p>给定6个内存分区：300KB, 600KB, 350KB, 200KB, 750KB, 125KB</p>
<p>给定5个作业：115KB, 500KB, 358KB, 200KB, 375KB</p>
<h2 id="运行结果展示">运行结果展示</h2>
<h3 id="分配内存">分配内存</h3>
<ul>
<li>首次适应算法</li>
</ul>
<img src="https://cdn.ethanloo.cn/img/image-20201211114347872.png" alt="image-20201211114347872" style="zoom:67%;" />
<ul>
<li>
<p>最佳适应算法</p>
<img src="https://cdn.ethanloo.cn/img/image-20201211114303462.png" alt="image-20201211114303462" style="zoom:67%;" />
</li>
</ul>
<h3 id="回收内存">回收内存</h3>
<ul>
<li>假设之前是用首次分配算法分配的内存空间，此时有11块内存，6个分区
<ul>
<li>可以看到我尝试回收第1块内存的时候，由于第一块本身就是空闲的，所以提示无需回收。</li>
<li>当我尝试回收第2块内存时，将第2块状态设为0之后，我发现第2块和第3块都属于第1个分区，所以合并两个内存块，重新变成一块连续的600KB大小的内存。</li>
</ul>
</li>
</ul>
<img src="https://cdn.ethanloo.cn/img/image-20201211192918333.png" alt="image-20201211192918333" style="zoom:67%;" />
<h2 id="总结与感想">总结与感想</h2>
<p>很有意思的一次实验。算法本身很好理解，首次适应和最佳适应都是字面意思。写代码的时候更多的是对数据结构的设计和对算法更深入的思考。“如何实现我脑子里的过程”，要解决这个问题着实不简单。</p>
<p>参考了网上的教程和实验报告的要求之后，初步设计成了这个样子，也算是简单实现了实验要求。但是设计本身实际上还有很多不足，比如，我没有尝试去实现命令窗口或者GUI的交互操作，而是直接把我的模拟操作写在了main函数里。另一方面，在内存回收的时候，更加真实的实现方式应该是通过某个任务的完成导致的释放它本身占用的内存，但是我只实现了指定内存块号进行释放并回收。整体实验的重心还是偏重于实现算法，对<strong>模拟</strong>的实现程度较低。</p>
]]></content>
      <categories>
        <category>实验报告</category>
      </categories>
      <tags>
        <tag>内存分配</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>算法小抄 | 第1章</title>
    <url>/post/2020-12-06-Algorithm/%E7%AC%AC1%E7%AB%A0%20%E6%A0%B8%E5%BF%83%E5%A5%97%E8%B7%AF/</url>
    <content><![CDATA[<p>其实在今年五六月份就发现了这个Github上很火的一个项目，但当时出于懒惰并没有仔细钻研</p>
<p><a href="https://github.com/labuladong/fucking-algorithm">labuladong/fucking-algorithm</a></p>
<p>一直到上个月（2020.11），因为要准备CSP，所以才开始看这个<strong>算法指南</strong></p>
<p>猛然发现，这个指南讲解的真的很人性化。就仿佛以一种向傻子（指我自己）阐述的口吻，来解释算法题和解题套路。</p>
<p>于是乎，这本《labuladong的算法小抄》刚出版两天，我便直接下单了。</p>
<blockquote>
<p>作者labuladong仿佛是应届毕业生，就是比我大一届，秋招拿了十二个offer。orz🤕</p>
</blockquote>
<p>在此做一些学习笔记，以此督促自己认真学习并加深理解。</p>
<p>由于本人比较熟悉python，所以笔记中的框架及具体代码都是基于python的。</p>
<h1>动态规划套路</h1>
<ul>
<li>
<p>动态规划的三个关键</p>
<ol>
<li>
<p>base case</p>
</li>
<li>
<p>DP table的定义</p>
</li>
<li>
<p>状态转移方程</p>
</li>
</ol>
</li>
</ul>
<p>看清了这三个之后，解决问题就如鱼得水了，直接结合例题来寻找感觉。</p>
<p><strong>例题</strong></p>
<p>假设现在要找的零钱为 amount = 11，硬币面值为coins = [1, 2, 5]，尝试找到所需硬币最少的方法</p>
<h2 id="N叉树解法">N叉树解法</h2>
<p>把大问题分解成小问题</p>
<p>想要知道找11块钱最少需要多少个硬币，我只要知道</p>
<ul>
<li>找10块钱需要的最少硬币数</li>
<li>找9块钱需要的最少硬币数</li>
<li>找6块钱需要的最少硬币数</li>
</ul>
<p>即可得出最后答案，那么我们按照这个思路来写递归</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_coins</span>(<span class="params">amount, coins</span>):</span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">if</span> amount == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> amount &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    res = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">        <span class="comment"># 找到子问题的所需硬币数</span></span><br><span class="line">        tmp = count_coins(amount - coin, coins)</span><br><span class="line">        <span class="keyword">if</span> tmp &gt;= <span class="number">0</span>:</span><br><span class="line">            res = <span class="built_in">min</span>(res, tmp)</span><br><span class="line">    <span class="keyword">return</span> res + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这样子去解决递归问题，会进行大量的重复计算（想象成一个N叉树）</p>
<ul>
<li>比如我想知道找11块最少需要多少硬币，自然会想知道10，9，6块的解</li>
<li>但是我在知道10块的解之后，我又会诞生一个新的求解9块的子问题（11-2=9，10-1=9）</li>
</ul>
<h2 id="备忘录优化解法">备忘录优化解法</h2>
<ul>
<li>通过新建一个哈希表来记录已经求解过的子问题的答案，来减少重复的递归</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_coins</span>(<span class="params">amount, coins, memo</span>):</span><br><span class="line">    <span class="keyword">if</span> amount <span class="keyword">in</span> memo:</span><br><span class="line">        <span class="comment"># memo是一个备忘录，用来记录已经计算过的最优解</span></span><br><span class="line">        <span class="comment"># memo[amout] = k，对应找amount元所需花的最少的硬币数</span></span><br><span class="line">        <span class="keyword">return</span> memo[amount]</span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">if</span> amount == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> amount &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    res = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">        <span class="comment"># 找到子问题的所需硬币数</span></span><br><span class="line">        tmp = count_coins(amount - coin, coins, memo)</span><br><span class="line">        <span class="keyword">if</span> tmp &gt;= <span class="number">0</span>:</span><br><span class="line">            res = <span class="built_in">min</span>(res, tmp)</span><br><span class="line">    <span class="keyword">if</span> res &lt; <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>):</span><br><span class="line">        memo[amount] = res+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="DP-Table解法">DP Table解法</h2>
<p>上面两种解法都是依靠递归，也就是自顶向上的解法，DP table属于是自底向上求解</p>
<p>因为不会用到递归，所以也不会报类似超过最大递归深度的错误</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RecursionError: maximum recursion depth exceeded <span class="keyword">in</span> comparison</span><br></pre></td></tr></table></figure>
<p>我们用数组来模拟递归，从最简单的问题求解即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">def count_coins(amount, coins):</span><br><span class="line">    <span class="comment"># 建立一个dptable去存储每种的最优解</span></span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    dp = [<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(amount + 1)]</span><br><span class="line">    dp[0] = 0</span><br><span class="line">    <span class="comment"># 去更新所有可能的金额的解</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(0, amount + 1):</span><br><span class="line">        tmp = dp[i]</span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">if</span> i - coin &gt;= 0:</span><br><span class="line">                tmp = min(tmp, dp[i - coin]+1)</span><br><span class="line">        dp[i] = tmp</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> dp[amount]</span><br></pre></td></tr></table></figure>
<h1>回溯法套路</h1>
<ul>
<li>关键思想：递归求解问题，每次尝试一种可能性，尝试到底之后再回溯</li>
</ul>
<p>三个关键问题</p>
<ol>
<li>路径：已经做出的选择</li>
<li>选择列表：下一步可以进行的选择</li>
<li>结束条件：要知道什么时候退出递归</li>
</ol>
<p>回溯法的算法框架</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">路径, 选择列表</span>):</span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.append(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        路径.做选择()</span><br><span class="line">        backtrack(路径, 选择列表)</span><br><span class="line">        路径.撤销选择()</span><br></pre></td></tr></table></figure>
<h2 id="全排列问题">全排列问题</h2>
<p>假设我要求[1,2,3]的全排列，那么针对三个关键问题</p>
<ol>
<li>路径：用一个数组来记录我已经选择了哪些数字</li>
<li>选择列表：既然是全排列，下一步能选择的数字就是[1,2,3]中我还没有加入路径的数字</li>
<li>结束条件：当我路径的长度为3时，我就知道已经实现了一种排列方式</li>
</ol>
<p>依据这三点可以很容易写出一个递归函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">path, nums</span>):</span><br><span class="line">    <span class="keyword">global</span> res</span><br><span class="line">    <span class="comment"># 结束条件是路径和我的数字个数一样</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">        res.append([i <span class="keyword">for</span> i <span class="keyword">in</span> path])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="comment"># 所有可能的选择就是不在path中的数字</span></span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> path:</span><br><span class="line">            path.append(num)</span><br><span class="line">            backtrack(path, nums)</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure>
<ul>
<li>回溯法就是纯暴力穷举，复杂度一般都很高</li>
</ul>
<h2 id="N皇后问题">N皇后问题</h2>
<p>给定一个NxN的棋盘，需要在每一行放一个皇后，最后保证</p>
<ul>
<li>每一列只有一个皇后</li>
<li>每根和对角线平行的斜线上只有一个皇后</li>
</ul>
<p>回溯法三个关键</p>
<ol>
<li>路径：就是记录我已经放了哪些皇后，一个二维数组来代表棋盘</li>
<li>选择列表：下一步能放的位置肯定是某一行的N个位置</li>
<li>结束条件：如果我现在的摆放已经无法满足上述条件，就直接退出递归；如果我把N行摆满了，且满足规则要求，说明这是一种合理的摆法。</li>
</ol>
<p><strong>思路</strong></p>
<p>为了方便描述棋盘的状态，我们将棋盘设置成一个N*N的二维数组</p>
<p>某格为0表示这格不放皇后，若为1表示这格放置皇后</p>
<ul>
<li>逐行放置皇后棋子</li>
<li>为了能快速确定选择列表，我们定义了三个集合
<ul>
<li>cols：已经放过的皇后的列数</li>
<li>left：和从左下↙到右上↗的对角线的平行线中哪些已经被放置了皇后
<ul>
<li>我们用皇后所在位置的行数-列数来标明这是哪根线</li>
<li>比如9*9的棋盘中，只要是行数-列数 = 8的都在中间的那根斜对角线上</li>
</ul>
</li>
<li>right：和left同理，标记的是从左上↖到右下↘的平行线</li>
</ul>
</li>
</ul>
<p><strong>代码实现</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = []</span><br><span class="line">N = <span class="number">9</span></span><br><span class="line">queens = [-<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line">cols, left, right = <span class="built_in">set</span>(), <span class="built_in">set</span>(), <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">backtrack</span>(<span class="params">row</span>):</span><br><span class="line">    <span class="comment"># row说明现在要放的皇后的所在行数</span></span><br><span class="line">    <span class="keyword">if</span> row == N:</span><br><span class="line">        <span class="comment"># 当前摆放符合规则,且已经摆了N个皇后</span></span><br><span class="line">        board = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line">        <span class="comment"># 生成最后的结果</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row):</span><br><span class="line">            board[i][queens[i]] = <span class="number">1</span></span><br><span class="line">        res.append(board)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        <span class="comment"># 尝试当前行的不同位置摆放皇后</span></span><br><span class="line">        <span class="comment"># 只对可能的位置进行选择</span></span><br><span class="line">        <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> cols <span class="keyword">and</span> row + j <span class="keyword">not</span> <span class="keyword">in</span> right <span class="keyword">and</span> row - j <span class="keyword">not</span> <span class="keyword">in</span> left:</span><br><span class="line">            queens[row] = j</span><br><span class="line">            cols.add(j)</span><br><span class="line">            right.add(row + j)</span><br><span class="line">            left.add(row - j)</span><br><span class="line">            backtrack(row+<span class="number">1</span>)</span><br><span class="line">            left.remove(row - j)</span><br><span class="line">            right.remove(row + j)</span><br><span class="line">            cols.remove(j)</span><br><span class="line"></span><br><span class="line">backtrack(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h1>BFS算法框架</h1>
<p>本质就是找起点到终点的最短路径。</p>
<p>一般框架如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">root, target</span>):</span><br><span class="line">    queue = []</span><br><span class="line">    <span class="comment"># queue是存储的是当前要遍历的这层的结点</span></span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="comment"># visited用来存储已经遍历过的结点，避免重复</span></span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    step = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        size = <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="comment"># 每次出队一个结点</span></span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="comment"># 如果这个结点是终点结点，就直接返回走的步数</span></span><br><span class="line">            <span class="keyword">if</span> node == target:</span><br><span class="line">                <span class="keyword">return</span> step</span><br><span class="line">            <span class="comment"># 当前结点不是终点，就继续向四周扩散</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> node.adj():</span><br><span class="line">                <span class="keyword">if</span> j <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    queue.append(j)</span><br><span class="line">        <span class="comment"># 每次遍历完一层结点，步数+1</span></span><br><span class="line">        step += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="二叉树的最小高度">二叉树的最小高度</h2>
<p>解决一个问题即可套上面的模板：</p>
<ol>
<li>
<p>起点和终点分别是什么？</p>
<p>起点就是根节点，终点就是叶节点</p>
</li>
</ol>
<p>OK，直接套模板（说是模板，其实就是把整个过程模拟出来）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">root</span>):</span><br><span class="line">    queue = [root]</span><br><span class="line">    step = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        size = <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            <span class="comment"># 从队列头部取出一个结点</span></span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node.left <span class="keyword">and</span> <span class="keyword">not</span> node.right:</span><br><span class="line">                <span class="comment"># 左右子节点均为空说明当前为叶节点</span></span><br><span class="line">                <span class="keyword">return</span> step</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        step += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>理解了队列，二叉树和BFS思路之后，在脑子里边模拟边写即可</p>
<p>这里不需要visited集合来去重是因为我们是一直向下遍历，二叉树向下遍历并不会有重复结点</p>
<h3 id="关键问题理解">关键问题理解</h3>
<ol>
<li>
<p>为什么BFS可以找到最短路径，DFS不能找到？</p>
<p>BFS可以找到最短路径是因为它所尝试的每一步都是这一步的所有可能，它借助队列，实现了一步一步齐头并进，每一次都是二叉树往下扩展一层。</p>
<p>DFS其实也可以找到最短路径，但是需要把二叉树的每一个树枝走到底，最后才能找到最短的记录。相比以行的扩展方式而言，这种操作会浪费不少时间。</p>
</li>
<li>
<p>DFS相比BFS而言有优势吗？</p>
<p>BFS虽然能找到最短路径，但是空间复杂度高，因为每次都是尝试的一层的全部可能性。</p>
<p>如果只是单纯需要找到路径，BFS的空间复杂度为O(N)，但是DFS的空间复杂度就是O(logN)。</p>
<p>一般在找最短路径的时候会使用到BFS，其他一般情况下都是用DFS(也可以说成是回溯法)</p>
</li>
</ol>
<h2 id="解开密码锁的最少次数">解开密码锁的最少次数</h2>
<ul>
<li>
<p>一道相对较难的BFS实践</p>
<p>有一个带有四个圆形拨轮的转盘锁，每个拨轮都有0-9共10个数字，每个拨轮都可以上下旋转，例如0→9，9→0</p>
<p>一开始的时候转盘初始为4个0，用字符串&quot;0000&quot;表示，现在有一个列表<code>deadends</code>和一个字符串<code>target</code></p>
<p><code>deadends</code>这个列表中会放一些死亡组合，要避免播出这个组合，返回播出<code>target</code>的最少次数。</p>
<p>当然也会有无法播出的情况，返回-1即可。</p>
</li>
</ul>
<p>按照思路套模板即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">deadends, target</span>):</span><br><span class="line">    queue = []</span><br><span class="line">    queue.append(<span class="string">&quot;0000&quot;</span>)</span><br><span class="line">    step = <span class="number">0</span></span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        size = <span class="built_in">len</span>(queue)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> deadends:</span><br><span class="line">                <span class="comment"># 当前为死亡状态，则跳过该路径</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> node == target:</span><br><span class="line">                <span class="comment"># 当前为目标状态，返回操作数</span></span><br><span class="line">                <span class="keyword">return</span> step</span><br><span class="line">            <span class="comment"># 尝试不同可能性</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                <span class="comment"># 一共有四个位置可以转</span></span><br><span class="line">                cur = <span class="built_in">int</span>(node[j])</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> [cur - <span class="number">1</span>, cur + <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">if</span> k &lt; <span class="number">0</span>: k = <span class="number">9</span></span><br><span class="line">                    <span class="keyword">if</span> k &gt; <span class="number">9</span>: k = <span class="number">0</span></span><br><span class="line">                    tmp = <span class="built_in">list</span>(node)</span><br><span class="line">                    tmp[j] = <span class="built_in">str</span>(k)</span><br><span class="line">                    code = <span class="string">&quot;&quot;</span>.join(tmp)</span><br><span class="line">                    <span class="keyword">if</span> code <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        queue.append(code)</span><br><span class="line">                        visited.add(code)</span><br><span class="line">        step += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>看起来很简单，但是我们需要更深入地研究。</li>
</ul>
<p>传统的BFS（也就是我上面的这个递归函数）只是单纯地自顶向下求解，事实上，我们可以使用双向BFS来优化整体的过程。</p>
<p>双向BFS会从起点和终点两边开始扩散，只需要遍历半棵树就能找到交集。</p>
<blockquote>
<p>要注意，使用双向BFS的前提是要知道终点的状态</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bfs</span>(<span class="params">deadends, target</span>):</span><br><span class="line">    queue1, queue2 = [], []</span><br><span class="line">    queue1.append(<span class="string">&quot;0000&quot;</span>)</span><br><span class="line">    queue2.append(target)</span><br><span class="line">    step = <span class="number">0</span></span><br><span class="line">    visited = <span class="built_in">set</span>()</span><br><span class="line">    <span class="keyword">while</span> queue1 <span class="keyword">and</span> queue2:</span><br><span class="line">        <span class="comment"># 用states数组去存储当前扩散出来的状态</span></span><br><span class="line">        states = []</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> queue1:</span><br><span class="line">            <span class="comment"># 扩散queue1</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> deadends:</span><br><span class="line">                <span class="comment"># 当前为死亡状态，则跳过该路径</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> queue2:</span><br><span class="line">                <span class="comment"># 当前为目标状态，返回操作数</span></span><br><span class="line">                <span class="keyword">return</span> step</span><br><span class="line">            visited.add(node)</span><br><span class="line">            <span class="comment"># 尝试不同可能性</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">                <span class="comment"># 一共有四个位置可以转</span></span><br><span class="line">                cur = <span class="built_in">int</span>(node[j])</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> [cur - <span class="number">1</span>, cur + <span class="number">1</span>]:</span><br><span class="line">                    <span class="comment"># 每个位置可以向上拨，也可以向下拨</span></span><br><span class="line">                    <span class="keyword">if</span> k &lt; <span class="number">0</span>: k = <span class="number">9</span></span><br><span class="line">                    <span class="keyword">if</span> k &gt; <span class="number">9</span>: k = <span class="number">0</span></span><br><span class="line">                    tmp = <span class="built_in">list</span>(node)</span><br><span class="line">                    tmp[j] = <span class="built_in">str</span>(k)</span><br><span class="line">                    code = <span class="string">&quot;&quot;</span>.join(tmp)</span><br><span class="line">                    <span class="keyword">if</span> code <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        states.append(code)</span><br><span class="line">        step += <span class="number">1</span></span><br><span class="line">        queue1 = queue2</span><br><span class="line">        <span class="comment"># 交换两个队列，实现交替扩散</span></span><br><span class="line">        queue2 = states</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(bfs([<span class="string">&quot;0123&quot;</span>], <span class="string">&quot;0238&quot;</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>针对双向BFS的优化
<ul>
<li>双向BFS中，会从两边交换进行扩散，队列中的元素越多，扩散出来的新元素也就越多</li>
<li>针对这一点，我们可以控制每次扩散的队列是元素较少的队列</li>
<li>使得以尽可能小的空间代价，来扩散两个队列找到交点</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> queue1 <span class="keyword">and</span> queue2:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(queue1) &gt; <span class="built_in">len</span>(queue2):</span><br><span class="line">            queue1, queue2 = queue2, queue1</span><br></pre></td></tr></table></figure>
<h1>双指针技巧套路框架</h1>
<h2 id="快慢指针可以实现">快慢指针可以实现</h2>
<ol>
<li>
<p>判断链表中是否有环</p>
<ul>
<li>相当于追及问题，快指针每次走两步，慢指针每次走一步</li>
<li>如果快慢指针相遇，说明快指针超了慢指针一圈（超了一个环的长度）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">has_cycle</span>(<span class="params">head</span>):</span><br><span class="line">    fast, slow = head, head</span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> fast == slow:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>已知链表中有环，找到环的起始位置</p>
<ul>
<li>首先跟上文类似，先用追及问题的方式，找到两个指针第一次相遇的位置</li>
<li>此时慢指针走了k步，快指针走了2k步
<ul>
<li>假设两者的相遇点和环的起点距离为m</li>
<li>那么环的起点和头节点head的距离就是k-m</li>
<li>也就是说，如果从头节点开始走，走k-m步就会到达环的起始位置</li>
<li>巧的是，如果从当前相遇的位置出发，走k-m步也会到达环的起始位置</li>
</ul>
</li>
<li>此时，让慢指针回到起点，重新出发，快指针不动
<ul>
<li>两者以同样的速度，每次前进一格出发</li>
<li>两者相遇的位置就是环的起点</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">has_cycle</span>(<span class="params">head</span>):</span><br><span class="line">    fast, slow = head, head</span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> fast == slow:</span><br><span class="line">            <span class="comment"># 找到两者相遇的位置</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    slow = head</span><br><span class="line">    <span class="keyword">while</span> slow != fast:</span><br><span class="line">        <span class="comment"># 找到两者第二次相遇的位置</span></span><br><span class="line">        fast = fast.<span class="built_in">next</span></span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>
<p>真的神奇！✨</p>
</li>
<li>
<p>寻找无环单链表的中点</p>
<p>快指针每次前进两步，慢指针每次前进一步</p>
<p>当快指针走到链表尽头的时候，慢指针就恰好在链表的中点了</p>
<p>如果链表长度为奇数，慢指针就是在正中间，如果链表长度为偶数，慢指针就是在中点偏右</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_mid_node</span>(<span class="params">head</span>):</span><br><span class="line">    fast, slow = head, head</span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">        fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>寻找单链表中的倒数第k个结点</p>
<p>让快指针先前进k步，然后慢指针从head出发，两个指针同时每次前进一格</p>
<p>快指针走到底，慢指针就指向倒数第k个结点了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find_kth_node</span>(<span class="params">head, k</span>):</span><br><span class="line">    fast, slow = head, head</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">        fast = fast.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">while</span> fast:</span><br><span class="line">        fast = fast.<span class="built_in">next</span></span><br><span class="line">        slow = slow.<span class="built_in">next</span></span><br><span class="line">    <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
        <tag>fucking-algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年12月刷题日志</title>
    <url>/post/2020-12-01-Algorithm/2020%E5%B9%B412%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p><strong>12.31</strong></p>
<p>再见啦，2020</p>
<img src="https://cdn.ethanloo.cn/img/20201231090005.png" alt="image-20201231090004979" style="zoom: 50%;" />
<p>太困了，先睡一会儿</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="435-无重叠区间"><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a></h4>
<p>难度中等271</p>
<p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p>
<p><strong>注意:</strong></p>
<ol>
<li>可以认为区间的终点总是大于它的起点。</li>
<li>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</li>
</ol>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [ [1,2], [2,3], [3,4], [1,3] ]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [ [1,2], [1,2], [1,2] ]</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [ [1,2], [2,3] ]</span><br><span class="line"></span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eraseOverlapIntervals</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 贪心</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(intervals)&lt;<span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        intervals.sort(key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">        last_end = intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> left, right <span class="keyword">in</span> intervals[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> left&gt;=last_end:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                last_end = right</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(intervals)-cnt</span><br></pre></td></tr></table></figure>
<p><strong>12.30</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1046-最后一块石头的重量"><a href="https://leetcode-cn.com/problems/last-stone-weight/">1046. 最后一块石头的重量</a></h4>
<p>难度简单</p>
<p>有一堆石头，每块石头的重量都是正整数。</p>
<p>每一回合，从中选出两块 <strong>最重的</strong> 石头，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p>
<ul>
<li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li>
<li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li>
</ul>
<p>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 <code>0</code>。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[2,7,4,1,8,1]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，</span><br><span class="line">再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，</span><br><span class="line">接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，</span><br><span class="line">最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= stones.length &lt;= 30</code></li>
<li><code>1 &lt;= stones[i] &lt;= 1000</code></li>
</ol>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lastStoneWeight</span>(<span class="params">self, stones: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stones = [-i <span class="keyword">for</span> i <span class="keyword">in</span> stones]</span><br><span class="line">        heapify(stones)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(stones)&gt;<span class="number">1</span>:</span><br><span class="line">            big, small = -heapq.heappop(stones), -heapq.heappop(stones)</span><br><span class="line">            <span class="keyword">if</span> big==small:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                heapq.heappush(stones, -(big-small))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(stones) <span class="keyword">else</span> -heapq.heappop(stones)</span><br></pre></td></tr></table></figure>
<p><strong>12.29</strong></p>
<p>老样子，期末考试期间不写题解</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="330-按要求补齐数组"><a href="https://leetcode-cn.com/problems/patching-array/">330. 按要求补齐数组</a></h4>
<p>难度困难</p>
<p>给定一个已排序的正整数数组 *nums，*和一个正整数 *n 。*从 <code>[1, n]</code> 区间内选取任意个数字补充到 <em>nums</em> 中，使得 <code>[1, n]</code> 区间内的任何数字都可以用 <em>nums</em> 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3], n = 6</span><br><span class="line">输出: 1 </span><br><span class="line">解释:</span><br><span class="line">根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。</span><br><span class="line">现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。</span><br><span class="line">其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。</span><br><span class="line">所以我们最少需要添加一个数字。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,5,10], n = 20</span><br><span class="line">输出: 2</span><br><span class="line">解释: 我们需要添加 [2, 4]。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,2,2], n = 5</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minPatches</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res, x = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        index, length = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> x&lt;=n:</span><br><span class="line">            <span class="keyword">if</span> index&lt;<span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[index]&lt;=x:</span><br><span class="line">                x += nums[index]</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x *= <span class="number">2</span></span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>12.28</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="188-买卖股票的最佳时机-IV"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></h4>
<p>难度困难</p>
<p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔交易。</p>
<p>**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：k = 2, prices = [2,4,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：k = 2, prices = [3,2,6,5,0,3]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。</span><br><span class="line">     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= k &lt;= 10^9</code></li>
<li><code>0 &lt;= prices.length &lt;= 1000</code></li>
<li><code>0 &lt;= prices[i] &lt;= 1000</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>动态规划</p>
<p>又是复习，参考着大佬的代码优化了一下</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, k: <span class="built_in">int</span>, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 动态规划</span></span><br><span class="line">        <span class="comment"># 开辟两个数组，一个存放当天结束时候没有股票，另一个存放当天结束的时候手里有股票</span></span><br><span class="line">        buy = [-<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>)]</span><br><span class="line">        sell = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,k+<span class="number">1</span>):</span><br><span class="line">                buy[j] = <span class="built_in">max</span>(sell[j-<span class="number">1</span>]-price, buy[j])</span><br><span class="line">                sell[j] = <span class="built_in">max</span>(sell[j], buy[j]+price)</span><br><span class="line">        <span class="keyword">return</span> sell[k]</span><br></pre></td></tr></table></figure>
<p><strong>12.27</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="205-同构字符串"><a href="https://leetcode-cn.com/problems/isomorphic-strings/">205. 同构字符串</a></h4>
<p>难度简单282</p>
<p>给定两个字符串 <em><strong>s</strong></em> 和 *<strong>t*</strong>，判断它们是否是同构的。</p>
<p>如果 <em><strong>s</strong></em> 中的字符可以被替换得到 *<strong>t*</strong> ，那么这两个字符串是同构的。</p>
<p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;egg&quot;, t = &quot;add&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;foo&quot;, t = &quot;bar&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;paper&quot;, t = &quot;title&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>用两个字典互相映射</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isIsomorphic</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        dic_s, dic_t = <span class="built_in">dict</span>(), <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            cur_s, cur_t = s[i], t[i]</span><br><span class="line">            <span class="keyword">if</span> cur_s <span class="keyword">in</span> dic_s <span class="keyword">and</span> dic_s[cur_s] != cur_t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> cur_t <span class="keyword">in</span> dic_t <span class="keyword">and</span> dic_t[cur_t] != cur_s:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            dic_s[cur_s] = cur_t</span><br><span class="line">            dic_t[cur_t] = cur_s</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><strong>12.26</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="85-最大矩形"><a href="https://leetcode-cn.com/problems/maximal-rectangle/">85. 最大矩形</a></h4>
<p>难度困难</p>
<p>给定一个仅包含 <code>0</code> 和 <code>1</code> 、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]</span><br><span class="line">输出：6</span><br><span class="line">解释：最大矩形如上图所示。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = []</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[&quot;0&quot;]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[&quot;1&quot;]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[&quot;0&quot;,&quot;0&quot;]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>rows == matrix.length</code></li>
<li><code>cols == matrix[0].length</code></li>
<li><code>0 &lt;= row, cols &lt;= 200</code></li>
<li><code>matrix[i][j]</code> 为 <code>'0'</code> 或 <code>'1'</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>就算是困难题，也给你锤烂，暴力法，yyds！（其实就是自己菜）</p>
<ol>
<li>
<p>暴力解法</p>
<p>为了确定每个位置能扩展出来最大的矩形面积，我们要知道这个位置向右有多少个连续的1，向下有多少个连续的1。知道之后呢，就分别向右和向下遍历，确定矩形的最大面积即可。</p>
<p>以向下遍历为例，假设当前这个位置向右有5个连续的1</p>
<ul>
<li>我们初始化宽度为5，高度为1，当前的最大矩形面积是5</li>
<li>开始向下遍历
<ul>
<li>向下一格之后，数字是1，向右最多有4个连续的1，因此当前宽度就只能是4，高度为2，最大矩形面积为8</li>
<li>再向下一格，数字是1，向右最多有3个连续的1，当前宽度就是3，高度为3，最大面积9</li>
<li>再向下一格，数字是0，因此停止扩展</li>
</ul>
</li>
<li>向右遍历也是一个道理</li>
</ul>
</li>
<li>
<p>递增栈的巧妙解法</p>
<blockquote>
<p>算法详情<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></p>
</blockquote>
<p>首先初始化一个高度数组<code>heights</code>，去记录每列最多有多少个连续的1</p>
<p>按行去遍历数组，以题目里的例子为例</p>
<img src="https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg" alt="img" style="zoom:33%;" />
<ul>
<li>第一行的时候 <code>heights = [1,0,1,0,0]</code></li>
<li>第二行的时候 <code>heights = [2,0,2,1,1]</code></li>
<li>第三行的时候 <code>heights = [3,1,2,2,2]</code></li>
<li>以第三行为例，来当前情况下求最大的面积</li>
<li>为了减少判断，我们往数组里放两个哨兵 <code>heights = [0]+heights+[0]</code></li>
<li>初始化递增栈 <code>stk=[0]</code></li>
<li>从<code>j=1</code>开始遍历 <code>heights</code>
<ul>
<li>当前的<code>heights[j]=3</code>比栈顶位置的高度<code>heights[stk[-1]]=0</code>高，所以直接把<code>j</code>丢到栈里</li>
<li>当前的<code>heights[j]=1</code>比栈顶位置的高度<code>3</code>要小，所以我们当前就能确定以<code>3</code>为高度的最大矩形面积</li>
<li>我们把栈顶元素<code>pop</code>出来，它的位置是<code>1</code>，因为我们的栈是递增栈，所以当前栈里的所有元素的位置的高度必定是比<code>3</code>要小的，所以我们的宽度只能是当前遍历的位置<code>2</code>减去栈顶元素的位置<code>0</code>再减去1，乘上高度<code>3</code>，所以最大面积就是3</li>
<li>之后同理</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>俺只是抄题解的菜🐓罢了</p>
</blockquote>
<p><img src="https://cdn.ethanloo.cn/img/20201226101345.png" alt="image-20201226101337858"></p>
<p><strong>代码</strong></p>
<ol>
<li>
<p>暴力</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximalRectangle</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        rows = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        cols = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 记录每个1的右边和下边最多有多少个连续的1</span></span><br><span class="line">        <span class="comment"># 先记录行</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            last = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] ==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    last += <span class="number">1</span></span><br><span class="line">                    matrix[i][j] = [<span class="string">&#x27;1&#x27;</span>, last]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    last = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            last = <span class="number">0</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    last += <span class="number">1</span></span><br><span class="line">                    matrix[i][j].append(last)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    last = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j][<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    <span class="comment"># 向下找到最大的扩展可能性</span></span><br><span class="line">                    height = <span class="number">1</span></span><br><span class="line">                    width = matrix[i][j][<span class="number">1</span>]</span><br><span class="line">                    row, col = i, j</span><br><span class="line">                    res = <span class="built_in">max</span>(res, height*width)</span><br><span class="line">                    <span class="keyword">while</span> row+<span class="number">1</span>&lt;rows <span class="keyword">and</span> matrix[row+<span class="number">1</span>][j][<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                        row += <span class="number">1</span></span><br><span class="line">                        height += <span class="number">1</span></span><br><span class="line">                        width = <span class="built_in">min</span>(width, matrix[row][j][<span class="number">1</span>])</span><br><span class="line">                        res = <span class="built_in">max</span>(width*height, res)</span><br><span class="line">                    <span class="comment"># 再向右找到最大的扩展可能性</span></span><br><span class="line">                    width = <span class="number">1</span></span><br><span class="line">                    height = matrix[i][j][<span class="number">2</span>]</span><br><span class="line">                    <span class="keyword">while</span> col+<span class="number">1</span>&lt;cols <span class="keyword">and</span> matrix[i][col+<span class="number">1</span>][<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                        col += <span class="number">1</span></span><br><span class="line">                        width += <span class="number">1</span></span><br><span class="line">                        height = <span class="built_in">min</span>(height, matrix[row][j][<span class="number">2</span>])</span><br><span class="line">                        res = <span class="built_in">max</span>(width*height, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>借助递增栈</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximalRectangle</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        rows = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        cols = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 每次按列记录上面有多少个连续的1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        heights = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(cols+<span class="number">2</span>)] <span class="comment"># 加入了两哨兵站</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    heights[j+<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    heights[j+<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 更新完heights数组之后开始求最大面积</span></span><br><span class="line">            stk = [<span class="number">0</span>] <span class="comment"># stk是一个递增栈</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,cols+<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">while</span> heights[j] &lt; heights[stk[-<span class="number">1</span>]]:</span><br><span class="line">                    index = stk.pop()</span><br><span class="line">                    width = j-(stk[-<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line">                    res = <span class="built_in">max</span>(res, width*heights[index])</span><br><span class="line">                stk.append(j)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>12.25</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="455-分发饼干"><a href="https://leetcode-cn.com/problems/assign-cookies/">455. 分发饼干</a></h4>
<p>难度简单</p>
<p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p>
<p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: g = [1,2,3], s = [1,1]</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><br><span class="line">所以你应该输出1。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: g = [1,2], s = [1,2,3]</span><br><span class="line">输出: 2</span><br><span class="line">解释: </span><br><span class="line">你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。</span><br><span class="line">你拥有的饼干数量和尺寸都足以让所有孩子满足。</span><br><span class="line">所以你应该输出2.</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= g.length &lt;= 3 * 104</code></li>
<li><code>0 &lt;= s.length &lt;= 3 * 104</code></li>
<li><code>1 &lt;= g[i], s[j] &lt;= 231 - 1</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>双指针</p>
<p>先对胃口数组和饼干数组排序，升序</p>
<p>然后分别用<code>i,j</code>两个指针遍历数组，如果胃口大，就把饼干数组的指针右移直到能吃饱为止</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findContentChildren</span>(<span class="params">self, g: <span class="type">List</span>[<span class="built_in">int</span>], s: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        g.sort()</span><br><span class="line">        s.sort()</span><br><span class="line">        i, j, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;<span class="built_in">len</span>(g) <span class="keyword">and</span> j&lt;<span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">while</span> j&lt;<span class="built_in">len</span>(s) <span class="keyword">and</span> g[i]&gt;s[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j&lt;<span class="built_in">len</span>(s):</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>12.24</strong></p>
<p>这就是困难题吗，莫名其妙过了，爱了爱了</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="135-分发糖果"><a href="https://leetcode-cn.com/problems/candy/">135. 分发糖果</a></h4>
<p>难度困难</p>
<p>老师想给孩子们分发糖果，有 <em>N</em> 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p>
<p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p>
<ul>
<li>每个孩子至少分配到 1 个糖果。</li>
<li>相邻的孩子中，评分高的孩子必须获得更多的糖果。</li>
</ul>
<p>那么这样下来，老师至少需要准备多少颗糖果呢？</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,0,2]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,2]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。</span><br><span class="line">     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>先从左向右遍历，保证单方面合理
<ul>
<li>如果当前遍历的孩子的评分比左侧的分数高</li>
<li>我给他的糖果数就要比左侧的孩子多一个</li>
</ul>
</li>
<li>再从右向左遍历，保证双方面合理
<ul>
<li>如果当前遍历的孩子的评分比右侧的分数高</li>
<li>我给他的糖果数就要比右侧的孩子多一个</li>
<li>在这次遍历决定糖果数的时候要保证，当前的糖果数不能比之前单方面考虑的时候少</li>
</ul>
</li>
</ul>
<blockquote>
<p>我也不知道为什么这么纯粹的贪心就 AC 了</p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">candy</span>(<span class="params">self, ratings: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ratings:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(ratings)</span><br><span class="line">        candy = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(ratings)):</span><br><span class="line">            <span class="keyword">if</span> ratings[i]&gt;ratings[i-<span class="number">1</span>]:</span><br><span class="line">                candy[i] = candy[i-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ratings)-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> ratings[i]&gt;ratings[i+<span class="number">1</span>]:</span><br><span class="line">                candy[i] = <span class="built_in">max</span>(candy[i+<span class="number">1</span>]+<span class="number">1</span>, candy[i]) </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(candy)</span><br></pre></td></tr></table></figure>
<p><strong>12.23</strong></p>
<p>我可太困了😴</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="387-字符串中的第一个唯一字符"><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/">387. 字符串中的第一个唯一字符</a></h4>
<p>难度简单</p>
<p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s = &quot;leetcode&quot;</span><br><span class="line">返回 0</span><br><span class="line"></span><br><span class="line">s = &quot;loveleetcode&quot;</span><br><span class="line">返回 2</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>哈希表计数</li>
<li>找到所有出现次数为1的字母</li>
<li>找到这些字母中位置最靠前的</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">firstUniqChar</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dic = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> dic:</span><br><span class="line">                dic[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[i] = <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">set</span>(s):</span><br><span class="line">            <span class="keyword">if</span> dic[i] == <span class="number">1</span>:</span><br><span class="line">                res.append(s.index(i))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(res) <span class="keyword">if</span> res <span class="keyword">else</span> -<span class="number">1</span>     </span><br></pre></td></tr></table></figure>
<p><strong>12.22</strong></p>
<p>为啥层序遍历也变成中等难度了🧐</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="103-二叉树的锯齿形层序遍历"><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h4>
<p>难度中等</p>
<p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p>
<p>例如：<br>
给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<p>返回锯齿形层序遍历如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>层序遍历，根据当前遍历的层数来决定是否要倒序输出</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">zigzagLevelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        nodes, res = [],[]</span><br><span class="line">        nodes.append(root)</span><br><span class="line">        height = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> nodes:</span><br><span class="line">            tmp, cur = [],[]</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">                cur.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    tmp.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    tmp.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> height%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">                res.append(cur)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(cur[::-<span class="number">1</span>])</span><br><span class="line">            height += <span class="number">1</span></span><br><span class="line">            nodes = tmp</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>12.21</strong></p>
<p>easy cozy</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="746-使用最小花费爬楼梯"><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h4>
<p>难度简单436</p>
<p>数组的每个索引作为一个阶梯，第 <code>i</code>个阶梯对应着一个非负数的体力花费值 <code>cost[i]</code>(索引从0开始)。</p>
<p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p>
<p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: cost = [10, 15, 20]</span><br><span class="line">输出: 15</span><br><span class="line">解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ol>
<li><code>cost</code> 的长度将会在 <code>[2, 1000]</code>。</li>
<li>每一个 <code>cost[i]</code> 将会是一个Integer类型，范围为 <code>[0, 999]</code>。</li>
</ol>
</blockquote>
<p><strong>思路</strong></p>
<p>最纯粹的动态规划，唯一的小trick就是在原数组后面加个0</p>
<blockquote>
<p>真的搞不懂为啥设定成最后一级台阶不是楼顶</p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minCostClimbingStairs</span>(<span class="params">self, cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(cost)</span><br><span class="line">        cost.append(<span class="number">0</span>)</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>], dp[<span class="number">1</span>] = cost[<span class="number">0</span>], cost[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(cost)):</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>])+cost[i]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p><strong>12.20</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="316-去除重复字母"><a href="https://leetcode-cn.com/problems/remove-duplicate-letters/">316. 去除重复字母</a></h4>
<p>难度中等</p>
<p>给你一个字符串 <code>s</code> ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 <strong>返回结果的字典序最小</strong>（要求不能打乱其他字符的相对位置）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;bcabc&quot;</span><br><span class="line">输出：&quot;abc&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;cbacdcbc&quot;</span><br><span class="line">输出：&quot;acdb&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 104</code></li>
<li><code>s</code> 由小写英文字母组成</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>
<p>边遍历<code>s</code>，边考虑我们要保留哪些字母，丢弃哪些字母</p>
</li>
<li>
<p>用一个栈去存储我们选择保留的字母</p>
</li>
<li>
<p>假设当前遍历的是<code>s</code></p>
<ul>
<li>如果<code>s</code>已经在栈中，就忽略</li>
<li>否则就保留<code>s</code></li>
<li>但是为了最后的输出字典序最小，我们需要尽可能地删掉和<code>s</code>相邻且比<code>s</code>还要大的字母</li>
<li>在删除的同时，还要保证不能太贪了，如果要准备删的字母是它最后一次出现了，就停手</li>
</ul>
<blockquote>
<p>感觉有点像满门抄斩，但是给留个独苗</p>
</blockquote>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicateLetters</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        dic = collections.Counter(s)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                <span class="keyword">while</span> res <span class="keyword">and</span> res[-<span class="number">1</span>]&gt;i <span class="keyword">and</span> dic[res[-<span class="number">1</span>]]&gt;<span class="number">0</span>:</span><br><span class="line">                    res.pop()</span><br><span class="line">                res.append(i)</span><br><span class="line">            dic[i] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(res)</span><br></pre></td></tr></table></figure>
<p><strong>12.19</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="48-旋转图像"><a href="https://leetcode-cn.com/problems/rotate-image/">48. 旋转图像</a></h4>
<p>难度中等</p>
<p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵表示一个图像。</p>
<p>将图像顺时针旋转 90 度。</p>
<p><strong>说明：</strong></p>
<p>你必须在**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>**旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>使用另一个矩阵来旋转图像。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定 matrix = </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定 matrix =</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>好家伙，给我人转晕了，我们慢慢分析，找一下规律</p>
<ul>
<li>假设矩阵行数=<code>n</code>，列数=<code>n</code>
<ul>
<li>以第二个矩阵为例，行数=4，列数=4，经过旋转</li>
<li><code>(1,0)=&gt;(0,2)</code></li>
<li><code>(1,1)=&gt;(1,2)</code></li>
<li><code>(1,2)=&gt;(2,2)</code></li>
<li><code>(1,3)=&gt;(3,1)</code></li>
</ul>
</li>
<li>矩阵中的<code>(row,col)</code>在旋转90°之后，到了<code>(col,n-row-1)</code>
<ul>
<li>即<code>(row,col)=&gt;(col,n-row-1)</code></li>
</ul>
</li>
<li>根据这个规律可以有两种实现矩阵原地旋转的方式</li>
</ul>
<ol>
<li>
<p>设缓存量，逐个交换</p>
<p>每次的旋转都可以把元素分成四个一组，将四个元素的值逐个交换</p>
<p>这四个元素分别是</p>
<ul>
<li><code>matrix[row][col]</code></li>
<li><code>matrix[col,n-row-1]</code></li>
<li><code>matrix[n-row-1,n-col-1]</code></li>
<li><code>matrix[n-col-1,row]</code></li>
</ul>
<p>只要让第一个值到第二个位置去，第二个值到第三个位置去，第三个值到第四个位置去，第四个值到第一个位置去即可</p>
<p>要实现这个，可以设一个缓存量<code>tmp</code>，来实现四个元素的值的交换（python也可以直接交换，但是我个人觉得代码可读性太差了）</p>
<p>还有一个问题是应该分成哪些组呢？</p>
<p>偶数情况就是平均分成四块，<code>n^2 = 4*(n/2)*(n/2)</code></p>
<p>奇数情况需要分解成<code>n^2 = 4*((n-1)/2)*((n+1)/2)+1</code>直接看官方题解的图吧</p>
<img src="https://assets.leetcode-cn.com/solution-static/48/2.png" alt="fig2" style="zoom: 25%;" />
</li>
<li>
<p>巧翻转</p>
<p>首先将矩阵按水平轴翻转，即上下翻转</p>
<p><code>matrix[row][col]=matrix[n-row-1][col]</code></p>
<p>再将矩阵根据主对角线翻转，即右上的元素到左下</p>
<p><code>matrix[n-row-1][col]=matrix[col][n-row-1]</code></p>
<p>因此最后实现的是</p>
<p><code>matrix[row][col]=&gt;matrix[col][n-row-1]</code></p>
<p>正好是我们要求的变换</p>
</li>
</ol>
<p><strong>代码</strong></p>
<ol>
<li>
<p>逐个交换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>((n+<span class="number">1</span>)//<span class="number">2</span>):</span><br><span class="line">                tmp = matrix[i][j]</span><br><span class="line">                matrix[i][j] = matrix[n-j-<span class="number">1</span>][i]</span><br><span class="line">                matrix[n-j-<span class="number">1</span>][i] = matrix[n-i-<span class="number">1</span>][n-j-<span class="number">1</span>]</span><br><span class="line">                matrix[n-i-<span class="number">1</span>][n-j-<span class="number">1</span>] = matrix[j][n-i-<span class="number">1</span>]</span><br><span class="line">                matrix[j][n-i-<span class="number">1</span>] = tmp</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>翻转</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="comment"># 上下翻转</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                matrix[i][j], matrix[n-i-<span class="number">1</span>][j] = matrix[n-i-<span class="number">1</span>][j], matrix[i][j]</span><br><span class="line">        <span class="comment"># 对角线翻转</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>12.18</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="389-找不同"><a href="https://leetcode-cn.com/problems/find-the-difference/">389. 找不同</a></h4>
<p>难度简单</p>
<p>给定两个字符串 <em><strong>s</strong></em> 和 <em><strong>t</strong></em>，它们只包含小写字母。</p>
<p>字符串 *<strong>t*</strong> 由字符串 *<strong>s*</strong> 随机重排，然后在随机位置添加一个字母。</p>
<p>请找出在 <em><strong>t</strong></em> 中被添加的字母。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abcd&quot;, t = &quot;abcde&quot;</span><br><span class="line">输出：&quot;e&quot;</span><br><span class="line">解释：&#x27;e&#x27; 是那个被添加的字母。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;&quot;, t = &quot;y&quot;</span><br><span class="line">输出：&quot;y&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ae&quot;, t = &quot;aea&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= s.length &lt;= 1000</code></li>
<li><code>t.length == s.length + 1</code></li>
<li><code>s</code> 和 <code>t</code> 只包含小写字母</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>哈，都可以哈</p>
<p>用一个字典统计字母出现次数，s中出现了就-1，t出现了就+1</p>
<p>最后value为1对应的key就是我们要找的字母</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTheDifference</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        dic_t = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">            dic_t[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            dic_t[i] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dic_t.keys():</span><br><span class="line">            <span class="keyword">if</span> dic_t[i]&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>
<p><strong>12.17</strong></p>
<p>正好复习一下两个星期前看的labuladong的算法小抄</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="714-买卖股票的最佳时机含手续费"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></h4>
<p>难度中等</p>
<p>给定一个整数数组 <code>prices</code>，其中第 <code>i</code> 个元素代表了第 <code>i</code> 天的股票价格 ；非负整数 <code>fee</code> 代表了交易股票的手续费用。</p>
<p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p>
<p>返回获得利润的最大值。</p>
<p>**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: prices = [1, 3, 2, 8, 4, 9], fee = 2</span><br><span class="line">输出: 8</span><br><span class="line">解释: 能够达到的最大利润:  </span><br><span class="line">在此处买入 prices[0] = 1</span><br><span class="line">在此处卖出 prices[3] = 8</span><br><span class="line">在此处买入 prices[4] = 4</span><br><span class="line">在此处卖出 prices[5] = 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ul>
<li>
<p><code>0 &lt; prices.length &lt;= 50000</code>.</p>
</li>
<li>
<p><code>0 &lt; prices[i] &lt; 50000</code>.</p>
</li>
<li>
<p><code>0 &lt;= fee &lt; 50000</code>.</p>
</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>动态规划三要素</p>
<ol>
<li>
<p><code>dp</code>数组定义</p>
<p>因为我们每天结束的时候最多两个状态</p>
<ul>
<li>手里没股票</li>
<li>手里有股票</li>
</ul>
<p>所以就定义</p>
<ul>
<li>
<p><code>dp[i][0]</code>表示第<code>i</code>天结束的时候手里没股票时的最大利润</p>
</li>
<li>
<p><code>dp[i][1]</code>表示第<code>i</code>天结束的时候手里有股票时的最大利润</p>
</li>
</ul>
</li>
<li>
<p>base case</p>
<p>一开始每天的利润初始化为0</p>
<p>根据数组定义，第0天的状态就是<code>dp[0][0]=0,dp[0][1]=-prices[0]</code></p>
</li>
<li>
<p>状态转移方程</p>
<p>如果当天结束的时候没有股票，有两种可能</p>
<ul>
<li>当天卖出了股票</li>
<li>当天开始的时候就没有股票</li>
</ul>
<p>如果当天结束的时候有股票</p>
<ul>
<li>当天新买的股票</li>
<li>当天开始的时候已经持有了股票</li>
</ul>
<p>因此，考虑到手续费，状态转移方程为</p>
<p><code>dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i]-fee)</code></p>
<p><code>dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])</code></p>
</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>], fee: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 动态规划</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>, -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]-fee)</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[-<span class="number">1</span>][<span class="number">0</span>], dp[-<span class="number">1</span>][<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>优化一下空间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>], fee: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 动态规划</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        dp0, dp1 = <span class="number">0</span>, -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            dp0, dp1 = <span class="built_in">max</span>(dp0, dp1+prices[i]-fee), <span class="built_in">max</span>(dp1, dp0-prices[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp0, dp1)</span><br></pre></td></tr></table></figure>
<p><strong>12.16</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="290-单词规律"><a href="https://leetcode-cn.com/problems/word-pattern/">290. 单词规律</a></h4>
<p>难度简单237</p>
<p>给定一种规律 <code>pattern</code> 和一个字符串 <code>str</code> ，判断 <code>str</code> 是否遵循相同的规律。</p>
<p>这里的 <strong>遵循</strong> 指完全匹配，例如， <code>pattern</code> 里的每个字母和字符串 <code>str</code> 中的每个非空单词之间存在着双向连接的对应规律。</p>
<p><strong>示例1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: pattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>示例 4:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: pattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong><br>
你可以假设 <code>pattern</code> 只包含小写字母， <code>str</code> 包含了由单个空格分隔的小写字母。</p>
</blockquote>
<p><strong>思路</strong></p>
<p>两个哈希表互相找，一个以<code>pattern</code>中的字母为key，一个以<code>str</code>中的单词为key</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wordPattern</span>(<span class="params">self, pattern: <span class="built_in">str</span>, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        dic_p = <span class="built_in">dict</span>()</span><br><span class="line">        dic_w = <span class="built_in">dict</span>()</span><br><span class="line">        words = s.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(words) != <span class="built_in">len</span>(pattern):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(words)):</span><br><span class="line">            p = pattern[i]</span><br><span class="line">            w = words[i]</span><br><span class="line">            <span class="keyword">if</span> p <span class="keyword">not</span> <span class="keyword">in</span> dic_p <span class="keyword">and</span> w <span class="keyword">not</span> <span class="keyword">in</span> dic_w:</span><br><span class="line">                dic_p[p] = w</span><br><span class="line">                dic_w[w] = p</span><br><span class="line">            <span class="keyword">elif</span> p <span class="keyword">not</span> <span class="keyword">in</span> dic_p <span class="keyword">or</span> w <span class="keyword">not</span> <span class="keyword">in</span> dic_w:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> dic_p[p] != w <span class="keyword">or</span> dic_w[w]!=p:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><strong>12.15</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="738-单调递增的数字"><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/">738. 单调递增的数字</a></h4>
<p>难度中等</p>
<p>给定一个非负整数 <code>N</code>，找出小于或等于 <code>N</code> 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。</p>
<p>（当且仅当每个相邻位数上的数字 <code>x</code> 和 <code>y</code> 满足 <code>x &lt;= y</code> 时，我们称这个整数是单调递增的。）</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: N = 10</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: N = 1234</span><br><span class="line">输出: 1234</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: N = 332</span><br><span class="line">输出: 299</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong> <code>N</code> 是在 <code>[0, 10^9]</code> 范围内的一个整数。</p>
</blockquote>
<p><strong>思路</strong></p>
<p>用递增栈存数字，然后贪！</p>
<p>我们首先来找一下思路</p>
<ol>
<li>
<p>如果原来的数字能顺利的存放到递增栈中，那挺好，直接返回就行。</p>
</li>
<li>
<p>但是大部分情况下都不是这样的，例如<code>3455521</code>，它在第6位，即<code>2</code>开始不是递增的了，这个时候该怎么办呢？</p>
<p>这个时候肯定应该丢掉栈顶的一部分数字，然后把栈顶的一个数字减小1，来保证我最后的结果比原数字小。</p>
<p>然后放尽可能多的9到栈里，来保证最后我的结果最大。</p>
</li>
</ol>
<p>OK，现在来思考要丢掉几个数字，放几个9</p>
<ul>
<li>可以看到，当我尝试放<code>2</code>的时候，我的栈应该是<code>[3, 4, 5, 5, 5]</code></li>
<li>这个时候，如果只丢掉一个<code>5</code>，就变成<code>[3, 4, 5, 5]</code>，这个时候把栈顶元素减小1，那就不是递增的了呀</li>
<li>所以我们要让栈顶丢到只剩一个<code>5</code>，然后把<code>5</code>变成<code>4</code>放到栈里面去</li>
<li>再补<code>9</code>，<code>9</code>的个数应该是当前原数字的长度减掉当前栈的长度</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">monotoneIncreasingDigits</span>(<span class="params">self, N: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 贪心法</span></span><br><span class="line">        N = <span class="built_in">str</span>(N)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(N)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">or</span> <span class="built_in">int</span>(N[i])&gt;=<span class="built_in">int</span>(res[-<span class="number">1</span>]):</span><br><span class="line">                res.append(N[i])</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(res)&gt;=<span class="number">2</span> <span class="keyword">and</span> res[-<span class="number">1</span>]==res[-<span class="number">2</span>]:</span><br><span class="line">                res.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(res[-<span class="number">1</span>])&gt;<span class="number">0</span>:</span><br><span class="line">                res[-<span class="number">1</span>] = <span class="built_in">str</span>(<span class="built_in">int</span>(res[-<span class="number">1</span>])-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.pop()</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(res)&lt;<span class="built_in">len</span>(N):</span><br><span class="line">                res.append(<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(res))</span><br></pre></td></tr></table></figure>
<p><strong>12.14</strong></p>
<p>昨天csp熬了三个多小时才200多分 💢</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="49-字母异位词分组"><a href="https://leetcode-cn.com/problems/group-anagrams/">49. 字母异位词分组</a></h4>
<p>难度中等</p>
<p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li>所有输入均为小写字母。</li>
<li>不考虑答案输出的顺序。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>无非就是建一个字典，定义一个key，然后把所有字母异位词放到一个value里。</p>
<ol>
<li>
<p>手动哈希</p>
<p>把所有的字符串转换成自定义的键值</p>
<p>例如“sssdda”我就转换成“a1d2s3”，这样就可以很方便地存取</p>
</li>
<li>
<p>排序</p>
<p>所有字符串都按字母序排一遍序，这样子字母异位词就是同一个词了</p>
<p>事实证明排序比上面第一种方法快得多</p>
</li>
</ol>
<p><img src="https://cdn.ethanloo.cn/img/20201214095351.png" alt="image-20201214095207104"></p>
<p>​	排序🐂🍺嗷</p>
<p><strong>代码</strong></p>
<ol>
<li>哈希</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">groupAnagrams</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        <span class="comment"># 手动哈希</span></span><br><span class="line">        dic = <span class="built_in">dict</span>()</span><br><span class="line">        words = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> strs:</span><br><span class="line">            hash_code = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">                <span class="keyword">if</span> word.count(w)&gt;<span class="number">0</span>:</span><br><span class="line">                    hash_code += w+<span class="built_in">str</span>(word.count(w))</span><br><span class="line">            <span class="keyword">if</span> hash_code <span class="keyword">in</span> dic:</span><br><span class="line">                dic[hash_code].append(word)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[hash_code] = [word]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(dic.values())</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>排序</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">groupAnagrams</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        <span class="comment"># 排序</span></span><br><span class="line">        dic = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> strs:</span><br><span class="line">            hash_code = <span class="string">&quot;&quot;</span>.join(<span class="built_in">sorted</span>(word))</span><br><span class="line">            <span class="keyword">if</span> hash_code <span class="keyword">in</span> dic:</span><br><span class="line">                dic[hash_code].append(word)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[hash_code] = [word]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(dic.values())</span><br></pre></td></tr></table></figure>
<p><strong>12.13</strong></p>
<p>嚯，今天考csp，leetcode竟然给我放假</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="217-存在重复元素"><a href="https://leetcode-cn.com/problems/contains-duplicate/">217. 存在重复元素</a></h4>
<p>难度简单</p>
<p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任意一值在数组中出现至少两次，函数返回 <code>true</code> 。如果数组中每个元素都不相同，则返回 <code>false</code> 。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>哈希表</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)!=<span class="built_in">len</span>(<span class="built_in">set</span>(nums))</span><br></pre></td></tr></table></figure>
<p><strong>12.12</strong></p>
<p>美好的周末从看题解开始</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="376-摆动序列"><a href="https://leetcode-cn.com/problems/wiggle-subsequence/">376. 摆动序列</a></h4>
<p>难度中等</p>
<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为**摆动序列。**第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p>
<p>例如， <code>[1,7,4,9,2,5]</code> 是一个摆动序列，因为差值 <code>(6,-3,5,-7,3)</code> 是正负交替出现的。相反, <code>[1,4,7,2,5]</code> 和 <code>[1,7,4,5,5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p>
<p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,7,4,9,2,5]</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 整个序列均为摆动序列。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,17,5,10,13,15,10,5,16,8]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7,8,9]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p><strong>进阶:</strong><br>
你能否用 O(<em>n</em>) 时间复杂度完成此题</p>
</blockquote>
<p><strong>思路</strong></p>
<p>动态规划</p>
<ul>
<li>
<p>建立两个数组<code>up,down</code></p>
</li>
<li>
<p><code>up[i],down[i]</code>分别表示<code>nums</code>的前<code>i</code>个数字能够组成的最长子序列长度</p>
</li>
<li>
<p>其中<code>up</code>数组存储的子序列要求最后是上升的，<code>down</code>数组的子序列最后是下降的</p>
</li>
<li>
<p>base case</p>
<ul>
<li><code>up[0], down[0] = 1, 1</code></li>
</ul>
</li>
<li>
<p>状态转移</p>
<img src="https://cdn.ethanloo.cn/img/image-20201212091344652.png" alt="image-20201212091344652" style="zoom:67%;" />
</li>
<li>
<p>最后比较这两个数组中的最后一个值，大的那个就是答案</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wiggleMaxLength</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        up = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        down = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment"># 这两个数组用来记录遍历到i时的最大子序列长度</span></span><br><span class="line">        up[<span class="number">0</span>], down[<span class="number">0</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&lt;nums[i-<span class="number">1</span>]:</span><br><span class="line">                up[i] = up[i-<span class="number">1</span>]</span><br><span class="line">                down[i] = <span class="built_in">max</span>(down[i-<span class="number">1</span>], up[i-<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">elif</span> nums[i]&gt;nums[i-<span class="number">1</span>]:</span><br><span class="line">                up[i] = <span class="built_in">max</span>(down[i-<span class="number">1</span>]+<span class="number">1</span>, up[i-<span class="number">1</span>])</span><br><span class="line">                down[i] = down[i-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                up[i] = up[i-<span class="number">1</span>]</span><br><span class="line">                down[i] = down[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(down[n-<span class="number">1</span>], up[n-<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p><strong>12.11</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="649-Dota2-参议院"><a href="https://leetcode-cn.com/problems/dota2-senate/">649. Dota2 参议院</a></h4>
<p>难度中等</p>
<p>Dota2 的世界里有两个阵营：<code>Radiant</code>(天辉)和 <code>Dire</code>(夜魇)</p>
<p>Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的<code>**一**</code>项：</p>
<ol>
<li>
<p><code>禁止一名参议员的权利</code>：</p>
<p>参议员可以让另一位参议员在这一轮和随后的几轮中丧失<strong>所有的权利</strong>。</p>
</li>
<li>
<p><code>宣布胜利</code>：</p>
</li>
</ol>
<p>​     如果参议员发现有权利投票的参议员都是<strong>同一个阵营的</strong>，他可以宣布胜利并决定在游戏中的有关变化。</p>
<p>给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 <code>Radiant</code>（天辉）和 <code>Dire</code>（夜魇）。然后，如果有 <code>n</code> 个参议员，给定字符串的大小将是 <code>n</code>。</p>
<p>以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。</p>
<p>假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 <code>Radiant</code> 或 <code>Dire</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;RD&quot;</span><br><span class="line">输出：&quot;Radiant&quot;</span><br><span class="line">解释：第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;RDD&quot;</span><br><span class="line">输出：&quot;Dire&quot;</span><br><span class="line">解释：</span><br><span class="line">第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利</span><br><span class="line">第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止</span><br><span class="line">第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利</span><br><span class="line">因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>给定字符串的长度在 <code>[1, 10,000]</code> 之间.</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>双队列模拟投票即可，好困，睡了</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predictPartyVictory</span>(<span class="params">self, senate: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        senate_r, senate_d = [], []</span><br><span class="line">        n = <span class="built_in">len</span>(senate)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> senate[i] == <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">                senate_d.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                senate_r.append(i)</span><br><span class="line">        <span class="keyword">while</span> senate_r <span class="keyword">and</span> senate_d:</span><br><span class="line">            <span class="keyword">if</span> senate_r[<span class="number">0</span>] &lt; senate_d[<span class="number">0</span>]:</span><br><span class="line">                senate_r.append(senate_r[<span class="number">0</span>]+n)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                senate_d.append(senate_d[<span class="number">0</span>]+n)</span><br><span class="line">            senate_d.pop(<span class="number">0</span>)</span><br><span class="line">            senate_r.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> senate_r: <span class="keyword">return</span> <span class="string">&quot;Radiant&quot;</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="string">&quot;Dire&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>12.10</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="860-柠檬水找零"><a href="https://leetcode-cn.com/problems/lemonade-change/">860. 柠檬水找零</a></h4>
<p>难度简单</p>
<p>在柠檬水摊上，每一杯柠檬水的售价为 <code>5</code> 美元。</p>
<p>顾客排队购买你的产品，（按账单 <code>bills</code> 支付的顺序）一次购买一杯。</p>
<p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。</p>
<p>注意，一开始你手头没有任何零钱。</p>
<p>如果你能给每位顾客正确找零，返回 <code>true</code> ，否则返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[5,5,5,10,20]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。</span><br><span class="line">第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。</span><br><span class="line">第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。</span><br><span class="line">由于所有客户都得到了正确的找零，所以我们输出 true。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[5,5,10]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[10,10]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[5,5,10,10,20]</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。</span><br><span class="line">对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。</span><br><span class="line">对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。</span><br><span class="line">由于不是每位顾客都得到了正确的找零，所以答案是 false。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= bills.length &lt;= 10000</code></li>
<li><code>bills[i]</code> 不是 <code>5</code> 就是 <code>10</code> 或是 <code>20</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>经典老番，模拟即可</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lemonadeChange</span>(<span class="params">self, bills: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        dic = <span class="built_in">dict</span>()</span><br><span class="line">        dic[<span class="number">5</span>], dic[<span class="number">10</span>] = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> bills:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">5</span>:</span><br><span class="line">                dic[<span class="number">5</span>] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i == <span class="number">10</span>:</span><br><span class="line">                <span class="keyword">if</span> dic[<span class="number">5</span>]==<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dic[<span class="number">5</span>] -= <span class="number">1</span></span><br><span class="line">                    dic[<span class="number">10</span>] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> dic[<span class="number">10</span>]&gt;<span class="number">0</span> <span class="keyword">and</span> dic[<span class="number">5</span>]&gt;<span class="number">0</span>:</span><br><span class="line">                    dic[<span class="number">10</span>] -=<span class="number">1</span></span><br><span class="line">                    dic[<span class="number">5</span>]-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> dic[<span class="number">5</span>]&gt;=<span class="number">3</span>:</span><br><span class="line">                    dic[<span class="number">5</span>] -=<span class="number">3</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><strong>12.9</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="62-不同路径"><a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a></h4>
<p>难度中等</p>
<p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p>
<p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p>
<p>问总共有多少条不同的路径？</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 7</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 7, n = 3</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= m, n &lt;= 100</code></li>
<li>题目数据保证答案小于等于 <code>2 * 109</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>蛮经典的题目，一开始直接套递归，结果超时了</p>
<p>动态规划轻松ac</p>
<ul>
<li>
<p>定义dp数组</p>
<ul>
<li><code>dp[i][j]代表了从0,0到i,j有多少种走法</code></li>
</ul>
</li>
<li>
<p>状态转移</p>
<ul>
<li>因为只能向下走或者向右走，所以每格的走法就是上面一格的走法加左边一格的走法</li>
<li><code>dp[i][j]=dp[i-1][j]+dp[i][j-1]</code></li>
</ul>
</li>
<li>
<p>base case</p>
<ul>
<li>将<code>dp[0,0]</code>定义为1，因为我们从起点出发，就一种走法</li>
</ul>
</li>
<li>
<p>遍历更新整个<code>dp</code>数组即可，最后<code>dp[m-1][n-1]</code>就是我们的答案</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        paths = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        paths[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                tmp = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">and</span> j==<span class="number">0</span>:</span><br><span class="line">                    tmp += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span>:</span><br><span class="line">                    tmp += paths[i-<span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">if</span> j&gt;<span class="number">0</span>:</span><br><span class="line">                    tmp += paths[i][j-<span class="number">1</span>]</span><br><span class="line">                paths[i][j] = tmp</span><br><span class="line">        <span class="keyword">return</span> paths[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p><strong>12.8</strong></p>
<p>巧了嘛这不是，昨天刚好在复习回溯法解N皇后</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="842-将数组拆分成斐波那契序列"><a href="https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/">842. 将数组拆分成斐波那契序列</a></h4>
<p>难度中等</p>
<p>给定一个数字字符串 <code>S</code>，比如 <code>S = &quot;123456579&quot;</code>，我们可以将它分成斐波那契式的序列 <code>[123, 456, 579]</code>。</p>
<p>形式上，斐波那契式序列是一个非负整数列表 <code>F</code>，且满足：</p>
<ul>
<li><code>0 &lt;= F[i] &lt;= 2^31 - 1</code>，（也就是说，每个整数都符合 32 位有符号整数类型）；</li>
<li><code>F.length &gt;= 3</code>；</li>
<li>对于所有的<code>0 &lt;= i &lt; F.length - 2</code>，都有 <code>F[i] + F[i+1] = F[i+2]</code> 成立。</li>
</ul>
<p>另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。</p>
<p>返回从 <code>S</code> 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 <code>[]</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;123456579&quot;</span><br><span class="line">输出：[123,456,579]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;11235813&quot;</span><br><span class="line">输出: [1,1,2,3,5,8,13]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;112358130&quot;</span><br><span class="line">输出: []</span><br><span class="line">解释: 这项任务无法完成。</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&quot;0123&quot;</span><br><span class="line">输出：[]</span><br><span class="line">解释：每个块的数字不能以零开头，因此 &quot;01&quot;，&quot;2&quot;，&quot;3&quot; 不是有效答案。</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: &quot;1101111&quot;</span><br><span class="line">输出: [110, 1, 111]</span><br><span class="line">解释: 输出 [11,0,11,11] 也同样被接受。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= S.length &lt;= 200</code></li>
<li>字符串 <code>S</code> 中只含有数字。</li>
</ol>
</blockquote>
<p><strong>思路</strong></p>
<p>就是常规的深搜+剪枝</p>
<ul>
<li>
<p><code>result</code>用来存放可能的序列</p>
</li>
<li>
<p><code>nums</code>数组中存放已经存入当前序列的数字</p>
</li>
<li>
<p><code>index</code>用来标记当前应该从<code>S</code>的哪个位置开始遍历</p>
</li>
<li>
<p>递归函数<code>dfs</code></p>
<ul>
<li>结束条件
<ul>
<li>当前的<code>index</code>已经为<code>S</code>的长度时，说明我们已经遍历完整个字符串了</li>
<li>如果当前的<code>nums</code>的长度≥3，说明这个序列是合理的，放到<code>result</code>中</li>
<li>无论合理不合理，最后都需要退出递归</li>
</ul>
</li>
<li>可能路径
<ul>
<li>如果当前<code>nums</code>的长度小于2，则从<code>index</code>开始，后面能组成的数字都是合理的，都可以加入路径继续搜索</li>
<li>如果<code>nums</code>的长度≥2，则需要保证后面的数字是等于<code>nums</code>数组中最后两个数字之和，才可以加入路径继续搜索</li>
</ul>
</li>
<li>剪枝
<ul>
<li>按照题目说明，如果我现在组成的数字是<code>0</code>开头，且长度大于1，就直接退出递归</li>
<li>同理，如果当前尝试组成的数字大于2^31-1，也要退出递归</li>
<li>同时，如果我当前组成的数字，已经超过了<code>nums</code>数组中最后两个数字之和，也是退出递归</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">splitIntoFibonacci</span>(<span class="params">self, S: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">nums, index</span>):</span><br><span class="line">            <span class="keyword">if</span> index == <span class="built_in">len</span>(S) <span class="keyword">and</span> <span class="built_in">len</span>(nums)&gt;=<span class="number">3</span>:</span><br><span class="line">                res.append(nums)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">elif</span> index&gt;= <span class="built_in">len</span>(S):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;<span class="number">2</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index+<span class="number">1</span>, <span class="built_in">len</span>(S)+<span class="number">1</span>):</span><br><span class="line">                    cur_num = <span class="built_in">int</span>(S[index:i])</span><br><span class="line">                    <span class="keyword">if</span> i&gt;index+<span class="number">1</span> <span class="keyword">and</span> S[index]==<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> cur_num&gt;<span class="number">2147483647</span>:</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    dfs(nums+[cur_num], i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                target = nums[-<span class="number">1</span>]+nums[-<span class="number">2</span>]</span><br><span class="line">                <span class="keyword">if</span> target&gt;<span class="number">2147483647</span>:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index+<span class="number">1</span>, <span class="built_in">len</span>(S)+<span class="number">1</span>):</span><br><span class="line">                    cur_num = <span class="built_in">int</span>(S[index:i])</span><br><span class="line">                    <span class="keyword">if</span> (i&gt;index+<span class="number">1</span> <span class="keyword">and</span> S[index]==<span class="string">&#x27;0&#x27;</span>):</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    <span class="keyword">if</span> cur_num&lt;target:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">elif</span> cur_num == target:</span><br><span class="line">                        dfs(nums+[cur_num], i)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">        dfs([], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>] <span class="keyword">if</span> res <span class="keyword">else</span> []</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p><strong>12.7</strong></p>
<blockquote>
<h4 id="861-翻转矩阵后的得分"><a href="https://leetcode-cn.com/problems/score-after-flipping-matrix/">861. 翻转矩阵后的得分</a></h4>
<p>难度中等</p>
<p>有一个二维矩阵 <code>A</code> 其中每个元素的值为 <code>0</code> 或 <code>1</code> 。</p>
<p>移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 <code>0</code> 都更改为 <code>1</code>，将所有 <code>1</code> 都更改为 <code>0</code>。</p>
<p>在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。</p>
<p>返回尽可能高的分数。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]</span><br><span class="line">输出：39</span><br><span class="line">解释：</span><br><span class="line">转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]</span><br><span class="line">0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 20</code></li>
<li><code>1 &lt;= A[0].length &lt;= 20</code></li>
<li><code>A[i][j]</code> 是 <code>0</code> 或 <code>1</code></li>
</ol>
</blockquote>
<p><strong>思路</strong></p>
<p>贪心法</p>
<ul>
<li>首先通过行的移动保证每行第一个元素为1</li>
<li>然后对第一列以后的所有列进行移动
<ul>
<li>保证每列的1比0多</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">matrixScore</span>(<span class="params">self, A: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 先通过行变化把第一列全部变成1</span></span><br><span class="line">        rows, cols = <span class="built_in">len</span>(A), <span class="built_in">len</span>(A[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">if</span> A[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                    A[i][j] = <span class="number">1</span>-A[i][j]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 再进行列变化使后面的列的1的个数尽可能多</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,cols):</span><br><span class="line">            cnt_one, cnt_zero = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">                <span class="keyword">if</span> A[i][j] == <span class="number">1</span>: cnt_one += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: cnt_zero += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt_zero&gt;cnt_one:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">                    A[i][j] = <span class="number">1</span>-A[i][j]</span><br><span class="line">        <span class="comment"># 求和</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> A:</span><br><span class="line">            tmp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                tmp += row[j]*<span class="number">2</span>**(cols-j-<span class="number">1</span>)</span><br><span class="line">            res += tmp</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>12.6</strong></p>
<p>好久没做简单题了👶</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="118-杨辉三角"><a href="https://leetcode-cn.com/problems/pascals-triangle/">118. 杨辉三角</a></h4>
<p>难度简单</p>
<p>给定一个非负整数 *numRows，*生成杨辉三角的前 <em>numRows</em> 行。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="img"></p>
<p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>
<p>没啥思路，模拟就完事儿了</p>
<blockquote>
<p>因为不小心把两层循环都写成了<code>i</code>，调试了半天😓</p>
</blockquote>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">self, numRows: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        last_row= []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numRows):</span><br><span class="line">            cur_row = [<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(last_row)-<span class="number">1</span>):</span><br><span class="line">                cur_row.append(last_row[j]+last_row[j+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span>:</span><br><span class="line">                cur_row.append(<span class="number">1</span>)</span><br><span class="line">            res.append(cur_row)</span><br><span class="line">            last_row = cur_row</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>12.5</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="621-任务调度器"><a href="https://leetcode-cn.com/problems/task-scheduler/">621. 任务调度器</a></h4>
<p>难度中等</p>
<p>给你一个用字符数组 <code>tasks</code> 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</p>
<p>然而，两个 <strong>相同种类</strong> 的任务之间必须有长度为整数 <code>n</code> 的冷却时间，因此至少有连续 <code>n</code> 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p>
<p>你需要计算完成所有任务所需要的 <strong>最短时间</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 2</span><br><span class="line">输出：8</span><br><span class="line">解释：A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B</span><br><span class="line">     在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 </span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 0</span><br><span class="line">输出：6</span><br><span class="line">解释：在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0</span><br><span class="line">[&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;]</span><br><span class="line">[&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;]</span><br><span class="line">[&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;]</span><br><span class="line">...</span><br><span class="line">诸如此类</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;], n = 2</span><br><span class="line">输出：16</span><br><span class="line">解释：一种可能的解决方案是：</span><br><span class="line">     A -&gt; B -&gt; C -&gt; A -&gt; D -&gt; E -&gt; A -&gt; F -&gt; G -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= task.length &lt;= 104</code></li>
<li><code>tasks[i]</code> 是大写英文字母</li>
<li><code>n</code> 的取值范围为 <code>[0, 100]</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>自己写了个模拟的方法，时间复杂度O(nlogn)，结果超过8%😓</p>
<p>标准数学解法的时间复杂度是O(N)</p>
<ul>
<li>我们把时间分成一块儿一块儿的，每一块为n+1
<ul>
<li>完成任务相当于往每个时间快内加入一个任务</li>
<li>这样做的话，最后一个时间块内(最后一个时间块长度&lt;=n+1)，我们必定需要完成那个次数最多的任务
<ul>
<li>比如我总共需要做3次A，2次B，1次C，n设为3，那么我最后一个时间块内必定要完成A任务，且只需要完成A任务即可结束</li>
</ul>
</li>
<li>所以，我们只要求出某个任务出现的最大次数，就能知道我们要分多少个块</li>
<li>求出块数之后，只要确定最后一个时间块的大小，即可确定完成所有任务所需时间</li>
</ul>
</li>
<li>最后一个时间块的大小 = 出现次数为最大次数的任务个数
<ul>
<li>比如3次A，2次B，1次C，那么最后一个时间块只需要完成一个A</li>
<li>3次A，10次B，10次C，那么最后一个时间块内就需要完成B和C</li>
</ul>
</li>
<li>因此，我们只需要确定任务出现的最大次数，以及最大次数的任务个数，即可直接求出所需要总时间</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">leastInterval</span>(<span class="params">self, tasks: <span class="type">List</span>[<span class="built_in">str</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dic = collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tasks:</span><br><span class="line">            dic[i] += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 任务的最大次数</span></span><br><span class="line">        max_cnt = <span class="built_in">max</span>(dic.values())</span><br><span class="line">        <span class="comment"># 最大次数任务的个数</span></span><br><span class="line">        max_job = <span class="built_in">len</span>([i <span class="keyword">for</span> i <span class="keyword">in</span> dic <span class="keyword">if</span> dic[i]==max_cnt])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>((n+<span class="number">1</span>)*(max_cnt-<span class="number">1</span>)+max_job, <span class="built_in">len</span>(tasks))</span><br></pre></td></tr></table></figure>
<p><strong>12.4</strong></p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="659-分割数组为连续子序列"><a href="https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences/">659. 分割数组为连续子序列</a></h4>
<p>难度中等</p>
<p>给你一个按升序排序的整数数组 <code>num</code>（可能包含重复数字），请你将它们分割成一个或多个子序列，其中每个子序列都由连续整数组成且长度至少为 3 。</p>
<p>如果可以完成上述分割，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,3,4,5]</span><br><span class="line">输出: True</span><br><span class="line">解释:</span><br><span class="line">你可以分割出这样两个连续子序列 : </span><br><span class="line">1, 2, 3</span><br><span class="line">3, 4, 5</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,3,4,4,5,5]</span><br><span class="line">输出: True</span><br><span class="line">解释:</span><br><span class="line">你可以分割出这样两个连续子序列 : </span><br><span class="line">1, 2, 3, 4, 5</span><br><span class="line">3, 4, 5</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,4,5]</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li>输入的数组长度范围为 [1, 10000]</li>
</ol>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>贪心法
<ul>
<li>构建两个字典
<ul>
<li>一个计数字典<code>nc</code></li>
<li>一个子序列字典<code>tail</code>
<ul>
<li><code>tail[num]=i表示有i个以num为结尾的子序列</code></li>
</ul>
</li>
</ul>
</li>
<li>遍历<code>nums</code>
<ul>
<li>设当前遍历的数为<code>num</code></li>
<li>如果当前这个数字已经被用掉了，即<code>nc[num]==0</code>，直接跳过</li>
<li>否则，查看一下有没有以<code>num-1</code>为结尾的子序列，即<code>tail[num-1]&gt;0</code>
<ul>
<li>如果有，则增加一条以<code>num</code>为结尾的子序列，同时要去掉一条以<code>num-1</code>为结尾的子序列</li>
</ul>
</li>
<li>如果没有，就尝试构建一条新的子序列，以<code>num</code>为首部，跟上<code>num+1</code>和<code>num+2</code>，用掉对应的数字，然后增加一条以<code>num+2</code>为结尾的子序列</li>
<li>如果无法延长已有子序列也无法构建新序列，就返回False</li>
</ul>
</li>
<li>成功遍历完，就返回True</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPossible</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        nc, tail = defaultdict(<span class="built_in">int</span>), defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            nc[num] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> nc[num] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> tail[num-<span class="number">1</span>]:</span><br><span class="line">                nc[num] -= <span class="number">1</span></span><br><span class="line">                tail[num-<span class="number">1</span>] -=<span class="number">1</span></span><br><span class="line">                tail[num] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> tail[num-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> nc[num] <span class="keyword">and</span> nc[num+<span class="number">1</span>] <span class="keyword">and</span> nc[num+<span class="number">2</span>]:</span><br><span class="line">                    tail[num+<span class="number">2</span>] += <span class="number">1</span></span><br><span class="line">                    nc[num] -= <span class="number">1</span></span><br><span class="line">                    nc[num+<span class="number">1</span>] -=<span class="number">1</span></span><br><span class="line">                    nc[num+<span class="number">2</span>] -=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p><strong>12.3</strong></p>
<blockquote>
<h4 id="204-计数质数"><a href="https://leetcode-cn.com/problems/count-primes/">204. 计数质数</a></h4>
<p>难度简单</p>
<p>统计所有小于非负整数 <em><code>n</code></em> 的质数的数量。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 10</span><br><span class="line">输出：4</span><br><span class="line">解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= n &lt;= 5 * 106</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>假设2为质数，那么2的倍数就都不是质数</li>
<li>假设3为质数，那么3的倍数就都不是质数</li>
<li>低效率的实现方法（我一开始写的）
<ul>
<li>新建一个集合<code>nums</code>，把<code>[2,n-1]</code>中的全部数字放进去</li>
<li>然后遍历<code>[2,n-1]</code>
<ul>
<li>如果当前遍历的数字<code>x</code>还在<code>nums</code>中，就把<code>x</code>的倍数全部删掉</li>
<li>同时统计删除的个数</li>
</ul>
</li>
<li>计算总共删掉的个数和总的数字个数，得出素数个数</li>
</ul>
</li>
<li>改进后的方法
<ul>
<li>新建一个数组<code>nums</code>，长度为<code>n</code>，初始化所有元素为1</li>
<li>遍历<code>[2,n-1]</code>
<ul>
<li>如果<code>nums[x]==1</code>，说明这个数字为质数，计数器+1</li>
<li>因为这个数字是质数，所以对它的倍数进行删除操作，全部置为0</li>
</ul>
</li>
<li>最后返回计数器</li>
</ul>
</li>
</ul>
<blockquote>
<p>一开始我以为是集合导致的速度慢，但是我把方法1改成了数组实现还是很慢</p>
<p>应该是进行了太多次加减计算？</p>
</blockquote>
<p><strong>代码</strong></p>
<ul>
<li>方法1</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nums = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n):</span><br><span class="line">            nums.add(i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">del_num</span>(<span class="params">nums, num</span>):</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*num,n+<span class="number">1</span>,num):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> nums:</span><br><span class="line">                    nums.remove(i)</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> cnt</span><br><span class="line">        res = n-<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n):</span><br><span class="line">            res -= del_num(nums, i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<ul>
<li>方法2</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n):</span><br><span class="line">            <span class="keyword">if</span> nums[i]:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*i,n,i):</span><br><span class="line">                    nums[j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
<p><strong>12.2</strong></p>
<p>手动裂开（自行脑补微信新表情）</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="321-拼接最大数"><a href="https://leetcode-cn.com/problems/create-maximum-number/">321. 拼接最大数</a></h4>
<p>难度困难</p>
<p>给定长度分别为 <code>m</code> 和 <code>n</code> 的两个数组，其元素由 <code>0-9</code> 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 <code>k (k &lt;= m + n)</code> 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。</p>
<p>求满足该条件的最大数。结果返回一个表示该最大数的长度为 <code>k</code> 的数组。</p>
<p><strong>说明:</strong> 请尽可能地优化你算法的时间和空间复杂度。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 = [3, 4, 6, 5]</span><br><span class="line">nums2 = [9, 1, 2, 5, 8, 3]</span><br><span class="line">k = 5</span><br><span class="line">输出:</span><br><span class="line">[9, 8, 6, 5, 3]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 = [6, 7]</span><br><span class="line">nums2 = [6, 0, 4]</span><br><span class="line">k = 5</span><br><span class="line">输出:</span><br><span class="line">[6, 7, 6, 0, 4]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 = [3, 9]</span><br><span class="line">nums2 = [8, 9]</span><br><span class="line">k = 3</span><br><span class="line">输出:</span><br><span class="line">[9, 8, 9]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>是真的看不出来该怎么做</p>
<p>根据题解写个大概思路</p>
<ul>
<li>
<p>参考了<a href="https://leetcode-cn.com/problems/create-maximum-number/solution/pin-jie-zui-da-shu-by-leetcode-solution/">官方题解</a>和<a href="https://leetcode-cn.com/problems/create-maximum-number/solution/321pin-jie-zui-da-shu-by-heydom/">这个兄弟的题解</a></p>
</li>
<li>
<p>要从两个数组中挑选<code>k</code>个数字出来，拼成最大序列，总体来说需要两步</p>
<ol>
<li>从第一个数组中挑选<code>i</code>个数字组成最大子序列<code>seq1</code>，从第二个数组中挑选<code>k-i</code>个数字组成最大子序列<code>seq2</code></li>
<li>根据某种规则，把这两个最大子序列合并成一个最大子序列</li>
</ol>
</li>
<li>
<p>✨从数组<code>nums</code>中，找出长度为<code>size</code>的最大子序列方法</p>
<ul>
<li>新建一个空栈<code>stk</code></li>
<li>设定一个最大抛弃值<code>drop</code>
<ul>
<li><code>drop=数组的长度-size</code></li>
</ul>
</li>
<li>遍历<code>nums</code>中的数字
<ul>
<li>如果栈非空，且当前遍历的数字比栈顶元素大
<ul>
<li>就一直抛弃栈顶元素，每次抛弃一个元素，<code>drop -= 1</code></li>
<li>直到栈空或者<code>drop=0</code></li>
</ul>
</li>
<li>把当前遍历的这个数字放到栈里</li>
</ul>
</li>
<li>返回栈的前<code>size</code>个数字，就是最大子序列</li>
</ul>
</li>
<li>
<p>✨把两个最大子序列<code>seq1和seq2</code>合并成一个最大子序列的方法</p>
<ul>
<li>
<p>不断从<code>seq1</code>或者<code>seq2</code>中取首部的数字</p>
<ul>
<li>
<p>每次从字典序大的那个子序列中取数字</p>
</li>
<li>
<p>python中两个数组直接对比，获得是按字典序比较的结果</p>
<blockquote>
<p>比如[2,7,1,4]&gt;[2,3,3,6]，因为这里的第0位相等，第1位上3&gt;1</p>
</blockquote>
</li>
<li>
<p>这么做的原因是能保证每次取完数字之后，下一次比较的时候能取到尽可能大的数</p>
<blockquote>
<p>如果我先从[2,3,3,6]中取了首数字，第二步就变成了从[3,3,6]和[2,7,1,4]中取数字</p>
<p>这样合并出来的子序列就从<code>2-&gt;7</code>变成了<code>2-&gt;3</code>，那就不是最大子序列了</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>每次取完首部数字之后，记得要把这个数字给移除</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>小生愚钝，不吝赐教，欢迎指教</p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxNumber</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 找到最大子序列的方法</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_max_sequence</span>(<span class="params">nums, size</span>):</span><br><span class="line">            <span class="comment"># 从nums数组中，找到长度为size的最大子序列</span></span><br><span class="line">            <span class="comment"># 利用栈</span></span><br><span class="line">            stk = []</span><br><span class="line">            <span class="comment"># drop是用来保证最后的子序列长度不小于size</span></span><br><span class="line">            drop = <span class="built_in">len</span>(nums)-size</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">while</span> drop <span class="keyword">and</span> stk <span class="keyword">and</span> stk[-<span class="number">1</span>]&lt;num:</span><br><span class="line">                    stk.pop()</span><br><span class="line">                    drop -=<span class="number">1</span></span><br><span class="line">                stk.append(num)</span><br><span class="line">            <span class="keyword">return</span> stk[:size]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">seq1, seq2</span>):</span><br><span class="line">            <span class="comment"># 把两个最大子序列合并成一个最大子序列</span></span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">while</span> seq1 <span class="keyword">or</span> seq2:</span><br><span class="line">                <span class="comment"># 每次加入一个较大子序列的首位数</span></span><br><span class="line">                tmp = seq1 <span class="keyword">if</span> seq1&gt;seq2 <span class="keyword">else</span> seq2</span><br><span class="line">                res.append(tmp[<span class="number">0</span>])</span><br><span class="line">                <span class="comment"># 插入一个数字之后要删掉原序列中的数字</span></span><br><span class="line">                tmp.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环两个子序列的可能长度</span></span><br><span class="line">        res = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i&lt;=<span class="built_in">len</span>(nums1) <span class="keyword">and</span> k-i&lt;=<span class="built_in">len</span>(nums2):</span><br><span class="line">                tmp = merge(get_max_sequence(nums1, i), get_max_sequence(nums2, k-i))</span><br><span class="line">                res = <span class="built_in">max</span>(res, tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><strong>12.1</strong></p>
<p>美好的一天从偷懒开始</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h4>
<p>难度中等691</p>
<p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p>
<p><strong>进阶：</strong></p>
<ul>
<li>你可以设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题吗？</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= nums.length &lt;= 105</code></li>
<li><code>-109 &lt;= nums[i] &lt;= 109</code></li>
<li><code>nums</code> 是一个非递减数组</li>
<li><code>-109 &lt;= target &lt;= 109</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>面试官觉得很无聊的两个思路
<ol>
<li>从头开始遍历，从尾部开始遍历，找到数字出现的两个位置</li>
<li>用python封装好的方法，先正序用index方法找到target的第一次出现位置，再把数组逆序一下找到target的第一次出现位置</li>
</ol>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> target <span class="keyword">not</span> <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [nums.index(target), <span class="built_in">len</span>(nums)-<span class="number">1</span>-nums[::-<span class="number">1</span>].index(target)]</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>但止步于这两个无脑方法肯定是不行的</p>
</li>
<li>
<p>看进阶的时间复杂度要求 <code>O(log n)</code>就知道肯定是二分，相当于把python封装的方法自己实现一遍</p>
<blockquote>
<p>自己写一个二分能因为细节提交错好多次</p>
</blockquote>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>,-<span class="number">1</span>]</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        index = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;=right:</span><br><span class="line">            mid = (left+right+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]==target:</span><br><span class="line">                index = mid</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&gt;target:</span><br><span class="line">                right = mid-<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> index==-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>,-<span class="number">1</span>]</span><br><span class="line">        start, end = index, index</span><br><span class="line">        <span class="keyword">while</span> start&gt;=<span class="number">0</span> <span class="keyword">and</span> nums[start]==target:</span><br><span class="line">            start -= <span class="number">1</span></span><br><span class="line">        start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> end&lt;<span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[end]==target:</span><br><span class="line">            end+=<span class="number">1</span></span><br><span class="line">        end-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [start, end]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题日志</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Java实现多线程矩阵相乘</title>
    <url>/post/2020-11-26-Algorithm/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%B9%98/</url>
    <content><![CDATA[<h3 id="单线程计算矩阵相乘">单线程计算矩阵相乘</h3>
<blockquote>
<p>开发一个单线程的程序，分别计算不同规模矩阵的乘积，并记录矩阵相乘花费的时间；</p>
</blockquote>
<h4 id="从文件中读取矩阵的方法">从文件中读取矩阵的方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">readMatrix</span><span class="params">(<span class="type">double</span>[][] matrix, String fileName)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">pathName</span> <span class="operator">=</span> <span class="string">&quot;./mx/&quot;</span> + fileName + <span class="string">&quot;.txt&quot;</span>;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(pathName); <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(fr)) &#123;</span><br><span class="line">        String line;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cntLine</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            String[] nums = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">                matrix[cntLine][i] = Double.valueOf(nums[i]).doubleValue();</span><br><span class="line">            &#125;</span><br><span class="line">            cntLine++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="两矩阵相乘的方法">两矩阵相乘的方法</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span>[][] multiple(<span class="type">double</span>[][] matrixA, <span class="type">double</span>[][] matrixB) &#123;</span><br><span class="line">    <span class="comment">// 串行进行矩阵乘法</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> matrixA.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> matrixA[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">double</span>[][] res = <span class="keyword">new</span> <span class="title class_">double</span>[rows][cols];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; cols; k++) &#123;</span><br><span class="line">                res[i][j] += matrixA[i][k] * matrixB[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="main函数">main函数</h4>
<ul>
<li>根据不同的规格读取矩阵文件</li>
<li>进行矩阵乘法计算</li>
<li>输出计算的耗时</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] sizes = &#123;<span class="number">64</span>,<span class="number">128</span>,<span class="number">512</span>,<span class="number">1024</span>&#125;;</span><br><span class="line">    Date start,end;</span><br><span class="line">    <span class="type">double</span>[][] matrixA= <span class="keyword">new</span> <span class="title class_">double</span>[size][size];;</span><br><span class="line">    <span class="type">double</span>[][] matrixB= <span class="keyword">new</span> <span class="title class_">double</span>[size][size];;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;sizes.length;i++)&#123;</span><br><span class="line">        size = sizes[i];</span><br><span class="line">        matrixA = <span class="keyword">new</span> <span class="title class_">double</span>[size][size];</span><br><span class="line">        matrixB = <span class="keyword">new</span> <span class="title class_">double</span>[size][size];</span><br><span class="line">        start = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        readMatrix(matrixA, <span class="string">&quot;M&quot;</span> + size + <span class="string">&quot;A&quot;</span>);</span><br><span class="line">        readMatrix(matrixB, <span class="string">&quot;M&quot;</span> + size + <span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="type">double</span>[][] ans = multiple(matrixA, matrixB);</span><br><span class="line">        end = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;单线程串行计算&quot;</span> + size + <span class="string">&quot;x&quot;</span> + size + <span class="string">&quot;矩阵乘法耗时：&quot;</span> + (end.getTime() - start.getTime()) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运行结果">运行结果</h4>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201110225637.png" alt="image-20201110225637263"></p>
<h4 id="结果分析">结果分析</h4>
<p><strong>算法复杂度分析</strong></p>
<ul>
<li>
<p>矩阵相乘的时间复杂度为O(N³)</p>
</li>
<li>
<p>64x64矩阵相乘大约需要运算260 000次=2.6x10^5^</p>
</li>
<li>
<p>128x128矩阵相乘大约需要运算2 100 000次=2.1x10^6^</p>
</li>
<li>
<p>512x512矩阵相乘大约需要运算130 000 000次=1.3x10^8^</p>
</li>
<li>
<p>1024x1024矩阵相乘大约需要运算1 070 000 000次=1.07x10^9^</p>
</li>
</ul>
<p><strong>运行环境分析</strong></p>
<ul>
<li>
<p>笔记本CPU i5-8250U 四核八线程 主频1.6GHz = 每秒计算上限为1.6x10^9^</p>
</li>
<li>
<p>由于当前是单线程运行，所以理论上限应该是每秒运算2x10^8^次</p>
</li>
<li>
<p>加上笔记本CPU会自动降频以减少能耗，所以实际的运算速度会比理论上限低</p>
</li>
</ul>
<p><strong>运行结果分析</strong></p>
<ul>
<li><code>各规格矩阵相乘耗时</code> 基本和 <code>理论计算值÷理论计算速度</code> 吻合</li>
</ul>
<h3 id="四线程计算矩阵相乘">四线程计算矩阵相乘</h3>
<blockquote>
<p>开发一个 4 线程的程序，分别计算 16x16 128x128 512x512 矩阵的乘积，并记录矩阵相乘花费的时间；</p>
</blockquote>
<h4 id="定义运算线程类">定义运算线程类</h4>
<ul>
<li>每个线程需要被分配各自的任务来实现多线程矩阵计算</li>
<li>比如新建2个线程，一个矩阵应该负责1,3,5…列的计算，另一个矩阵负责2,4,6…列的计算</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MatrixThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span>[][] A;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span>[][] B;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span>[][] C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MatrixThread</span><span class="params">(<span class="type">int</span> start, <span class="type">double</span>[][] A, <span class="type">double</span>[][] B, <span class="type">double</span>[][] C)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.A = A;</span><br><span class="line">        <span class="built_in">this</span>.B = B;</span><br><span class="line">        <span class="built_in">this</span>.C = C;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 根据线程数量划分线程任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; MatrixMultiple.size; i += MatrixMultiple.totalThreads) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; MatrixMultiple.size; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; MatrixMultiple.size; k++) &#123;</span><br><span class="line">                    C[i][j] += A[i][k] * B[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用所定义的线程计算矩阵">使用所定义的线程计算矩阵</h4>
<ul>
<li>建立线程数组</li>
<li>初始化每个线程</li>
<li>启动每个线程</li>
<li>在线程运行完之后终止线程</li>
<li>检验多线程计算的矩阵结果和单线程计算的结果是否相同</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] sizes = &#123; <span class="number">64</span>, <span class="number">128</span>, <span class="number">512</span>, <span class="number">1024</span> &#125;;</span><br><span class="line">    Date start, end;</span><br><span class="line">    <span class="type">double</span>[][] matrixA = <span class="keyword">new</span> <span class="title class_">double</span>[size][size];</span><br><span class="line">    <span class="type">double</span>[][] matrixB = <span class="keyword">new</span> <span class="title class_">double</span>[size][size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; sizes.length; k++) &#123;</span><br><span class="line">        size = sizes[k];</span><br><span class="line">        matrixA = <span class="keyword">new</span> <span class="title class_">double</span>[size][size];</span><br><span class="line">        matrixB = <span class="keyword">new</span> <span class="title class_">double</span>[size][size];</span><br><span class="line">        start = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        readMatrix(matrixA, <span class="string">&quot;M&quot;</span> + size + <span class="string">&quot;A&quot;</span>);</span><br><span class="line">        readMatrix(matrixB, <span class="string">&quot;M&quot;</span> + size + <span class="string">&quot;B&quot;</span>);</span><br><span class="line">        <span class="type">double</span>[][] ans = multiple(matrixA, matrixB);</span><br><span class="line">        end = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">time1</span> <span class="operator">=</span> end.getTime() - start.getTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;单线程串行计算&quot;</span> + size + <span class="string">&quot;x&quot;</span> + size + <span class="string">&quot;矩阵乘法耗时：&quot;</span> + time1 + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> <span class="title class_">Thread</span>[totalThreads]; <span class="comment">// 线程组</span></span><br><span class="line">        <span class="type">double</span>[][] matrixC = <span class="keyword">new</span> <span class="title class_">double</span>[size][size]; <span class="comment">// 存放答案数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalThreads; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MatrixThread</span>(i, matrixA, matrixB, matrixC)); <span class="comment">// 初始化每个线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        start = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalThreads; i++) &#123;</span><br><span class="line">            threads[i].start(); <span class="comment">// 启动每个线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; totalThreads; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                threads[i].join(); <span class="comment">// 当线程结束时就终止线程</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        end = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        <span class="type">long</span> <span class="variable">time2</span> <span class="operator">=</span> end.getTime() - start.getTime();</span><br><span class="line">        System.out.println(</span><br><span class="line">            totalThreads + <span class="string">&quot;线程并行计算&quot;</span> + size + <span class="string">&quot;x&quot;</span> + size + <span class="string">&quot;矩阵乘法耗时：&quot;</span> + time2 + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">rate</span> <span class="operator">=</span> <span class="number">1.0</span>*(time1-time2)/time1;</span><br><span class="line">        System.out.printf(</span><br><span class="line">            totalThreads + <span class="string">&quot;线程并行计算&quot;</span> + size + <span class="string">&quot;x&quot;</span> + size + <span class="string">&quot;矩阵乘法的节约时间比例为%.2f\n&quot;</span>, rate);</span><br><span class="line">        <span class="comment">// 对多线程计算结果进行检验</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ans[i][j] != matrixC[i][j]) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;行&quot;</span> + <span class="string">&quot;第&quot;</span> + j + <span class="string">&quot;列不相等&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="运行结果-2">运行结果</h4>
<ul>
<li>多次运行以避免偶然性和减少误差</li>
</ul>
<center class="half">    <img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201113105022.png" width="300"/>    <img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201113105227.png" width="300"/>    <img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201113105307.png" width="300"/> </center>
<blockquote>
<p>当前耗时只考虑多线程计算的时间，没有把创建线程和初始化线程的时间算进去</p>
</blockquote>
<ul>
<li>可以看到四线程运行并不能跑满CPU利用率</li>
</ul>
<img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201126230925.png" alt="image-20201126230925233" style="zoom: 80%;" />
<h4 id="结果分析-2">结果分析</h4>
<ul>
<li>可以看到由于CPU最大支持8线程，所以在4线程的情况下是能做到并行的
<ul>
<li>4线程并行情况下运算耗时大约为单线程情况下的四分之一</li>
<li>矩阵规模越大，节约比例越接近0.75</li>
</ul>
</li>
<li>这里我只用了四个线程进行计算，但是却可以发现这边显示的CPU0-7的利用率都同时提升了
<ul>
<li>按理来说，4个线程应该最多只能在4个核上运行</li>
<li>原因是，事实上这个CPU在物理上就是4个内核，只是在逻辑上抽象成了8个逻辑处理器</li>
<li>可以理解为我把现在雇佣了四个厨师，每个厨师可以同时两只手做两个菜，即左手做一份菜，右手做一份菜</li>
<li>现在我派这四个厨师每人做一份菜</li>
<li>他们现在很省力，因为可以左手做半份菜，右手做半份菜</li>
<li>这对于他们来说只需要花费50%的力气就足够了</li>
</ul>
</li>
</ul>
<h3 id="十六线程计算矩阵相乘">十六线程计算矩阵相乘</h3>
<ul>
<li>定义线程类和计算代码类似，在此不再赘述</li>
<li>只需要改线程数即可 <code>public static int totalThreads = 16;</code></li>
</ul>
<h4 id="运行结果-3">运行结果</h4>
<ul>
<li>多次运行以避免偶然性和减少误差</li>
</ul>
<center class="half">    
    <img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201113111437.png" width="300"/>   
    <img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201113111456.png" width="300"/>    
    <img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201113111531.png" width="300"/>
</center>
<ul>
<li>可以在任务管理器中明显看到，在进行多线程计算时，CPU利用率显著提高，甚至直接跑满了</li>
<li>利用win10自带的资源监视器也可以很明显地看到了是8个核的利用率都满了</li>
</ul>
<p>​     <img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201126230533.png" width="600" style="zoom: 80%;" /><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201126230521.png" width="200"/></p>
<h4 id="结果分析-3">结果分析</h4>
<ul>
<li>16线程的理论节约时间比例应该是$15/16 = 0.9375$
<ul>
<li>但是实际上由于CPU只支持最大8线程并行，所以即使创建了16线程，也没有能做到16线程并行</li>
<li>所以理论节约时间比例的上限只有$7/8 = 0.875$</li>
</ul>
</li>
<li>可以看到这次运行时间节约比例和理论值差的很多
<ul>
<li>16线程（实际是8线程）计算的所花的时间甚至比4线程计算的时间还要长</li>
<li>个人理解是JVM在线程调度的时候开销增加，导致16进程计算矩阵相乘的时候浪费了大量时间进行线程方面的操作</li>
<li>当然由于本身系统环境本身也不是不变的，所以也有可能是其他进程对该程序的影响。</li>
</ul>
</li>
<li>在这个情况下，这四个厨子（四个物理核心）
<ul>
<li>我让他们每人做两份菜</li>
<li>他们每人左手做一份，右手做一份（每个核心抽象成两个逻辑处理器）</li>
<li>因此他们已经达到了自己的极限</li>
</ul>
</li>
</ul>
<h2 id="线程学习总结">线程学习总结</h2>
<ol>
<li>合理利用多线程可以有效的增加计算速度</li>
<li>相对与单线程来说，多线程的编程会更加复杂</li>
<li>过多的线程数并不一定能节省时间，可能会导致计算时间的增加</li>
</ol>
]]></content>
      <categories>
        <category>实验报告</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年11月刷题日志</title>
    <url>/post/2020-11-01-Algorithm/2020%E5%B9%B411%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201130093802.png" alt="image-20201130093755634"></p>
<h3 id="11-30">11.30</h3>
<p>美好的一周从周一刷题开始结束</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="767-重构字符串"><a href="https://leetcode-cn.com/problems/reorganize-string/">767. 重构字符串</a></h4>
<p>难度中等</p>
<p>给定一个字符串<code>S</code>，检查是否能重新排布其中的字母，使得两相邻的字符不同。</p>
<p>若可行，输出任意可行的结果。若不可行，返回空字符串。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: S = &quot;aab&quot;</span><br><span class="line">输出: &quot;aba&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: S = &quot;aaab&quot;</span><br><span class="line">输出: &quot;&quot;</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ul>
<li><code>S</code> 只包含小写字母并且长度在<code>[1, 500]</code>区间内。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>参考了<a href="https://leetcode-cn.com/problems/reorganize-string/solution/c-tong-ji-ci-shu-pai-xu-dai-zhu-shi-by-xiao-fu-zi-/">大佬的c++题解</a></p>
<p>说白了就是贪心</p>
<ul>
<li>用字典统计字母出现次数
<ul>
<li>这里如果某个字母出现的次数超过了字符串长度的一半</li>
<li>那肯定是无法重构的，因为最后必然会剩下两个同字符相邻</li>
</ul>
</li>
<li>再根据字母的出现次数升序排列</li>
<li>构建一个数组，初始化每个位置为0</li>
<li>从index = 1的位置开始逐个插入字母，从出现次数最少的开始</li>
<li>index逐次递增2，插入字母，index出界了就从0开始重新插，插到最后就是答案</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reorganizeString</span>(<span class="params">self, S: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        dic = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> dic:</span><br><span class="line">                dic[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dic[i] &gt; (<span class="built_in">len</span>(S)+<span class="number">1</span>)//<span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        inds = <span class="built_in">list</span>(<span class="built_in">set</span>(S))</span><br><span class="line">        inds.sort(key = <span class="keyword">lambda</span> x:dic[x])</span><br><span class="line">        res = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S))]</span><br><span class="line">        index = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> inds:</span><br><span class="line">            cnt = dic[i]</span><br><span class="line">            char = i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cnt):</span><br><span class="line">                <span class="keyword">if</span> index&gt;=<span class="built_in">len</span>(S):</span><br><span class="line">                    index = <span class="number">0</span></span><br><span class="line">                res[index] = char</span><br><span class="line">                index += <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(res)</span><br></pre></td></tr></table></figure>
<h3 id="11-29">11.29</h3>
<p>美好的周日从实验室开会和简单题开始</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="976-三角形的最大周长"><a href="https://leetcode-cn.com/problems/largest-perimeter-triangle/">976. 三角形的最大周长</a></h4>
<p>难度简单</p>
<p>给定由一些正数（代表长度）组成的数组 <code>A</code>，返回由其中三个长度组成的、<strong>面积不为零</strong>的三角形的最大周长。</p>
<p>如果不能形成任何面积不为零的三角形，返回 <code>0</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[2,1,2]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,2,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[3,2,3,4]</span><br><span class="line">输出：10</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[3,6,2,3]</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>3 &lt;= A.length &lt;= 10000</code></li>
<li><code>1 &lt;= A[i] &lt;= 10^6</code></li>
</ol>
</blockquote>
<p><strong>思路</strong></p>
<p>真·简单题</p>
<ul>
<li>对边进行排序，最大的周长必定是数组中三个连续的边长组成的（贪心）</li>
<li>所以从后往前遍历三条边，找到能组成三角形的情况，返回周长即最大周长</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestPerimeter</span>(<span class="params">self, A: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        A.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(A)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> A[i+<span class="number">2</span>]&gt;=A[i+<span class="number">1</span>]+A[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> A[i]+A[i+<span class="number">1</span>]+A[i+<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="11-28">11.28</h3>
<p>这一天，又是体测又是知识竞赛又是互联网+路演ppt，人晕了😵</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="493-翻转对"><a href="https://leetcode-cn.com/problems/reverse-pairs/">493. 翻转对</a></h4>
<p>难度困难</p>
<p>给定一个数组 <code>nums</code> ，如果 <code>i &lt; j</code> 且 <code>nums[i] &gt; 2*nums[j]</code> 我们就将 <code>(i, j)</code> 称作一个*<strong>重要翻转对*</strong>。</p>
<p>你需要返回给定数组中的重要翻转对的数量。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,3,2,3,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [2,4,3,5,1]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ol>
<li>给定数组的长度不会超过<code>50000</code>。</li>
<li>输入数组中的所有数字都在32位整数的表示范围内。</li>
</ol>
</blockquote>
<p><strong>思路</strong></p>
<p>别问，问就是抄的大佬题解</p>
<ul>
<li>归并排序
<ul>
<li>边排序边计算反转对的数量</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_pairs</span>(<span class="params">self, nums, left, right</span>):</span><br><span class="line">        <span class="comment"># 计算可用对数</span></span><br><span class="line">        <span class="comment"># 假设nums[left:mid]和nums[mid+1:right]都是升序排列</span></span><br><span class="line">        res, mid = <span class="number">0</span>, (left+right)//<span class="number">2</span></span><br><span class="line">        <span class="comment"># 利用双指针去计算当前可以有多少个匹配项</span></span><br><span class="line">        j = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, mid+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> j&lt;=right <span class="keyword">and</span> nums[i]&gt;<span class="number">2</span>*nums[j]:</span><br><span class="line">                <span class="comment"># 当右边找到的数比左边的数两倍还大的时候</span></span><br><span class="line">                <span class="comment"># 说明左边数组i位置和剩下的数字都可以和j自称翻转对</span></span><br><span class="line">                <span class="comment"># 那就加上这么多对,继续考虑j之后的数字</span></span><br><span class="line">                res += mid-i+<span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 当j对应的数字太大了,说明需要增加i对应的数字的大小</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">self, nums, nums_sorted, l, r</span>):</span><br><span class="line">        <span class="keyword">if</span> l&gt;= r:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        mid = (l+r)//<span class="number">2</span></span><br><span class="line">        <span class="comment"># 每次递归的值就是左数组中的翻转对+右数组中的翻转对+两个数组中交叉的翻转对</span></span><br><span class="line">        res = self.merge_sort(nums, nums_sorted, l, mid)+self.merge_sort(nums, nums_sorted, mid+<span class="number">1</span>, r)+self.find_pairs(nums, l, r)</span><br><span class="line">        <span class="comment"># 接下来进行归并排序,把左数组和右数组合并成有序的数组</span></span><br><span class="line">        i, j, k = l, mid+<span class="number">1</span>, l</span><br><span class="line">        <span class="keyword">while</span> i&lt;= mid <span class="keyword">and</span> j&lt;= r:</span><br><span class="line">            <span class="keyword">if</span> nums[i]&lt;=nums[j]:</span><br><span class="line">                nums_sorted[k] = nums[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums_sorted[k] = nums[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i&lt;=mid:</span><br><span class="line">            nums_sorted[k] = nums[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j&lt;= r:</span><br><span class="line">            nums_sorted[k] = nums[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(l, r+<span class="number">1</span>):</span><br><span class="line">            nums[k] = nums_sorted[k]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversePairs</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 归并排序解决问题</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nums_sorted = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">return</span> self.merge_sort(nums, nums_sorted, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h3 id="11-27">11.27</h3>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="454-四数相加-II"><a href="https://leetcode-cn.com/problems/4sum-ii/">454. 四数相加 II</a></h4>
<p>难度中等</p>
<p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 <code>(i, j, k, l)</code> ，使得 <code>A[i] + B[j] + C[k] + D[l] = 0</code>。</p>
<p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。</p>
<p><strong>例如:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">A = [ 1, 2]</span><br><span class="line">B = [-2,-1]</span><br><span class="line">C = [-1, 2]</span><br><span class="line">D = [ 0, 2]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">两个元组如下:</span><br><span class="line">1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>蛮可惜的，这个思路应该很容易想，但是我却看了题解标题才想出来</p>
<ul>
<li>存两个哈希表（只存一个也可以），一个放A和B中间元素可能的和，另一个放C和D可能的和</li>
<li>然后遍历第一个哈希表的键，去看它的相反数在B中的出现次数</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSumCount</span>(<span class="params">self, A: <span class="type">List</span>[<span class="built_in">int</span>], B: <span class="type">List</span>[<span class="built_in">int</span>], C: <span class="type">List</span>[<span class="built_in">int</span>], D: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dic1, dic2 = <span class="built_in">dict</span>(), <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># A和B可能的和存入dic1中，C和D可能的和存入dic2中</span></span><br><span class="line">        n = <span class="built_in">len</span>(A)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                a, b, c, d = A[i], B[j], C[i], D[j]</span><br><span class="line">                <span class="keyword">if</span> a+b <span class="keyword">in</span> dic1:</span><br><span class="line">                    dic1[a+b] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dic1[a+b] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> c+d <span class="keyword">in</span> dic2:</span><br><span class="line">                    dic2[c+d] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dic2[c+d] = <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dic1.keys():</span><br><span class="line">            <span class="keyword">if</span> -i <span class="keyword">in</span> dic2:</span><br><span class="line">                res += dic1[i]*dic2[-i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<h3 id="11-26">11.26</h3>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="164-最大间距"><a href="https://leetcode-cn.com/problems/maximum-gap/">164. 最大间距</a></h4>
<p>难度困难</p>
<p>给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。</p>
<p>如果数组元素个数小于 2，则返回 0。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,6,9,1]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [10]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 数组元素个数小于 2，因此返回 0。</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li>你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。</li>
<li>请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>如果忽略线性时间复杂度的说明，则直接排序完遍历数组求相邻元素的最大差距即可</p>
<p>然而困难题显然不是这么简单的（虽然按题解来写的程序时间复杂度O(N)会比库函数排序慢）</p>
<ul>
<li>
<p>利用桶排序</p>
<ol>
<li>创建很多个桶</li>
<li>把所有的数字放到合适的桶里</li>
<li>计算相邻非空桶之间的最大差值</li>
</ol>
</li>
<li>
<p>比如<code>nums = [3,6,9,1]</code></p>
<ul>
<li>每个桶装的数字距离就是 (9-1)/(4-1) = 2</li>
<li>意味着我们会有这么多个桶，能装的数字范围为
<ol>
<li>[0,2)</li>
<li>[2,4)</li>
<li>[4,6)</li>
<li>[6,8)</li>
<li>[8,10)</li>
</ol>
</li>
<li>然后遍历<code>nums</code>把数字分别装入桶中</li>
<li>最后桶的状态
<ol>
<li>[1]</li>
<li>[3]</li>
<li>[]</li>
<li>[6]</li>
<li>[9]</li>
</ol>
</li>
<li>最后我们发现3-1=2，6-3=3，9-6=3，所以最大差值是3</li>
</ul>
</li>
<li>
<p>那为什么这么干就是O(N)了呢？</p>
<ul>
<li>我们在把数字装入桶里的时候，只遍历了一边数组</li>
<li>在确定最大差值的时候，只遍历了一遍桶</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumGap</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 利用桶排序解题</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 首先确定桶的长度，每个桶都是等间距</span></span><br><span class="line">        buckt_len = <span class="built_in">max</span>(<span class="number">1</span>, (<span class="built_in">max</span>(nums)-<span class="built_in">min</span>(nums))//(<span class="built_in">len</span>(nums)-<span class="number">1</span>))</span><br><span class="line">        <span class="comment"># 最多可能要把数字放到这么多个桶中</span></span><br><span class="line">        buckt_num = (<span class="built_in">max</span>(nums)-<span class="built_in">min</span>(nums))//buckt_len+<span class="number">1</span></span><br><span class="line">        buckets = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(buckt_num)]</span><br><span class="line">        <span class="comment"># 然后把所有的数字放到桶中</span></span><br><span class="line">        min_num = <span class="built_in">min</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            buckets[(num-min_num)//buckt_len].append(num)</span><br><span class="line">        <span class="comment"># 然后计算相邻非空桶之间的最大差值</span></span><br><span class="line">        prev = min_num</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> bucket:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">min</span>(bucket)-prev)</span><br><span class="line">            prev = <span class="built_in">max</span>(bucket)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="11-25">11.25</h3>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1370-上升下降字符串"><a href="https://leetcode-cn.com/problems/increasing-decreasing-string/">1370. 上升下降字符串</a></h4>
<p>难度简单</p>
<p>给你一个字符串 <code>s</code> ，请你根据下面的算法重新构造字符串：</p>
<ol>
<li>从 <code>s</code> 中选出 <strong>最小</strong> 的字符，将它 <strong>接在</strong> 结果字符串的后面。</li>
<li>从 <code>s</code> 剩余字符中选出 <strong>最小</strong> 的字符，且该字符比上一个添加的字符大，将它 <strong>接在</strong> 结果字符串后面。</li>
<li>重复步骤 2 ，直到你没法从 <code>s</code> 中选择字符。</li>
<li>从 <code>s</code> 中选出 <strong>最大</strong> 的字符，将它 <strong>接在</strong> 结果字符串的后面。</li>
<li>从 <code>s</code> 剩余字符中选出 <strong>最大</strong> 的字符，且该字符比上一个添加的字符小，将它 <strong>接在</strong> 结果字符串后面。</li>
<li>重复步骤 5 ，直到你没法从 <code>s</code> 中选择字符。</li>
<li>重复步骤 1 到 6 ，直到 <code>s</code> 中所有字符都已经被选过。</li>
</ol>
<p>在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。</p>
<p>请你返回将 <code>s</code> 中字符重新排序后的 <strong>结果字符串</strong> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;aaaabbbbcccc&quot;</span><br><span class="line">输出：&quot;abccbaabccba&quot;</span><br><span class="line">解释：第一轮的步骤 1，2，3 后，结果字符串为 result = &quot;abc&quot;</span><br><span class="line">第一轮的步骤 4，5，6 后，结果字符串为 result = &quot;abccba&quot;</span><br><span class="line">第一轮结束，现在 s = &quot;aabbcc&quot; ，我们再次回到步骤 1</span><br><span class="line">第二轮的步骤 1，2，3 后，结果字符串为 result = &quot;abccbaabc&quot;</span><br><span class="line">第二轮的步骤 4，5，6 后，结果字符串为 result = &quot;abccbaabccba&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;rat&quot;</span><br><span class="line">输出：&quot;art&quot;</span><br><span class="line">解释：单词 &quot;rat&quot; 在上述算法重排序以后变成 &quot;art&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;leetcode&quot;</span><br><span class="line">输出：&quot;cdelotee&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ggggggg&quot;</span><br><span class="line">输出：&quot;ggggggg&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;spo&quot;</span><br><span class="line">输出：&quot;ops&quot;</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= s.length &lt;= 500</code></li>
<li><code>s</code> 只包含小写英文字母。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>就按照题目的要求模拟整个过程即可</p>
<p>利用字典来统计每个字母出现的次数，然后对出现的字母进行排序（python里的sort可以直接实现按字典序排序）</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortString</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        dic = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">set</span>(s):</span><br><span class="line">            dic[i] = s.count(i)</span><br><span class="line">        keys = <span class="built_in">sorted</span>(<span class="built_in">list</span>(<span class="built_in">set</span>(s)))</span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        cnt = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">while</span> cnt&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">                <span class="keyword">if</span> dic[key]&gt;<span class="number">0</span>:</span><br><span class="line">                    res += key</span><br><span class="line">                    dic[key] -= <span class="number">1</span></span><br><span class="line">                    cnt -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> keys[::-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> dic[key]&gt;<span class="number">0</span>:</span><br><span class="line">                    res += key</span><br><span class="line">                    dic[key] -= <span class="number">1</span></span><br><span class="line">                    cnt -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="11-24">11.24</h3>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="222-完全二叉树的节点个数"><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h4>
<p>难度中等</p>
<p>给出一个<strong>完全二叉树</strong>，求出该树的节点个数。</p>
<p><strong>说明：</strong></p>
<p><a href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a>的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \  /</span><br><span class="line">4  5 6</span><br><span class="line"></span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>我不讲武德，直接忽略完全二叉树，广搜直接求结点数
<ul>
<li>时间复杂度O(N)</li>
</ul>
</li>
<li>标准答案思路
<ul>
<li>先求出层数</li>
<li>然后根据层数算出结点的上下限</li>
<li>根据上下限来进行二分确定结点数</li>
<li>二分的时候，利用位运算去判断某个结点存不存在</li>
<li>时间复杂度O(log²N)</li>
</ul>
</li>
</ul>
<p><strong>思路</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">exist</span>(<span class="params">root, level, mid</span>):</span><br><span class="line">            bits, node = <span class="number">1</span> &lt;&lt; (level-<span class="number">1</span>), root</span><br><span class="line">            <span class="keyword">while</span> node <span class="keyword">and</span> bits&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> bits&amp;mid:</span><br><span class="line">                    node = node.right</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node = node.left</span><br><span class="line">                bits&gt;&gt;=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">and</span> node.left:</span><br><span class="line">            node, level = node.left, level+<span class="number">1</span></span><br><span class="line">        low, high = <span class="number">1</span>&lt;&lt;level, (<span class="number">1</span>&lt;&lt;(level+<span class="number">1</span>)) -<span class="number">1</span></span><br><span class="line">        mid = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> low&lt;high:</span><br><span class="line">            mid = (high-low+<span class="number">1</span>)//<span class="number">2</span> + low</span><br><span class="line">            <span class="keyword">if</span> exist(root, level, mid):</span><br><span class="line">                low = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(low, mid)</span><br></pre></td></tr></table></figure>
<h3 id="11-23">11.23</h3>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="452-用最少数量的箭引爆气球"><a href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a></h4>
<p>难度中等</p>
<p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p>
<p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 <code>x``start</code>，<code>x``end</code>， 且满足  <code>xstart ≤ x ≤ x``end</code>，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p>
<p>给你一个数组 <code>points</code> ，其中 <code>points [i] = [xstart,xend]</code> ，返回引爆所有气球所必须射出的最小弓箭数。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：points = [[10,16],[2,8],[1,6],[7,12]]</span><br><span class="line">输出：2</span><br><span class="line">解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：points = [[1,2],[3,4],[5,6],[7,8]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：points = [[1,2],[2,3],[3,4],[4,5]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：points = [[1,2]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：points = [[2,3],[2,3]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>0 &lt;= points.length &lt;= 104</code></li>
<li><code>points[i].length == 2</code></li>
<li><code>-231 &lt;= xstart &lt; xend &lt;= 231 - 1</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>贪心算法，只要保证每次射出的箭追求最大利益的方式即可保证最后花最少的箭</li>
<li>怎么保证利益最大呢？
<ul>
<li>假设我们有4个气球是<code>[0,2], [1,3], [2, 4]，[4,5]</code></li>
<li>一开始我为了射爆第一个气球，至少需要花一根箭，那这个位置无所谓<code>[0,2]</code>中间任意一个整数即可</li>
<li>所以我们一开始<code>left = 0, right =2</code></li>
<li>再来看第二个气球，<code>[1,3] </code>，我们发现他的左边界是1，右边界是3，和当前的可射范围<code>[0,2]</code>是有交集的</li>
<li>所以我们当前仍只需要一根箭，不过范围缩小到<code>left = 1, right =  2</code>，左边取大的，右边取小的</li>
<li>第三个气球依然可以用同一根箭射爆，<code>left = 2, right = 2</code></li>
<li>到第四个气球的时候，我们发现无法用这根箭射穿了，所以我们需要多花一根箭，同时当前的范围重置为<code>left = 4，right = 5</code></li>
<li>因此，射爆这四个气球所需要花的最少箭数为2</li>
</ul>
</li>
<li>可以看到这里我们气球的排序是按照右边界从小到大来排序的，这样子才能保证用的箭尽可能少，而且通过一遍遍历就可以求出箭的个数
<ul>
<li>因为这样排序之后，我们箭的发射位置是从最左往最右考虑的，而且是以连续的方式，所以每根箭会考虑尽可能射穿所有相邻的气球</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMinArrowShots</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 按照气球结束坐标的大小排序</span></span><br><span class="line">        points.sort(key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        length = <span class="built_in">len</span>(points)</span><br><span class="line">        <span class="keyword">if</span> length&lt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left, right = points[<span class="number">0</span>]</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;<span class="built_in">len</span>(points):</span><br><span class="line">            cur_left, cur_right = points[i]</span><br><span class="line">            <span class="keyword">if</span> cur_left&gt;right:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                left,right = cur_left, cur_right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = <span class="built_in">max</span>(cur_left, left)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure>
<h3 id="11-22">11.22</h3>
<p>回家度了一天半的假，继续开工</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="242-有效的字母异位词"><a href="https://leetcode-cn.com/problems/valid-anagram/">242. 有效的字母异位词</a></h4>
<p>难度简单</p>
<p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong><br>
你可以假设字符串只包含小写字母。</p>
<p><strong>进阶:</strong><br>
如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p>
</blockquote>
<p><strong>思路</strong></p>
<p>就用哈希表（字典）去存取每个字符串中字母出现的次数就行了</p>
<p>这里有一个比较节省空间的技巧是只开辟一个字典</p>
<p>同时遍历两个字符串，将<code>s</code>中字符对应的键值+1，<code>t</code>中字符对应的键值-1</p>
<p>最后遍历字典的key值，如果有不等于0的key就返回false，全为0则返回true</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        dic_s, dic_t = defaultdict(<span class="built_in">int</span>), defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            dic_s[s[i]] += <span class="number">1</span></span><br><span class="line">            dic_t[t[i]] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dic_s == dic_t</span><br></pre></td></tr></table></figure>
<h3 id="11-21">11.21</h3>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="148-排序链表"><a href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a></h4>
<p>难度中等</p>
<p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p>
<p><strong>进阶：</strong></p>
<ul>
<li>你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</li>
</ul>
<p><strong>示例 1：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [4,2,1,3]</span><br><span class="line">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [-1,5,3,4,0]</span><br><span class="line">输出：[-1,0,3,4,5]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目在范围 <code>[0, 5 * 104]</code> 内</li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>刷了这么久的题，第一个想法仍然是用内置的sort函数，果然是中了偷🐔的毒</p>
<p>只能看正经的题解</p>
<ul>
<li>递归版归并排序
<ul>
<li>时间复杂度O(NlogN)，空间复杂度O(logN)</li>
</ul>
</li>
<li>迭代版归并排序
<ul>
<li>时间复杂度O(NlogN)，空间复杂度O(1)</li>
</ul>
</li>
<li>不思进取，我今天只追求能看懂递归版的</li>
<li>首先归并排序的整体思路是
<ul>
<li>把需要排列的链表看成两段</li>
<li>前半段和后半段</li>
<li>如果前半段是有序的，后半段是有序的，我就可以将两段有序的链表合并成一个有序的链表</li>
<li>此处假设前后半段均为有序即递归</li>
</ul>
</li>
<li>每次需要做的就是
<ul>
<li>先用快满指针把两个链表切成两端</li>
<li>利用递归确定好两个排完序的链表的头节点</li>
<li>利用双指针，将两个有序链表合并成一个有序链表</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="comment"># 首先用快慢指针将链表分成两段</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        slow,fast=head,head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow=slow.<span class="built_in">next</span></span><br><span class="line">            fast=fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 此时slow指向中间结点或者是前半部分的最后一个结点</span></span><br><span class="line">        tmp = slow.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 将前后段链表进行排序</span></span><br><span class="line">        left, right = self.sortList(head), self.sortList(tmp)</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        new_head = dummy</span><br><span class="line">        <span class="comment"># 利用双指针合并两个有序链表</span></span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">if</span> left.val&lt;right.val:</span><br><span class="line">                new_head.<span class="built_in">next</span> = left</span><br><span class="line">                left = left.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                new_head.<span class="built_in">next</span> = right</span><br><span class="line">                right = right.<span class="built_in">next</span></span><br><span class="line">            new_head = new_head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            new_head.<span class="built_in">next</span> = left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_head.<span class="built_in">next</span> = right</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span>        </span><br></pre></td></tr></table></figure>
<h3 id="11-20">11.20</h3>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="147-对链表进行插入排序"><a href="https://leetcode-cn.com/problems/insertion-sort-list/">147. 对链表进行插入排序</a></h4>
<p>难度中等</p>
<p>对链表进行插入排序。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" alt="img"><br>
插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。<br>
每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。</p>
<p><strong>插入排序算法：</strong></p>
<ol>
<li>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。</li>
<li>每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。</li>
<li>重复直到所有输入数据插入完为止。</li>
</ol>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>一开始自己写，虽然过了，但是插入排序写了四十多行的代码简直了🤮</p>
<p>看题解优化了一下自己的解法</p>
<p>自己主要是没设置dummyhead导致的代码丑陋</p>
<p>改了之后好看多了</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertionSortList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        cur_node = head.<span class="built_in">next</span></span><br><span class="line">        last_node = head</span><br><span class="line">        <span class="keyword">while</span> cur_node:</span><br><span class="line">            <span class="keyword">if</span> cur_node.val&gt;=last_node.val:</span><br><span class="line">                last_node  = last_node.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev = dummy</span><br><span class="line">                <span class="keyword">while</span> prev.<span class="built_in">next</span>.val&lt;cur_node.val:</span><br><span class="line">                    prev = prev.<span class="built_in">next</span></span><br><span class="line">                last_node.<span class="built_in">next</span> = cur_node.<span class="built_in">next</span></span><br><span class="line">                cur_node.<span class="built_in">next</span> = prev.<span class="built_in">next</span></span><br><span class="line">                prev.<span class="built_in">next</span> = cur_node</span><br><span class="line">            cur_node = last_node.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<h3 id="11-19">11.19</h3>
<p>完了嘛这不是，简单题都不会做了</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="283-移动零"><a href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零</a></h4>
<p>难度简单</p>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure>
<p><strong>说明</strong>:</p>
<ol>
<li>必须在原数组上操作，不能拷贝额外的数组。</li>
<li>尽量减少操作次数。</li>
</ol>
</blockquote>
<p><strong>思路</strong></p>
<p>又看了题解</p>
<ul>
<li>
<p>将非零的数字移到数组前部，然后将后面的位置全部置零即可</p>
</li>
<li>
<p>双指针</p>
<ul>
<li>新建两个指针指向头部<code>i,j=0,0</code></li>
<li><code>i</code>表示当前遍历到的非零的数字的个数</li>
<li><code>j</code>表示当前遍历的所有数字的个数</li>
</ul>
</li>
<li>
<p>利用<code>j</code>去遍历所有的数字，然后把所有非零的数字填充到<code>i</code>的位置</p>
</li>
<li>
<p>每次填充的时候令<code>i</code>指针后移</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j&lt;<span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[j]!=<span class="number">0</span>:</span><br><span class="line">                nums[i] = nums[j]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[k] = <span class="number">0</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h3 id="11-18">11.18</h3>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="134-加油站"><a href="https://leetcode-cn.com/problems/gas-station/">134. 加油站</a></h4>
<p>难度中等488</p>
<p>在一条环路上有 <em>N</em> 个加油站，其中第 <em>i</em> 个加油站有汽油 <code>gas[i]</code> 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 <em>i</em> 个加油站开往第 <em>i+1</em> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p>
<p><strong>说明:</strong></p>
<ul>
<li>如果题目有解，该答案即为唯一答案。</li>
<li>输入数组均为非空数组，且长度相同。</li>
<li>输入数组中的元素均为非负数。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">gas  = [1,2,3,4,5]</span><br><span class="line">cost = [3,4,5,1,2]</span><br><span class="line"></span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">gas  = [2,3,4]</span><br><span class="line">cost = [3,4,3]</span><br><span class="line"></span><br><span class="line">输出: -1</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油</span><br><span class="line">你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>别的不会，就会死算，直接模拟了一遍从每个加油站出发的情况</li>
<li>时间复杂度是O(N²)</li>
<li>以为过不了，结果</li>
</ul>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201118150326.png" alt="image-20201118150326517"></p>
<ul>
<li>看了题解发现这原来是一道脑筋急转弯的题目</li>
<li>或者用数学可以证明
<ul>
<li>假设从加油站<code>i</code>出发，到<code>j</code>加油站的发现油不够了</li>
<li>则无论从<code>i~j-1</code>之间，任意一个加油站出发，最终到<code>j</code>加油站都会不够油
<ul>
<li>因为之前<code>i</code>出发肯定剩余油量&gt;=0嘛，在<code>i</code>之后出发甚至连之前剩余的油都没了</li>
</ul>
</li>
<li>所以我们可以直接从<code>j</code>开始重新尝试出发</li>
</ul>
</li>
<li>如果最后尝试的起点超过了终点，则说明无法环路行驶</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canCompleteCircuit</span>(<span class="params">self, gas: <span class="type">List</span>[<span class="built_in">int</span>], cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        diffs = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gas)):</span><br><span class="line">            diffs.append(gas[i]-cost[i])</span><br><span class="line">        <span class="comment"># 找到一段累加和一直为0的一段序列</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> start&lt;<span class="built_in">len</span>(diffs):</span><br><span class="line">            tmp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(diffs)):</span><br><span class="line">                index = (start+i)%<span class="built_in">len</span>(diffs)</span><br><span class="line">                tmp += diffs[index]</span><br><span class="line">                <span class="keyword">if</span> tmp&lt;<span class="number">0</span>:</span><br><span class="line">                    start = start + i + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="11-17">11.17</h3>
<p>ohhh 简单题</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1030-距离顺序排列矩阵单元格"><a href="https://leetcode-cn.com/problems/matrix-cells-in-distance-order/">1030. 距离顺序排列矩阵单元格</a></h4>
<p>难度简单</p>
<p>给出 <code>R</code> 行 <code>C</code> 列的矩阵，其中的单元格的整数坐标为 <code>(r, c)</code>，满足 <code>0 &lt;= r &lt; R</code> 且 <code>0 &lt;= c &lt; C</code>。</p>
<p>另外，我们在该矩阵中给出了一个坐标为 <code>(r0, c0)</code> 的单元格。</p>
<p>返回矩阵中的所有单元格的坐标，并按到 <code>(r0, c0)</code> 的距离从最小到最大的顺序排，其中，两单元格<code>(r1, c1)</code> 和 <code>(r2, c2)</code> 之间的距离是曼哈顿距离，<code>|r1 - r2| + |c1 - c2|</code>。（你可以按任何满足此条件的顺序返回答案。）</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：R = 1, C = 2, r0 = 0, c0 = 0</span><br><span class="line">输出：[[0,0],[0,1]]</span><br><span class="line">解释：从 (r0, c0) 到其他单元格的距离为：[0,1]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：R = 2, C = 2, r0 = 0, c0 = 1</span><br><span class="line">输出：[[0,1],[0,0],[1,1],[1,0]]</span><br><span class="line">解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2]</span><br><span class="line">[[0,1],[1,1],[0,0],[1,0]] 也会被视作正确答案。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：R = 2, C = 3, r0 = 1, c0 = 2</span><br><span class="line">输出：[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]</span><br><span class="line">解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2,2,3]</span><br><span class="line">其他满足题目要求的答案也会被视为正确，例如 [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= R &lt;= 100</code></li>
<li><code>1 &lt;= C &lt;= 100</code></li>
<li><code>0 &lt;= r0 &lt; R</code></li>
<li><code>0 &lt;= c0 &lt; C</code></li>
</ol>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>对所有需要考虑的点进行排序即可</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">allCellsDistOrder</span>(<span class="params">self, R: <span class="built_in">int</span>, C: <span class="built_in">int</span>, r0: <span class="built_in">int</span>, c0: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res= []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(R):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(C):</span><br><span class="line">                res.append([i,j])</span><br><span class="line">        res.sort(key = <span class="keyword">lambda</span> x: (<span class="built_in">abs</span>(x[<span class="number">0</span>]-r0)+<span class="built_in">abs</span>(x[<span class="number">1</span>]-c0)))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="11-16">11.16</h3>
<p>another and another vegetable day</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="406-根据身高重建队列"><a href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></h4>
<p>难度中等</p>
<p>假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对<code>(h, k)</code>表示，其中<code>h</code>是这个人的身高，<code>k</code>是排在这个人前面且身高大于或等于<code>h</code>的人数。 编写一个算法来重建这个队列。</p>
<p><strong>注意：</strong><br>
总人数少于1100人。</p>
<p><strong>示例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>又要看题解做题 🤨</p>
<ul>
<li>贪心法
<ul>
<li>从矮到高一个个分配位置</li>
<li>这样可以保证先放的人的位置不会对后放的人的位置造成影响</li>
<li>因为每个人的整数对（h, k）只记录了在ta前面的身高大于ta的人数</li>
<li>因为这道题一定有解，所以按照一定的规则逐个插入就能得到合法解</li>
</ul>
</li>
<li>利用python自带的排序方法，按照优先考虑h，再考虑k的方法进行排序
<ul>
<li>把身高低的人拍到前面</li>
<li>如果身高相同，就把k大的先放到前面
<ul>
<li>这里也是贪心法的思想，因为需要先插入这些k值大的人</li>
</ul>
</li>
</ul>
</li>
<li>例如
<ul>
<li><code>[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</code></li>
</ul>
</li>
<li>排序完之后就会变成
<ul>
<li><code>[[4,4], [5,2], [5,0], [6,1], [7,1], [7,0]]</code></li>
</ul>
</li>
<li>然后初始化一个最后的排序完的数组<code>res</code>
<ul>
<li><code>res = [0, 0, 0, 0, 0, 0]</code></li>
<li>0说明这个位置还没有人</li>
</ul>
</li>
<li>然后按照排序完之后的人员来进行插入
<ul>
<li>此时不需要考虑身高，因为已经是按照从矮到高排序</li>
<li>根据k值，从头开始遍历<code>res</code>数组</li>
<li>找到k个0之后的一个空位，就是自己需要插入的位置</li>
</ul>
</li>
<li><code>[4.4]</code>第一个进行插入操作，一开始数组里都是空位，所以ta找到4个空位后，自然会插入第5个空位
<ul>
<li><code>res = [0, 0, 0, 0, [4,4], 0]</code></li>
</ul>
</li>
<li>这个时候开始找第二个人的位置，ta是<code>[5,2]</code>，所以从头开始找到两个空位之后，就会插入第三个空位
<ul>
<li><code>res = [0, 0, [5，2], 0, [4,4], 0]</code></li>
</ul>
</li>
<li>直到把所有人都安排好位置，就可以返回数组<code>res</code></li>
<li>本题贪心法思想理解
<ul>
<li>其实每次插入一个人的时候，队伍里的人的身高都不超过ta</li>
<li>又由于我们是根据k值降序，所以和ta同样身高的人，如果k比ta大，那么肯定已经被插到队伍的后面去了，所以不用管</li>
<li>如果k比ta小，那么之后自然会插入ta的前面</li>
<li>所以ta能够不顾及他人的身高，只看空位数就能找到自己应该待的位置</li>
<li>一言以蔽之，把越是不会影响其他人的位置的人越先插到队伍里</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reconstructQueue</span>(<span class="params">self, people: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 首先将所有人按身高的从低到高排序</span></span><br><span class="line">        people.sort(key = <span class="keyword">lambda</span> x: (x[<span class="number">0</span>], -x[<span class="number">1</span>]))</span><br><span class="line">        length = <span class="built_in">len</span>(people)</span><br><span class="line">        res = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length)]</span><br><span class="line">        <span class="keyword">for</span> person <span class="keyword">in</span> people:</span><br><span class="line">            <span class="comment"># 找空插入这个人</span></span><br><span class="line">            space = person[<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> res[i]:</span><br><span class="line">                    space -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> space == <span class="number">0</span>:</span><br><span class="line">                        res[i] = person</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="11-15">11.15</h3>
<p>another vegetable day</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="402-移掉K位数字"><a href="https://leetcode-cn.com/problems/remove-k-digits/">402. 移掉K位数字</a></h4>
<p>难度中等</p>
<p>给定一个以字符串表示的非负整数 <em>num</em>，移除这个数中的 <em>k</em> 位数字，使得剩下的数字最小。</p>
<p><strong>注意:</strong></p>
<ul>
<li><em>num</em> 的长度小于 10002 且 ≥ <em>k。</em></li>
<li><em>num</em> 不会包含任何前导零。</li>
</ul>
<p><strong>示例 1 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: num = &quot;1432219&quot;, k = 3</span><br><span class="line">输出: &quot;1219&quot;</span><br><span class="line">解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: num = &quot;10200&quot;, k = 1</span><br><span class="line">输出: &quot;200&quot;</span><br><span class="line">解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</span><br></pre></td></tr></table></figure>
<p>示例 <strong>3 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: num = &quot;10&quot;, k = 2</span><br><span class="line">输出: &quot;0&quot;</span><br><span class="line">解释: 从原数字移除所有的数字，剩余为空就是0。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>从数字的最左侧开始维护一个递增栈，最后返回整个递增栈能构成的数字并去除前导零
<ul>
<li>例如num=‘12342013’, k=2</li>
<li>我们要去掉的就是34</li>
</ul>
</li>
<li>首先开辟一个栈</li>
<li>往栈里开始放数字
<ul>
<li>[1]</li>
<li>[1,2]</li>
<li>[1,2,3]</li>
<li>[1,2,3,4]</li>
</ul>
</li>
<li>此时我们发现，现在要放的数字是2，但是把2放进这个栈，那这个栈就不是递增的了呀</li>
<li>所以，我们就要把栈顶元素pop掉，每pop一个数，代表了我们就用掉了一次移出数字的机会</li>
<li>当我们没有移除数字的机会（k==0）或者现在栈顶元素已经比我们当前这个数字小的时候</li>
<li>就可以继续往栈里放数字啦</li>
<li>直到把整个num字符串遍历完为止</li>
<li>如果我们在遍历完之后还有删除数字的机会，那我们就把最后放到栈里的几个数字去掉即可</li>
<li>最后把栈拼接成一个字符串并去除前导零</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeKdigits</span>(<span class="params">self, num: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> num:</span><br><span class="line">            <span class="keyword">while</span> nums <span class="keyword">and</span> i&lt;nums[-<span class="number">1</span>] <span class="keyword">and</span> k:</span><br><span class="line">                nums.pop()</span><br><span class="line">                k-=<span class="number">1</span></span><br><span class="line">            nums.append(i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> k&gt;<span class="number">0</span>:</span><br><span class="line">            nums = nums[:-k]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(nums).lstrip(<span class="string">&#x27;0&#x27;</span>) <span class="keyword">or</span> <span class="string">&quot;0&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="11-14">11.14</h3>
<p>芜湖，周末简单题</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1122-数组的相对排序"><a href="https://leetcode-cn.com/problems/relative-sort-array/">1122. 数组的相对排序</a></h4>
<p>难度简单</p>
<p>给你两个数组，<code>arr1</code> 和 <code>arr2</code>，</p>
<ul>
<li><code>arr2</code> 中的元素各不相同</li>
<li><code>arr2</code> 中的每个元素都出现在 <code>arr1</code> 中</li>
</ul>
<p>对 <code>arr1</code> 中的元素进行排序，使 <code>arr1</code> 中项的相对顺序和 <code>arr2</code> 中的相对顺序相同。未在 <code>arr2</code> 中出现过的元素需要按照升序放在 <code>arr1</code> 的末尾。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]</span><br><span class="line">输出：[2,2,2,1,4,3,3,9,6,7,19]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>arr1.length, arr2.length &lt;= 1000</code></li>
<li><code>0 &lt;= arr1[i], arr2[i] &lt;= 1000</code></li>
<li><code>arr2</code> 中的元素 <code>arr2[i]</code> 各不相同</li>
<li><code>arr2</code> 中的每个元素 <code>arr2[i]</code> 都出现在 <code>arr1</code> 中</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>没啥好写的，上代码吧</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">relativeSortArray</span>(<span class="params">self, arr1: <span class="type">List</span>[<span class="built_in">int</span>], arr2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        dic = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 第一遍遍历arr1 统计每个元素的出现次数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr1:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                dic[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[i] += <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 第一遍遍历arr2 输出对应元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr2:</span><br><span class="line">            res += dic[i]*[i]</span><br><span class="line">            dic[i] = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 第二遍遍历arr1 输出未在arr2中出现的元素</span></span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr1:</span><br><span class="line">            <span class="keyword">if</span> dic[i]&gt;<span class="number">0</span>:</span><br><span class="line">                tmp.append(i)</span><br><span class="line">        <span class="keyword">return</span> res+<span class="built_in">sorted</span>(tmp)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="11-13">11.13</h3>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="328-奇偶链表"><a href="https://leetcode-cn.com/problems/odd-even-linked-list/">328. 奇偶链表</a></h4>
<p>难度中等</p>
<p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p>
<p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL </span><br><span class="line">输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li>应当保持奇数节点和偶数节点的相对顺序。</li>
<li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>可恶，要原地算法，偷不了🐔了</p>
<ul>
<li>一个odd结点指向head，一个even结点指向head.next，一个even_head结点指向head.next</li>
<li>两个结点向后遍历，例如1-&gt;2-&gt;3-&gt;4
<ul>
<li>把even的下一个结点作为odd的下一个结点
<ul>
<li>1-&gt;3</li>
</ul>
</li>
<li>把odd指针后移
<ul>
<li>odd = 3</li>
</ul>
</li>
<li>把odd的后一个结点作为even的下一个结点
<ul>
<li>2-&gt;4</li>
</ul>
</li>
<li>把even指针后移
<ul>
<li>even = 4</li>
</ul>
</li>
<li>当前遍历完之后就变成了1-&gt;3, 2-&gt;4</li>
</ul>
</li>
<li>直到遍历到even结点为空或者even没有下一个结点</li>
<li>最后把odd的next指针指向even_head即可</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">oddEvenList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        odd = head</span><br><span class="line">        even = head.<span class="built_in">next</span></span><br><span class="line">        even_head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> even <span class="keyword">and</span> even.<span class="built_in">next</span>:</span><br><span class="line">            odd.<span class="built_in">next</span> = even.<span class="built_in">next</span></span><br><span class="line">            odd = odd.<span class="built_in">next</span></span><br><span class="line">            even.<span class="built_in">next</span> = odd.<span class="built_in">next</span></span><br><span class="line">            even = even.<span class="built_in">next</span></span><br><span class="line">        odd.<span class="built_in">next</span> = even_head</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure>
<h3 id="11-12">11.12</h3>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="922-按奇偶排序数组-II"><a href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/">922. 按奇偶排序数组 II</a></h4>
<p>难度简单</p>
<p>给定一个非负整数数组 <code>A</code>， A 中一半整数是奇数，一半整数是偶数。</p>
<p>对数组进行排序，以便当 <code>A[i]</code> 为奇数时，<code>i</code> 也是奇数；当 <code>A[i]</code> 为偶数时， <code>i</code> 也是偶数。</p>
<p>你可以返回任何满足上述条件的数组作为答案。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[4,2,5,7]</span><br><span class="line">输出：[4,5,2,7]</span><br><span class="line">解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>2 &lt;= A.length &lt;= 20000</code></li>
<li><code>A.length % 2 == 0</code></li>
<li><code>0 &lt;= A[i] &lt;= 1000</code></li>
</ol>
</blockquote>
<p><strong>思路</strong></p>
<p>既然对空间复杂度没有要求我就直接偷懒了</p>
<ul>
<li>新建数组<code>tmp1,tmp2</code></li>
<li>遍历数组A，把里面的奇数放到tmp1里，偶数放到tmp2里</li>
<li>然后最后循环从tmp1里取一个，tmp2里取一个，生成答案数组</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortArrayByParityII</span>(<span class="params">self, A: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        tmp1, tmp2 = [], []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">            <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">                tmp1.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp2.append(i)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tmp1)):</span><br><span class="line">            res+=[tmp2[i], tmp1[i]]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="11-11">11.11</h3>
<p>没想到剁完手还能敲代码，差点忘了这每日一题</p>
<blockquote>
<h4 id="514-自由之路"><a href="https://leetcode-cn.com/problems/freedom-trail/">514. 自由之路</a></h4>
<p>难度困难143</p>
<p>电子游戏“辐射4”中，任务“通向自由”要求玩家到达名为“Freedom Trail Ring”的金属表盘，并使用表盘拼写特定关键词才能开门。</p>
<p>给定一个字符串 <strong>ring</strong>，表示刻在外环上的编码；给定另一个字符串 <strong>key</strong>，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的<strong>最少</strong>步数。</p>
<p>最初，<strong>ring</strong> 的第一个字符与12:00方向对齐。您需要顺时针或逆时针旋转 ring 以使 <strong>key</strong> 的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 <strong>key</strong> 中的所有字符。</p>
<p>旋转 <strong>ring</strong> 拼出 key 字符 <strong>key[i]</strong> 的阶段中：</p>
<ol>
<li>您可以将 <strong>ring</strong> 顺时针或逆时针旋转<strong>一个位置</strong>，计为1步。旋转的最终目的是将字符串 <strong>ring</strong> 的一个字符与 12:00 方向对齐，并且这个字符必须等于字符 <strong>key[i] 。</strong></li>
<li>如果字符 <strong>key[i]</strong> 已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 <strong>1 步</strong>。按完之后，您可以开始拼写 <strong>key</strong> 的下一个字符（下一阶段）, 直至完成所有拼写。</li>
</ol>
<p><strong>示例：</strong></p>
<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/ring.jpg" alt="img" style="zoom: 50%;" />
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: ring = &quot;godding&quot;, key = &quot;gd&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释:</span><br><span class="line"> 对于 key 的第一个字符 &#x27;g&#x27;，已经在正确的位置, 我们只需要1步来拼写这个字符。 </span><br><span class="line"> 对于 key 的第二个字符 &#x27;d&#x27;，我们需要逆时针旋转 ring &quot;godding&quot; 2步使它变成 &quot;ddinggo&quot;。</span><br><span class="line"> 当然, 我们还需要1步进行拼写。</span><br><span class="line"> 因此最终的输出是 4。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><strong>ring</strong> 和 <strong>key</strong> 的字符串长度取值范围均为 1 至 100；</li>
<li>两个字符串中都只有小写字符，并且均可能存在重复字符；</li>
<li>字符串 <strong>key</strong> 一定可以由字符串 <strong>ring</strong> 旋转拼出。</li>
</ol>
</blockquote>
<p><strong>题解</strong></p>
<p>在这里先推荐一个<a href="https://leetcode-cn.com/problems/freedom-trail/solution/python3-lai-ba-zhan-shi-shi-shi-ju-zhuquan-guo-zui/">大佬的题解</a>，看完之后半小时以内就能自己敲出来</p>
<p>整体采取<strong>动态规划</strong>和<strong>bfs</strong>的思路</p>
<ul>
<li>我们要确保的是最后最优解，中途只要尽量最优即可</li>
<li>最重要的是保存多种可能路径，还得保证不去记录肯定不可能是最优解的路径</li>
</ul>
<p>这次要用的关键数据结构是字典</p>
<ul>
<li>
<p>首先我们建立一个空字典<code>dic</code></p>
<ul>
<li>这个字典用来存放每个字母的位置</li>
</ul>
</li>
<li>
<p>遍历<code>ring</code>来初始化<code>dic</code>字典</p>
<ul>
<li>
<p><code>dic</code>的所有<code>keys</code>就是<code>ring</code>中出现过的字母</p>
</li>
<li>
<p>每种字母对应key也是一个字典</p>
<ul>
<li>这个字典记录的是：这种字母出现的位置和已经操作的步数（初始化时步数均为0）</li>
</ul>
</li>
<li>
<p>例如<code>ring = abcdac</code></p>
</li>
<li>
<p>初始化字典后<code>dic = &#123;'a':&#123;0:0, 4:0&#125;, 'b'：&#123;1:0&#125;, 'c':&#123;2:0,5:0&#125;, 'd':&#123;3:0&#125;&#125;</code></p>
</li>
</ul>
</li>
<li>
<p>然后去遍历<code>key</code></p>
<ul>
<li>根据每个字母和上一次出现的字母，去更新<code>dic</code></li>
<li>例如<code>key = cab</code></li>
<li>假设我们当前遍历的是<code>c</code>，那么我们可以看到<code>dic[‘c’]=&#123;2:0,5:0&#125;</code></li>
<li>我们遍历的上一个位置是0（即起点开始），我们知道走到2至少要2步（向右走），走到5至少要1步（向左走）</li>
<li>所以我们更新<code>dic['c']=&#123;2:3, 5:2&#125;</code>（走步数+按1步）</li>
<li>接下去找下一个字母<code>a</code></li>
<li>我们可以看到<code>dic['a']=&#123;0:0, 4:0&#125;</code>，要走到0，至少要1步（从5出发），要走到4也是至少1步（从5出发）</li>
<li>所以我们更新<code>dic['a']=&#123;0:1+2+1, 4:1+2+1&#125;</code>（本次走的步数+之前走的步数+按1步）</li>
</ul>
</li>
<li>
<p>遍历完整个<code>key</code>之后，字典中对应的<code>key</code>的最后一个字母的字典的<code>values</code>中的最小值，就是答案</p>
</li>
<li>
<p>这边有两个小技巧没提及，代码里实现了，读者可以自己思考</p>
<ul>
<li>如何找到最短步数</li>
<li>如何保证一开始是从0出发</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findRotateSteps</span>(<span class="params">self, ring: <span class="built_in">str</span>, key: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dic = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 首先初始化字典，把每种字母转换成一个字典</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> <span class="built_in">set</span>(<span class="built_in">list</span>(ring)):</span><br><span class="line">            <span class="comment"># dic[&#x27;a&#x27;] = &#123;a出现的第一个位置: 0, a出现的第二个位置: 0...&#125;</span></span><br><span class="line">            tmp = <span class="built_in">dict</span>()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ring)):</span><br><span class="line">                <span class="keyword">if</span> ring[i] == word:</span><br><span class="line">                    tmp[i] = <span class="number">0</span></span><br><span class="line">            dic[word] = tmp</span><br><span class="line">        <span class="comment"># 然后根据当前的字典去找最短路</span></span><br><span class="line">        last_word = ring[<span class="number">0</span>]</span><br><span class="line">        head = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> key:</span><br><span class="line">            <span class="comment"># 每次更新dic[word]对应的字典</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> dic[word].keys():</span><br><span class="line">                min_dis = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">                target = i</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> dic[last_word].keys():</span><br><span class="line">                    start = j</span><br><span class="line">                    last_dis = dic[last_word][j]</span><br><span class="line">                    <span class="keyword">if</span> head:</span><br><span class="line">                        start = <span class="number">0</span></span><br><span class="line">                    <span class="comment"># 正向走到对应字母所需要的距离</span></span><br><span class="line">                    foward_dis  = <span class="built_in">abs</span>(start-target)</span><br><span class="line">                    <span class="comment"># 逆向</span></span><br><span class="line">                    backword_dis = <span class="built_in">len</span>(ring)-foward_dis</span><br><span class="line">                    min_dis = <span class="built_in">min</span>(min_dis,backword_dis+last_dis, foward_dis+last_dis)</span><br><span class="line">                dic[word][i] = min_dis+<span class="number">1</span></span><br><span class="line">            head = <span class="literal">False</span></span><br><span class="line">            last_word = word</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(dic[key[-<span class="number">1</span>]].values())</span><br></pre></td></tr></table></figure>
<h3 id="11-10">11.10</h3>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="31-下一个排列"><a href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列</a></h4>
<p>难度中等</p>
<p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p>
<p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p>
<p>必须**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>**修改，只允许使用额外常数空间。</p>
<p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br>
<code>1,2,3</code> → <code>1,3,2</code><br>
<code>3,2,1</code> → <code>1,2,3</code><br>
<code>1,1,5</code> → <code>1,5,1</code></p>
</blockquote>
<p><strong>思路</strong></p>
<p>想了半天，最终还是看了题解</p>
<ul>
<li>
<p>整体思想是找到一个小数和一个大数，要保证这个大数在小数后面，然后交换</p>
</li>
<li>
<p>首先从后往前遍历，找到我们需要交换的一个小数</p>
<ul>
<li>例如1,2,3,4,8,7,3</li>
<li>可以看到7到3是降序，8到7也是降序</li>
<li>但是4到6是升序</li>
<li>那么就取4作为我们的小数</li>
</ul>
</li>
<li>
<p>然后从后往前，找一个大数</p>
<ul>
<li>首先看到3，3比4小，不能作为大数</li>
<li>7比4大，所以就选它作为大数</li>
</ul>
</li>
<li>
<p>交换大数和小数</p>
<ul>
<li>变成1,2,3,7,8,4,3</li>
</ul>
</li>
<li>
<p>但是我们可以看到，这样子并不是严格的下一个排列</p>
<ul>
<li>因为1,2,3,7,3,4,8才是</li>
</ul>
</li>
<li>
<p>所以需要给现在大数的所在位置即7的位置之后的序列，重新排序，排列成升序</p>
</li>
<li>
<p>由于我们知道8 4 3是降序排列的，所以从两边开始两两调换元素的位置就能变成升序序列</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextPermutation</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i = <span class="built_in">len</span>(nums)-<span class="number">2</span></span><br><span class="line">        <span class="comment"># 从后往前找需要交换的小数</span></span><br><span class="line">        <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> nums[i]&gt;nums[i+<span class="number">1</span>]:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 此时nums[i+1:]都是降序 且num[i]&lt;nums[i+1]</span></span><br><span class="line">        <span class="comment"># i位置的数就是我们要找的小数</span></span><br><span class="line">        <span class="comment"># 从后往前找 找到尽可能小的大数</span></span><br><span class="line">        <span class="keyword">if</span> i&gt;=<span class="number">0</span>:</span><br><span class="line">            j = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j&gt;=<span class="number">0</span> <span class="keyword">and</span> nums[i]&gt;=nums[j]:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="comment"># 将小数后面进行升序排列</span></span><br><span class="line">        left = i+<span class="number">1</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="11-9">11.9</h3>
<p>😴</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="973-最接近原点的-K-个点"><a href="https://leetcode-cn.com/problems/k-closest-points-to-origin/">973. 最接近原点的 K 个点</a></h4>
<p>难度中等</p>
<p>我们有一个由平面上的点组成的列表 <code>points</code>。需要从中找出 <code>K</code> 个距离原点 <code>(0, 0)</code> 最近的点。</p>
<p>（这里，平面上两点之间的距离是欧几里德距离。）</p>
<p>你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：points = [[1,3],[-2,2]], K = 1</span><br><span class="line">输出：[[-2,2]]</span><br><span class="line">解释： </span><br><span class="line">(1, 3) 和原点之间的距离为 sqrt(10)，</span><br><span class="line">(-2, 2) 和原点之间的距离为 sqrt(8)，</span><br><span class="line">由于 sqrt(8) &lt; sqrt(10)，(-2, 2) 离原点更近。</span><br><span class="line">我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：points = [[3,3],[5,-1],[-2,4]], K = 2</span><br><span class="line">输出：[[3,3],[-2,4]]</span><br><span class="line">（答案 [[-2,4],[3,3]] 也会被接受。）</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= K &lt;= points.length &lt;= 10000</code></li>
<li><code>-10000 &lt; points[i][0] &lt; 10000</code></li>
<li><code>-10000 &lt; points[i][1] &lt; 10000</code></li>
</ol>
</blockquote>
<p><strong>思路</strong></p>
<p>要偷懒还是很好偷的</p>
<p>直接用个库函数排序然后切片就解决问题了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kClosest</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], K: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        points.sort(key = <span class="keyword">lambda</span> x:x[<span class="number">0</span>]**<span class="number">2</span>+x[<span class="number">1</span>]**<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> points[:K]</span><br></pre></td></tr></table></figure>
<p>但这不就是耍流氓吗 还是用优先队列吧</p>
<p>简单来说就是用优先队列（大根堆）这个数据结构来维护一组点</p>
<p>保证这组点的数量一直小于等于K，且他们是当前遍历到的离原点最近的点</p>
<p>具体怎么做到呢</p>
<ul>
<li>
<p>先往堆里放前K个点，按照<code>(-距离平方，点的index)</code>的格式</p>
<ul>
<li>之所以是距离平方是因为，python里优先队列是小根堆，所以为了把距离过长的在维护堆得时候去掉，就要取相反数</li>
</ul>
</li>
<li>
<p>再继续遍历剩下的点</p>
<ul>
<li>碰到距离比小根堆顶（也就是-距离平方最小的点）要小的
<ul>
<li>就放到小根堆里</li>
<li>并移除堆顶元素</li>
</ul>
</li>
</ul>
</li>
<li>
<p>直到遍历结束</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kClosest</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], K: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(K):</span><br><span class="line">            x,y = points[i]</span><br><span class="line">            res.append((-x**<span class="number">2</span>-y**<span class="number">2</span>,i))</span><br><span class="line">        heapq.heapify(res)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(K,<span class="built_in">len</span>(points)):</span><br><span class="line">            x,y = points[i]</span><br><span class="line">            dis = -x**<span class="number">2</span>-y**<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> dis&gt;res[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">                heapq.heappushpop(res, (dis, i))</span><br><span class="line">        <span class="keyword">return</span> [points[i[<span class="number">1</span>]] <span class="keyword">for</span> i <span class="keyword">in</span> res]</span><br></pre></td></tr></table></figure>
<h3 id="11-8">11.8</h3>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="122-买卖股票的最佳时机-II"><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h4>
<p>难度简单938</p>
<p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p>
<p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p>
<p>**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= prices.length &lt;= 3 * 10 ^ 4</code></li>
<li><code>0 &lt;= prices[i] &lt;= 10 ^ 4</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>虽然是简单题，但是最后还是看了题解</p>
<p>果然还是没能理解动归的精髓</p>
<ul>
<li>
<p>用两个变量来记录</p>
<ul>
<li>某一天不拥有股票时的最大利润 = <code>d0</code></li>
<li>某一天拥有股票时的最大利润 = <code>d1</code></li>
</ul>
</li>
<li>
<p>遍历整个prices数组，并动态更新这两个变量</p>
</li>
<li>
<p>某一天不拥有股票有两种可能</p>
<ol>
<li>当天卖出了股票</li>
<li>当天和前一天都未买入</li>
</ol>
<p><code>dp0=max(dp0,dp1+prices[i])</code></p>
</li>
<li>
<p>某一天拥有股票有两种可能</p>
<ol>
<li>当天买入了股票</li>
<li>之前买入了股票</li>
</ol>
<p><code>dp1=max(dp0-prices[i],dp1)</code></p>
</li>
<li>
<p>遍历完数组后，<code>dp0</code>就是最后的最大收益值</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 动态规划</span></span><br><span class="line">        dp0, dp1 = <span class="number">0</span>, -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 用两个变量来存储某一天手中无股票和手中有股票时的最大利润</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            dp0 = <span class="built_in">max</span>(dp1+price, dp0)</span><br><span class="line">            dp1 = <span class="built_in">max</span>(dp1, dp0-price)</span><br><span class="line">        <span class="keyword">return</span> dp0</span><br></pre></td></tr></table></figure>
<h3 id="11-7">11.7</h3>
<p>life sucks</p>
<h3 id="11-6">11.6</h3>
<p>计网人，咬咬牙</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1356-根据数字二进制下-1-的数目排序"><a href="https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits/">1356. 根据数字二进制下 1 的数目排序</a></h4>
<p>难度简单37</p>
<p>给你一个整数数组 <code>arr</code> 。请你将数组中的元素按照其二进制表示中数字 <strong>1</strong> 的数目升序排序。</p>
<p>如果存在多个数字二进制中 <strong>1</strong> 的数目相同，则必须将它们按照数值大小升序排列。</p>
<p>请你返回排序后的数组。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [0,1,2,3,4,5,6,7,8]</span><br><span class="line">输出：[0,1,2,4,8,3,5,6,7]</span><br><span class="line">解释：[0] 是唯一一个有 0 个 1 的数。</span><br><span class="line">[1,2,4,8] 都有 1 个 1 。</span><br><span class="line">[3,5,6] 有 2 个 1 。</span><br><span class="line">[7] 有 3 个 1 。</span><br><span class="line">按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [1024,512,256,128,64,32,16,8,4,2,1]</span><br><span class="line">输出：[1,2,4,8,16,32,64,128,256,512,1024]</span><br><span class="line">解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [10000,10000]</span><br><span class="line">输出：[10000,10000]</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [2,3,5,7,11,13,17,19]</span><br><span class="line">输出：[2,3,5,17,7,11,13,19]</span><br></pre></td></tr></table></figure>
<p><strong>示例 5：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [10,100,1000,10000]</span><br><span class="line">输出：[10,100,10000,1000]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 500</code></li>
<li><code>0 &lt;= arr[i] &lt;= 10^4</code></li>
</ul>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortByBits</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">countOne</span>(<span class="params">num</span>):</span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">bin</span>(num).count(<span class="string">&#x27;1&#x27;</span>), num)</span><br><span class="line">        arr.sort(key = countOne)</span><br><span class="line">        <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>
<h3 id="11-5">11.5</h3>
<p>抄作业了抄作业了</p>
<p>不使用优化的解法python直接超时了</p>
<img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201105105825.png" alt="image-20201105105825102" style="zoom:50%;" />
<p><strong>题目</strong></p>
<blockquote>
<h4 id="127-单词接龙"><a href="https://leetcode-cn.com/problems/word-ladder/">127. 单词接龙</a></h4>
<p>难度中等</p>
<p>给定两个单词（<em>beginWord</em> 和 <em>endWord</em>）和一个字典，找到从 <em>beginWord</em> 到 <em>endWord</em> 的最短转换序列的长度。转换需遵循如下规则：</p>
<ol>
<li>每次转换只能改变一个字母。</li>
<li>转换过程中的中间单词必须是字典中的单词。</li>
</ol>
<p><strong>说明:</strong></p>
<ul>
<li>如果不存在这样的转换序列，返回 0。</li>
<li>所有单词具有相同的长度。</li>
<li>所有单词只由小写字母组成。</li>
<li>字典中不存在重复的单词。</li>
<li>你可以假设 <em>beginWord</em> 和 <em>endWord</em> 是非空的，且二者不相同。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">输出: 5</span><br><span class="line"></span><br><span class="line">解释: 一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class="line">     返回它的长度 5。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">解释: endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ladderLength</span>(<span class="params">self, beginWord: <span class="built_in">str</span>, endWord: <span class="built_in">str</span>, wordList: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        word_set = <span class="built_in">set</span>(wordList)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(word_set)==<span class="number">0</span> <span class="keyword">or</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> word_set:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> beginWord <span class="keyword">in</span> word_set:</span><br><span class="line">            word_set.remove(beginWord)</span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        visited.add(beginWord)</span><br><span class="line">        visited.add(endWord)</span><br><span class="line">        begin_visited = <span class="built_in">set</span>()</span><br><span class="line">        begin_visited.add(beginWord)</span><br><span class="line">        end_visited = <span class="built_in">set</span>()</span><br><span class="line">        end_visited.add(endWord)</span><br><span class="line"></span><br><span class="line">        word_len = <span class="built_in">len</span>(beginWord)</span><br><span class="line">        step = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> begin_visited:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(begin_visited) &gt; <span class="built_in">len</span>(end_visited):</span><br><span class="line">                begin_visited, end_visited = end_visited, begin_visited</span><br><span class="line">            next_level_visited = <span class="built_in">set</span>()</span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> begin_visited:</span><br><span class="line">                word_list = <span class="built_in">list</span>(word)</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(word_len):</span><br><span class="line">                    origin_char = word_list[j]</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">                        word_list[j] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)+k)</span><br><span class="line">                        next_word = <span class="string">&#x27;&#x27;</span>.join(word_list)</span><br><span class="line">                        <span class="keyword">if</span> next_word <span class="keyword">in</span> word_set:</span><br><span class="line">                            <span class="keyword">if</span> next_word <span class="keyword">in</span> end_visited:</span><br><span class="line">                                <span class="keyword">return</span> step+<span class="number">1</span></span><br><span class="line">                            <span class="keyword">if</span> next_word <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                                next_level_visited.add(next_word)</span><br><span class="line">                                visited.add(next_word)</span><br><span class="line">                    word_list[j] = origin_char</span><br><span class="line">            begin_visited = next_level_visited</span><br><span class="line">            step+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="11-4">11.4</h3>
<p>哎，今天考完了操作系统</p>
<p>虽然基本都是原题，但是有道15分的甘特图我估计🈚了</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="57-插入区间"><a href="https://leetcode-cn.com/problems/insert-interval/">57. 插入区间</a></h4>
<p>难度困难</p>
<p>给出一个*无重叠的 ，*按照区间起始端点排序的区间列表。</p>
<p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[1,3],[6,9]], newInterval = [2,5]</span><br><span class="line">输出：[[1,5],[6,9]]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]</span><br><span class="line">输出：[[1,2],[3,10],[12,16]]</span><br><span class="line">解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</span><br></pre></td></tr></table></figure>
</blockquote>
<p>困难题就这</p>
<p>不过是多写几个elif的事情</p>
<p>不说了，复习计算机网络去了</p>
<img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201104135845.png" alt="image-20201104135845665" style="zoom:80%;" />
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], newInterval: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(intervals)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [newInterval]</span><br><span class="line">        tmp = []</span><br><span class="line">        new_left, new_right = newInterval[<span class="number">0</span>], newInterval[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> new_right&lt;intervals[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> [newInterval]+intervals</span><br><span class="line">        <span class="keyword">if</span> new_left&gt;intervals[-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> intervals+[newInterval]</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(intervals)):</span><br><span class="line">            left, right = intervals[i][<span class="number">0</span>], intervals[i][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> new_left&lt;=left <span class="keyword">and</span> new_right&gt;=right:</span><br><span class="line">                <span class="comment"># 第一种情况newInterval包含了[left, right]</span></span><br><span class="line">                tmp.append(newInterval)</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> left&lt;=new_left <span class="keyword">and</span> right&gt;=new_right:</span><br><span class="line">                tmp.append(intervals[i])</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> new_left&lt;=right <span class="keyword">and</span> new_right&gt;=right:</span><br><span class="line">                tmp.append([left, new_right])</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> new_left&lt;=left <span class="keyword">and</span> new_right&gt;=left:</span><br><span class="line">                tmp.append([new_left, right])</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp.append(intervals[i])</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            <span class="comment"># 说明没插入</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tmp)-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> tmp[i+<span class="number">1</span>][<span class="number">0</span>]&gt;new_right:</span><br><span class="line">                    tmp = tmp[:i+<span class="number">1</span>]+[newInterval]+tmp[i+<span class="number">1</span>:]</span><br><span class="line">        <span class="comment"># 合并有重叠的数组</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(tmp) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> tmp</span><br><span class="line">        ans = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;<span class="built_in">len</span>(tmp)-<span class="number">1</span>:</span><br><span class="line">            left1, right1 = tmp[i]</span><br><span class="line">            left2, right2 = tmp[i+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> right1&lt;left2:</span><br><span class="line">                ans.append(tmp[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> i&lt;<span class="built_in">len</span>(tmp)-<span class="number">1</span> <span class="keyword">and</span> tmp[i+<span class="number">1</span>][<span class="number">0</span>]&lt;=right1:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 这个时候找到了需要合并的右边界</span></span><br><span class="line">                ans.append([left1,tmp[i][<span class="number">1</span>]])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i==<span class="built_in">len</span>(tmp)-<span class="number">1</span>:</span><br><span class="line">                ans.append(tmp[-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="11-3">11.3</h3>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="941-有效的山脉数组"><a href="https://leetcode-cn.com/problems/valid-mountain-array/">941. 有效的山脉数组</a></h4>
<p>难度简单</p>
<p>给定一个整数数组 <code>A</code>，如果它是有效的山脉数组就返回 <code>true</code>，否则返回 <code>false</code>。</p>
<p>让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：</p>
<ul>
<li>
<p><code>A.length &gt;= 3</code></p>
</li>
<li>
<p>在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 &lt; i &lt; A.length - 1</span><br></pre></td></tr></table></figure>
<p>条件下，存在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i</span><br></pre></td></tr></table></figure>
<p>使得：</p>
<ul>
<li><code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</code></li>
<li><code>A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li>
</ul>
</li>
</ul>
<img src="https://assets.leetcode.com/uploads/2019/10/20/hint_valid_mountain_array.png" alt="img" style="zoom:67%;" />
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[2,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[3,5,5]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[0,3,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= A.length &lt;= 10000</code></li>
<li><code>0 &lt;= A[i] &lt;= 10000 </code></li>
</ol>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validMountainArray</span>(<span class="params">self, A: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(A)&lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        prev = A[<span class="number">0</span>]-<span class="number">1</span>  <span class="comment"># 用来记录经过的上一个数</span></span><br><span class="line">        flag = <span class="number">0</span>  <span class="comment"># 用来记录是否已经翻过山峰</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">            <span class="keyword">if</span> flag==<span class="number">0</span> <span class="keyword">and</span> i&gt;prev:</span><br><span class="line">                prev = i</span><br><span class="line">            <span class="keyword">elif</span> flag==<span class="number">0</span> <span class="keyword">and</span> i&lt;prev <span class="keyword">and</span> i!=A[<span class="number">0</span>]-<span class="number">1</span>:</span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line">                prev = i</span><br><span class="line">            <span class="keyword">elif</span> flag == <span class="number">1</span> <span class="keyword">and</span> i&lt;prev:</span><br><span class="line">                prev = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="11-2">11.2</h3>
<p>软件测试的期中考试有点崩，sad</p>
<p>近日只贴代码</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="349-两个数组的交集"><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h4>
<p>难度简单</p>
<p>给定两个数组，编写一个函数来计算它们的交集。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">输出：[9,4]</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li>输出结果中的每个元素一定是唯一的。</li>
<li>我们可以不考虑输出结果的顺序。</li>
</ul>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums1)&gt;<span class="built_in">len</span>(nums2):</span><br><span class="line">            nums1, nums2 = nums2, nums1</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">set</span>(nums1):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">                ans.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>赶紧复习操作系统和计网去了，想保住3.9好难TAT</p>
<h3 id="11-1">11.1</h3>
<p>刚刚竟然没注意把日期写成了10.32🙃</p>
<p>估计是学傻了</p>
<p>可惜了昨天的sn没能夺冠（dwg就nm强得离谱）</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="140-单词拆分-II"><a href="https://leetcode-cn.com/problems/word-break-ii/">140. 单词拆分 II</a></h4>
<p>难度困难</p>
<p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词列表的字典 <em>wordDict</em>，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。</p>
<p><strong>说明：</strong></p>
<ul>
<li>分隔时可以重复使用字典中的单词。</li>
<li>你可以假设字典中没有重复的单词。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;catsanddog&quot;</span><br><span class="line">wordDict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  &quot;cats and dog&quot;,</span><br><span class="line">  &quot;cat sand dog&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;pineapplepenapple&quot;</span><br><span class="line">wordDict = [&quot;apple&quot;, &quot;pen&quot;, &quot;applepen&quot;, &quot;pine&quot;, &quot;pineapple&quot;]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  &quot;pine apple pen apple&quot;,</span><br><span class="line">  &quot;pineapple pen apple&quot;,</span><br><span class="line">  &quot;pine applepen apple&quot;</span><br><span class="line">]</span><br><span class="line">解释: 注意你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;catsandog&quot;</span><br><span class="line">wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出:</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>我一开始看到这题目还很开心，因为在一节专选课刚做过<a href="https://www.ethanloo.cn/post/2020-10-20-%E5%9F%BA%E4%BA%8E%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E7%9A%84%E5%8F%A5%E5%AD%90%E5%88%86%E8%AF%8D/">分词法的实验</a></p>
<p>可惜最大前向匹配法和最大后相匹配法并不能解决这个问题，因为从这里的示例二就能看出来，他的分词不是用“最大”这个规则能解决的</p>
<p>单纯地使用前向或后向并不能把<code>pineapple</code>拆解成<code>pine apple</code></p>
<p>咋办呢，看大佬题解呗</p>
<ul>
<li>动态规划+dfs</li>
<li>用动态规划求解字符的前n个字符能否拆解成若干字串
<ul>
<li>用一个dp数组去记录</li>
</ul>
</li>
<li>用dfs，在dp数组的基础上，去找到所有可能性</li>
</ul>
<blockquote>
<p>就写个大概思路吧，还要准备三门专业必修课的期中考试😭</p>
</blockquote>
]]></content>
      <categories>
        <category>刷题日志</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>软件测试与质量保证课程笔记</title>
    <url>/post/2020-10-24-Basic/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>Software Testing and Quality Assurance(SQA)</p>
<h2 id="Session-1-Introduction">Session 1 Introduction</h2>
<h3 id="Why-we-need-software-testing">Why we need software testing?</h3>
<ul>
<li>我们需要软件</li>
<li>我们需要高质量的软件</li>
<li>我们需要一些方法来确保软件质量</li>
</ul>
<h3 id="Fundamentals-of-Software-Quality-Assurance">Fundamentals of Software Quality Assurance</h3>
<ul>
<li>质量的定义是一个软件的完美程度</li>
<li>质量也可以被解释成满足顾客以下的需求：
<ul>
<li>Explicit 明确的
<ul>
<li>External 外在：features 特性，usability 可用性</li>
</ul>
</li>
<li>Implicit 暗含的
<ul>
<li>Internal 内在：maintainability 可维护性，user experience 用户体验</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Introducing-Software-Quality-Assurance">Introducing Software Quality Assurance</h3>
<ul>
<li>需要在软件开发周期(SDLC)的**每一个阶段(Each phase)**进行软件质量的保证</li>
<li>SQA是<strong>监控(monitor)<strong>和</strong>改善(improve)<strong>软件开发过程的一个</strong>有计划的(planned)</strong>、**系统(systematic)**的方法。</li>
</ul>
<h3 id="Quality-Assurance-and-Quality-Control">Quality Assurance and Quality Control</h3>
<ul>
<li>
<p>Quality activities 可以被分为两类：</p>
<ul>
<li>Preventive activities 预防性活动</li>
<li>Detective activities 检测性活动</li>
</ul>
</li>
<li>
<p><strong>QA</strong>面向的是缺陷的<strong>预防</strong>，它被用来在发展和不断提升的过程中去实现一个组织定义好的质量政策</p>
<ul>
<li>Quality Audit 质量审核</li>
<li>Process definition 过程定义</li>
<li>Tool selection 工具选择</li>
<li>Training 培训</li>
<li>Peer review 同行评审</li>
<li>Requirements tracking 需求跟踪</li>
<li>Quality metrics collection 质量量度收集</li>
</ul>
</li>
<li>
<p><strong>QC</strong>是将产品的质量去和特定的标准对比的过程，当质量未达到应用标准时会采取一定的措施</p>
<ul>
<li>QC面向的是缺陷的<strong>检测</strong></li>
<li>Inspection 检查</li>
<li>Testing 测试</li>
<li>Checkpoint review 检验点审查</li>
</ul>
</li>
</ul>
<h3 id="Testing-Overview">Testing Overview</h3>
<ul>
<li>
<p>What is testing?</p>
<ul>
<li>分析**软件项目(software item)<strong>来</strong>检测(detect)<strong>已有的和所需要的情况之间的区别，同时去</strong>评价(evaluate)**软件项目的特性。</li>
</ul>
</li>
<li>
<p>Who does testing?</p>
<ul>
<li>
<p>Software Tester</p>
</li>
<li>
<p>Software Developer</p>
</li>
<li>
<p>Project Lead/Manager</p>
</li>
<li>
<p>End User</p>
</li>
<li>
<p>Crowdsourcing Testing</p>
<ul>
<li>Anyone-crowd worker</li>
</ul>
</li>
</ul>
</li>
<li>
<p>When to start testing?</p>
<ul>
<li>
<p>越早越好</p>
</li>
<li>
<p>取决于开发模型</p>
<ul>
<li>瀑布模型 vs 增量模型</li>
</ul>
</li>
<li>
<p>测试在SDLC的不同阶段形式也不同</p>
</li>
</ul>
</li>
<li>
<p>When to stop testing?</p>
<ul>
<li>
<p>永远不会结束</p>
</li>
<li>
<p>一些方面</p>
<ul>
<li>
<p>测试的deadlines</p>
</li>
<li>
<p>管理层决定</p>
</li>
<li>
<p>测试样例执行完成</p>
</li>
<li>
<p>功能或代码覆盖到达某一点</p>
</li>
<li>
<p>bug率低于某一个特定的值并且没有一些严重的bug被识别出来</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Session-2-Preliminary-to-software-testing">Session 2 Preliminary to software testing</h2>
<h3 id="What-is-defect">What is defect?</h3>
<ul>
<li>Error（错误）：在写程序过程中发生</li>
<li>Fault（故障）：是一个或多个错误的表现（<strong>internal</strong> state 内在状态）</li>
<li>Failure（失效）：当一段错误的代码被执行引起了一个错误的状态并且被传播到程序的输出中</li>
<li>Incident（事故）：当Failure发生时没有任何信息被显示</li>
</ul>
<h3 id="Software-defect-definition">Software defect definition</h3>
<ul>
<li>
<p>各种的软件问题</p>
</li>
<li>
<p>存在于代码，数据和文档中</p>
</li>
<li>
<p>与用户的期望不同</p>
</li>
<li>
<p>例如：</p>
<ul>
<li>软件的功能不能被正确执行</li>
<li>缺点
<ul>
<li>运行缓慢</li>
</ul>
</li>
<li>不一致性
<ul>
<li>Ctrl + S 不能保存设置</li>
</ul>
</li>
<li>用于界面设计缺陷
<ul>
<li>一个按钮本来应该显示五个字母，但是只有三个字母可以被看见</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="BUG-kinds">BUG kinds</h3>
<ul>
<li>
<p>Syntactic errors 语法错误</p>
<ul>
<li>
<p>Mal-formed program 畸形的程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x*x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Semantic erros  语义错误</p>
<ul>
<li>
<p>Symbol errors</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> n*n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Type errors</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">squre</span><span class="params">(<span class="type">float</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Logical errors 逻辑错误</p>
<ul>
<li>
<p>编译器:”no errors”</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x+x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="Verification-vs-Validation">Verification vs. Validation</h3>
<ul>
<li>Verification（验证）：软件应该符合它的软件需求规格说明书（<strong>静态</strong>）</li>
<li>Validation（确认）：这个软件做的是用户真的需要的（<strong>动态</strong>）</li>
</ul>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201024185543.png" alt="image-20200916103154717"></p>
<table>
<thead>
<tr>
<th>方面</th>
<th>Verification</th>
<th>Validation</th>
</tr>
</thead>
<tbody>
<tr>
<td>含义</td>
<td>你做的方法对吗</td>
<td>你做的是对的东西吗</td>
</tr>
<tr>
<td>目标</td>
<td>确保软件系统满足了所有的功能要求</td>
<td>确保功能符合预期的行为</td>
</tr>
<tr>
<td>时间</td>
<td>Verification先进行，包括检查文档和代码等</td>
<td>Validation后进行，包括整体产品的检查</td>
</tr>
<tr>
<td>参与者</td>
<td>开发者完成</td>
<td>测试人员完成</td>
</tr>
<tr>
<td>活动</td>
<td>需要的是静态的活动，包括复审，程序规格覆核和一些确认软件是否正确的检查</td>
<td>需要动态的活动包括针对需求去执行软件</td>
</tr>
</tbody>
</table>
<h3 id="Testing-vs-debugging">Testing vs. debugging</h3>
<ul>
<li>
<p><strong>Testing</strong></p>
<p>包含的是对于软件中的bug的识别，而不需要纠正。</p>
<p>Testing是在测试阶段实行的。</p>
</li>
<li>
<p><strong>Debugging</strong></p>
<p>包含的是识别（identifying），分离（isolating）并且修正（fixing）问题和bug。</p>
<p>Debugging是在开发阶段实行的，同时要进行单元测试（Unit Testing）或者在修复已报告的bug的阶段</p>
</li>
</ul>
<h3 id="White-box-vs-Black-box-Test">White-box vs. Black-box Test</h3>
<ul>
<li><strong>白盒测试</strong>
<ul>
<li>测试组件是否符合开发设计要求</li>
<li>structural testing 结构化测试</li>
<li>internal testing 内部测试</li>
<li>测试的关键：
<ul>
<li>源代码 / 设计</li>
</ul>
</li>
</ul>
</li>
<li><strong>黑盒测试</strong>
<ul>
<li>测试组件是否符合软件需求规格说明书 SRS</li>
<li>behavioral testing 行为测试</li>
<li>external testing 外在测试</li>
<li>input-output testing 输入输出的测试</li>
<li>测试的关键：
<ul>
<li>Specification 软件需求规格说明书</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Testing-Life-Cycle">Testing Life Cycle</h3>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201024203237.jpg" alt="STQA_Session_02_Preliminary"></p>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201024185548.png" alt="image-20200916112440932"></p>
<h3 id="Model-of-testing">Model of testing</h3>
<ul>
<li>
<p>The V model</p>
<ul>
<li>用于减少纠正错误的代价，缺陷必须在开发生命周期的早期就被发现</li>
<li>V模型提出了一种软件开发的方法，使得软件开发和软件测试同时开始</li>
</ul>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201024203247.png" alt="image-20200916103328258"></p>
</li>
<li>
<p>V模型的缺陷</p>
<ul>
<li>只关注了<strong>动态的测试(dynamic testing)</strong></li>
<li>没有提及静态测试技术的优点和有效性</li>
</ul>
</li>
<li>
<p>The W model</p>
<ul>
<li>W模型是针对V模型限制的一种扩展和补充</li>
<li>只关注了各开发阶段的静态测试</li>
<li>这些技术比动态测试更加便宜更加高效</li>
</ul>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201024185547.png" alt="image-20200916102554570"></p>
</li>
<li>
<p>从Test the Reuirements到Test the Design Document都是<strong>Verification</strong></p>
</li>
<li>
<p>Unit Test到Acceptance Test都是<strong>Validation</strong></p>
</li>
</ul>
<h3 id="Types-of-testing">Types of testing</h3>
<ol>
<li>
<p>测试用例生成的起源 Source of test generation</p>
<table>
<thead>
<tr>
<th>Artifact</th>
<th>Techique</th>
</tr>
</thead>
<tbody>
<tr>
<td>需求</td>
<td>黑盒</td>
</tr>
<tr>
<td>代码</td>
<td>白盒</td>
</tr>
<tr>
<td>需求和代码</td>
<td>黑盒和白盒</td>
</tr>
<tr>
<td>正式模型：图或者数学的表达方式</td>
<td>基于模型的表达</td>
</tr>
<tr>
<td>组件的接口 （Component’s interface）</td>
<td>接口测试</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>生命周期阶段 Life cycle phase</p>
<table>
<thead>
<tr>
<th>Phase</th>
<th>Techique</th>
</tr>
</thead>
<tbody>
<tr>
<td>编程</td>
<td>单元测试</td>
</tr>
<tr>
<td>集成</td>
<td>集成测试</td>
</tr>
<tr>
<td>系统集成</td>
<td>系统测试</td>
</tr>
<tr>
<td>发布系统（先行版）</td>
<td>Alpha/Beta-tesing/Acceptance tesing</td>
</tr>
<tr>
<td>维护</td>
<td>回归测试</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>测试目的为导向的测试 Goal-directed testing</p>
</li>
</ol>
<h2 id="Session-3-White-Box-Testing">Session 3 White-Box Testing</h2>
<h3 id="Basic-concepts">Basic concepts</h3>
<ul>
<li>白盒测试
<ul>
<li>是一种Validation的技术，用来检查代码是否像预期一样工作</li>
<li>代码的逻辑和结构是可见的</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>White-box Testing</th>
<th>Black-box Testing</th>
</tr>
</thead>
<tbody>
<tr>
<td>程序结构</td>
<td>已知程序结构</td>
<td>未知程序结构</td>
</tr>
<tr>
<td>规模</td>
<td>小规模测试</td>
<td>大规模测试</td>
</tr>
<tr>
<td>依据</td>
<td>详细设计说明，源代码</td>
<td>需求说明，概要设计说明</td>
</tr>
<tr>
<td>面向</td>
<td>程序结构</td>
<td>输入输出接口，功能要求</td>
</tr>
<tr>
<td>适用</td>
<td>单元测试</td>
<td>集成，系统，验收测试</td>
</tr>
<tr>
<td>测试人员</td>
<td>开发人员</td>
<td>专门测试人员，用户</td>
</tr>
<tr>
<td>优点</td>
<td>能够对程序内部的特定部位进行覆盖</td>
<td>能站在用户立场上进行测试</td>
</tr>
<tr>
<td>缺点</td>
<td>无法检验程序的外部特性，不能检测对需求的遗漏</td>
<td>不能测试程序内部特定部位，如果程序规格说明有误，则无法发现</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>白盒测试的难点</p>
<ul>
<li>对于多个选择和流程的循环网来说，不同路径的所有可能路径的总数是天文数字</li>
<li>循环20次，有5^20次路径</li>
</ul>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201024203317.png" alt="image-20200916101834433"></p>
</li>
<li>
<p>不适用穷举调式（exhaustive testing）的原因</p>
<ul>
<li>过于耗费时间</li>
<li>如果有路径遗漏（path omission），穷举调试无法检测到错误</li>
<li>不能发现与数据有关的错误（例如界限和特定的输入）</li>
</ul>
</li>
<li>
<p>白盒测试基于以下原则</p>
<ul>
<li>模块中所有**独立(independent)**的路径必须被实现过至少一次。 <strong>Basis Path Testing</strong></li>
<li>所有的逻辑值需要有两个测试案例：true和false。 <strong>Logic Coverage</strong></li>
<li>检查</li>
<li>程序内部数据结构，并确保其结构的有效性。<strong>Static Testing + Data Flow Testing</strong></li>
<li>在可操作的范围内，运行所有循环。 <strong>Loop Testing</strong></li>
</ul>
</li>
</ul>
<h3 id="Logic-Coverage">Logic Coverage</h3>
<ul>
<li>逻辑覆盖的分类 <strong>Logic Coverage</strong>
<ul>
<li>Statement Coverage</li>
<li>Decision Coverage</li>
<li>Condition Coverage</li>
<li>Condition-Decision Coverage</li>
<li>Condition Combination Coverage</li>
<li>Path Coverage</li>
<li>Complete Coverage</li>
<li>Modified Condition/Decision Coverage</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201024185550.png" alt="image-20200921114105730"></p>
<h4 id="Statement-Coverage-语句覆盖">Statement Coverage 语句覆盖</h4>
<ul>
<li>确保每个可执行语句至少被运行一次</li>
<li>在图中，所有可执行的语句都在L1中，所以选择L1来设计测试案例</li>
<li>$L1 = [(A=2)and(B=0)]or[(A&gt;1)and(B=0)and(x/A&gt;1)]$</li>
<li>假设有三个<strong>变异体(Mutant)</strong>
<ul>
<li>第一个判断变成 (A &gt; 1) or (B=0)</li>
<li>第二个判断变成 (A = 2) and (X&gt;0)</li>
</ul>
</li>
<li>测试用例A=2，B=0，X=3无法检测出错误</li>
</ul>
<h4 id="Decision-Coverage-判定覆盖">Decision Coverage 判定覆盖</h4>
<ul>
<li>
<p>确保每条判断语句的真假分支都至少走过一次</p>
</li>
<li>
<p>针对“Switch–Case”的语句就是多分支</p>
</li>
<li>
<p>测试案例(A, B, x)</p>
<ul>
<li>t1 = (2, 0, 3)经过ace，t2 = (1, 1, 1)经过abd</li>
<li>t3 = (2, 1, 1)经过abe，t4 = (3, 0, 3)经过acd</li>
<li>但是如果把x&gt;1错写成x&lt;1，这两组测试用例无法检测出错误</li>
</ul>
</li>
<li>
<p>Decisions Coverage无法保证能检测出判断语句中的错误情况</p>
</li>
</ul>
<h4 id="Condition-Coverage-条件覆盖">Condition Coverage 条件覆盖</h4>
<ul>
<li>
<p>确保程序中每种情况可能的值至少都要实现一次</p>
</li>
<li>
<p>A &gt; 1 对应T1</p>
</li>
<li>
<p>B = 0 对应T2</p>
</li>
<li>
<p>A = 2 对应T3</p>
</li>
<li>
<p>X &gt; 1 对应T4</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>测试用例</th>
<th>路径</th>
<th>条件真值Condition value</th>
<th>覆盖路径Coverage branch</th>
</tr>
</thead>
<tbody>
<tr>
<td>(2, 0, 4)</td>
<td>ace</td>
<td>T1 T2 T3 T4</td>
<td>ce (T, T)</td>
</tr>
<tr>
<td>(1, 1, 1)</td>
<td>abd</td>
<td>!T1 !T2 !T3 !T4</td>
<td>bd (F, F)</td>
</tr>
</tbody>
</table>
<ul>
<li>下组测试用例证明，满足条件覆盖CC不一定满足判定覆盖DC</li>
</ul>
<table>
<thead>
<tr>
<th>测试用例</th>
<th>路径</th>
<th>条件真值Condition value</th>
<th>覆盖路径Coverage branch</th>
</tr>
</thead>
<tbody>
<tr>
<td>(1, 0, 3)</td>
<td>abe</td>
<td>!T1 T2 !T3 T4</td>
<td>be (F, T)</td>
</tr>
<tr>
<td>(2, 1, 1)</td>
<td>abe</td>
<td>T1 !T2 T3 !T4</td>
<td>be (F, T)</td>
</tr>
</tbody>
</table>
<ul>
<li>下组测试用例证明，满足判定覆盖DC不一定满足条件覆盖CC</li>
</ul>
<table>
<thead>
<tr>
<th>测试用例</th>
<th>路径</th>
<th>条件真值Condition value</th>
<th>覆盖路径Coverage branch</th>
</tr>
</thead>
<tbody>
<tr>
<td>(2, 0, 4)</td>
<td>ace</td>
<td>T1 T2 T3 T4</td>
<td>ce (T, T)</td>
</tr>
<tr>
<td>(3, 1, 1)</td>
<td>abd</td>
<td>T1 !T2 !T3 !T4</td>
<td>bd (F, F)</td>
</tr>
</tbody>
</table>
<h4 id="Condition-Decision-Coverage-条件判断覆盖">Condition/Decision Coverage 条件判断覆盖</h4>
<ul>
<li>
<p>确保每条判断语句的真假分支都至少走过一次</p>
</li>
<li>
<p>同时确保程序中每种情况可能的值至少都要实现一次</p>
</li>
<li>
<p>例如上面第一组测试用例</p>
</li>
</ul>
<h4 id="Condition-Combination-Coverage-条件组合覆盖">Condition Combination Coverage 条件组合覆盖</h4>
<ul>
<li>
<p>每个判定所有可能的条件组合</p>
</li>
<li>
<p>包括了DC,CC,CDC</p>
</li>
</ul>
<ol>
<li>A &gt; 1，B = 0 T1T2</li>
<li>A &gt; 1，B ≠ 0 T1!T2</li>
<li>A ≯ 1，B = 0 !T1T2</li>
<li>A ≯ 1，B ≠ 0 !T1!T2</li>
<li>A = 2，X &gt; 1 T3T4</li>
<li>A = 2，X ≯ 1 T3!T4</li>
<li>A  ≠ 2，X&gt;1 !T3T4</li>
<li>A ≠ 2，X ≯ 1 !T3!T4</li>
</ol>
<table>
<thead>
<tr>
<th>测试用例</th>
<th>路径</th>
<th>Coverage condition</th>
<th>Combination Coverage No.</th>
</tr>
</thead>
<tbody>
<tr>
<td>(2, 0, 4)</td>
<td>ace</td>
<td>T1 T2 T3 T4</td>
<td>1, 5</td>
</tr>
<tr>
<td>(2, 1, 1)</td>
<td>abe</td>
<td>T1 !T2 T3 !T4</td>
<td>2, 6</td>
</tr>
<tr>
<td>(1, 1, 1)</td>
<td>abe</td>
<td>!T1 T2 !T3 T4</td>
<td>3, 7</td>
</tr>
<tr>
<td>(1, 1, 1)</td>
<td>abd</td>
<td>!T1 !T2 !T3 !T4</td>
<td>4, 8</td>
</tr>
</tbody>
</table>
<ul>
<li>满足CCC，但是只覆盖了三个路径，遗漏了acd</li>
</ul>
<h4 id="Path-Coverage-路径覆盖">Path Coverage 路径覆盖</h4>
<ul>
<li>覆盖程序中所有可能的路径</li>
</ul>
<h4 id="Complete-Coverage-全覆盖">Complete Coverage 全覆盖</h4>
<ul>
<li>Complete Coverage  = Condition Combination Coverage + Path Coverage</li>
</ul>
<table>
<thead>
<tr>
<th>测试用例</th>
<th>路径</th>
<th>Coverage condition</th>
<th>Combination Coverage No.</th>
</tr>
</thead>
<tbody>
<tr>
<td>(2, 0, 4)</td>
<td>ace</td>
<td>T1 T2 T3 T4</td>
<td>1, 5</td>
</tr>
<tr>
<td>(2, 1, 1)</td>
<td>abe</td>
<td>T1 !T2 T3 !T4</td>
<td>2, 6</td>
</tr>
<tr>
<td>(1, 0, 3)</td>
<td>abe</td>
<td>!T1 T2 !T3 T4</td>
<td>3, 7</td>
</tr>
<tr>
<td>(1, 1, 1)</td>
<td>abd</td>
<td>!T1 !T2 !T3 !T4</td>
<td>4, 8</td>
</tr>
<tr>
<td>(3, 0, 3)</td>
<td>acd</td>
<td>T1 T2 !T3 !T4</td>
<td>1, 8</td>
</tr>
</tbody>
</table>
<h4 id="Modified-Condition-Decision-Coverage">Modified Condition/Decision Coverage</h4>
<ul>
<li>每个入口和出口都被调用</li>
<li>满足判定覆盖</li>
<li>满足条件覆盖</li>
<li>在每个条件的判定中都必须显示出它能独立地影响判定的结果</li>
</ul>
<table>
<thead>
<tr>
<th>测试用例</th>
<th>路径</th>
<th>Coverage condition</th>
<th>Combination Coverage No.</th>
</tr>
</thead>
<tbody>
<tr>
<td>(2, 0, 4)</td>
<td>ace</td>
<td>T1 T2 T3 T4</td>
<td>1, 5</td>
</tr>
<tr>
<td>(2, 1, 1)</td>
<td>abe</td>
<td>T1 !T2 T3 !T4</td>
<td>2, 6</td>
</tr>
<tr>
<td>(1, 0, 3)</td>
<td>abe</td>
<td>!T1 T2 !T3 T4</td>
<td>3, 7</td>
</tr>
<tr>
<td>(1, 1, 1)</td>
<td>abd</td>
<td>!T1 !T2 !T3 !T4</td>
<td>4, 8</td>
</tr>
</tbody>
</table>
<h4 id="练习题">练习题</h4>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201024185549.png" alt="image-20200916114033990"></p>
<ul>
<li>Statement Coverage</li>
</ul>
<table>
<thead>
<tr>
<th>测试用例</th>
<th>覆盖情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>(18, 18)</td>
<td>S3</td>
</tr>
<tr>
<td>(-1, -1)</td>
<td>S1</td>
</tr>
<tr>
<td>(1, 1)</td>
<td>S2</td>
</tr>
</tbody>
</table>
<ul>
<li>Decision Coverage</li>
</ul>
<table>
<thead>
<tr>
<th>测试用例</th>
<th>覆盖情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>(18, 18)</td>
<td>YY</td>
</tr>
<tr>
<td>(10, 10)</td>
<td>YN</td>
</tr>
<tr>
<td>(-1, -1)</td>
<td>NN</td>
</tr>
<tr>
<td>(1, 1)</td>
<td>NY</td>
</tr>
</tbody>
</table>
<ul>
<li>Condition Coverage
<ul>
<li>T1: X&gt;8</li>
<li>T2: Y&gt;5</li>
<li>T3: X&gt;0</li>
<li>T4: Y&gt;0</li>
<li>T5: X&gt;16</li>
<li>T6: Y&gt;10</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>测试用例</th>
<th>覆盖情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>(18, 18)</td>
<td>T1, T2, T5, T6</td>
</tr>
<tr>
<td>(10, 10)</td>
<td>T1, T2, !T5, !T6</td>
</tr>
<tr>
<td>(-1, -1)</td>
<td>!T1, !T2, !T3, !T4</td>
</tr>
<tr>
<td>(1, 1)</td>
<td>!T1, !T2, T3, T4</td>
</tr>
</tbody>
</table>
<ul>
<li>Condition/Decision Coverage</li>
</ul>
<table>
<thead>
<tr>
<th>测试用例</th>
<th>判定覆盖情况</th>
<th>条件覆盖情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>(18, 18)</td>
<td>YY</td>
<td>T1, T2, T5, T6</td>
</tr>
<tr>
<td>(10, 10)</td>
<td>YN</td>
<td>T1, T2, !T5, !T6</td>
</tr>
<tr>
<td>(-1, -1)</td>
<td>NN</td>
<td>!T1, !T2, !T3, !T4</td>
</tr>
<tr>
<td>(1, 1)</td>
<td>NY</td>
<td>!T1, !T2, T3, T4</td>
</tr>
</tbody>
</table>
<ul>
<li>MCDC</li>
</ul>
<table>
<thead>
<tr>
<th>测试用例</th>
<th>条件覆盖情况</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>(18, 18)</td>
<td>T1, T2, T5, T6</td>
<td>T T</td>
</tr>
<tr>
<td>(15,11)</td>
<td>T1, T2, !T5, T6</td>
<td>T F</td>
</tr>
<tr>
<td>(17, 10)</td>
<td>T1, T2, T5, !T6</td>
<td>T F</td>
</tr>
<tr>
<td><strong>(10, 10)舍</strong></td>
<td><strong>T1, T2, !T5, !T6</strong></td>
<td>T F</td>
</tr>
<tr>
<td>(-1, -1)</td>
<td>!T1, !T2, !T3, !T4</td>
<td>F F</td>
</tr>
<tr>
<td>(-1, 6)</td>
<td>!T1, T2, !T3, T4</td>
<td>F T</td>
</tr>
<tr>
<td>(10, -1)</td>
<td>T1, !T2, T3, !T4</td>
<td>F T</td>
</tr>
<tr>
<td><strong>(1, 1)舍</strong></td>
<td><strong>!T1, !T2, T3, T4</strong></td>
<td>F T</td>
</tr>
</tbody>
</table>
<ul>
<li>Condition Combination Coverage</li>
</ul>
<ol>
<li>X&gt;8, Y&gt;5 <strong>T1 T2</strong></li>
<li>X&gt;8, Y&lt;=5 <strong>T1 !T2</strong></li>
<li>X&lt;=8, Y&gt;5 <strong>!T1 T2</strong></li>
<li>X&lt;=8, Y&lt;=5 <strong>!T1 !T2</strong></li>
<li>X&gt;0, Y&gt;0 <strong>T3 T4</strong></li>
<li>X&gt;0, Y&lt;=0 <strong>T3 !T4</strong></li>
<li>X&lt;=0, Y&gt;0 <strong>!T3 T4</strong></li>
<li>X&lt;=0, Y&lt;=0 <strong>!T3 !T4</strong></li>
<li>X&gt;16, Y&gt;10 <strong>T5 T6</strong></li>
<li>X&gt;16, Y&lt;=10 <strong>T5 !T6</strong></li>
<li>X&lt;=16, Y&gt;10 <strong>!T5 T6</strong></li>
<li>X&lt;=16, Y&lt;=10 <strong>!T5!T6</strong></li>
</ol>
<table>
<thead>
<tr>
<th>测试用例</th>
<th>组合覆盖情况</th>
<th>条件覆盖情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>(18, 18)</td>
<td>1,9</td>
<td>T1, T2, T5, T6</td>
</tr>
<tr>
<td>(15,11)</td>
<td>1,10</td>
<td>T1, T2, !T5, T6</td>
</tr>
<tr>
<td>(17, 10)</td>
<td>1,11</td>
<td>T1, T2, T5, !T6</td>
</tr>
<tr>
<td>(10, 10)</td>
<td>1,12</td>
<td>T1, T2, !T5, !T6</td>
</tr>
<tr>
<td>(-1, -1)</td>
<td>4,8</td>
<td>!T1, !T2, !T3, !T4</td>
</tr>
<tr>
<td>(-1, 6)</td>
<td>3,7</td>
<td>!T1, T2, !T3, T4</td>
</tr>
<tr>
<td>(10, -1)</td>
<td>2,6</td>
<td>T1, !T2, T3, !T4</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>Path Coverage</p>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201024185551.png" alt="image-20200922114158843"></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>测试用例</th>
<th>路径</th>
</tr>
</thead>
<tbody>
<tr>
<td>(18, 18)</td>
<td>d</td>
</tr>
<tr>
<td>(10, 10)</td>
<td>c</td>
</tr>
<tr>
<td>(-1, -1)</td>
<td>a</td>
</tr>
<tr>
<td>(1, 1)</td>
<td>b</td>
</tr>
</tbody>
</table>
<ul>
<li>Complete Coverage</li>
</ul>
<table>
<thead>
<tr>
<th>测试用例</th>
<th>组合覆盖情况</th>
<th>条件覆盖情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>(18, 18)</td>
<td>1,9</td>
<td>T1, T2, T5, T6</td>
</tr>
<tr>
<td>(15,11)</td>
<td>1,10</td>
<td>T1, T2, !T5, T6</td>
</tr>
<tr>
<td>(17, 10)</td>
<td>1,11</td>
<td>T1, T2, T5, !T6</td>
</tr>
<tr>
<td>(10, 10)</td>
<td>1,12</td>
<td>T1, T2, !T5, !T6</td>
</tr>
<tr>
<td>(-1, -1)</td>
<td>4,8</td>
<td>!T1, !T2, !T3, !T4</td>
</tr>
<tr>
<td>(-1, 6)</td>
<td>3,7</td>
<td>!T1, T2, !T3, T4</td>
</tr>
<tr>
<td>(10, -1)</td>
<td>2,6</td>
<td>T1, !T2, T3, !T4</td>
</tr>
<tr>
<td>(1, 1)</td>
<td>4,5</td>
<td>!T1, !T2, T3, T4</td>
</tr>
</tbody>
</table>
<p>A AND (B OR C)</p>
<ul>
<li>DC</li>
</ul>
<table>
<thead>
<tr>
<th>A, B, C</th>
<th>Decsion</th>
<th>Condition</th>
</tr>
</thead>
<tbody>
<tr>
<td>1, 1, 1</td>
<td>T</td>
<td>A B C</td>
</tr>
<tr>
<td>1, 1, 0</td>
<td>T</td>
<td>A B !C</td>
</tr>
<tr>
<td>1, 0, 1</td>
<td>T</td>
<td>A !B C</td>
</tr>
<tr>
<td>0, 1, 1</td>
<td>F</td>
<td>!A B C</td>
</tr>
<tr>
<td>1, 0, 0</td>
<td>F</td>
<td>A !B !C</td>
</tr>
<tr>
<td>0, 1, 0</td>
<td>F</td>
<td>!A B !C</td>
</tr>
<tr>
<td>0, 0, 1</td>
<td>F</td>
<td>!A !B C</td>
</tr>
<tr>
<td>0, 0, 0</td>
<td>F</td>
<td>!A !B !C</td>
</tr>
</tbody>
</table>
<img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201024185552.png" alt="image-20200922124059004" style="zoom:67%;" />
<img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201024221133.png" alt="image-20201024221133555" style="zoom:67%;" />
<h3 id="Control-Flow-Graph">Control Flow Graph</h3>
<ul>
<li>
<p>可以认为是一种简化的程序流程图，重点去凸显控制流的结构</p>
</li>
<li>
<p>结构</p>
<ul>
<li>箭头arrow用边edge表示控制流走向</li>
<li>结点node都用圆圈circle来表示若干行为</li>
<li>由边和结点圈起来的地方叫做regions</li>
<li><strong>predicate node</strong>至少包含了一个条件</li>
</ul>
</li>
<li>
<p>程序流程图和控制流图的转换</p>
<img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201024221226.png" alt="image-20201024221226106" style="zoom:67%;" />
</li>
</ul>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201024185555.jpg" alt="image-20200927104628919"></p>
<h4 id="练习题-2">练习题</h4>
<ul>
<li>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201024185556.png" alt="STQA_Session_04_Basis Path Testing"></p>
</li>
<li>
<p>语句覆盖SC</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>测试用例(A, B, S)</th>
<th>语句覆盖情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>2, 2, 0</td>
<td>e,c</td>
</tr>
<tr>
<td>0, 0, 10000</td>
<td>b,f</td>
</tr>
</tbody>
</table>
<ul>
<li>判定覆盖DC</li>
</ul>
<table>
<thead>
<tr>
<th>测试用例(A, B, S)</th>
<th>判定覆盖情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>2, 2, 0</td>
<td>T, F</td>
</tr>
<tr>
<td>0, 0, 10000</td>
<td>F, T</td>
</tr>
</tbody>
</table>
<ul>
<li>条件覆盖CC
<ul>
<li>A&gt;1 对应T1</li>
<li>B&gt;1 对应T2</li>
<li>S&gt;9999 对应T3</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>测试用例(A, B, S)</th>
<th>条件覆盖情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>2, 2, 0</td>
<td>T1, T2, !T3</td>
</tr>
<tr>
<td>0, 0, 10000</td>
<td>!T1, !T2, T3</td>
</tr>
</tbody>
</table>
<ul>
<li>条件判定覆盖CDC</li>
</ul>
<table>
<thead>
<tr>
<th>测试用例(A, B, S)</th>
<th>条件覆盖情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>2, 2, 0</td>
<td>T1, T2, !T3</td>
</tr>
<tr>
<td>0, 0, 10000</td>
<td>!T1, !T2, T3</td>
</tr>
</tbody>
</table>
<ul>
<li>条件组合覆盖CCC</li>
</ul>
<table>
<thead>
<tr>
<th>测试用例(A, B, S)</th>
<th>条件覆盖情况</th>
</tr>
</thead>
<tbody>
<tr>
<td>2, 2, 10000</td>
<td>T1, T2, T3</td>
</tr>
<tr>
<td>1, 2, 10000</td>
<td>!T1, T2, T3</td>
</tr>
<tr>
<td>1, 1, 9997</td>
<td>!T1, !T2, !T3</td>
</tr>
<tr>
<td>2, 1, 9997</td>
<td>T1, !T2, !T3</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> iStudents, <span class="type">int</span> iData[ ])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> y=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> z=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> loop=<span class="number">0</span>; loop&lt; iStudents;loop++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> dNum= iData[loop];</span><br><span class="line">		<span class="keyword">if</span>(dNum&lt;<span class="number">60</span>)</span><br><span class="line">			x++;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(dNum&gt;=<span class="number">60</span>)</span><br><span class="line">				y++;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				z++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201024185558.png" alt="image-20200928104856202" style="zoom:67%;" />
<ul>
<li>环路复杂度 = 4</li>
<li>基本路径数 = 4</li>
</ul>
<table>
<thead>
<tr>
<th>路径</th>
<th>输入-&gt;输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>3-4-17</td>
<td>iStudents = 0 -&gt; x=0, y=0, z=0</td>
</tr>
<tr>
<td>3-4-7-8-16-4-17</td>
<td>iStudents = 1, iData = [59] -&gt; x=1, y=0, z=0</td>
</tr>
<tr>
<td>3-4-7-11-12-15-16-4-17</td>
<td>iStudents = 1, iData = [61] -&gt; x=0, y=1, z=0</td>
</tr>
<tr>
<td>3-4-7-11-14-15-16-4-17</td>
<td>null</td>
</tr>
</tbody>
</table>
<h2 id="Session-4-Basis-Path-Testing">Session 4 Basis Path Testing</h2>
<ul>
<li>
<p>使用这种方法生成一系列线性无关路径（基本路径）</p>
</li>
<li>
<p>使用基本路径的原因</p>
<ul>
<li>穷举法难以实现</li>
<li>使用流程化的设计去获取一系列逻辑复杂度测量</li>
<li>测试用例至少执行了每条语句一次</li>
</ul>
</li>
<li>
<p>介于全路径覆盖和分支覆盖</p>
</li>
<li>
<p>如何设计</p>
<ul>
<li>使用设计图或者代码，画出控制流图</li>
<li>算出流图的<strong>环路复杂度cyclomatic complexity</strong></li>
<li>确定基本路径的数量</li>
<li>设计测试用例来执行每条路径</li>
</ul>
</li>
</ul>
<h3 id="环路复杂度计算">环路复杂度计算</h3>
<ul>
<li>Cyclomatic complexity
<ul>
<li>每当新增一条独立路径，要能覆盖多一个结点或多一条边</li>
<li>$Edges - Nodes + 2$</li>
<li>$Predicate Nodes+1$
<ul>
<li>判定结点，要做出逻辑选择的结点（出度≥2）</li>
<li>循环入口出口结点</li>
<li>判断分支结点</li>
</ul>
</li>
<li>$closed regions+1$</li>
</ul>
</li>
</ul>
<h3 id="练习">练习</h3>
<ul>
<li>
<p>输入：Score[i]</p>
</li>
<li>
<p>输出：n2, sum, average</p>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201024185600.png" alt="image-20200928111930225"></p>
</li>
<li>
<p>不进行条件分解，要满足分支覆盖</p>
<ul>
<li>
<img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201024185559.png" alt="image-20200928111143173" style="zoom:67%;" />
</li>
<li>
<p>环路复杂度 = 4</p>
</li>
<li>
<table>
<thead>
<tr>
<th>路径</th>
<th>输入(Scores数组)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1-2-7-8-10</td>
<td>[-1]</td>
</tr>
<tr>
<td>1-2-7-9-10</td>
<td>null</td>
</tr>
<tr>
<td>1-2-3-4-5-6-7-8-10</td>
<td>[-2,-1]</td>
</tr>
<tr>
<td>1-2-3-4-6-7-9-10</td>
<td>[1, -1]</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>进行条件分解</p>
<ul>
<li>
<img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201024185601.png" alt="image-20200928113349427" style="zoom:67%;" />
</li>
<li>
<p>环路复杂度 = 6</p>
</li>
<li>
<table>
<thead>
<tr>
<th>路径</th>
<th>输入</th>
</tr>
</thead>
<tbody>
<tr>
<td>1-2-3-4-5-6-7-8-2-9-10-12</td>
<td>[1, -1]</td>
</tr>
<tr>
<td>1-2-3-4-5-6-8-2-9-10-12</td>
<td>[101,-1]</td>
</tr>
<tr>
<td>1-2-3-4-5-8-2-9-10-12</td>
<td>[-2, -1]</td>
</tr>
<tr>
<td>1-2-3-9-10-12</td>
<td>null</td>
</tr>
<tr>
<td>1-2-9-10-12</td>
<td>[-1]</td>
</tr>
<tr>
<td>1-2-9-11-12</td>
<td>null</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
<h2 id="Session-5-Loop-Testing">Session 5 Loop Testing</h2>
<ul>
<li>Simple Loops
<ul>
<li>简单循环</li>
</ul>
</li>
<li>Nested Loops
<ul>
<li>嵌套循环</li>
</ul>
</li>
<li>Concatenated Loops
<ul>
<li>串联循环</li>
</ul>
</li>
<li>Unstructured Loops
<ul>
<li>非结构化循环</li>
</ul>
</li>
</ul>
<h3 id="简单循环-Simple-Loops">简单循环 Simple Loops</h3>
<ul>
<li>若n为循环的最大可能次数
<ul>
<li>执行0次</li>
<li>执行1次</li>
<li>执行2次</li>
<li>执行m次，m&lt;n</li>
<li>执行n-1次，n次，n+1次</li>
</ul>
</li>
</ul>
<h3 id="嵌套循环-Nested-Loops">嵌套循环 Nested Loops</h3>
<ul>
<li>
<p>从最内层循环开始</p>
</li>
<li>
<p>对最内存循环进行Simple Loops测试</p>
</li>
<li>
<p>一层一层向外，所有外层取最小值，其余的嵌套循环取典型值typical values</p>
</li>
</ul>
<h3 id="串联循环-Concatenated-Loops">串联循环 Concatenated Loops</h3>
<ul>
<li>如果每个循环独立于其他循环
<ul>
<li>使用简单循环的测试方法</li>
</ul>
</li>
<li>反之
<ul>
<li>需要应用循环测试</li>
</ul>
</li>
</ul>
<h3 id="非结构化循环">非结构化循环</h3>
<ul>
<li>重新设计循环</li>
<li>不要使用<code>go to</code>语句</li>
</ul>
<h3 id="Z-path-coverage">Z path coverage</h3>
<ul>
<li>测试循环的简单方法就是使用 Z path coverage</li>
<li>就是把循环简化为IF结构</li>
<li>循环执行一次或零次</li>
</ul>
<h3 id="例题">例题</h3>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20201012104940630.png" alt="image-20201012104940630" style="zoom:70%;" align=left/><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20201012105603198.png" alt="image-20201012105603198" style="zoom:67%;" align=right /></p>
<ul>
<li>基本路径
<ul>
<li>3.1-3.2-12</li>
<li>3.1-3.2-5-6.1-10-3.3-3.2-12</li>
<li>3.1-3.2-5-6.1-6.2-10-3.3-3.2-12</li>
<li>3.1-3.2-5-6.1-6.2-8-6.1-6.2-10-3.3-3.2-12</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>路径</th>
<th>测试用例 numbers[], array_size</th>
<th>输出</th>
</tr>
</thead>
<tbody>
<tr>
<td>3.1-3.2-12</td>
<td>[1,2], 0</td>
<td>[1,2]</td>
</tr>
<tr>
<td>3.1-3.2-5-6.1-9-3.3-3.2-12</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>3.1-3.2-5-6.1-6.2-10-3.3-3.2-12</td>
<td>[1,2], 2</td>
<td>[1,2]</td>
</tr>
<tr>
<td>3.1-3.2-5-6.1-6.2-8-6.1-10-3.3-3.2-12</td>
<td>[2,1], 2</td>
<td>[1,2]</td>
</tr>
</tbody>
</table>
<h3 id="Data-Flow-Testing">Data Flow Testing</h3>
<ul>
<li>变量的定义，使用和删除的位置</li>
<li>检测的错误
<ul>
<li>错误的声明或输入语句</li>
<li>缺失定义语句</li>
<li>谓词错误</li>
</ul>
</li>
</ul>
<h4 id="Variable-Definitions-and-Uses">Variable Definitions and Uses</h4>
<ul>
<li>
<p>定义变量</p>
<ul>
<li>赋值表达式的左侧
<ul>
<li><code>y = 7</code></li>
</ul>
</li>
<li>在输入语句中
<ul>
<li><code>input(y)</code></li>
</ul>
</li>
<li>输出时的调用
<ul>
<li><code>DOIT(X:IN,Y:OUT)</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>使用变量</p>
<ul>
<li>赋值语句的右侧
<ul>
<li><code>y = x+17</code></li>
</ul>
</li>
<li>作为函数参数被调用
<ul>
<li><code>y=sqrt(x)</code></li>
</ul>
</li>
<li>分支语句中
<ul>
<li><code>if x&gt;0 then</code></li>
</ul>
</li>
<li><strong>p-use</strong>
<ul>
<li>分支中使用变量</li>
</ul>
</li>
<li><strong>c-use</strong>
<ul>
<li>非分支中使用变量</li>
</ul>
</li>
</ul>
</li>
<li>
<p>一些变量可能即被定义又被使用</p>
<ul>
<li><code>y=y+x</code></li>
<li><code>y:in/out</code></li>
</ul>
</li>
<li>
<p>变量第一次出现的三种可能存在</p>
<ul>
<li>~d — 变量不存在，被定义了</li>
<li>~u — 变量不存在，被使用了</li>
<li>~k — 变量不存在，被销毁了</li>
</ul>
</li>
<li>
<p>9种配对方式</p>
<ul>
<li><strong>dd</strong> — 定义了之后又定义了
<ul>
<li>未被使用过，但定义了两次，有可能是错的</li>
</ul>
</li>
<li>du — 定义了之后使用了</li>
<li><strong>dk</strong> — 定义了然后被销毁了
<ul>
<li>有可能是错的</li>
</ul>
</li>
<li>ud</li>
<li>uu</li>
<li>uk</li>
<li>kd</li>
<li><strong>ku</strong> - 销毁之后又被使用
<ul>
<li>严重错误</li>
</ul>
</li>
<li><strong>kk</strong> - 销毁之后又被销毁
<ul>
<li>有可能是错的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Data-flow-graph">Data flow graph</h4>
<ul>
<li>所有变量
<ul>
<li>definition</li>
<li>use</li>
<li>destruction</li>
</ul>
</li>
<li>流程
<ul>
<li>画图</li>
<li>静态测试</li>
<li>动态测试</li>
</ul>
</li>
</ul>
<img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20201012114922666.png" alt="image-20201012114922666"  />
<ul>
<li>针对变量x
<ul>
<li>~define</li>
<li><strong>define-define</strong></li>
<li>define-use</li>
</ul>
</li>
<li>针对变量y
<ul>
<li><strong>~use</strong></li>
<li>use-define</li>
<li>define-use</li>
<li>use-kill</li>
<li><strong>define-kill</strong></li>
</ul>
</li>
<li>针对变量z
<ul>
<li><strong>~kill</strong></li>
<li><strong>kill-use</strong></li>
<li>use-use</li>
<li>use-use</li>
<li>use-define</li>
<li><strong>kill-kill</strong></li>
<li>kill-define</li>
<li>define-use</li>
</ul>
</li>
</ul>
<h2 id="Session-6-Data-Flow-Testing">Session 6 Data Flow Testing</h2>
<ul>
<li><strong>定义清除 definition clear(def-clear)</strong>
<ul>
<li>对变量没有重复定义(re-definition)</li>
</ul>
</li>
<li><strong>定义使用对 definition-use pair(du-pair)</strong>
<ul>
<li>对变量来说，从定义到使用的def-clear路径</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">input</span>(A, B) <span class="comment"># 使用AB</span></span><br><span class="line"><span class="keyword">if</span> B&gt;<span class="number">1</span>: <span class="comment"># 使用B</span></span><br><span class="line">	A = A+<span class="number">7</span> <span class="comment"># 定义，使用A</span></span><br><span class="line"><span class="keyword">if</span> A&gt;<span class="number">10</span>: <span class="comment"># 使用A</span></span><br><span class="line">    B = A+B <span class="comment"># 定义B，使用AB</span></span><br><span class="line">output(A, B) <span class="comment"># 定义AB</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>定义</p>
<ul>
<li>
<p><strong>simple</strong></p>
<ul>
<li>路径中的所有边不同</li>
</ul>
</li>
<li>
<p><strong>loop-free</strong></p>
<ul>
<li>没有环路（经过的结点不重复）</li>
</ul>
</li>
<li>
<table>
<thead>
<tr>
<th>path</th>
<th>simple</th>
<th>loop-free</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;1,3,4,2&gt;</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>&lt;1,2,3,2&gt;</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>&lt;1,2,3,1,2&gt;</td>
<td>not</td>
<td>no</td>
</tr>
<tr>
<td>&lt;1,2,3,2,4&gt;</td>
<td>yes</td>
<td>no</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p><strong>DU-PATH</strong></p>
<ul>
<li>对于任意的变量，如果变量v被定义，必须满足
<ol>
<li>如果是v的<strong>c-use</strong>在<strong>nk</strong>结点上，则必须保证**&lt;n1,n2,…,nj,nk&gt;<strong>是一条def-clear且</strong>simple**的path
<ul>
<li>simple: 没有重复边</li>
</ul>
</li>
<li>如果是v的<strong>p-use</strong>在**&lt;nj,nk&gt;<strong>边上，那么</strong>&lt;n1,n2,…nj&gt;<strong>必须是def-clear且</strong>loop-free**的path
<ul>
<li>loop-free: 没有重复结点</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201021124125.png" alt="image-20201021124125112"></p>
<ul>
<li>针对变量A</li>
</ul>
<table>
<thead>
<tr>
<th>du-pair</th>
<th>d-c path</th>
</tr>
</thead>
<tbody>
<tr>
<td>(1,2)</td>
<td>&lt;1,2&gt;</td>
</tr>
<tr>
<td>(1,4)</td>
<td>&lt;1,3,4&gt;</td>
</tr>
<tr>
<td>(1,5)</td>
<td>&lt;1,3,4,5&gt;</td>
</tr>
<tr>
<td></td>
<td>&lt;1,3,5&gt;</td>
</tr>
<tr>
<td>(1,&lt;3,4&gt;)</td>
<td>&lt;1,3,4&gt;</td>
</tr>
<tr>
<td>(1,&lt;3,5&gt;)</td>
<td>&lt;1,3,5&gt;</td>
</tr>
<tr>
<td>(2,4)</td>
<td>&lt;2,3,4&gt;</td>
</tr>
<tr>
<td>(2,5)</td>
<td>&lt;2,3,4,5&gt;</td>
</tr>
<tr>
<td></td>
<td>&lt;2,3,5&gt;</td>
</tr>
<tr>
<td>(2,&lt;3,4&gt;)</td>
<td>&lt;2,3,4&gt;</td>
</tr>
<tr>
<td>(2,&lt;3,5&gt;)</td>
<td>&lt;2,3,5&gt;</td>
</tr>
</tbody>
</table>
<ul>
<li>针对变量B</li>
</ul>
<table>
<thead>
<tr>
<th>du-pair</th>
<th>d-c path</th>
</tr>
</thead>
<tbody>
<tr>
<td>(1,&lt;1,2&gt;)</td>
<td>&lt;1,2&gt;</td>
</tr>
<tr>
<td>(1,&lt;1,3&gt;)</td>
<td>&lt;1,3&gt;</td>
</tr>
<tr>
<td>(1,4)</td>
<td>&lt;1,3,4&gt;</td>
</tr>
<tr>
<td></td>
<td>&lt;1,2,3,4&gt;</td>
</tr>
<tr>
<td>(1,5)</td>
<td>&lt;1,3,5&gt;</td>
</tr>
<tr>
<td></td>
<td>&lt;1,2,3,5&gt;</td>
</tr>
<tr>
<td>(4,5)</td>
<td>&lt;4,5&gt;</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p><strong>全定义覆盖 All-Defs</strong></p>
<ul>
<li>关于某个变量v，它所有定义的地方都至少覆盖一次</li>
</ul>
</li>
<li>
<p><strong>全使用覆盖 All-Uses</strong></p>
<ul>
<li>关于某个变量v，所有引用的地方都至少覆盖一次</li>
</ul>
</li>
<li>
<p>例题</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">input(X,Y) <span class="comment">// 使用X</span></span><br><span class="line"><span class="keyword">while</span>(Y&gt;<span class="number">0</span>) <span class="keyword">do</span></span><br><span class="line">    <span class="title function_">if</span> <span class="params">(X&gt;<span class="number">0</span>)</span> then</span><br><span class="line">        Y = Y-X;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        input(X);</span><br><span class="line">	end_if</span><br><span class="line">end_while</span><br><span class="line"><span class="title function_">output</span><span class="params">(X,Y)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>数据流图</p>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201021124315.png" alt="image-20201021124315032"></p>
</li>
<li>
<p>X</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>du-pairs</th>
<th>d-c path</th>
</tr>
</thead>
<tbody>
<tr>
<td>(1,&lt;3,4&gt;)</td>
<td>&lt;1,2,3,4&gt;</td>
</tr>
<tr>
<td></td>
<td>&lt;1,2,3,4,(6,2,3,4)*&gt;</td>
</tr>
<tr>
<td>(1,&lt;3,5&gt;)</td>
<td>&lt;1,2,3,5&gt;</td>
</tr>
<tr>
<td>(1,4)</td>
<td>&lt;1,2,3,4&gt;</td>
</tr>
<tr>
<td></td>
<td>&lt;1,2,3,4,(6,2,3,4)*&gt;</td>
</tr>
<tr>
<td>(1,7)</td>
<td>&lt;1,2,7&gt;</td>
</tr>
<tr>
<td></td>
<td>&lt;1,2,3,4,6,2,7&gt;</td>
</tr>
<tr>
<td></td>
<td>&lt;1,2,3,4,6,(2,3,4,6)*,2,7&gt;</td>
</tr>
<tr>
<td>(5, 4)</td>
<td>&lt;5,6,2,3,4&gt;</td>
</tr>
<tr>
<td></td>
<td>&lt;5,6,2,3,4,(6,2,3,4)*&gt;</td>
</tr>
<tr>
<td>(5,7)</td>
<td>&lt;5,6,2,7&gt; ×</td>
</tr>
<tr>
<td></td>
<td>&lt;5,6,2,3,4,6,2,7&gt;</td>
</tr>
<tr>
<td></td>
<td>&lt;5,6,2,3,4,6,(2,3,4,6)*,2,7&gt;</td>
</tr>
<tr>
<td>(5,&lt;3,4&gt;)</td>
<td>&lt;5,6,2,3,4&gt;</td>
</tr>
<tr>
<td></td>
<td>&lt;5,6,2,3,4,(6,2,3,4)*&gt;</td>
</tr>
<tr>
<td>(5,&lt;3,4&gt;)</td>
<td>&lt;5,6,2,3,5&gt;</td>
</tr>
<tr>
<td></td>
<td>&lt;5,6,2,3,4,6,2,3,5&gt;</td>
</tr>
<tr>
<td></td>
<td>&lt;5,6,2,3,4,6,(2,3,4,6)*,2,3,5&gt;</td>
</tr>
</tbody>
</table>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201021124335.png" alt="image-20201021124335185"></p>
<ul>
<li>Y</li>
</ul>
<table>
<thead>
<tr>
<th>du-pairs</th>
<th>d-c path</th>
<th>du path</th>
</tr>
</thead>
<tbody>
<tr>
<td>(1,&lt;2,7&gt;)</td>
<td>&lt;1,2,7&gt;</td>
<td>√</td>
</tr>
<tr>
<td>(1,&lt;6,3&gt;)</td>
<td>&lt;1,2,3,5,6,3&gt;</td>
<td>×</td>
</tr>
<tr>
<td></td>
<td>&lt;1,2,(3,5,6)*,3&gt;</td>
<td>×</td>
</tr>
<tr>
<td>(1,&lt;6,7&gt;)</td>
<td>&lt;1,2,3,5,6,7&gt;</td>
<td>√</td>
</tr>
<tr>
<td>(1,&lt;2,3&gt;)</td>
<td>&lt;1,2,3&gt;</td>
<td>√</td>
</tr>
<tr>
<td>(1,4)</td>
<td>&lt;1,2,3,4&gt;</td>
<td>√</td>
</tr>
<tr>
<td></td>
<td>&lt;1,2,3,5,6,3,4&gt;</td>
<td>×</td>
</tr>
<tr>
<td>(1,7)</td>
<td>&lt;1,2,7&gt;</td>
<td>√</td>
</tr>
<tr>
<td></td>
<td>&lt;1,2,3,5,6,7&gt;</td>
<td>√</td>
</tr>
<tr>
<td></td>
<td>&lt;1,2,(3,4,6)*,7&gt; inf</td>
<td>×</td>
</tr>
<tr>
<td>(4,4)</td>
<td>&lt;4,6,3,4&gt;</td>
<td></td>
</tr>
<tr>
<td>(4,7)</td>
<td>&lt;4,6,7&gt;</td>
<td>√</td>
</tr>
<tr>
<td></td>
<td>&lt;(4,6,2,3)*,4,6,2,7&gt;</td>
<td>×</td>
</tr>
<tr>
<td>(4,&lt;6,3&gt;)</td>
<td>&lt;4,6,3&gt;</td>
<td>√</td>
</tr>
<tr>
<td>(4,&lt;6,7&gt;)</td>
<td>&lt;4,6,7&gt;</td>
<td>√</td>
</tr>
</tbody>
</table>
<p><strong>练习题</strong></p>
<figure class="highlight plaintext"><figcaption><span>basic</span></figcaption><table><tr><td class="code"><pre><span class="line">Program Commission (INPUT, OUTPUT)  </span><br><span class="line">‘  </span><br><span class="line">Dim locks, stocks, barrels As Integer  </span><br><span class="line">Dim lockPrice, stockPrice, barrelPrice As Real  </span><br><span class="line">Dim totalLocks, totalStocks, totalBarrels As Integer  </span><br><span class="line">Dim lockSales, stockSales, barrelSales As Real  </span><br><span class="line">Dim sales, commission: REAL  </span><br><span class="line">‘  </span><br><span class="line">lockPrice = 45.0  </span><br><span class="line">stockPrice = 30.0  </span><br><span class="line">barrelPrice = 25.0  </span><br><span class="line">totalLocks = 0 </span><br><span class="line">totalStocks = 0 </span><br><span class="line">totalBarrels = 0 </span><br><span class="line">‘  </span><br><span class="line">Input (locks)  </span><br><span class="line">While NOT(locks = -1)  ‘Input device uses </span><br><span class="line">-1 to indicate end of data  </span><br><span class="line">   Input (stocks, barrels)  </span><br><span class="line">   totalLockstotalLocks = totalLocks + locks  </span><br><span class="line">   totalStockstotalStocks = totalStocks + stocks  </span><br><span class="line">   totalBarrelstotalBarrels = totalBarrels + barrels  </span><br><span class="line">   Input (locks)  </span><br><span class="line">EndWhile  </span><br><span class="line">‘  </span><br><span class="line">Output (&quot;Locks sold: &quot;, totalLocks)  </span><br><span class="line">Output (&quot;Stocks sold: &quot;, totalStocks)  </span><br><span class="line">Output (&quot;Barrels sold: &quot;, totalBarrels)  </span><br><span class="line">‘  </span><br><span class="line">lockSales = lockPrice * totalLocks  </span><br><span class="line">stockSales = stockPrice * totalStocks  </span><br><span class="line">barrelSales = barrelPrice * totalBarrels  </span><br><span class="line">sales = lockSales + stockSales + barrelSales  </span><br><span class="line">Output (&quot;Total sales: &quot;, sales)  </span><br><span class="line">‘  </span><br><span class="line">If (sales &gt; 1800.0)  </span><br><span class="line">   Then   </span><br><span class="line">      commission = 0.10 * 1000.0  </span><br><span class="line">      commissioncommission = commission + 0.15 * 800.0  </span><br><span class="line">      commissioncommission = commission +</span><br><span class="line">0.20 * (sales-1800.0)  </span><br><span class="line">   Else If (sales &gt; 1000.0)  </span><br><span class="line">         Then   </span><br><span class="line">            commission = 0.10 * 1000.0  </span><br><span class="line">            commissioncommission = commission </span><br><span class="line">+ 0.15* (sales-1000.0)  </span><br><span class="line">         Else commission = 0.10 * sales  </span><br><span class="line">        EndIf  </span><br><span class="line">EndIf  </span><br><span class="line">Output (&quot;Commission is $&quot;, commission)  </span><br><span class="line">‘  </span><br><span class="line">End Commission</span><br></pre></td></tr></table></figure>
<ul>
<li>控制流图</li>
</ul>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201019170755.png" alt="image-20201019170755067"></p>
<ul>
<li>
<p><strong>LockPrice</strong></p>
<table>
<thead>
<tr>
<th>du-pairs</th>
<th>def-clear paths</th>
<th>du-path</th>
</tr>
</thead>
<tbody>
<tr>
<td>(7,24)</td>
<td>&lt;7-13,(14-19),(14-19)*,20-24&gt;</td>
<td>×</td>
</tr>
<tr>
<td></td>
<td>&lt;7-13,14,20-24&gt;</td>
<td>√</td>
</tr>
<tr>
<td></td>
<td>&lt;7-13,14-19,20-24&gt;</td>
<td>√</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>TotalStocks</strong></p>
<table>
<thead>
<tr>
<th>du-pairs</th>
<th>def-clear paths</th>
<th>du-path</th>
</tr>
</thead>
<tbody>
<tr>
<td>(11,17)</td>
<td>&lt;11-13,14,15-17&gt;</td>
<td>√</td>
</tr>
<tr>
<td>(11,22)</td>
<td>&lt;11-13,14,20,21-22&gt;</td>
<td>√</td>
</tr>
<tr>
<td>(11,25)</td>
<td>&lt;11-13,14,20,21-25&gt;</td>
<td>√</td>
</tr>
<tr>
<td>(17,17)</td>
<td>&lt;17-19,14,15-17&gt;</td>
<td>×</td>
</tr>
<tr>
<td>(17,22)</td>
<td>&lt;17-19,14,20,21-22&gt;</td>
<td>√</td>
</tr>
<tr>
<td>(17,25)</td>
<td>&lt;17-19,14,20,21-25&gt;</td>
<td>√</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>Barrels</strong></p>
<table>
<thead>
<tr>
<th>du-pairs</th>
<th>def-clear paths</th>
<th>du-path</th>
</tr>
</thead>
<tbody>
<tr>
<td>(15,18)</td>
<td>&lt;15,16,17,18&gt;</td>
<td>√</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>LockSales</strong></p>
<table>
<thead>
<tr>
<th>du-pairs</th>
<th>def-clear paths</th>
<th>du-path</th>
</tr>
</thead>
<tbody>
<tr>
<td>(24,27)</td>
<td>&lt;24,25,26,27&gt;</td>
<td>√</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>Sales</strong></p>
<table>
<thead>
<tr>
<th>du-pairs</th>
<th>def-clear paths</th>
<th>du-path</th>
</tr>
</thead>
<tbody>
<tr>
<td>(27,&lt;29,30&gt;)</td>
<td>&lt;27,28,29,30&gt;</td>
<td>√</td>
</tr>
<tr>
<td>(27,33)</td>
<td>&lt;27,28,29,30-33&gt;</td>
<td>√</td>
</tr>
<tr>
<td>(27,&lt;34,35&gt;)</td>
<td>&lt;27,28,29,34,35&gt;</td>
<td>√</td>
</tr>
<tr>
<td>(27,37)</td>
<td>&lt;27,28,29,34,35,36,37&gt;</td>
<td>√</td>
</tr>
<tr>
<td>(27,38)</td>
<td>&lt;27,28,29,34,38&gt;</td>
<td>√</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>Commission</strong></p>
<table>
<thead>
<tr>
<th>du-pairs</th>
<th>def-clear paths</th>
<th>du-path</th>
</tr>
</thead>
<tbody>
<tr>
<td>(31,32)</td>
<td>&lt;31,32&gt;</td>
<td>√</td>
</tr>
<tr>
<td>(32,33)</td>
<td>&lt;32,33&gt;</td>
<td>√</td>
</tr>
<tr>
<td>(33,41)</td>
<td>&lt;33,40,41&gt;</td>
<td>√</td>
</tr>
<tr>
<td>(36,37)</td>
<td>&lt;36,37&gt;</td>
<td>√</td>
</tr>
<tr>
<td>(37,41)</td>
<td>&lt;37,39,40,41&gt;</td>
<td>√</td>
</tr>
<tr>
<td>(38,41)</td>
<td>&lt;38,39,40,41,42&gt;</td>
<td>√</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>Test cases</strong></p>
<table>
<thead>
<tr>
<th>du-paths</th>
<th>variations</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;7-13,14,20-24&gt;</td>
<td>lockPrice = 45.0, lock = -1</td>
</tr>
<tr>
<td>&lt;7-13,14,15-19,20-24&gt;</td>
<td>lockPrice = 45.0, lock = 1, -1</td>
</tr>
<tr>
<td>&lt;11-13,14,15-17&gt;</td>
<td>totalStocks = 0, lock = 1, stocks = 1</td>
</tr>
<tr>
<td>&lt;11-13,14,20,21-22&gt;</td>
<td>totalStocks = 0, lock = -1</td>
</tr>
<tr>
<td>&lt;11-13,14,20,21-25&gt;</td>
<td>totalStocks = 0, lock = -1</td>
</tr>
<tr>
<td>&lt;17-19,14,20,21-22&gt;</td>
<td>lock = 1, -1 stocks = 1</td>
</tr>
<tr>
<td>&lt;17-19,14,20,21-25&gt;</td>
<td>lock = 1, -1 stocks = 1</td>
</tr>
<tr>
<td>&lt;15,16,17,18&gt;</td>
<td>barrels = 1</td>
</tr>
<tr>
<td>&lt;24,25,26,27&gt;</td>
<td>lock = 1, -1, lockSales = 45.0</td>
</tr>
<tr>
<td>&lt;27,28,29,30&gt;</td>
<td>lockSales = 4500, stockSales = 3000, barrelSales = 2500</td>
</tr>
<tr>
<td>&lt;27,28,29,30-33&gt;</td>
<td>lockSales = 4500, stockSales = 3000, barrelSales = 2500</td>
</tr>
<tr>
<td>&lt;27,28,29,34,35&gt;</td>
<td>lockSales = 450, stockSales = 300, barrelSales = 500</td>
</tr>
<tr>
<td>&lt;27,28,29,34,35,36,37&gt;</td>
<td>lockSales = 450, stockSales = 300, barrelSales = 500</td>
</tr>
<tr>
<td>&lt;27,28,29,34,38&gt;</td>
<td>lockSales = 45, stockSales = 30, barrelSales = 50</td>
</tr>
<tr>
<td>&lt;31,32&gt;</td>
<td>commission = 100</td>
</tr>
<tr>
<td>&lt;32,33&gt;</td>
<td>commission = 100</td>
</tr>
<tr>
<td>&lt;33,40,41&gt;</td>
<td>commission = 100, sales = 2000</td>
</tr>
<tr>
<td>&lt;36,37&gt;</td>
<td>commission = 100, sales = 1500</td>
</tr>
<tr>
<td>&lt;37,39,40,41&gt;</td>
<td>commission = 100, sales = 1500</td>
</tr>
<tr>
<td>&lt;38,39,40,41,42&gt;</td>
<td>commission = 100, sales = 1500</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h2 id="Session-7-Black-Box-Testing-—-Boundary-Value-Analysis">Session 7 Black-Box Testing — Boundary Value Analysis</h2>
<h3 id="Introduction-of-Black-Box-Testing">Introduction of Black-Box Testing</h3>
<ul>
<li>黑盒测试设计技术
<ul>
<li>Boundary Value Analysis 边界值分析</li>
<li>Equivalence Patitioning</li>
<li>Decision Table 判定表</li>
<li>Cause-Effect Graph 因果图</li>
<li>Combinatiorial Test 组合测试</li>
</ul>
</li>
</ul>
<h3 id="Boundary-Value-Analysis">Boundary Value Analysis</h3>
<ul>
<li>基本思想
<ul>
<li>错误往往聚集在边界上</li>
<li>对所有输入的变量取
<ul>
<li>min</li>
<li>min+，略微比下界大</li>
<li>nom(nominal, typical)</li>
<li>max-，略微比上界小</li>
<li>max+</li>
</ul>
</li>
</ul>
</li>
<li>例如：数组，循环，≤
<ul>
<li>输入的值必须在0-100中间</li>
<li>测试用例
<ul>
<li>0, 1, 56, 99, 100</li>
</ul>
</li>
</ul>
</li>
<li>Robustness Testing 健壮性测试
<ul>
<li>是对边界值分析的简单扩展</li>
<li>max+和min-的测试用例</li>
</ul>
</li>
<li>基于单缺陷假设 Single fault assumption
<ul>
<li>Normal Boundary Values 基本边界值分析</li>
<li>Robustness Boundary Values 健壮性边界值分析</li>
</ul>
</li>
<li>考虑多个变量取极端值
<ul>
<li>Multiple Variable of Boundary Values (Worst-Case Testing) 多变量的边界值分析</li>
<li>Robust Multiple Variable of Boundary Values (Robust Worst-Case Testing) 多变量的健壮性边界值分析</li>
</ul>
</li>
</ul>
<p><strong>Example</strong></p>
<ul>
<li>
<p>函数F，变量x和y</p>
<ul>
<li>a &lt;= x &lt;= b</li>
<li>c &lt;= y &lt;= d</li>
</ul>
</li>
<li>
<p>Normal Boundary Values</p>
<ul>
<li><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201021112310.png" alt="image-20201021112302771"></li>
<li>针对n个变量，4n+1个测试用例</li>
</ul>
</li>
<li>
<p>Robustness Boundary Values</p>
<ul>
<li>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201021112321.png" alt="image-20201021112321547"></p>
</li>
<li>
<p>针对n个变量，6n+1个测试用例</p>
</li>
<li>
<blockquote>
<p>浅蓝色的点不能取</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>Multiple Variable of Boundary Values</p>
<ul>
<li><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201021112336.png" alt="image-20201021112336484"></li>
<li>针对n个变量，5^n个测试用例</li>
</ul>
</li>
<li>
<p>Robust Multiple Variable of Boundary Values</p>
<ul>
<li><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201021112356.png" alt="image-20201021112356197"></li>
<li>针对n个变量，7^n个测试用例</li>
</ul>
</li>
</ul>
<h3 id="Examples">Examples</h3>
<h4 id="The-Triangle-Problem">The Triangle Problem</h4>
<ul>
<li>
<p>输入三个整数a, b, c作为三条边的长度</p>
<ul>
<li>1&lt;=a&lt;=200</li>
<li>1&lt;=b&lt;=200</li>
<li>1&lt;=c&lt;=200</li>
</ul>
</li>
<li>
<p>基本边界值分析需要4n+1= 13个测试用例</p>
<table>
<thead>
<tr>
<th>a</th>
<th>b</th>
<th>c</th>
<th>Equilateral</th>
<th>Isosceles</th>
<th>scalene</th>
<th>NotATriangle</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>100</td>
<td>100</td>
<td></td>
<td>True</td>
<td>True</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>100</td>
<td>100</td>
<td></td>
<td>True</td>
<td>True</td>
<td></td>
</tr>
<tr>
<td>199</td>
<td>100</td>
<td>100</td>
<td></td>
<td>True</td>
<td>True</td>
<td></td>
</tr>
<tr>
<td>200</td>
<td>100</td>
<td>100</td>
<td></td>
<td></td>
<td></td>
<td>True</td>
</tr>
<tr>
<td>100</td>
<td>1</td>
<td>100</td>
<td></td>
<td>True</td>
<td>True</td>
<td></td>
</tr>
<tr>
<td>100</td>
<td>2</td>
<td>100</td>
<td></td>
<td>True</td>
<td>True</td>
<td></td>
</tr>
<tr>
<td>100</td>
<td>199</td>
<td>100</td>
<td></td>
<td>True</td>
<td>True</td>
<td></td>
</tr>
<tr>
<td>100</td>
<td>200</td>
<td>100</td>
<td></td>
<td></td>
<td></td>
<td>True</td>
</tr>
<tr>
<td>100</td>
<td>100</td>
<td>1</td>
<td></td>
<td>True</td>
<td>True</td>
<td></td>
</tr>
<tr>
<td>100</td>
<td>100</td>
<td>2</td>
<td></td>
<td>True</td>
<td>True</td>
<td></td>
</tr>
<tr>
<td>100</td>
<td>100</td>
<td>199</td>
<td></td>
<td>True</td>
<td>True</td>
<td></td>
</tr>
<tr>
<td>100</td>
<td>100</td>
<td>200</td>
<td></td>
<td>True</td>
<td>True</td>
<td>True</td>
</tr>
<tr>
<td>100</td>
<td>100</td>
<td>100</td>
<td>True</td>
<td>True</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ul>
<h4 id="The-NextDate-Problem">The NextDate Problem</h4>
<ul>
<li>输入三个整型变量 month, day, year
<ul>
<li>1 &lt;= month &lt;= 12</li>
<li>1 &lt;= day &lt;= 31</li>
<li>1812 &lt;= year &lt;= 2012</li>
</ul>
</li>
<li>输出这个日期的第二天</li>
<li>测试用例
<ul>
<li>month: 0, 1, 2, 6, 11, 12, 13</li>
<li>day: 0, 1, 2, 15, 30, 31, 32</li>
<li>year: 1811, 1812, 1813, 1900, 2011, 2012, 2013</li>
</ul>
</li>
</ul>
<h4 id="Limitation-of-BVA">Limitation of BVA</h4>
<ul>
<li>适用于物理数量型的变量</li>
<li>对于逻辑类变量来说，例如PIN或者电话号码</li>
</ul>
<h4 id="Advantages-of-BVA">Advantages of BVA</h4>
<h4 id="limitations-of-BVA">limitations of BVA</h4>
<h4 id="Exercise-1">Exercise 1</h4>
<blockquote>
<p>There are three integer inputs x, y, z, corresponding to the length, width and height of a rectangle respectively. All of these three inputs are in the range of [2, 20], the output is the volume of the rectangle.</p>
</blockquote>
<ul>
<li>
<p>List the number of test cases that needed by four types of boundary value analysis respectively</p>
<ul>
<li>normal : 4n+1 = 13</li>
<li>robustness: 6n+1 = 19</li>
<li>mutiple: 5^n = 125</li>
<li>robustness mutiple: 7^n = 49*7 = 343</li>
</ul>
</li>
<li>
<p>Design the test cases by Robustness Boundary Value Analysis.</p>
<table>
<thead>
<tr>
<th>x</th>
<th>y</th>
<th>z</th>
<th>volume</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>11</td>
<td>11</td>
<td>121</td>
</tr>
<tr>
<td>2</td>
<td>11</td>
<td>11</td>
<td>242</td>
</tr>
<tr>
<td>3</td>
<td>11</td>
<td>11</td>
<td>363</td>
</tr>
<tr>
<td>19</td>
<td>11</td>
<td>11</td>
<td>19*121</td>
</tr>
<tr>
<td>20</td>
<td>11</td>
<td>11</td>
<td>20*121</td>
</tr>
<tr>
<td>21</td>
<td>11</td>
<td>11</td>
<td>21*121</td>
</tr>
<tr>
<td>11</td>
<td>1</td>
<td>11</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>2</td>
<td>11</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>3</td>
<td>11</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>19</td>
<td>11</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>20</td>
<td>11</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>21</td>
<td>11</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>11</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>11</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>11</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>11</td>
<td>19</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>11</td>
<td>20</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>11</td>
<td>21</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>11</td>
<td>11</td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="Equivalence-Partitioning">Equivalence Partitioning</h3>
<ul>
<li>等价类划分</li>
<li>Partition</li>
</ul>
<h4 id="Equivalence-Class-等价类">Equivalence Class 等价类</h4>
<ul>
<li>利用等价类中的一种测试用例来代表整个等价类
<ul>
<li>来检测是否有缺陷</li>
</ul>
</li>
</ul>
<h4 id="Equivalence-Class-Testing-等价类测试">Equivalence Class Testing 等价类测试</h4>
<ul>
<li>弱一般等价类测试
<ul>
<li>Weak Normal Equivalence Class Testing</li>
</ul>
</li>
<li>强一般等价类测试
<ul>
<li>Strong Normal Equivalence Class Testing</li>
</ul>
</li>
<li>弱健壮等价类测试
<ul>
<li>Weak Robust Equivalence Class Testing</li>
</ul>
</li>
<li>强健壮等价类测试
<ul>
<li>Strong Robust Equivalence Class Testing</li>
</ul>
</li>
<li>Strong ECTesting
<ul>
<li>所有变量的迪卡尔积</li>
<li>ECx × ECy = {(x1,y1),(x1,y2),(x2,y1),(x2,y2),(x3,y1),(x3,y2)}</li>
</ul>
</li>
<li>Weak ECTesting
<ul>
<li>每一个等价类都被覆盖到过</li>
<li>例如{(x1,y1),(x2,y2),(x3,y2)}
<ul>
<li>这里x1, x2, x3被覆盖</li>
<li>y1, y2被覆盖</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Interaction-Fault">Interaction Fault</h4>
<ul>
<li>Simple Fault 一个变量</li>
<li>Pair-wise interaction fault 两个变量</li>
</ul>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">input(x, y);</span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">0</span>)&#123; <span class="comment">// 这里应该是 x+1&gt;=0</span></span><br><span class="line">	output(<span class="number">2</span>*y);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> output(<span class="number">3</span>*y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$x,y\in{-2,-1,1,2}$</p>
<p>则弱测试就足够检测出程序中的问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">input(x, y);</span><br><span class="line"><span class="keyword">if</span>(x&amp;&amp;y)&#123; <span class="comment">// 这里应该是 x||y</span></span><br><span class="line">	output(f(x,y));</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> output(g(x,y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$x,y\in{T,F}$</p>
<p>需要强测试才能检测出fault</p>
</blockquote>
<ul>
<li>
<p>强测试的缺陷</p>
<ul>
<li>会产生很多不可能的，赘余的，没有用的测试用例</li>
</ul>
</li>
<li>
<p>弱健壮等价类测试</p>
<ul>
<li>对于有效的输入，等同于弱一般等价类测试</li>
<li>对于无效的输入，必须只有一个无效的值，其余的值还是有效的</li>
</ul>
<img src="../../../../Academic Source/Recent Source/软件测试与质量保证/软件测试与质量保证.assets/image-20201028104832821.png" alt="image-20201028104832821" style="zoom:50%;" />
</li>
<li>
<p>强健壮等价类测试</p>
<ul>
<li>
<p>考虑所有无效输入的值</p>
<img src="../../../../Academic Source/Recent Source/软件测试与质量保证/软件测试与质量保证.assets/image-20201028105103929.png" alt="image-20201028105103929" style="zoom:50%;" />
</li>
</ul>
</li>
<li>
<p>混合路径 Hybrid approach</p>
<ul>
<li>
<p>强一般+弱健壮</p>
<img src="../../../../Academic Source/Recent Source/软件测试与质量保证/软件测试与质量保证.assets/image-20201028105536580.png" alt="image-20201028105536580" style="zoom:50%;" />
</li>
</ul>
</li>
<li>
<p>测试用例数量的计算</p>
</li>
<li>
<p>有n个变量$x_1,x_2,x_3…,x_n$</p>
</li>
<li>
<p>有效的等价类${E(x_1),E(x_2),E(x_3)…,E(x_n)}$</p>
</li>
<li>
<p>无效的等价类${I(x_1),I(x_2),I(x_3)…,I(x_n)}$</p>
<ul>
<li>弱一般
<ul>
<li>$max{E(x_1),E(x_2),E(x_3)…,E(x_n)}$</li>
</ul>
</li>
<li>强一般
<ul>
<li>$E(x_1)<em>E(x_2)</em>…*E(x_n)$</li>
</ul>
</li>
<li>弱健壮
<ul>
<li>$max{E(x_1),E(x_2),E(x_3)…,E(x_n)}+\sum_{i=1}^{n}I(x_i)$</li>
</ul>
</li>
<li>强健壮
<ul>
<li>$\prod^n_{i=1}(E(X_i)+I(x_i))$</li>
</ul>
</li>
<li>混合
<ul>
<li>$E(x_1)<em>E(x_2)</em>…*E(x_n)+\prod^n_{i=1}I(x_i)$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Example">Example</h4>
<p>针对三角形划分等价类</p>
<ul>
<li>Valid ECs:
<ul>
<li>V1 = {&lt;a,b,c&gt; : the triangle with sides a,b,and c is equilateral}</li>
<li>V2 = {&lt;a,b,c&gt; : the triangle with sides a,b,and c is isosceles}</li>
<li>V3 = {&lt;a,b,c&gt; : the triangle with sides a,b,and c is scalene}</li>
</ul>
</li>
<li>Invalid ECs:
<ul>
<li>IV1 = {&lt;a,b,c&gt; : sides a,b,and c do not form a triangle}</li>
<li>IV2 = {&lt;a,b,c&gt;: a is not in the range of permitted values}</li>
<li>IV3 = {&lt;a,b,c&gt;: b is not in the range of permitted values}</li>
<li>IV4 = {&lt;a,b,c&gt;: c is not in the range of permitted values}</li>
</ul>
</li>
<li><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201101104036.png" alt="image-20201028113709670">
<ul>
<li>针对2，没有测试不同的等腰</li>
<li>针对4,没有测试上边界</li>
<li>针对5,6,7,没有测试超上边界的值</li>
</ul>
</li>
</ul>
<h3 id="Decision-Table">Decision Table</h3>
<h3 id="Cause-Effect-Graph">Cause-Effect Graph</h3>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>基于最大匹配算法的句子分词</title>
    <url>/post/2020-10-20-Algorithm/%E5%9F%BA%E4%BA%8E%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E7%9A%84%E5%8F%A5%E5%AD%90%E5%88%86%E8%AF%8D/</url>
    <content><![CDATA[<h1>目标</h1>
<p>我们的最终目标是实现把一个句子分解成若干个合理的单词</p>
<ul>
<li>“我们今天一起去吃麦当劳吧”  =&gt; [“我们”，“今天”，“一起”，“去”，“吃”，“麦当劳”，“吧”]</li>
</ul>
<h1>算法介绍</h1>
<p>进行本次使用的分词方法是非常好理解的<strong>正向最大匹配算法</strong></p>
<h2 id="已知条件">已知条件</h2>
<ul>
<li>在分词前首先得有一个<strong>字典</strong>来存储已知的单词
<ul>
<li><code>[一起，今天，吃饭，我们，我，肯德基 ]</code></li>
<li>从这个词典我们知道，<strong>单词的最大长度</strong>为<strong>3</strong></li>
</ul>
</li>
<li>需要进行分词的<strong>句子</strong>
<ul>
<li>我们今天一起吃麦当劳吧</li>
</ul>
</li>
</ul>
<h2 id="匹配流程">匹配流程</h2>
<ol>
<li>从当前位置开始，向右截取单词可能的最大长度，组成当前词
<ul>
<li>例如一开始，当前位置就是0，单词最大可能的长度为3</li>
<li>也就是截取了从0开始长度为3的字符串，<code>我们今</code></li>
</ul>
</li>
<li>和字典中的词逐一进行匹配
<ul>
<li>在字典<code>[一起，今天，吃饭，我们，我，肯德基 ]</code>，去寻找是否有<code>我们今</code></li>
</ul>
</li>
<li>如果匹配成功，则进行下一次匹配 ，下次匹配从当前这个词后面开始</li>
<li>如果匹配不成功，就缩短长度，重新截取，直到能匹配成功或单词长度为1
<ul>
<li><code>我们今</code>，匹配失败，所以就令当前的长度减一</li>
<li>现在是截取的字符串是<code>我们</code>，匹配成功</li>
<li>匹配成功后就从<code>今天一</code>开始继续尝试</li>
</ul>
</li>
</ol>
<h2 id="分词结果">分词结果</h2>
<p>通过上面的匹配流程可以很容易看出来最终结果：</p>
<p><code>[我们，今天，一起，吃，麦，当，劳，吧]</code></p>
<blockquote>
<p>由于“麦当劳”不存在我们的词典中，所以最后分词结果中，它只能以单个字存在</p>
</blockquote>
<h1>课程实验</h1>
<p><strong>任务</strong></p>
<ul>
<li>
<p>使用最大匹配算法、词典文件（corpus.dict.txt），对语料（corpus.sentence.txt）进行分词</p>
</li>
<li>
<p>将分词的结果输出到文件corpus.out.txt中；</p>
</li>
<li>
<p>对比corpus.answer.txt和corpus.out.txt，给出算法的P/R/F指标</p>
</li>
</ul>
<p><strong>输出</strong></p>
<ul>
<li>
<p>一个corpus.out.txt文件（格式参照corpus.answer.txt）</p>
</li>
<li>
<p>P/R/F指标(格式类似于：Precision = 36 / 100 = 36.00%</p>
</li>
</ul>
<h2 id="文件格式">文件格式</h2>
<ul>
<li>
<p>词典文件<code>corpus.dict.txt</code></p>
<ul>
<li>可以看到第一行直接给了单词个数和单词的最大长度</li>
</ul>
<img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201020230647.png" alt="image-20201020230647761" style="zoom:67%;" />
</li>
<li>
<p>句子文件<code>corpus.sentence.txt</code></p>
<img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201020230735.png" alt="image-20201020230735172" style="zoom:67%;" />
</li>
<li>
<p>标准答案文件<code>corpus.answer.txt</code></p>
<img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201020231434.png" alt="image-20201020231434417" style="zoom:67%;" />
</li>
</ul>
<h2 id="程序组成">程序组成</h2>
<ul>
<li><code>wordsegment.py</code>
<ul>
<li>使用最大匹配算法进行句子分词，并将结果输出到<code>corpus.out.txt</code>文件中</li>
</ul>
</li>
<li><code>cal_prf.py</code>
<ul>
<li>给出算法的P/R/F指标（在命令行输出）</li>
</ul>
</li>
</ul>
<h2 id="程序编写">程序编写</h2>
<h4 id="wordsegment-py"><code>wordsegment.py</code></h4>
<ul>
<li>
<p>首先初始化词典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_dict</span>():</span><br><span class="line">    <span class="comment"># 读取词典文件</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始初始化词典...&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;corpus.dict.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>, ) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            words_all = f.readlines()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            f.close()</span><br><span class="line">    <span class="comment"># 读取第一行信息，包括词数和单词最大长度</span></span><br><span class="line">    dic = []</span><br><span class="line">    rows, max_length = words_all[<span class="number">0</span>].split()</span><br><span class="line">    rows, max_length = <span class="built_in">int</span>(rows), <span class="built_in">int</span>(max_length)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rows):</span><br><span class="line">        dic.append(words_all[i].rstrip(<span class="string">&#x27;\n&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;初始化词典完成，单词个数%d，最大单词长度%d&quot;</span> % (rows, max_length))</span><br><span class="line">    <span class="keyword">return</span> dic, max_length</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>然后初始化所有句子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_sentences</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;开始读取句子文件...&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;corpus.sentence.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>, ) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = f.readlines()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            f.close()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data)):</span><br><span class="line">        data[i] = data[i].rstrip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;句子文件读取完毕&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用最大向前法进行分词</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">output_corpus</span>(<span class="params">dic, max_length, data</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;利用向前最大匹配法进行分词...&quot;</span>)</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&quot;corpus.out.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(line) &gt; <span class="number">0</span>:</span><br><span class="line">            max_len = <span class="built_in">min</span>(<span class="built_in">len</span>(line), max_length)</span><br><span class="line">            try_word = line[<span class="number">0</span>:max_len]</span><br><span class="line">            <span class="keyword">while</span> try_word <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(try_word) == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                try_word = try_word[<span class="number">0</span>:(<span class="built_in">len</span>(try_word) - <span class="number">1</span>)]</span><br><span class="line">            f.write(try_word + <span class="string">&quot; &quot;</span>)</span><br><span class="line">            line = line[<span class="built_in">len</span>(try_word):]</span><br><span class="line">        f.write(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    f.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;分词完毕&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>main函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 读取匹配单词所需字典和单词的最大长度</span></span><br><span class="line">    words_dic, max_word_len = get_dict()</span><br><span class="line">    <span class="comment"># 读取所有句子</span></span><br><span class="line">    sentences = get_sentences()</span><br><span class="line">    <span class="comment"># 分词</span></span><br><span class="line">    output_corpus(words_dic, max_word_len, sentences)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="cal-prf-py"><code>cal_prf.py</code></h3>
<ul>
<li>
<p>读取分词结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_out</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;读取分词结果文件...&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;corpus.out.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>, ) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            out = f.readlines()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            f.close()</span><br><span class="line">    <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>读取分词的标准答案</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_answer</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;读取分词标准答案文件...&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;corpus.answer.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>, ) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            answer = f.readlines()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            f.close()</span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>计算并输出PRF三个参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cal_prf</span>():</span><br><span class="line">    out = get_out()</span><br><span class="line">    answer = get_answer()</span><br><span class="line">    right_cnt = <span class="number">0</span>  <span class="comment"># 正确识别的个体总数</span></span><br><span class="line">    rec_cnt = <span class="number">0</span>  <span class="comment"># 识别出的个体总数</span></span><br><span class="line">    ans_cnt = <span class="number">0</span>  <span class="comment"># 测试集中存在的个体总数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(out)):</span><br><span class="line">        rec_line = out[i].split()</span><br><span class="line">        ans_line = answer[i].split()</span><br><span class="line">        rec_cnt += <span class="built_in">len</span>(rec_line)</span><br><span class="line">        ans_cnt += <span class="built_in">len</span>(ans_line)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> rec_line:</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> ans_line:</span><br><span class="line">                right_cnt += <span class="number">1</span></span><br><span class="line">    precision = right_cnt/rec_cnt</span><br><span class="line">    recall = right_cnt/ans_cnt</span><br><span class="line">    f1 = precision*recall*<span class="number">2</span>/(precision+recall)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Precision = %d/%d = %.3f&quot;</span> %(right_cnt, rec_cnt, precision))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Recall = %d/%d = %.3f&quot;</span> %(right_cnt, ans_cnt, recall))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;F1 = %.3f*%.3f*2/(%.3f+%.3f) = %.3f&quot;</span> %(precision, recall, precision, recall, f1))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="运行结果">运行结果</h2>
<ul>
<li>
<p>分词结果文件<code>corpus_out.txt</code></p>
<img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201021144224.png" alt="image-20201021144224528" style="zoom:67%;" />
</li>
<li>
<p>参数计算</p>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201021145508.png" alt="image-20201021145508485"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>实验报告</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>分词</tag>
        <tag>最大匹配算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Typecho-&gt;Hexo搬家日记</title>
    <url>/post/2020-10-14-Diaries/%E5%8D%9A%E5%AE%A2%E6%90%AC%E5%AE%B6%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="把博客从Typecho改成Hexo的主要原因">把博客从Typecho改成Hexo的主要原因</h2>
<p><strong>一言以蔽之</strong></p>
<ul>
<li>更优质的生态环境</li>
</ul>
<p><strong>说大白话</strong></p>
<p>​	原本在Typecho上花40大洋买了一个主题，但是发现和自己的原本的预期并不一样。</p>
<p>​	后又偶然发现一款叫做Hexo的博客框架下有很多非常好康的主题，遂搬迁至此。</p>
<p>​	一般平常写文章的话就是先用Typora在本地写完，然后在网页端打开对应的博客的后台界面，复制粘贴，点击发布文章。</p>
<p>​	其实挺麻烦的，又要编辑本地文档，又要打开网页后台上传文章。</p>
<p>​	一旦搭建好环境，搞好hook，换成Hexo之后的话，本地编辑文档之后，只要用命令行hexo d -g一下即可推送到服务器。</p>
<h3 id="Typecho">Typecho</h3>
<ul>
<li>
<p>优点</p>
<ul>
<li>轻量</li>
<li>开发简单</li>
<li>动态，搭建和写博文都比较方便</li>
</ul>
</li>
<li>
<p>缺点</p>
<ul>
<li>没有特别满意的主题</li>
<li>用的人比较少，生态环境一般</li>
<li>已经两年没发布新版本了</li>
</ul>
</li>
</ul>
<h3 id="Hexo">Hexo</h3>
<ul>
<li>
<p>优点</p>
<ul>
<li>
<p><strong>好看</strong></p>
</li>
<li>
<p>静态，可以部署在github上，相当于只要出域名的钱，省下了服务器的钱</p>
<ul>
<li>这个对我影响不大，因为阿里云的ECS服务器学生优惠价每个月一杯奶茶钱都不到</li>
</ul>
</li>
<li>
<p>优质的生态环境</p>
<ul>
<li>有很多官方插件和第三方插件</li>
<li>也支持很多扩展</li>
</ul>
</li>
</ul>
</li>
<li>
<p>缺点</p>
<ul>
<li>因为是静态的，所以部署到自己的服务器上之后要做到同步更新需要折腾一下</li>
</ul>
</li>
</ul>
<h2 id="坎坷的搬家路">坎坷的搬家路</h2>
<p>流程</p>
<ol>
<li>建GitHub仓库</li>
<li>本地用npm下载hexo</li>
<li>本地文件同步到GitHub仓库</li>
<li>服务器端用bt面板设置hook</li>
</ol>
<p>做完这几步，只要本地<code>hexo new pages xxxx</code>命令来新建<code>.md</code>文件</p>
<p>保存完文件之后，执行<code>hexo clean &amp;&amp; hexo d -g</code>来生成文件并部署到服务器端就可以了</p>
<p>整个过程遇到了不少的问题，也算是比较艰辛，在这儿就不详细展开了。</p>
]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Typecho</tag>
        <tag>博客建设</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络笔记</title>
    <url>/post/2020-10-08-Basic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1>计算机网络</h1>
<h2 id="第1章-概述">第1章 概述</h2>
<h3 id="计算机网络的定义">计算机网络的定义</h3>
<ul>
<li>计算机网络主要是由一些通用的、可编程的硬件互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</li>
</ul>
<h4 id="计算机网络的特点">计算机网络的特点</h4>
<ul>
<li>连通性(Connectivity)
<ul>
<li>使上网用户之间都可以交换信息（数据，以及各种音频视频） ，好像这些用户的计算机都可以彼此直接连通一样。</li>
</ul>
</li>
<li>共享(Sharing)
<ul>
<li>指资源共享。</li>
<li>资源共享的含义是多方面的。可以是信息共享、软件共享，也可以是硬件共享。</li>
</ul>
</li>
</ul>
<h4 id="互联网定义">互联网定义</h4>
<ul>
<li>互联网，特指 Internet，它起源于美国，是由数量极大的各种计算机网络互连起来而形成的一个互连网络。它采用 TCP/IP 协议族作为通信规则，是一个覆盖全球、实现全球范围内连通性和资源共享的计算机网络。</li>
</ul>
<h4 id="internet和Internet的区别">internet和Internet的区别</h4>
<ul>
<li>internet（互连网）是一个通用名词，它泛指由多个计算机网络互连而成的网络。</li>
<li>Internet（互联网或因特网）则是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，它采用 TCP/IP 协议族作为通信的规则，且其前身是美国的 ARPANET。</li>
</ul>
<table>
<thead>
<tr>
<th>Internet</th>
<th>internet</th>
</tr>
</thead>
<tbody>
<tr>
<td>网络的网络</td>
<td>网络的网络</td>
</tr>
<tr>
<td>特指遵循 TCP/IP 标准、利用路由器将各种计算机网络互连起来而形成的、一个覆盖全球的、特定的互连网</td>
<td>泛指由多个不同类型计算机网络互连而成的网络</td>
</tr>
<tr>
<td>使用 TCP/IP</td>
<td>除 TCP/IP 外，还可以使用其他协议</td>
</tr>
<tr>
<td>是一个专用名词</td>
<td>是一个通用名词</td>
</tr>
</tbody>
</table>
<h3 id="互联网基础">互联网基础</h3>
<h4 id="互联网基础结构发展的三个阶段">互联网基础结构发展的三个阶段</h4>
<ul>
<li>
<p>第一阶段：从单个网络 ARPANET 向互联网发展的过程。</p>
</li>
<li>
<p>第二阶段：建成了三级结构的互联网。</p>
</li>
<li>
<p>第三阶段：逐渐形成了多层次 ISP 结构的互联网。</p>
<ul>
<li><strong>ISP: Internet Service Provider</strong></li>
</ul>
<blockquote>
<p>例如电信，移动，联通</p>
</blockquote>
</li>
</ul>
<h4 id="成为互联网正式标准要经过的阶段">成为互联网正式标准要经过的阶段</h4>
<ul>
<li>建议标准 (Proposed Standard) ——从这个阶段开始就成为 RFC 文档。</li>
<li>互联网标准 (Internet Standard) ——达到正式标准后，每个标准就分配到一个编号 STD xxxx。 一个标准可以和多个 RFC 文档关联。</li>
</ul>
<h4 id="互联网的组成">互联网的组成</h4>
<ul>
<li>边缘部分：由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。</li>
<li>核心部分：由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）。</li>
</ul>
<h4 id="互联网的边缘部分">互联网的边缘部分</h4>
<ul>
<li>处在互联网边缘的部分就是连接在互联网上的所有的主机。这些主机又称为<strong>端系统 (end system)</strong>。</li>
</ul>
<img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20200919162131281.png" alt="image-20200919162131281" style="zoom:67%;" />
<h4 id="端系统之间通信"><strong>端系统之间通信</strong></h4>
<ul>
<li>”主机A和主机B进行通信“ 实际上是指运行在主机A上的某个程序和运行在主机B上的另一个程序进行通信
<ul>
<li>客户-服务器方式（C/S方式）Client/Server
<ul>
<li>客户是服务的请求方，服务器是服务的提供方</li>
<li>双方都要使用网络核心部分所提供的服务</li>
</ul>
</li>
<li>对等方式（P2P方式）Peer-to-Peer
<ul>
<li>两个主机在通信同时不区分服务请求方和提供方</li>
<li>可以支持大量对等用户同时工作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="互联网的核心部分">互联网的核心部分</h4>
<ul>
<li>
<p>核心部分起特殊作用的是<strong>路由器(router)</strong></p>
<ul>
<li>是实现<strong>分组交换(packet switching)<strong>的关键构建，其任务是</strong>转发</strong>收到的分组。</li>
</ul>
</li>
<li>
<p>交换的含义</p>
<ul>
<li>转接</li>
<li>从通信资源的分配角度看，交换就是按照某种方式动态地分配传输线路的资源</li>
</ul>
</li>
<li>
<p>三种交换技术</p>
<ol>
<li>
<p>电路交换</p>
<p><strong>三个阶段：</strong></p>
<ul>
<li>建立连接：建立一条专用的物理通路，以保证双方通话时所需的通信资源在通信时不会被其他用户占用</li>
<li>通信：主叫和被叫双方能互相通电话</li>
<li>释放连接：释放刚才占用的所有通信资源</li>
</ul>
<p><strong>交换特点：</strong></p>
<ul>
<li>计算机数据具有突发性</li>
<li>传送计算机数据时，通信线路的利用率很低</li>
</ul>
</li>
<li>
<p>分组交换</p>
<p><strong>主要特点：</strong></p>
<ul>
<li>采用<strong>存储转发</strong>技术</li>
<li>在发送端，先把较长的报文划分成较短的、固定长度的数据段</li>
</ul>
<p><strong>交换过程：</strong></p>
<ul>
<li>在每个数据段前面添加上首部构成<strong>分组(packet)</strong></li>
<li>分组交换网以分组作文数据传输单元，依次把各分组发送到接收端</li>
<li>接收端收到分组后剥去首部并还原成报文</li>
<li>最后在接收端把收到的数据恢复成为原来的报文、</li>
</ul>
<p><strong>分组交换的传输单元：</strong></p>
<ul>
<li>每一个分组的首部都有<strong>地址</strong>等控制信息</li>
<li>交换机根据<strong>地址信息</strong>把分组转发到下一个结点交换机</li>
<li>每个分组在互联网中独立地选择传输路径</li>
<li>用这样<strong>存储转发</strong>的方式，最后分组就能到达最终目的地</li>
</ul>
<p><strong>路由器</strong></p>
<ul>
<li>在路由器的输入和输出端口之间没有直接连线</li>
<li>处理分组过程：
<ol>
<li>把收到的分组<strong>放入缓存（暂时存储）</strong></li>
<li><strong>查找转发表</strong>，找出到某个目的地址应该从哪个端口转发</li>
<li>把分组送到适当的端口<strong>转发</strong>出去</li>
</ol>
</li>
<li>路由器和主机的不同
<ul>
<li>主机是为用户进行信息处理的，并向网络发送分组，从网络接收分组</li>
<li>路由器对分组进行存储转发，最后把分组交付目的主机</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>优点</th>
<th>所采用的手段</th>
</tr>
</thead>
<tbody>
<tr>
<td>高效</td>
<td>在分组传输的过程中动态分配传输带宽，对通信链路是逐段占用。</td>
</tr>
<tr>
<td>灵活</td>
<td>为每一个分组独立地选择最合适的转发路由。</td>
</tr>
<tr>
<td>迅速</td>
<td>以分组作为传送单位，可以不先建立连接就能向其他主机发送分组。</td>
</tr>
<tr>
<td>可靠</td>
<td>保证可靠性的网络协议；分布式多路由的分组交换网，使网络有很好的生存性。</td>
</tr>
</tbody>
</table>
<p><strong>分组交换的问题</strong></p>
<ul>
<li>分组在各结点存储转发时需要<strong>排队</strong>，这就会造成一定的<strong>时延</strong>。</li>
<li>分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的<strong>开销</strong>。</li>
</ul>
</li>
<li>
<p>报文交换</p>
</li>
</ol>
<h4 id="三种交换的比较">三种交换的比较</h4>
<ul>
<li>若要连续传送大量的数据，且其传送时间远大于连接建立时间，则<strong>电路交换</strong>的传输速率较快。</li>
<li><strong>报文交换</strong>和<strong>分组交换</strong>不需要预先分配传输带宽，在传送突发数据时可提高整个网络的信道利用率。</li>
<li>由于一个分组的长度往往远小于整个报文的长度，因此<strong>分组交换</strong>比报文交换的时延小，同时也具有更好的灵活性。</li>
</ul>
<img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20200919170307592.png" alt="image-20200919170307592" style="zoom:67%;" />
</li>
</ul>
<h3 id="网络的分类">网络的分类</h3>
<ol>
<li>
<p>按照网络的作用范围分类</p>
<ul>
<li>广域网 WAN (Wide Area Network)：作用范围通常为几十到几千公里。</li>
<li>城域网 MAN (Metropolitan Area Network)：作用距离约为 5~50 公里。</li>
<li>局域网 LAN (Local Area Network) ：局限在较小的范围（如 1 公里左右）。</li>
<li>个人区域网 PAN (Personal Area Network) ：范围很小，大约在 10 米左右。</li>
</ul>
</li>
<li>
<p>按网络的使用者进行分类</p>
<ul>
<li>
<p>公用网 (public network)</p>
<p>按规定交纳费用的人都可以使用的网络。因此也可称为公众网。</p>
</li>
<li>
<p>专用网 (private network)</p>
<p>为特殊业务工作的需要而建造的网络。</p>
</li>
</ul>
</li>
<li>
<p>用来把用户接入到互联网的网络</p>
<ul>
<li>接入网 AN (Access Network)，它又称为本地接入网或居民接入网，用于将用户接入互联网。</li>
<li>接入网本身既不属于互联网的核心部分，也不属于互联网的边缘部分。</li>
<li><strong>接入网是从某个用户端系统到互联网中的第一个路由器（也称为边缘路由器）之间的一种网络。</strong></li>
<li>从覆盖的范围看，很多接入网还是属于局域网。</li>
<li>从作用上看，接入网只是起到让用户能够与互联网连接的“桥梁”作用。</li>
</ul>
</li>
</ol>
<h3 id="计算机网络的性能指标⭐">计算机网络的性能指标⭐</h3>
<ol>
<li>
<p><strong>速率</strong></p>
<ul>
<li>比特（bit）是计算机中数据量的单位</li>
<li>速率是计算机网络中最重要的一个性能指标，指的是<strong>数据的传送速率</strong>，它也称为<strong>数据率 (data rate)</strong> 或<strong>比特率 (bit rate)</strong>。</li>
<li>速率的单位是 bit/s，或 kbit/s、Mbit/s、 Gbit/s等。例如4 x 10^10 bit/s 的数据率就记为 40 Gbit/s。</li>
<li><strong>速率往往是指额定速率或标称速率，非实际运行速率。</strong></li>
</ul>
</li>
<li>
<p><strong>带宽</strong></p>
<ul>
<li>
<p>“带宽”(bandwidth) 本来是指信号具有的<strong>频带宽度</strong>，其单位是赫（或千赫、兆赫、吉赫等）。</p>
</li>
<li>
<p>在计算机网络中，带宽用来表示网络中某通道传送数据的能力。表示在单位时间内网络中的某信道所能通过的“<strong>最高数据率</strong>”。单位是 bit/s，即 “比特每秒”。</p>
<blockquote>
<p>在“带宽”的上述两种表述中，前者为频域称谓，而后者为时域称谓，其本质是相同的。也就是说，一条通信链路的“带宽”越宽，其所能传输的“最高数据率”也越高。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>吞吐量</strong></p>
<ul>
<li>吞吐量 (throughput) 表示在单位时间内通过某个网络（或信道、接口）的数据量。</li>
<li>吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道<strong>实际上到底有多少数据量</strong>能够通过网络。</li>
<li>吞吐量受网络的带宽或网络的额定速率的限制。</li>
</ul>
</li>
<li>
<p><strong>时延</strong></p>
<ul>
<li>
<p>时延 (delay 或 latency) 是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。</p>
</li>
<li>
<p>有时也称为<strong>延迟</strong>或迟延。</p>
</li>
<li>
<p>网络中的时延由以下几个不同的部分组成：</p>
<ol>
<li>
<p>发送时延</p>
<ul>
<li>也称为传输时延</li>
<li>发送数据时，数据帧从结点进入到传输媒体所需要的时间</li>
<li>也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间</li>
<li>发送时延 = $\frac{数据帧长度(bit)}{发送速率(bit/s)}$</li>
</ul>
</li>
<li>
<p>传播时延</p>
<ul>
<li>电磁波在信道中需要传播一定的距离而花费的时间</li>
<li>发送时延与传播时延有本质上的不同</li>
<li>信号发送速率和信号在信道上的传播速率是完全不同的概念</li>
<li>传播时延 = $\frac{信道长度（米）}{信号在信道上的传播速率（米/秒）}$</li>
</ul>
<blockquote>
<ul>
<li>
<p>对于高速网络链路，我们提高的仅仅是数据的<strong>发送速率</strong>而不是比特在链路上的<strong>传播速率</strong>。</p>
</li>
<li>
<p>提高链路带宽减小了数据的发送时延。</p>
</li>
</ul>
</blockquote>
<p><strong>以下说法是错误的：</strong></p>
<p><strong>“在高速链路（或高带宽链路）上，比特会传送得更快些”。</strong></p>
</li>
<li>
<p>处理时延</p>
</li>
</ol>
<ul>
<li>主机或路由器在收到分组时，为处理分组（例如分析首部、提取数据、差错检验或查找路由）所花费的时间。</li>
</ul>
<ol start="4">
<li>排队时延
<ul>
<li>分组在路由器输入输出队列中<strong>排队等待处理</strong>所经历的时延。</li>
<li>排队时延的长短往往取决于<strong>网络中当时的通信量</strong>。</li>
</ul>
</li>
</ol>
</li>
<li>
<p><strong>总时延</strong> <strong>=</strong> <strong>发送时延</strong>   <strong>+</strong> <strong>传播时延</strong>   <strong>+</strong> <strong>处理时延</strong>   <strong>+</strong> <strong>排队时延</strong></p>
</li>
</ul>
<img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20200919190404349.png" alt="image-20200919190404349" style="zoom:67%;" />
</li>
<li>
<p><strong>时延带宽积</strong></p>
<ul>
<li>链路的时延带宽积又称为以比特为单位的链路长度。</li>
<li>时延带宽积 = 传播时延 x 带宽</li>
</ul>
<blockquote>
<p>只有在代表链路的管道都充满比特时，链路才得到了充分利用。</p>
</blockquote>
</li>
<li>
<p><strong>往返时间RTT</strong></p>
<ul>
<li><strong>往返时间 RTT</strong> (round-trip time) 表示从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间。</li>
<li>在互联网中，往返时间还包括<strong>各中间结点的处理时延</strong>、<strong>排队时延</strong>以及转发数据时的<strong>发送时延</strong>。</li>
<li>当使用卫星通信时，往返时间 RTT 相对较长，是很重要的一个性能指标。</li>
</ul>
</li>
<li>
<p><strong>利用率</strong></p>
<ul>
<li>
<p>信道利用率</p>
<ul>
<li>信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。</li>
<li>完全空闲的信道的利用率是零。</li>
</ul>
</li>
<li>
<p>网络利用率</p>
<ul>
<li>网络利用率则是全网络的信道利用率的加权平均值。</li>
<li>信道利用率并非越高越好。当某信道的利用率增大时，该信道引起的时延也就迅速增加。</li>
</ul>
</li>
<li>
<p>时延和利用率的关系</p>
<ul>
<li>
<p>根据排队论的理论，当某信道的利用率增大时，该信道引起的时延也就迅速增加。</p>
</li>
<li>
<p>若令 $D_0$ 表示网络空闲时的时延，$D$ 表示网络当前的时延，则在适当的假定条件下，可以用下面的简单公式表示 $D$和 之间$D_0$的关系：</p>
<ul>
<li>$D = \frac{D_0}{1-U}$</li>
<li>其中：<em>U</em> 是网络的利用率，数值在 0 到 1 之间。</li>
</ul>
<img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20200919191348176.png" alt="image-20200919191348176" style="zoom:67%;" />
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="计算机网络的非性能特征">计算机网络的非性能特征</h3>
<ul>
<li>费用</li>
<li>质量</li>
<li>标准化</li>
<li>可靠性</li>
<li>可扩展性和可升级性</li>
<li>易于管理和维护</li>
</ul>
<h3 id="计算机网络体系结构">计算机网络体系结构</h3>
<h4 id="OSI参考模型">OSI参考模型</h4>
<ul>
<li>开放系统互连基本参考模型 OSI/RM (Open Systems Interconnection Reference Model)，简称为 OSI。</li>
</ul>
<blockquote>
<p>只要遵循 OSI 标准，一个系统就可以和位于世界上任何地方的、也遵循这同一标准的其他任何系统进行通信。</p>
</blockquote>
<ul>
<li>
<p>市场化失败的原因</p>
<ul>
<li>OSI 的专家们在完成 OSI 标准时没有商业驱动力；</li>
<li>OSI 的协议实现起来过分复杂，且运行效率很低；</li>
<li>OSI 标准的制定周期太长，因而使得按 OSI 标准生产的设备无法及时进入市场；</li>
<li>OSI 的层次划分也不太合理，有些功能在多个层次中重复出现。</li>
</ul>
</li>
<li>
<p>非国际标准 <strong>TCP/IP</strong> 却获得了最广泛的应用。TCP/IP 常被称为<strong>事实上的 (de facto) 国际标准</strong>。</p>
</li>
</ul>
<h4 id="协议和划分层次">协议和划分层次</h4>
<ul>
<li>
<p>数据交换必须遵守事先约定好的规则。</p>
</li>
<li>
<p><strong>规则</strong>明确规定了所交换数据的格式以及同步问题。</p>
</li>
<li>
<p><strong>网络协议 (network protocol)</strong>，简称为<strong>协议</strong>，是为进行网络中的数据交换而建立的规则、标准或约定。</p>
</li>
<li>
<p>协议的三个组成要素</p>
<ul>
<li>语法：数据和控制信息的结构或格式</li>
<li>语义：需要发出何种控制信息，完成何种动作以及做出何种响应</li>
<li>同步：事件实现顺序的详细说明</li>
</ul>
</li>
<li>
<p>协议的两种形式</p>
<ul>
<li><strong>文字描述</strong>—便于阅读和理解</li>
<li><strong>程序代码</strong>—计算机能够理解</li>
<li>必须都能对信息交换过程<strong>做出精确解释</strong></li>
</ul>
</li>
<li>
<p>分层的好处和缺点</p>
<ul>
<li>好处
<ul>
<li>各层独立</li>
<li>灵活性好</li>
<li>结构可分割</li>
<li>易于实现和维护</li>
<li>能促进标准化工作</li>
</ul>
</li>
<li>缺点
<ul>
<li>降低效率</li>
<li>有些功能在不同层次中出现，产生额外开销</li>
</ul>
</li>
</ul>
</li>
<li>
<p>各层完成的主要功能</p>
<ul>
<li>差错控制：使相应层次对等方的通信更加可靠。</li>
<li>流量控制：发送端的发送速率必须使接收端来得及接收，不要太快。</li>
<li>分段和重装：发送端将要发送的数据块划分为更小的单位，在接收端将其还原。</li>
<li>复用和分用：发送端几个高层会话复用一条低层的连接，在接收端再进行分用。</li>
<li>连接建立和释放：交换数据前先建立一条逻辑连接，数据传送结束后释放连接。</li>
</ul>
</li>
<li>
<p>计算机网络的体系结构</p>
<ul>
<li>计算机网络的<strong>体系结构 (architecture)</strong> 是计算机网络的各层及其协议的集合。</li>
<li>体系结构就是这个计算机网络及其部件<strong>所应完成的功能的精确定义</strong>。</li>
<li><strong>实现 (implementation)</strong> 是遵循这种体系结构的前提下用何种硬件或软件完成这些功能的问题。</li>
<li>体系结构是<strong>抽象</strong>的，而实现则是<strong>具体</strong>的，是真正在运行的计算机硬件和软件。</li>
</ul>
</li>
</ul>
<h4 id="五层协议的体系结构">五层协议的体系结构</h4>
<ul>
<li>OIS七层协议体系结构概念清晰，理论完整，但复杂不实用</li>
<li>TCP/IP是四层：
<ul>
<li>应用层</li>
<li>运输层</li>
<li>网际层</li>
<li>网络接口层</li>
</ul>
</li>
<li>但是最下面的网络接口层没有具体内容</li>
<li>五层协议体系结构，综合OSI和TCP/IP的优点</li>
</ul>
<img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20200920200838933.png" alt="image-20200920200838933" style="zoom:67%;" />
<ul>
<li>
<p><strong>PDU(Protocol Data Unit)：协议数据单元</strong></p>
</li>
<li>
<p>对等层次之间传送的数据单位称为该层的协议数据单元PDU</p>
</li>
<li>
<p>任何两个同样的层次把数据（即数据单元加单元控制信息）通过水平虚线直接传递给对方，这就是所谓的**对等层(peer layers)**之间的通信</p>
</li>
</ul>
<h4 id="实体、协议、服务和服务访问点">实体、协议、服务和服务访问点</h4>
<ul>
<li>**实体(entity)**表示任何可发送或接收信息的硬件或软件进程</li>
<li><strong>协议</strong>是控制两个<strong>对等实体</strong>进行通信的规则的集合</li>
<li>在协议控制下，两个对等实体间的通信使得本层能够<strong>向上一层提供服务</strong></li>
<li>要实现本层协议，还需要<strong>使用下层提供的服务</strong></li>
<li><strong>协议</strong>是<strong>水平的</strong>，即协议是控制对等实体之间通信的规则</li>
<li><strong>服务</strong>是<strong>垂直的</strong>，即服务是由下层向上层通过层间接口提供的</li>
</ul>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20200920202038155.png" alt="image-20200920202038155"></p>
<ul>
<li>同一系统相邻两层的实体进行交互的地方，称为<strong>服务访问点 SAP (Service Access Point)</strong>。</li>
<li>服务访问点SAP是一个抽象的概念，它实际上就是一个逻辑接口。</li>
<li>OSI把层与层之间交换的数据的单位称为<strong>服务数据单元 SDU (Service Data Unit)</strong>。</li>
<li>SDU 可以与 PDU 不一样，例如，可以是多个 SDU 合成为一个 PDU，也可以是一个 SDU 划分为几个 PDU。</li>
</ul>
<h4 id="TCP-IP的体系结构">TCP/IP的体系结构</h4>
<p><img src="%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.assets/image-20200920202738144.png" alt="image-20200920202738144"></p>
<ul>
<li>实际上，现在的互联网使用的 TCP/IP 体系结构有时已经发生了演变，即某些应用程序可以直接使用 IP 层，或甚至直接使用最下面的网络接口层。</li>
</ul>
<h2 id="第2章-物理层">第2章 物理层</h2>
<h3 id="物理层基本概念">物理层基本概念</h3>
<ul>
<li><strong>物理层</strong>只考虑在连接计算机的传输媒体上<strong>传输比特流</strong>，不是指具体的传输媒体</li>
<li>**物理层的作用：**尽可能屏蔽掉不同传输媒体和通信手段差异</li>
<li>物理层协议也叫做<strong>物理层规程（procedure）</strong></li>
<li>**物理层主要任务：**确定与传输媒体的接口的一些特性
<ul>
<li>机械特性：接口所用接线器的形状尺寸，引线数目</li>
<li>电气特性：接口电缆的各条线出现的电压范围</li>
<li>功能特性：某条线出现的某一电平的电压的意义</li>
<li>过程特性：对于不同功能的各种可能事件的出现顺序</li>
</ul>
</li>
</ul>
<h3 id="数据通信的基础知识">数据通信的基础知识</h3>
<h4 id="数据通信系统模型">数据通信系统模型</h4>
<ul>
<li>
<p>包括三大部分</p>
<ul>
<li>源系统（或发送端、发送方）</li>
<li>传输系统（或传输网络）</li>
<li>目的系统（或接收端、接收方）</li>
</ul>
</li>
<li>
<p>常用术语</p>
<ul>
<li>数据data：运送消息的实体</li>
<li>信号signal：数据的电气或电磁的表现</li>
<li>模拟信号analogous signal：代表消息的参数的取值是连续的</li>
<li>数字信号digital signal：代表消息的参数的取值是离散的</li>
<li>码元code：代表不同离散数值的基本波形</li>
</ul>
</li>
</ul>
<h4 id="信道相关概念">信道相关概念</h4>
<ul>
<li>
<p>信道</p>
<ul>
<li>
<p>一般用来表示向某一个方向传送信息的媒体</p>
</li>
<li>
<p>单工通信</p>
</li>
<li>
<p>只有一个方向的通信</p>
</li>
<li>
<p>半双工通信</p>
<ul>
<li>通信双方都可以发送消息，但不能同时发送</li>
</ul>
</li>
<li>
<p>全双工通信</p>
<ul>
<li>通信双方可以同时发送和接收信息</li>
</ul>
</li>
<li>
<p>基带信号</p>
<ul>
<li>来自信源的信号</li>
</ul>
<blockquote>
<p>像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号</p>
</blockquote>
</li>
<li>
<p>调制</p>
<ul>
<li>基带信号包含许多低频成分，甚至有直流成分，许多信道不能传输这种低频分量或直流分量</li>
<li>**基带调制：**仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号，这种过程称为编码(coding)</li>
<li><strong>带通调制：<strong>使用载波(carrier)进行调制，把基带信号频率搬移到较高频段，并转换为</strong>模拟信号</strong>，这样就更好地在模拟信道中传输
<ul>
<li>**带通信号：**经过载波调制后的信号</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>常用编码方式</p>
<ul>
<li>**不归零制：**正电平代表 1，负电平代表 0。</li>
<li>**归零制：**正脉冲代表 1，负脉冲代表 0。</li>
<li>**曼彻斯特编码：**位周期中心的向上跳变代表 0，位周期中心的向下跳变代表 1。但也可反过来定义。</li>
<li>**差分曼彻斯特编码：**在每一位的中心处始终都有跳变。位开始边界有跳变代表 0，而位开始边界没有跳变代表 1。</li>
</ul>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20201008223221914.png" alt="image-20201008223221914"></p>
<ul>
<li>曼彻斯特编码和差分曼彻斯特编码产生的信号频率比不归零制高。</li>
<li>从自同步能力来看，不归零制不能从信号波形中提取信号时钟频率（这叫做没有自同步能力），但是<strong>曼彻斯特编码</strong>和<strong>差分曼彻斯特编码</strong>具有<strong>自同步能力</strong></li>
</ul>
</li>
<li>
<p>基本的带通<strong>调制</strong>方法</p>
<ol>
<li>调幅(AM)：载波的振幅随基带数字信号变化</li>
<li>调频(FM)：载波的频率随基带数字信号变化</li>
<li>调相(PM)：载波的初始相位随基带数字信号变化</li>
</ol>
</li>
</ul>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20201010155933256.png" alt="image-20201010155933256"></p>
<ul>
<li>
<p><strong>正交振幅调制</strong> <strong>QAM (Quadrature</strong> <strong>Amplitude Modulation)</strong></p>
<p>例如</p>
<ul>
<li>可供选择的相位有 12 种，而对于每一种相位有 1 或 2 种振幅可供选择。总共有 16 种组合，即 16 个码元。</li>
<li>由于 4 bit 编码共有 16 种不同的组合，因此这 16 个点中的每个点可对应于一种 4 bit 的编码。数据传输率可提高 4 倍。</li>
</ul>
<blockquote>
<p>不是码元越多越好。若每一个码元可表示的比特数越多，则在接收端进行解调时要正确识别每一种状态就越困难，出错率增加。</p>
</blockquote>
</li>
</ul>
<h4 id="信道的极限容量">信道的极限容量</h4>
<ul>
<li>
<p>码元的传输速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真越严重</p>
</li>
<li>
<p>限制码元在信道上的传输速率的因素</p>
<ul>
<li>
<p>信道能够通过的频率范围</p>
<ul>
<li>
<p>码元传输速率过高会出现<strong>码间串扰</strong>问题，使接收端无法识别码元</p>
<blockquote>
<p>信道频带越宽，能通过的信号高频分量越多，就可以用更高的速率传输码元而不出现码间串扰</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>信噪比</p>
<ul>
<li>信号的平均功率和噪声的平均功率之比</li>
<li>记为S/N，并用分贝作为度量单位</li>
<li>信噪比$(dB)=10log_{10}(S/N)(dB)$</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>香农公式</strong></p>
<ul>
<li>计算信道的极限信息传输速率C</li>
<li>$C = W log_2(1+S/N)  (bit/s) $</li>
<li>W为信号的宽带（以Hz为单位）</li>
<li>S为信道内所传信号的平均功率</li>
<li>N为信道内的高斯噪声功率</li>
</ul>
</li>
<li>
<p>信道的宽带或信道中的信噪比越大，信息的极限传输速率就越高</p>
</li>
<li>
<p>只要<strong>信息传输速率</strong>低于<strong>信道的极限信息传输速率</strong>，就一定可以找到某种办法来实现<strong>无差错的传输</strong>。</p>
</li>
<li>
<p>若信道带宽W或信噪比S/N没有上限，则信道的极限信息传输速率C也没有上限</p>
</li>
<li>
<p>对于频带宽度确定，信噪比不能提高，码元传输速率达到上限</p>
<ul>
<li>提高信息传输速率的方法是：<strong>用编码的方法让每一个码元携带更多比特的信息量。</strong></li>
</ul>
</li>
</ul>
<h3 id="物理层下的传输媒体">物理层下的传输媒体</h3>
<ul>
<li><strong>传输媒体</strong>也称为<strong>传输介质</strong>或<strong>传输媒介</strong>，是数据传输系统中在发送器和接收器之间的物理通路。</li>
<li>在<strong>导引型传输媒体</strong>中，电磁波被导引沿着固体媒体（铜线或光纤）传播。</li>
<li><strong>非导引型传输媒体</strong>就是指自由空间。在非导引型传输媒体中，电磁波的传输常称为无线传输。</li>
</ul>
<h4 id="导引型传输媒体">导引型传输媒体</h4>
<ul>
<li>双绞线
<ul>
<li>最常用</li>
<li>模拟信号和数字信号</li>
<li>通信距离几到十几公里</li>
<li><strong>屏蔽双绞线</strong> STP (Shielded Twisted Pair)</li>
<li><strong>无屏蔽双绞线</strong> UTP (Unshielded Twisted Pair)</li>
</ul>
</li>
<li>同轴电缆
<ul>
<li>有很好的抗干扰特性</li>
<li>用于传输较高速率的数据</li>
<li>带宽决定于电缆的质量</li>
<li>50 Ω 同轴电缆 —— LAN / 数字传输常用</li>
<li>75 Ω 同轴电缆 —— 有线电视 / 模拟传输常用</li>
</ul>
</li>
<li>光纤
<ul>
<li>光纤通信的传输媒体</li>
<li>可见光频率高，光纤传输带宽远远大于其他传输媒体</li>
<li>优点
<ul>
<li>通信容量大</li>
<li>传输损耗小，中继距离长</li>
<li>抗雷电和电磁干扰性能好</li>
<li>无传音干扰，保密性好</li>
<li>体积小，重量轻</li>
</ul>
</li>
<li>多模光纤
<ul>
<li>存在多条不同角度入射的光纤</li>
</ul>
</li>
<li>单模光纤
<ul>
<li>光线直径减小到只有一个光的播放，光会向前传播，不会产生多次反射</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="非导引型传输媒体">非导引型传输媒体</h4>
<ul>
<li>自由空间</li>
<li>无限传输使用的频段很广</li>
<li>短波（高频）通信主要是靠电离层的反射，但是短波信道的通信质量较差，传输速率低。</li>
<li>微波在空间主要是直线传播</li>
<li>传统微波通信方式
<ul>
<li>地面微波接力通信</li>
<li>卫星通信</li>
</ul>
</li>
</ul>
<h3 id="信道复用技术">信道复用技术</h3>
<h4 id="频分复用、时分复用和统计时分复用">频分复用、时分复用和统计时分复用</h4>
<ul>
<li><strong>复用</strong> <strong>(multiplexing)</strong></li>
<li>允许用户使用一个共享信道进行通信，降低成本，提高利用率</li>
<li><strong>频分复用</strong> <strong>FDM (Frequency</strong> <strong>Division Multiplexing)</strong>
<ul>
<li>将宽带分为多份</li>
<li>所有用户在同样的时间占用不同的带宽（指频率带宽而不是数据的放发送速率）资源</li>
</ul>
</li>
<li><strong>时分复用TDM (Time Division Multiplexing)</strong>
<ul>
<li>将时间划分为一段段等长的<strong>时分复用帧（TDM帧）</strong></li>
<li>每一个用户在每一个TDM帧中占用固定序号的时隙</li>
<li>每一个用户占用时隙都是周期性地出现（其周期是TDM帧的长度）</li>
<li>TDM信号也称为<strong>等时</strong> **(isochronous)**信号</li>
<li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong></li>
<li>使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。</li>
</ul>
</li>
<li>**统计时分复用 STDM (Statistic TDM) **
<ul>
<li>STDM帧不是固定分配时隙，而是按需动态地分配时隙</li>
<li>因此统计时分复用可以提高线路的利用率</li>
</ul>
</li>
</ul>
<h4 id="波分复用">波分复用</h4>
<ul>
<li>**波分复用 WDM(Wavelength Division Multiplexing) **
<ul>
<li>光的频分复用</li>
<li>使用一根光纤来同时传输多个光载波信号</li>
</ul>
</li>
</ul>
<h4 id="码分复用">码分复用</h4>
<ul>
<li>
<p>**码分复用 CDM (Code Division Multiplexing) **</p>
<ul>
<li><strong>码分多址 CDMA (Code Division Multiple Access)</strong></li>
</ul>
</li>
<li>
<p>**码片序列(chip sequence) **</p>
<ul>
<li>每一个比特时间划分为 <em>m</em> 个短的间隔，称为<strong>码片</strong> (chip)。</li>
<li>每个站被指派一个唯一的 <em>m</em> bit <strong>码片序列</strong>。
<ul>
<li>如发送比特 1，则发送自己的 <em>m</em> bit 码片序列。</li>
<li>如发送比特 0，则发送该码片序列的二进制反码。</li>
</ul>
</li>
</ul>
<blockquote>
<p>例如，S 站的 8 bit 码片序列是 00011011。</p>
<p>​	发送比特 1 时，就发送序列 00011011，</p>
<p>​	发送比特 0 时，就发送序列 11100100。</p>
<p>S 站的码片序列：(–1 –1 –1 +1 +1 –1 +1 +1)</p>
</blockquote>
</li>
<li>
<p>码片序列实现了扩频</p>
<ul>
<li>假定S站要发送信息的数据率为 <strong><em>b</em> bit/s</strong>。由于每一个比特要转换成 <em><strong>m</strong></em> 个比特的码片，因此 S 站实际上发送的数据率提高到 <strong><em>mb</em> bit/s</strong>，同时 S 站所占用的频带宽度也提高到原来数值的 m 倍。</li>
<li>这种通信方式是<strong>扩频</strong>(spread spectrum)通信中的一种</li>
<li>扩频通信通常有两大类
<ul>
<li>一种是<strong>直接序列扩频DSSS</strong> (Direct Sequence Spread Spectrum)，如上面讲的使用码片序列就是这一类。</li>
<li>另一种是<strong>跳频扩频FHSS</strong> (Frequency Hopping Spread Spectrum)。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>CDMA特点</p>
<ul>
<li>每个站的码片序列不仅必须<strong>各不相同</strong>，并且还必须<strong>互相正交</strong></li>
<li>在使用系统中使用<strong>伪随机码序列</strong></li>
</ul>
</li>
<li>
<p>码片序列的<strong>正交关系</strong></p>
<ul>
<li>向量S表示站S的码片向量，T表示其他任何站的码片向量</li>
<li>两个不同站的码片序列正交，就是向量S和T的规格化内积(inner product)等于0
<ul>
<li>$S\cdot T\equiv\frac1m\sum\limits^{m}_{i=1}S_iT_i=0$</li>
</ul>
</li>
<li>任何一个码片向量和该码片向量自己的规格化内积都是1
<ul>
<li>$S\cdot S\equiv\frac1m\sum\limits^{m}<em>{i=1}S_iS_i=\sum\limits^{m}</em>{i=1}S_i^2=\sum\limits^{m}_{i=1}(\pm1)^2=1$</li>
</ul>
</li>
<li>一个码片向量和该码片反码的向量的规格化内积值是-1</li>
</ul>
</li>
</ul>
<h4 id="数字传输系统">数字传输系统</h4>
<ul>
<li>与模拟通信相比，数字通信无论是在传输质量上还是经济上都有明显优势</li>
<li>旧的数字传输系统存在的缺点
<ul>
<li>速率标准不统一</li>
<li>不是同步传输</li>
</ul>
</li>
</ul>
<h3 id="宽带接入技术">宽带接入技术</h3>
<ul>
<li>用户要连接到互联网，必须先连接到某个ISP</li>
</ul>
<h4 id="ADSL技术">ADSL技术</h4>
<ul>
<li>
<p><strong>非对称数字用户线 ADSL</strong> (Asymmetric Digital Subscriber Line) 技术</p>
</li>
<li>
<p>用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务</p>
</li>
<li>
<p>把0-4kHz低段频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用</p>
</li>
<li>
<p>DSL是<strong>数字用户线</strong> (Digital Subscriber Line) 的缩写</p>
</li>
<li>
<p>DSL分类</p>
<ul>
<li>ADSL (Asymmetric Digital Subscriber Line)：非对称数字用户线</li>
<li>HDSL (High speed DSL)：高速数字用户线</li>
<li>SDSL (Single-line DSL)：1 对线的数字用户线</li>
<li>VDSL (Very high speed DSL)：甚高速数字用户线</li>
<li>DSL (Digital Subscriber Line) ：数字用户线</li>
<li>RADSL (Rate-Adaptive DSL)：速率自适应 DSL，是 ADSL 的一个子集，可自动调节线路速率）</li>
</ul>
</li>
<li>
<p>ADSL传输距离</p>
<ul>
<li>取决于数据率和用户线的线径（用户线越细，信号传输时的衰减就越大）</li>
<li>ADSL 所能得到的最高数据传输速率与实际的用户线上的信噪比密切相关</li>
</ul>
</li>
<li>
<p>ADSL特点</p>
<ul>
<li>上行和下行宽带做成不对成的
<ul>
<li>上行指用户到ISP，下行指从ISP到用户</li>
</ul>
</li>
<li>在用户线的两端各安装一个ADSL调制解调器</li>
<li>我国目前采用的方案是**离散多音调DMT(Discrete Multi-Tone)**调制技术
<ul>
<li>多音调就是<strong>多载波</strong>或<strong>多子信道</strong>的意思</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>DMT技术</strong></p>
<ul>
<li>采用<strong>频分复用</strong>的方法</li>
<li>相当于在一对用户线上使用许多小的调制解调器并行地传送数据</li>
</ul>
</li>
<li>
<p>ADSL的数据率</p>
<ul>
<li>采用<strong>自适应调制技术</strong>使用户线能够传送尽可能高的数据率</li>
<li>ADSL<strong>不能保证固定的数据率</strong></li>
</ul>
</li>
<li>
<p>第二代ADSL</p>
<ul>
<li>通过提高调制效率得到了更高的数据率</li>
<li>采用<strong>无缝速率自适应技术SRA</strong>(Seamless Rate Adaptation)，可在运营中不中断通信和不产生误码的情况下，自适应地调整数据率</li>
<li>改善了线路质量评测和故障定位功能</li>
</ul>
</li>
</ul>
<h4 id="光纤同轴混合网（HFC网）">光纤同轴混合网（HFC网）</h4>
<ul>
<li><strong>HFC (Hybrid Fiber Coax)</strong> 网是在目前覆盖面很广的有线电视网 CATV 的基础上开发的一种居民宽带接入网</li>
<li>除了可传送CATV外，还提供电话、数据和其他宽带交互型业务</li>
<li>现有的 CATV 网是树形拓扑结构的同轴电缆网络，它采用模拟技术的频分复用对电视节目进行单向传输</li>
<li><strong>HFC 网对 CATV 网进行了改造，具有双向传输功能，扩展了传输频带</strong></li>
<li>主干线路采用光纤
<ul>
<li>将原CATV网中的同轴电缆主干部分该换为<strong>光纤</strong>，并使用<strong>模拟光线技术</strong></li>
<li>采用光的<strong>振幅调制AM</strong>，比使用数字光纤更为经济</li>
<li>模拟光纤从<strong>头端</strong>连接到<strong>光纤结点(fiber node)</strong>，即在<strong>光分配节点ODN(Optical Distribution Node)</strong></li>
<li>在光纤结点光信号被转换为电信号</li>
<li>光纤结点以下就是同轴电缆</li>
</ul>
</li>
<li>每个家庭需要一个<strong>用户接口盒UIB(User Interface Box)</strong>，提供三种连接
<ol>
<li>使用同轴电缆连接到机顶盒，再连接到用户的电视机</li>
<li>使用双绞线连接到用户的电话机</li>
<li>使用电缆调制解调器连接到用户的计算机
<ul>
<li>**电缆调制解调器(Cable Modem)**是为HFC网而使用的调制解调器</li>
<li>传输速率高</li>
<li>只安装在用户端</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="FTTx技术">FTTx技术</h4>
<ul>
<li>是一种实现宽带居民接入网的方案，代表多种宽带光纤接入方式</li>
<li>FTTx代表Fiber to The …
<ul>
<li>**光纤到户 FTTH (Fiber To The Home)：**光纤一直铺设到用户家庭，可能是居民接入网最后的解决方法。</li>
<li>**光纤到大楼 FTTB (Fiber To The Building)：**光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。</li>
<li>**光纤到路边 FTTC (Fiber To The Curb)：**光纤铺到路边，从路边到各用户可使用星形结构绞线作为传输媒体。</li>
</ul>
</li>
</ul>
<h2 id="第3章-数据链路层">第3章 数据链路层</h2>
<ul>
<li>计算机网络体系结构</li>
</ul>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20201010202654836.png" alt="image-20201010202654836"></p>
<ul>
<li>网络中的主机、路由器等都必须实现数据链路层</li>
<li>局域网中的主机、交换机等都必须实现数据链路层</li>
<li>不同的链路层可能采用不同的数据链路层协议</li>
<li>数据链路层使用的信道
<ul>
<li>点对点信道
<ul>
<li>这种信道使用一对一的<strong>点对点</strong>通信方式</li>
</ul>
</li>
<li>广播信道
<ul>
<li>使用一对多的<strong>广播通信</strong>方式</li>
<li>必须使用专用的共享信道协议来协调这些主机的数据发送</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="使用点对点信道的数据链路层">使用点对点信道的数据链路层</h3>
<h4 id="数据链路和帧">数据链路和帧</h4>
<ul>
<li>
<p>**链路(link)**是一条无源的点到点的物理线路段，中间没有任何其他的交换结点</p>
<ul>
<li>一条链路只是一条通路的一个组成部分</li>
</ul>
</li>
<li>
<p>**数据链路(data link)**除了物理线路外，还必须有通信协议来控制这些数据的传输</p>
</li>
<li>
<p>把实现通信协议的硬件和软件加到链路上，就构成了<strong>数据链路</strong></p>
<ul>
<li>现在使用适配器（即网卡）来实现这些协议的硬件和软件</li>
<li>一般的适配器都包括了<strong>数据链路层</strong>和<strong>物理层</strong>的功能</li>
<li>早期的数据通信协议叫做<strong>通信规程（procedure）</strong></li>
</ul>
</li>
<li>
<p>数据链路层传送的是<strong>帧</strong></p>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20201010204345849.png" alt="image-20201010204345849"></p>
</li>
</ul>
<h4 id="三个基本问题">三个基本问题</h4>
<ul>
<li>封装成帧</li>
<li>透明传输</li>
<li>差错控制</li>
</ul>
<h5 id="封装成帧-framing">封装成帧 framing</h5>
<ul>
<li>
<p>就是在一段数据的前后分别添加首部和尾部，然后构成了帧</p>
</li>
<li>
<p>首部和尾部的作用就是<strong>帧定界</strong></p>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20201010204659257.png" alt="image-20201010204659257"></p>
</li>
<li>
<p>用控制字符进行帧定界的方法举例</p>
<ul>
<li>当数据是由可打印的ASCII码组成的文本文件时，帧定界可以使用特殊的<strong>帧定界符</strong></li>
<li><strong>控制字符 SOH</strong> (Start Of Header) 放在一帧的最前面，表示帧的首部开始</li>
<li><strong>控制字符 EOT</strong> (End Of Transmission) 表示帧的结束</li>
</ul>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20201010204843310.png" alt="image-20201010204843310"></p>
</li>
</ul>
<h5 id="透明传输">透明传输</h5>
<ul>
<li>
<p>如果数据中某个子节的代码恰好和SOH或者EOT一样，数据链路层就会错误定位帧边界</p>
</li>
<li>
<p>解决方法</p>
<ul>
<li><strong>子节填充 byte stuffing</strong></li>
<li><strong>字符填充 character stuffing</strong></li>
</ul>
</li>
<li>
<p>发送端的数据链路层在数据中出现控制字符SOH或者EOT的前面插入一个<strong>转义字符ESC</strong>（其十六进制编码是1B）</p>
</li>
<li>
<p>接收端的数据链路层在把数据传入网络层之前删除转义字符</p>
</li>
<li>
<p>如果转义字符也出现在数据中，那么应该在转义字符前插入一个转入字符，当接收端收到连续两个转义字符时，删除前面的一个</p>
</li>
<li>
<p><strong>透明</strong></p>
<ul>
<li>指某一个实际存在的事物看起来却好像不存在一样</li>
</ul>
<blockquote>
<p>“在数据链路层透明传送数据”表示无论发送什么样的比特组合的数据，这些数据都能够按照原样没有差错地通过这个数据链路层。</p>
</blockquote>
</li>
</ul>
<h5 id="差错检测">差错检测</h5>
<ul>
<li>比特差错，比如1变0，0变1</li>
<li>在一段时间内，传输错误的比特占所传输比特总数的比例称为<strong>误码率BER</strong>(bit error rate)
<ul>
<li>误码率和信噪比有关</li>
<li>在数据链路层传送的帧中，广泛使用了<strong>循环冗余检验CRC</strong>的检错技术</li>
</ul>
</li>
<li>循环冗余检验的原理
<ul>
<li>在发送端，先把数据划分成每组k个比特，在每组后面添加供差错检验用的n位冗余码。</li>
</ul>
</li>
<li>冗余码的计算
<ul>
<li>先在M后面添加n个0</li>
<li>得到的**（k+n）位的数<strong>除以事先选定好的长度为</strong>（n+1）位的除数P**，得出<strong>商是Q</strong>而<strong>余数是R</strong>，余数R比除数P少1位，即R是n位</li>
<li>将<strong>余数R</strong>作为<strong>冗余码</strong>拼接在数据M后面，一起发送出去</li>
</ul>
</li>
<li>接收端进行CRC检验
<ul>
<li>若得出的余数R=0，则判定这个帧没有差错，接受</li>
<li>若余数≠0，则判定这个帧由差错，丢弃</li>
</ul>
</li>
</ul>
<blockquote>
<p>计算举例</p>
<p>k = 6, M = 101001</p>
<p>设n=3, P = 1101</p>
<p>被除数 2^n*M = 101001000</p>
<p>运算结果 商Q = 110101，余数R=001</p>
<p>所以发送的数据是 2^n*M + R = 101001001</p>
</blockquote>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20201010212422896.png" alt="image-20201010212422896"></p>
<ul>
<li>帧检验序列FCS（Frame Check Sequence）
<ul>
<li>在数据后面添加的冗余码称为帧检验序列</li>
<li>CRC和FCS的区别
<ul>
<li>CRC是一种检错方法，FCS是指冗余码</li>
<li>FCS可以用CRC的方法得出，但CRC不是获得FCS的唯一方法</li>
</ul>
</li>
</ul>
</li>
<li><strong>注意点</strong>
<ul>
<li>仅用CRC只能做到<strong>无差错接受</strong>或者说<strong>无比特差错</strong>
<ul>
<li>凡是接受的帧，都能以非常接近于1的概率认为这些帧在传输过程中没有产生差错</li>
<li>凡是接收端数据链路层接受的帧都没有传输差错</li>
</ul>
</li>
<li>单纯使用CRC差错检测技术不能实现<strong>无差错传输</strong>或<strong>可靠传输</strong></li>
</ul>
</li>
</ul>
<h3 id="点对点协议PPP">点对点协议PPP</h3>
<h4 id="PPP协议特点">PPP协议特点</h4>
<ul>
<li><strong>点对点协议 PPP (Point-to-Point Protocol)</strong></li>
<li>用户到ISP的链路使用PPP协议</li>
<li>PPP协议需要满足的需求
<ul>
<li><strong>简单</strong> — <strong>首要</strong></li>
<li>封装成帧
<ul>
<li>必须规定特殊的字符作为帧定界符</li>
</ul>
</li>
<li>透明性
<ul>
<li>必须保证数据传输的透明性</li>
</ul>
</li>
<li>多种网络层协议
<ul>
<li>能够在同一条物理链路上支持多种网络层协议</li>
</ul>
</li>
<li>多种类型链路
<ul>
<li>能够在多种类型的链路上运行</li>
</ul>
</li>
<li>差错检测
<ul>
<li>能够对接收端接收到的帧进行检测，并立刻丢弃有差错的帧</li>
</ul>
</li>
<li>检测连接状态
<ul>
<li>能够及时自动检测出链路是否处于正常工作状态</li>
</ul>
</li>
<li>最大传送单元
<ul>
<li>必须对每一种类型的点对点链路设置最大传送单元 MTU 的标准默认值，促进各种实现之间的互操作性</li>
</ul>
</li>
<li>网络层地址协商
<ul>
<li>必须提供一种机制使通信的两个网络层实体能够通过协商知道或能够配置彼此的网络层地址</li>
</ul>
</li>
<li>数据压缩协商
<ul>
<li>必须提供一种方法来协商使用数据压缩算法</li>
</ul>
</li>
</ul>
</li>
<li>PPP协议不需要的
<ul>
<li>纠错</li>
<li>流量控制</li>
<li>序号</li>
<li>多点线路</li>
<li>半双工或单工链路</li>
</ul>
</li>
<li>PPP协议的组成
<ul>
<li>将IP数据报封装到串行链路的方法</li>
<li>链路控制协议LCP(Link Control Protocol)</li>
<li>网络控制协议NCP(Network Control Protocol)</li>
</ul>
</li>
</ul>
<h4 id="PPP协议的帧格式">PPP协议的帧格式</h4>
<ul>
<li>PPP帧首部4个字符，尾部2个字符</li>
<li>标志字段 F = 0x7E</li>
<li>地址字段 A 只置 0xFF，实际上并不起作用</li>
<li>控制字段C通常设置为 0x03</li>
<li>PPP是<strong>面向字节</strong>的，所有PPP帧的长度都是整数子节</li>
</ul>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20201013194639262.png" alt="image-20201013194639262"></p>
<ul>
<li>
<p>透明传输问题</p>
<ul>
<li>
<p><strong>异步传输</strong>时，使用一种特殊的<strong>字符填充</strong>法</p>
<ul>
<li>将信息字段中出现的每一个0x7E转变成2字节序列（0x7D，0x5E）</li>
<li>将信息字段中出现的每一个0x7D转变成2子节序列（0x7D，0x5D）</li>
<li>将信息组的那种出现的ASCII码的控制字符（即数值小于0x20的字符）的前面，加入一个0x7D字节，同时改变该字符的编码。</li>
</ul>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20201013195204741.png" alt="image-20201013195204741"></p>
</li>
<li>
<p><strong>同步传输</strong>时，协议规定采用硬件来完成<strong>比特填充</strong>（和HDLC做法一样）</p>
<ul>
<li>SONNET/SDH链路，同步传输，PPP协议采用零比特填充来实现透明传输</li>
<li>发送端，只要有5个连续的1，就立即填入1个0</li>
<li>接收端，每当发现5个连续的1，就把这5个连续的1后面的1个0删除</li>
</ul>
</li>
</ul>
</li>
<li>
<p>PPP协议不提供使用序号和确认的可靠传输的原因</p>
<ul>
<li>数据链路层出现差错的概率不大时，使用比较简单的PPP协议较为合理</li>
<li>因特网环境下，PPP信息字段放入的数据的IP数据报，数据链路层的可靠传输并不能保证网络层的传输也是可靠的</li>
<li>帧检验序列FCS字段可保证无差错接受</li>
</ul>
</li>
</ul>
<h4 id="PPP协议的工作状态">PPP协议的工作状态</h4>
<ul>
<li>用户拨号接入ISP，路由器的调制解调器对拨号做出确认，并建立物理连接</li>
<li>PC机向路由器发送一系列的LCP分组（封装成多个PPP帧）</li>
<li>这些分组及其相应选择一些PPP参数，进行网络层配置</li>
<li>NCP给新接入的PC机分配一个临时的IP地址，使PC机成为因特网上的一个主机</li>
<li>通信完毕时，NCP释放网络层连接，收回原来分配出去的IP地址</li>
<li>LCP释放数据链路层连接，最后释放物理层的连接</li>
<li><strong>PPP协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容</strong></li>
</ul>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20201013201234704.png" alt="image-20201013201234704"></p>
<h3 id="使用广播信道的数据链路层">使用广播信道的数据链路层</h3>
<h4 id="局域网的数据链路层">局域网的数据链路层</h4>
<ul>
<li>局域网的主要特点
<ul>
<li>网络为一个单位所拥有</li>
<li>地理范围和站点数目有限</li>
</ul>
</li>
<li>局域网优点
<ul>
<li>具有广播功能，一个站点可访问全网。局域网的主机可共享连接在局域网上的各种硬件和软件资源</li>
<li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变</li>
<li>提高了系统的可靠性、可用性和残存性</li>
</ul>
</li>
<li>共享信道的问题
<ul>
<li>一对多的广播通信方式</li>
<li>多个设备在共享的广播信道发送数据，会造成彼此干扰，导致发送失败</li>
</ul>
</li>
<li>媒体共享技术
<ul>
<li>静态划分信道
<ul>
<li>频分复用</li>
<li>时分复用</li>
<li>波分复用</li>
<li>码分复用</li>
</ul>
</li>
<li>动态媒体接入控制
<ul>
<li>随机接入</li>
<li>受控接入，例如多点线路探询或轮询</li>
</ul>
</li>
</ul>
</li>
<li>以太网的两个标准
<ul>
<li>DIX Ethernet V2，以太网严格意义上指符合该标准的局域网</li>
<li>IEEE 802.3，两者区别很小，可以将802.3局域网简称为以太网</li>
</ul>
</li>
<li>局域网的数据链路层拆成两个子层
<ul>
<li>逻辑链路控制LLC(Logical Link Control)子层
<ul>
<li>存放与传输媒体无关的内容</li>
<li>不管采用何种协议的局域网，对于LLC子层来说都是透明的</li>
<li>现在作用不大，现在很多适配器没有LLC协议</li>
</ul>
</li>
<li>媒体接入控制MAC(Medium Access Control)子层
<ul>
<li>存放与传输媒体有关的内容</li>
</ul>
</li>
</ul>
</li>
<li>适配器的作用
<ul>
<li>又称为<strong>通信适配器</strong>(adapter)或<strong>网络接口卡</strong>(Network Interface Card)，或<strong>网卡</strong></li>
<li>进行串行/并行转换</li>
<li>对数据进行缓存</li>
<li>在计算机的操作系统安装设备驱动程序</li>
<li>实现以太网协议</li>
</ul>
</li>
</ul>
<h4 id="CSMD-MD协议">CSMD/MD协议</h4>
<h4 id="使用集线器的星型拓扑">使用集线器的星型拓扑</h4>
<h4 id="以太网的信道利用率">以太网的信道利用率</h4>
<h4 id="以太网的MAC层">以太网的MAC层</h4>
<h3 id="扩展的以太网">扩展的以太网</h3>
<h3 id="高速以太网">高速以太网</h3>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>物联网导论笔记</title>
    <url>/post/2020-10-01-Basic/%E7%89%A9%E8%81%94%E7%BD%91%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<h1>物联网导论</h1>
<h2 id="第1章-物联网概述">第1章 物联网概述</h2>
<h2 id="第2章-自动识别技术和RFID">第2章 自动识别技术和RFID</h2>
<h3 id="自动识别技术">自动识别技术</h3>
<ul>
<li>
<p><strong>光学字符识别 OCR</strong></p>
</li>
<li>
<p>Optical Character Recognition</p>
<ul>
<li>模式识别的一种</li>
<li>设备通过光学机制识别字符</li>
</ul>
</li>
<li>
<p><strong>语音识别</strong></p>
</li>
<li>
<p>采用数字信号处理技术自动提取和决定语音中最基本有意义的信息</p>
</li>
<li>
<p><strong>虹膜识别</strong></p>
</li>
<li>
<p>最方便精确的生物识别技术</p>
<ul>
<li>身份鉴别基于虹膜的高度独特性和稳定性</li>
</ul>
</li>
<li>
<p><strong>指纹识别</strong></p>
<ul>
<li>实用角度由于其他生物识别技术</li>
<li>指纹各不相同、终生基本不变</li>
<li>总体特征
<ul>
<li>纹型</li>
<li>模式区</li>
<li>三角点</li>
<li>纹数</li>
</ul>
</li>
<li>局部特征
<ul>
<li>终结点</li>
<li>分叉点</li>
<li>分歧点</li>
<li>孤立点</li>
<li>环点</li>
<li>短纹</li>
</ul>
</li>
<li>处理流程
<ul>
<li>指纹图像采集</li>
<li>指纹图像处理</li>
<li>特征提取</li>
<li>特征值比对和匹配</li>
</ul>
</li>
</ul>
</li>
<li>
<p>IC卡</p>
<ul>
<li>
<p>Integrated Circuit Card 集成电路卡</p>
</li>
<li>
<p>IC卡应用系统</p>
<ul>
<li>IC卡
<ul>
<li>记录持卡人特征代码、文件资料的便携式信息载体</li>
</ul>
</li>
<li>接口设备
<ul>
<li>IC卡读写器，是卡和PC信息交换的桥梁</li>
<li>核心为可靠的工业控制单片机， 例如Intel的51系列</li>
</ul>
</li>
<li>计算机
<ul>
<li>系统的<strong>核心</strong>，完成信息处理、报表生成输出等</li>
</ul>
</li>
<li>通信网络和计算机
<ul>
<li>同窗用于金融服务等较大的系统</li>
</ul>
</li>
</ul>
</li>
<li>
<p>IC卡分类</p>
<ul>
<li>
<p>存储卡</p>
<ul>
<li>功能简单，没有安全保护逻辑</li>
<li>价格低廉，开发使用简便</li>
<li>存储容量增长块</li>
<li>多用于内部信息无需保密或不允许加密（急救卡）的场合</li>
</ul>
</li>
<li>
<p>逻辑加密卡</p>
<ul>
<li>有一定的安全保证</li>
<li>如保险卡、加油卡、驾驶卡</li>
</ul>
</li>
<li>
<p>CPU卡</p>
<ul>
<li>
<p>计算能力高，存储容量大，应用灵活，适应性强</p>
</li>
<li>
<p>安全防伪能力强</p>
</li>
<li>
<p>如手机SIM卡</p>
</li>
<li>
<p>按数据传输形式分类</p>
<ol>
<li>串行通信卡</li>
<li>并行通信卡</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>条形码技术</strong></p>
</li>
<li>
<p>为消除数据录入的瓶颈问题</p>
<ul>
<li><strong>条形码</strong>是由一组规则排列的<strong>条、空</strong>以及对应的字符组成的<strong>标记</strong></li>
<li>组成次序：静区（前）、起始符、数据符、（中间分割符，主要用于EAN码）、(校验符)、终止符、静区（后）</li>
<li><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20201012171749364.png" alt="image-20201012171749364"></li>
</ul>
</li>
<li>
<p>一维条形码</p>
<ul>
<li><strong>基本概念</strong>
<ul>
<li>对比度
<ul>
<li>越大，条码的光学特性越好 PCS = (RL-RD)/RL*100%</li>
<li>RL为条形码反射率，RD为空气反射率</li>
</ul>
</li>
<li>条码长度
<ul>
<li>从条码起始符前缘到终止符后缘的长度</li>
</ul>
</li>
<li>条码密度
<ul>
<li>单位长度的条码表示的字符个数</li>
</ul>
</li>
<li>双向条码
<ul>
<li>条码的两端都可以作为扫描起点的</li>
</ul>
</li>
<li>中间分隔符
<ul>
<li>条码符号中，位于两个相邻的条码符号之间且不代表任何信息的空</li>
</ul>
</li>
<li>连续性条码
<ul>
<li>条码字符中，两个相邻的条码字符之间没有中间分隔符的条码</li>
</ul>
</li>
<li>非连续性
<ul>
<li>条码字符中，两个相邻的条码字符之间存在中间分隔符的条码</li>
</ul>
</li>
</ul>
</li>
<li><strong>译码原理</strong>
<ul>
<li>激光扫描仪通过一个激光二极管发出光纤，照射到一个旋转的棱镜上</li>
<li>反射后的光线穿过阅读器照射到条码表面</li>
<li>光线经过条或空的反射后回到阅读器</li>
<li>由一个镜子进行采集、聚焦，通过光电转换器转换成电信号</li>
<li>电信号通过扫描器或终端上的译码软件进行译码</li>
</ul>
</li>
</ul>
</li>
<li>
<p>二维条形码</p>
</li>
<li>
<p><strong>一维条形码和二维条形码的比较</strong></p>
<ul>
<li>一维条形码
<ul>
<li>贮存数据不多，主要依靠计算机中的关联数据库</li>
<li>保密性能不高</li>
<li>污损后可读性差</li>
</ul>
</li>
<li>二维条形码
<ul>
<li>贮存数据量大，可存放1K组字符</li>
<li>可用扫描仪直接读取内容，无需另接数据库</li>
<li>保密性高</li>
<li>安全级别高时，污损50%仍可读取完整信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="RFID的历史和现状">RFID的历史和现状</h3>
<ul>
<li>射频识别技术 Radio Frequency Identification</li>
<li>利用射频信号通过空间耦合，实现无接触信息传递并通过信息达到识别目的</li>
<li>目前处于<strong>全面推广</strong>的阶段</li>
</ul>
<h3 id="RFID技术分析">RFID技术分析</h3>
<ul>
<li><strong>RFID系统组成</strong>
<ul>
<li>传送器、接收器、微处理器
<ul>
<li>三者通常被封装在一起，称为<strong>阅读器Reader</strong></li>
</ul>
</li>
<li>天线</li>
<li>标签</li>
</ul>
</li>
<li>阅读器
<ul>
<li>最重要且最复杂的一个组件</li>
<li>工作模式是主动向标签询问标识信息</li>
<li>有时称为<strong>询问器(Interrogator)</strong></li>
</ul>
</li>
<li>天线
<ul>
<li>同阅读器相连，用于在标签和阅读器之间传递射频信号</li>
<li>阅读器可以连接一个或多个天线</li>
</ul>
</li>
<li><strong>标签</strong> <strong>Tag</strong>
<ul>
<li>由耦合元件、芯片和微型天线组成</li>
<li>每个标签内部存有唯一的电子编码，附着在物体上标识目标对象</li>
<li>存储方式
<ul>
<li>电可擦可编程只读存储器 <strong>EEPROM</strong></li>
<li>铁电随机存取存储器 <strong>FRAM</strong></li>
<li>静态随机存取存储器 <strong>SRAM</strong></li>
</ul>
</li>
<li>标签分类
<ul>
<li>被动式标签 Passive Tag</li>
<li>主动标签 Active Tag</li>
<li>半主动标签 Semi-active Tag</li>
</ul>
</li>
<li>与条形码相比的<strong>优点</strong>
<ul>
<li>体积小且形状多样</li>
<li>环境适应性强</li>
<li>可重复使用</li>
<li>穿透性强</li>
<li>数据安全性</li>
</ul>
</li>
<li><strong>频率</strong>
<ul>
<li>低频，LF，30kHz-300kHz，无源标签，通信范围小于1米，低频信号能够穿过任意材料的物品而不降低它的读取距离</li>
<li>高频，HF，3MHz-30MHz，小于1米，不再需要线圈绕制，可以通过腐蚀活字印刷的方式制作标签内的天线</li>
<li>超高频，433MHz，860-960MHz，2.45GHz，5.8GHz，可以是有源标签和无源标签两种，通信距离一般4-6米，最大超过10米</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="RFID和物联网">RFID和物联网</h3>
<ul>
<li><strong>物联网</strong>是通过给所有物品贴上RFID标签，在现有互联网基础上构建所有参与流通的物品信息网络</li>
</ul>
<h2 id="第3章-无线传感器">第3章 无线传感器</h2>
<p>重点掌握</p>
<ul>
<li>无线传感网节点所需硬件的基本特性</li>
<li>TinyOS系统的特性</li>
<li>了解和基本掌握选路指标ETX、路由协议CTP、数据分发协议Drip等组网技术</li>
</ul>
<h3 id="概述">概述</h3>
<ul>
<li><strong>无线传感节点组成</strong>
<ul>
<li><strong>电池</strong></li>
<li><strong>传感器</strong></li>
<li><strong>微处理器</strong></li>
<li><strong>无线通信芯片</strong></li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20201012172435957.png" alt="image-20201012172435957"></p>
<ul>
<li>与传统传感器相比，无线传感节点
<ul>
<li>包括传感器部件</li>
<li>集成微型处理器和无线通信芯片</li>
<li>能够对感知信息进行<strong>分析处理</strong>和<strong>网络传输</strong></li>
</ul>
</li>
</ul>
<h3 id="硬件平台">硬件平台</h3>
<h4 id="传感器">传感器</h4>
<ul>
<li>选择是否需要外部模数转换器和额外的校准技术
<ul>
<li>根据处理器和传感器的<strong>交互方式</strong>：模拟信号/数字信号</li>
</ul>
</li>
</ul>
<h4 id="微处理器">微处理器</h4>
<ul>
<li>负责计算的核心</li>
<li><strong>深度集成</strong>的特征使得非常适合在无线传感器网络中使用
<ul>
<li>内存</li>
<li>闪存</li>
<li>数模转化器</li>
<li>数字IO</li>
</ul>
</li>
<li>影响节点工作整体性能的关键
<ul>
<li>功耗特性</li>
<li>唤醒时间
<ul>
<li>睡眠/工作状态间快速切换</li>
</ul>
</li>
<li>供电电压
<ul>
<li>长时间工作</li>
</ul>
</li>
<li>运算速度</li>
<li>内存大小</li>
</ul>
</li>
</ul>
<h4 id="通信芯片">通信芯片</h4>
<ul>
<li>
<p>通常消耗能量最多</p>
</li>
<li>
<p>重要指标：<strong>传输距离</strong></p>
<ul>
<li>发射功率越大，接受灵敏度越高，信号传输距离越远</li>
</ul>
</li>
</ul>
<h4 id="供能装置">供能装置</h4>
<ul>
<li>电池供电 =&gt; 节点容易部署</li>
<li>电压、环境变化 =&gt; 电池容量不能被完全利用</li>
<li>可再生能源存储能量
<ul>
<li>充电电池
<ul>
<li>自放电较少</li>
<li>电能利用率较高</li>
<li>充电效率低</li>
<li>充电次数有限</li>
</ul>
</li>
<li>超电容
<ul>
<li>充电效率高</li>
<li>充电次数可达100万次</li>
<li>不易受温度、振动因素影响</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="操作系统">操作系统</h3>
<ul>
<li>节点操作系统是<strong>微型化</strong>的</li>
<li>主要特点
<ul>
<li>硬件平台资源极其有限</li>
</ul>
</li>
</ul>
<h4 id="TinyOS">TinyOS</h4>
<ul>
<li>在目前无线传感网络研究领域使用最为广泛的OS</li>
<li>开发语言：nesC
<ul>
<li>专门为资源有限、硬件平台多样化的传感节点设计</li>
<li>使用nesC编写的应用程序基于组件</li>
<li>组件之间的交互<strong>必须通过接口</strong></li>
<li>一般有一个最顶层的配置文件</li>
</ul>
</li>
<li>任务调度
<ul>
<li>使用了事件驱动的单线程任务调度机制</li>
<li>任何一个时刻，处理器只能执行一个任务</li>
<li>单个TinyOS任务中不能有IO等阻塞的调用</li>
</ul>
</li>
<li>关键服务
<ul>
<li>OS核心服务</li>
<li>数据收集协议</li>
<li>数据分发协议</li>
<li>时间同步协议</li>
<li>网络重编程协议</li>
</ul>
</li>
</ul>
<h3 id="组网技术">组网技术</h3>
<h4 id="选路指标-ETX">选路指标 ETX</h4>
<ul>
<li>传输成功每个包需要的总传输次数</li>
<li>ETX，Expected Transmission Count</li>
<li>Link throughput ≈ 1/Link ETX​</li>
</ul>
<img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20201012175305044.png" alt="image-20201012175305044" style="zoom:67%;" />
<ul>
<li>
<p>假设链路有ACKs和重传</p>
<ul>
<li>P(TX success) = P(Data success) * P(ACK success)</li>
<li>Link ETX = 1 / P(TX success)  = 1 / [ P(Data success) * P(ACK success) ]</li>
</ul>
</li>
<li>
<p>实际计算ETX</p>
<ul>
<li>
<p>•P(Data success) ≈ measured fwd delivery ratio $r_{fwd}$</p>
<p>•P(ACK success) ≈ measured rev delivery ratio $r_{rev}$</p>
<p>•Link ETX ≈ 1 / ($r_{fwd}\times r_{rev}$)</p>
</li>
</ul>
</li>
<li>
<p>扩展到路径的情形 Route ETX = Sum of link ETXs</p>
<img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20201012175754505.png" alt="image-20201012175754505" style="zoom:67%;" />
</li>
</ul>
<h4 id="数据收集协议-CTP">数据收集协议 CTP</h4>
<ul>
<li>
<p>Collection Tree Protocol</p>
<ul>
<li>初始化：网络中每个节点广播自己到汇聚节点的路径的ETX</li>
<li>每个节点收到广播包之后，依据邻居节点广播的路径ETX，动态选择父节点，使得自己到汇聚节点的路径ETX尽量小</li>
<li>经过不断更新，网络中的每个节点都能够选择到一条到汇聚节点ETX之和最小的路径</li>
</ul>
</li>
<li>
<p>在TinyOS中的实现</p>
<ul>
<li>链路质量：综合考虑
<ul>
<li>CTP通过主动交换控制包来估计链路质量</li>
<li>通过被动侦听数据包来动态更新链路质量</li>
<li>CTP考虑了链路层信息</li>
<li>考虑了网络层队列是否有溢出的信息，以此来避免拥塞的节点</li>
<li>在控制包发送方面，使用了Trickle算法来自适应的控制发包的频率</li>
</ul>
</li>
</ul>
</li>
<li>
<p>信息传播方式</p>
<ul>
<li>Trickle Timer
<ul>
<li>在网络稳定的时候，Trickle算法二进制增长发包间隔，以减少发送包的数量</li>
<li>发生环路或其他异常时，Trickle算法缩短发包间隔至最小，使网络能及时恢复到正常状态</li>
</ul>
</li>
<li>优点
<ul>
<li>网络不变化，发送包数量少</li>
<li>网络一旦变化，迅速更新整个网络</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="数据分发协议">数据分发协议</h4>
<ul>
<li>Drip
<ul>
<li>Drip为每一个数据项分配一个版本号，版本号越高的数据越新</li>
<li>网络中每个节点周期性广播关于一个数据项的版本信息</li>
<li>Drip节点发现自己需要更新时，向邻居节点发送请求包</li>
<li>Drip节点收到请求包后广播关于被请求数据项的包</li>
</ul>
</li>
<li>数据分发协议和洪泛协议的区别
<ul>
<li>数据分发协议维护了每一个数据项的版本信息，保证该数据的最新版本可靠地扩散到整个网络</li>
</ul>
</li>
</ul>
<h3 id="传感网发展前景">传感网发展前景</h3>
<ul>
<li>
<p>制约性能提升的因素</p>
<ul>
<li>功耗
<ul>
<li>节能</li>
</ul>
</li>
<li>价格
<ul>
<li>廉价</li>
</ul>
</li>
<li>体积
<ul>
<li>微型化</li>
</ul>
</li>
</ul>
</li>
<li>
<p>节点的软件设计</p>
<ul>
<li>必须节约计算资源，避免超出节点的硬件能力</li>
</ul>
</li>
<li>
<p>灵活性与扩展性</p>
<ul>
<li>传感器节点被应用于不同的应用中</li>
<li>硬件设计需要满足一定的标准接口</li>
<li>软件设计必须是可裁剪的，能够根据不同应用的需求，安装不同功能的软件模块</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年10月刷题日志</title>
    <url>/post/2020-10-01-Algorithm/2020%E5%B9%B410%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h3 id="10-31">10.31</h3>
<p>python选手的福音来了</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="381-O-1-时间插入、删除和获取随机元素-允许重复"><a href="https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed/">381. O(1) 时间插入、删除和获取随机元素 - 允许重复</a></h4>
<p>难度困难</p>
<p>设计一个支持在<em>平均</em> 时间复杂度 <strong>O(1)</strong> 下**，** 执行以下操作的数据结构。</p>
<p><strong>注意: 允许出现重复元素。</strong></p>
<ol>
<li><code>insert(val)</code>：向集合中插入元素 val。</li>
<li><code>remove(val)</code>：当 val 存在时，从集合中移除一个 val。</li>
<li><code>getRandom</code>：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。</li>
</ol>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 初始化一个空的集合。</span><br><span class="line">RandomizedCollection collection = new RandomizedCollection();</span><br><span class="line"></span><br><span class="line">// 向集合中插入 1 。返回 true 表示集合不包含 1 。</span><br><span class="line">collection.insert(1);</span><br><span class="line"></span><br><span class="line">// 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。</span><br><span class="line">collection.insert(1);</span><br><span class="line"></span><br><span class="line">// 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。</span><br><span class="line">collection.insert(2);</span><br><span class="line"></span><br><span class="line">// getRandom 应当有 2/3 的概率返回 1 ，1/3 的概率返回 2 。</span><br><span class="line">collection.getRandom();</span><br><span class="line"></span><br><span class="line">// 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。</span><br><span class="line">collection.remove(1);</span><br><span class="line"></span><br><span class="line">// getRandom 应有相同概率返回 1 和 2 。</span><br><span class="line">collection.getRandom();</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>对于python来说这也就是一道表面困难题</p>
<p>一开始我只用了一个哈希表来解，结果发现单纯用字典在返回随机值的时候时间复杂度是O(N)</p>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201031101712.png" alt="image-20201031101705654"></p>
<p>于是乎又用数组+哈希表来优化解法，接下来针对每种操作讲解一下</p>
<ul>
<li>
<p>初始化</p>
<ul>
<li>新建一个空数组<code>nums</code></li>
<li>新建一个空字典<code>dic</code></li>
</ul>
</li>
<li>
<p>插入元素</p>
<ul>
<li>直接在<code>nums</code>数组中<code>append</code>要插入的值</li>
<li>令<code>dic[插入的值]+=1</code>
<ul>
<li>如果要插入的值不在字典的<code>key</code>中，就令<code>dic[插入的值]=1</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>删除元素</p>
<ul>
<li>首先使用字典来判断这个删除的数是否在数组中</li>
<li>如果这个数在字典的key中，且对应的<code>dic[要删除的数]&gt;=1</code>，说明是可以成功删除的
<ul>
<li>于是就使用<code>nums.remove(要删除的数)</code>和<code>dic[要删除的数]-=1</code>，来实现删去这个数</li>
</ul>
</li>
</ul>
</li>
<li>
<p>获取随机值</p>
</li>
<li>
<p>直接使用<code>random.randint(0, len(nums)-1)</code>来随机取一个index，返回<code>nums[index]</code></p>
</li>
<li>
<p>可以看到这样的实现是真的O(1)</p>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201031102903.png" alt="image-20201031102903759"></p>
</li>
</ul>
<h3 id="10-30">10.30</h3>
<p>昨天晚上九点多买完kfc发现自行车钥匙丢了</p>
<p>结果就推到了修车摊，人走回的学校</p>
<p>今天刚走去修车摊把我的车锁换了</p>
<p>累死了</p>
<p>不过leetcode这道题确实简单</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="463-岛屿的周长"><a href="https://leetcode-cn.com/problems/island-perimeter/">463. 岛屿的周长</a></h4>
<p>难度简单300</p>
<p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。</p>
<p>网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p>
<p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p>
<p><strong>示例 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">[[0,1,0,0],</span><br><span class="line">[1,1,1,0],</span><br><span class="line">[0,1,0,0],</span><br><span class="line">[1,1,0,0]]</span><br><span class="line"></span><br><span class="line">输出: 16</span><br><span class="line"></span><br><span class="line">解释: 它的周长是下面图片中的 16 个黄色的边：</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201030153857.png" alt="img"></p>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>先算出所有陆地方格的边总数
<ul>
<li>陆地方格数*4</li>
</ul>
</li>
<li>然后遍历每个陆地方格的四周，去掉重复计算的边</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">islandPerimeter</span>(<span class="params">self, grid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> grid:</span><br><span class="line">            ans += <span class="built_in">sum</span>(i)*<span class="number">4</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> grid:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        judges = [[<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,-<span class="number">1</span>],[-<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">        rows = <span class="built_in">len</span>(grid)</span><br><span class="line">        cols = <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                <span class="keyword">if</span> grid[i][j]==<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">for</span> x,y <span class="keyword">in</span> judges:</span><br><span class="line">                    row = x+i</span><br><span class="line">                    col = y+j</span><br><span class="line">                    <span class="keyword">if</span> row&lt;<span class="number">0</span> <span class="keyword">or</span> row&gt;=rows <span class="keyword">or</span> col&lt;<span class="number">0</span> <span class="keyword">or</span> col&gt;=cols:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> grid[row][col]==<span class="number">1</span>:</span><br><span class="line">                        ans-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans                 </span><br></pre></td></tr></table></figure>
<h3 id="10-29">10.29</h3>
<p>今天又放假？</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="129-求根到叶子节点数字之和"><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/">129. 求根到叶子节点数字之和</a></h4>
<p>难度中等</p>
<p>给定一个二叉树，它的每个结点都存放一个 <code>0-9</code> 的数字，每条从根到叶子节点的路径都代表一个数字。</p>
<p>例如，从根到叶子节点路径 <code>1-&gt;2-&gt;3</code> 代表数字 <code>123</code>。</p>
<p>计算从根到叶子节点生成的所有数字之和。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line"> 1</span><br><span class="line">/ \</span><br><span class="line">2   3</span><br><span class="line">输出: 25</span><br><span class="line">解释:</span><br><span class="line">从根到叶子节点路径 1-&gt;2 代表数字 12.</span><br><span class="line">从根到叶子节点路径 1-&gt;3 代表数字 13.</span><br><span class="line">因此，数字总和 = 12 + 13 = 25.</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [4,9,0,5,1]</span><br><span class="line"> 4</span><br><span class="line">/ \</span><br><span class="line">9   0</span><br><span class="line">/ \</span><br><span class="line">5   1</span><br><span class="line">输出: 1026</span><br><span class="line">解释:</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.</span><br><span class="line">从根到叶子节点路径 4-&gt;0 代表数字 40.</span><br><span class="line">因此，数字总和 = 495 + 491 + 40 = 1026.</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>也没啥好讲的，就递归深搜求解呗</p>
<p>搜到底的时候就记录一下值</p>
<p><strong>代码</strong></p>
<ul>
<li>我的丑陋代码</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumNumbers</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">add_ans</span>(<span class="params">cur_num, root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                res.append(cur_num*<span class="number">10</span>+root.val)</span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                add_ans(cur_num*<span class="number">10</span>+root.val, root.left)</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                add_ans(cur_num*<span class="number">10</span>+root.val, root.right)</span><br><span class="line">        add_ans(<span class="number">0</span>, root)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(res)</span><br></pre></td></tr></table></figure>
<ul>
<li>大佬的优美递归</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">self, cur_num, root</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> cur_num*<span class="number">10</span>+root.val</span><br><span class="line">        <span class="keyword">return</span> self.dfs(cur_num*<span class="number">10</span>+root.val, root.left) + self.dfs(cur_num*<span class="number">10</span>+root.val, root.right)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumNumbers</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">return</span> self.dfs(<span class="number">0</span>, root)</span><br></pre></td></tr></table></figure>
<h3 id="10-28">10.28</h3>
<p>今天又是简单题</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1207-独一无二的出现次数"><a href="https://leetcode-cn.com/problems/unique-number-of-occurrences/">1207. 独一无二的出现次数</a></h4>
<p>难度简单</p>
<p>给你一个整数数组 <code>arr</code>，请你帮忙统计数组中每个数的出现次数。</p>
<p>如果每个数的出现次数都是独一无二的，就返回 <code>true</code>；否则返回 <code>false</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [1,2,2,1,1,3]</span><br><span class="line">输出：true</span><br><span class="line">解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：arr = [-3,0,1,-3,1,1,1,-3,10,0]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= arr.length &lt;= 1000</code></li>
<li><code>-1000 &lt;= arr[i] &lt;= 1000</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>
<p>常规思路</p>
<ul>
<li>用字典计数</li>
<li>用集合判重</li>
</ul>
</li>
<li>
<p>不常规思路</p>
<ul>
<li>利用python的collections库中的Counter计数类，来统计数组中的数出现次数</li>
<li>利用<code>Counter(arr)</code>来让<code>[1,2,3,4,1,1,1]</code>来生成计数用的字典{1：4，2：1，3：1，4：1}</li>
<li>然后判重</li>
</ul>
<blockquote>
<p>其实就是一个道理</p>
</blockquote>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniqueOccurrences</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        cs = Counter(arr)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> cs:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">list</span>(cs.values()).count(cs[num]) != <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h3 id="10-27">10.27</h3>
<p>剪刀石头布的通信实验终于让我做完了！！！</p>
<p>快乐刷题</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="144-二叉树的前序遍历"><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></h4>
<p>难度中等</p>
<p>给定一个二叉树，返回它的 <em>前序</em> 遍历。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">3 </span><br><span class="line"></span><br><span class="line">输出: [1,2,3]</span><br></pre></td></tr></table></figure>
<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
</blockquote>
<p><strong>思路</strong></p>
<p>就不用递归写了，没啥技术含量</p>
<p>练习一下迭代吧</p>
<p><strong>常规解法</strong></p>
<ul>
<li>
<p>利用栈的后进先出的特性，来实现先左后右</p>
</li>
<li>
<p>初始化栈，将根节点存入栈</p>
</li>
<li>
<p>从栈中pop出一个结点</p>
<ul>
<li>然后把这个结点的值存储ans数组中</li>
<li>把该节点的右子结点push到栈中</li>
<li>把该节点的左子节点push到栈中</li>
<li>直到栈为空</li>
</ul>
</li>
</ul>
<p><strong>模板解法</strong></p>
<ul>
<li>初始化栈</li>
<li>令cur结点为根节点</li>
<li>当栈非空或cur结点非空时继续循环
<ul>
<li>将cur结点的值存入ans数组</li>
<li>把cur和它所有的左子结点都push到栈里</li>
<li>然后从栈顶取出一个结点
<ul>
<li>这个结点我们知道一定是最左下角的一个</li>
</ul>
</li>
<li>将cur设为该节点的右子结点</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = []</span><br><span class="line">        node = root</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">while</span> stack <span class="keyword">or</span> node:</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                ans.append(node.val)</span><br><span class="line">                stack.append(node)</span><br><span class="line">                node = node.left</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            node = node.right</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="10-26">10.26</h3>
<p>美好的自习周末就这么过去了，我却还卡在操作系统的剪刀石头布实验</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1365-有多少小于当前数字的数字"><a href="https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/">1365. 有多少小于当前数字的数字</a></h4>
<p>难度简单</p>
<p>给你一个数组 <code>nums</code>，对于其中每个元素 <code>nums[i]</code>，请你统计数组中比它小的所有数字的数目。</p>
<p>换而言之，对于每个 <code>nums[i]</code> 你必须计算出有效的 <code>j</code> 的数量，其中 <code>j</code> 满足 <code>j != i</code> <strong>且</strong> <code>nums[j] &lt; nums[i]</code> 。</p>
<p>以数组形式返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [8,1,2,2,3]</span><br><span class="line">输出：[4,0,1,1,3]</span><br><span class="line">解释： </span><br><span class="line">对于 nums[0]=8 存在四个比它小的数字：（1，2，2 和 3）。 </span><br><span class="line">对于 nums[1]=1 不存在比它小的数字。</span><br><span class="line">对于 nums[2]=2 存在一个比它小的数字：（1）。 </span><br><span class="line">对于 nums[3]=2 存在一个比它小的数字：（1）。 </span><br><span class="line">对于 nums[4]=3 存在三个比它小的数字：（1，2 和 2）。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [6,5,4,8]</span><br><span class="line">输出：[2,1,0,3]</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [7,7,7,7]</span><br><span class="line">输出：[0,0,0,0]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>2 &lt;= nums.length &lt;= 500</code></li>
<li><code>0 &lt;= nums[i] &lt;= 100</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>
<p>一道五个月前提交过的老题</p>
<ul>
<li>
<p>当时用的是排序，排完序之后找index函数确定每个数字的位置</p>
</li>
<li>
<p>其实挺无脑的，就贴个代码看一下吧</p>
</li>
<li>
<pre><code class="language-python">class Solution:
    def smallerNumbersThanCurrent(self, nums: List[int]) -&gt; List[int]:
        tmp_lst = sorted(nums)
        ans = [0]*len(nums)
        for i in range(len(nums)):
            ans[i] = tmp_lst.index(nums[i])
        return ans
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 上一种思路的时间复杂度是`O(NlogN)`，空间复杂度是`O(N)`</span><br><span class="line"></span><br><span class="line">- 看了官方题解的计数法重新写了一下（虽然也用了python的特性）</span><br><span class="line"></span><br><span class="line">  - 数字出现的值域是固定的`[1,100]`</span><br><span class="line">  - 建立一个长度为101的`cnt`数组去记录每个数字出现的次数</span><br><span class="line">  - 遍历数组`nums`，`cnt[num]+=1`</span><br><span class="line">  - 然后因为要计算的是比某个数字小的数出现的次数</span><br><span class="line">  - 所以要对cnt数组做一次前缀和</span><br><span class="line">  - 每个数加上所有在它左边的数</span><br><span class="line">  - 最后`cnt[i]`就是比`i`这个数小的数字出现次数</span><br><span class="line">  - 遍历`nums`，找到答案</span><br><span class="line"></span><br><span class="line">**代码**</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">class Solution:</span><br><span class="line">    def smallerNumbersThanCurrent(self, nums: List[int]) -&gt; List[int]:</span><br><span class="line">        # 由于数字的值域是[0, 100]</span><br><span class="line">        # 所以直接开辟一个数组来记录数字的出现次数</span><br><span class="line">        cnt = [0 for i in range(101)]</span><br><span class="line">        for num in nums:</span><br><span class="line">            cnt[num] += 1</span><br><span class="line">        # 根据出现次数我们可以计算出比x小的数有多少个</span><br><span class="line">        tmp = 0</span><br><span class="line">        for i in range(len(cnt)):</span><br><span class="line">            # 这里直接用python的特性来少设一个变量</span><br><span class="line">            tmp, cnt[i] = tmp+cnt[i], tmp</span><br><span class="line">        ans = []</span><br><span class="line">        for i in nums:</span><br><span class="line">            ans.append(cnt[i])</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>还是比原来方法快很多的</p>
</blockquote>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201026092122.png" alt="image-20201026092115525"></p>
<h3 id="10-25">10.25</h3>
<p>今日重阳节，云登山。</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="845-数组中的最长山脉"><a href="https://leetcode-cn.com/problems/longest-mountain-in-array/">845. 数组中的最长山脉</a></h4>
<p>难度中等</p>
<p>我们把数组 A 中符合下列属性的任意连续子数组 B 称为 “<em>山脉”</em>：</p>
<ul>
<li><code>B.length &gt;= 3</code></li>
<li>存在 <code>0 &lt; i &lt; B.length - 1</code> 使得 <code>B[0] &lt; B[1] &lt; ... B[i-1] &lt; B[i] &gt; B[i+1] &gt; ... &gt; B[B.length - 1]</code></li>
</ul>
<p>（注意：B 可以是 A 的任意子数组，包括整个数组 A。）</p>
<p>给出一个整数数组 <code>A</code>，返回最长 <em>“山脉”</em> 的长度。</p>
<p>如果不含有 “<em>山脉”</em> 则返回 <code>0</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[2,1,4,7,3,2,5]</span><br><span class="line">输出：5</span><br><span class="line">解释：最长的 “山脉” 是 [1,4,7,3,2]，长度为 5。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[2,2,2]</span><br><span class="line">输出：0</span><br><span class="line">解释：不含 “山脉”。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>0 &lt;= A.length &lt;= 10000</code></li>
<li><code>0 &lt;= A[i] &lt;= 10000</code></li>
</ol>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>用<code>diffs</code>数组去记录<code>A[i]-A[i-1]</code>的值</li>
<li>找到最长的山脉也就是找到最长的<code>[+,+,+,....,-,-,-,]</code>的数组长度+1</li>
<li>这个数组满足数组的前半部分都是正数，后半部分都是负数</li>
<li>要保证前半部分和后半部分的个数都大于0</li>
</ul>
<p><strong>代码</strong></p>
<p>今天代码写的很烂，建议直接忽略</p>
<p>一道中等题WA了将近10次才Pass我也太菜了吧</p>
<img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201025132219.png" alt="image-20201025132211962" style="zoom:67%;" />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">longestMountain</span>(<span class="params">self, A: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        diffs = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(A)):</span><br><span class="line">            diffs.append(A[i]-A[i-<span class="number">1</span>])</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        flag = <span class="number">0</span> <span class="comment"># 用来标记是否已经经过山峰</span></span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 找到diffs数组中最长的 ++++ ----- 数组</span></span><br><span class="line">        <span class="comment"># 1, -1, 1, -1, -1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> diffs:</span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> flag==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cur:</span><br><span class="line">                    cur = <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> flag==<span class="number">1</span>:</span><br><span class="line">                ans = <span class="built_in">max</span>(cur, ans)</span><br><span class="line">                cur = <span class="number">2</span></span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> i&lt;<span class="number">0</span> <span class="keyword">and</span> flag==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> cur==<span class="number">1</span> <span class="keyword">or</span> <span class="keyword">not</span> cur:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i&lt;<span class="number">0</span> <span class="keyword">and</span> flag==<span class="number">1</span>:</span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i==<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> flag==<span class="number">1</span>:</span><br><span class="line">                    ans = <span class="built_in">max</span>(ans, cur)</span><br><span class="line">                cur = <span class="number">1</span></span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, cur)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> ans&lt;<span class="number">3</span> <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="10-24">10.24</h3>
<p>程序员节快乐！</p>
<p>小D同学为啥每天都要生我的气呢…</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1024-视频拼接"><a href="https://leetcode-cn.com/problems/video-stitching/">1024. 视频拼接</a></h4>
<p>难度中等</p>
<p>你将会获得一系列视频片段，这些片段来自于一项持续时长为 <code>T</code> 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。</p>
<p>视频片段 <code>clips[i]</code> 都用区间进行表示：开始于 <code>clips[i][0]</code> 并于 <code>clips[i][1]</code> 结束。我们甚至可以对这些片段自由地再剪辑，例如片段 <code>[0, 7]</code> 可以剪切成 <code>[0, 1] + [1, 3] + [3, 7]</code> 三部分。</p>
<p>我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（<code>[0, T]</code>）。返回所需片段的最小数目，如果无法完成该任务，则返回 <code>-1</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">我们选中 [0,2], [8,10], [1,9] 这三个片段。</span><br><span class="line">然后，按下面的方案重制比赛片段：</span><br><span class="line">将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。</span><br><span class="line">现在我们手上有 [0,2] + [2,8] + [8,10]，而这些涵盖了整场比赛 [0, 10]。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：clips = [[0,1],[1,2]], T = 5</span><br><span class="line">输出：-1</span><br><span class="line">解释：</span><br><span class="line">我们无法只用 [0,1] 和 [1,2] 覆盖 [0,5] 的整个过程。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9</span><br><span class="line">输出：3</span><br><span class="line">解释： </span><br><span class="line">我们选取片段 [0,4], [4,7] 和 [6,9] 。</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：clips = [[0,4],[2,8]], T = 5</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">注意，你可能录制超过比赛结束时间的视频。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= clips.length &lt;= 100</code></li>
<li><code>0 &lt;= clips[i][0] &lt;= clips[i][1] &lt;= 100</code></li>
<li><code>0 &lt;= T &lt;= 100</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>题目序号是1024呢，标了中等但其实很简单，没啥算法和数据结构</p>
<ul>
<li>一开始设定<code>start, end = -1, 0</code>用来记录上一次的剪辑片段</li>
<li>就是很纯粹的贪心法，不断地找最长的片段拼到一起
<ul>
<li>每次找的片段的开始时间必须早于上一个片段的结束时间，同时还必须晚于上一个片段的开始时间</li>
<li>同时结束时间要比上一个片段的结束时间晚</li>
<li>然后保证每次找到的片段的结束时间是合法片段中能最晚结束的</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">videoStitching</span>(<span class="params">self, clips: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], T: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        start, end = -<span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> end&lt;T:</span><br><span class="line">            tmp = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> clips:</span><br><span class="line">                <span class="keyword">if</span> i[<span class="number">0</span>]&lt;= end <span class="keyword">and</span> i[<span class="number">1</span>]&gt;end <span class="keyword">and</span> i[<span class="number">0</span>]&gt;=start:</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> tmp:</span><br><span class="line">                        tmp = i</span><br><span class="line">                    <span class="keyword">elif</span> i[<span class="number">1</span>]&gt;=tmp[<span class="number">1</span>]:</span><br><span class="line">                        tmp = i</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> tmp:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            start = tmp[<span class="number">0</span>]</span><br><span class="line">            end = tmp[<span class="number">1</span>]</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span> <span class="keyword">if</span> <span class="keyword">not</span> ans <span class="keyword">else</span> ans</span><br><span class="line">                    </span><br></pre></td></tr></table></figure>
<h3 id="10-23">10.23</h3>
<p>太好了，今天可以自习一天了</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="234-回文链表"><a href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a></h4>
<p>难度简单</p>
<p>请判断一个链表是否为回文链表。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>
<p><strong>进阶：</strong><br>
你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</p>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>O(n) 空间复杂度
<ul>
<li>用数组nums存下每个结点值，利用切片操作直接返回nums == nums[::-1]</li>
</ul>
</li>
<li>O(1)空间复杂度
<ul>
<li>首先用快慢指针找到中间结点</li>
<li>翻转后半部分的链表</li>
<li>逐个对比前半部分链表结点和后半部分链表的值</li>
</ul>
</li>
<li>这几个算法写过了就不展开了，直接上进阶要求的代码</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPalindrome</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 先找到中间节点</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        fast,slow=head,head</span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 找到后半链表的头节点mid</span></span><br><span class="line">        mid = slow.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 反转后半部分的列表</span></span><br><span class="line">        node1, node2 = head, self.reverse(mid)</span><br><span class="line">        <span class="comment"># 逐个对比前后链表中结点的值</span></span><br><span class="line">        <span class="keyword">while</span> node1 <span class="keyword">and</span> node2:</span><br><span class="line">            <span class="keyword">if</span> node1.val != node2.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            node1 = node1.<span class="built_in">next</span></span><br><span class="line">            node2 = node2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">self, head</span>):</span><br><span class="line">        <span class="comment"># 从head开始反转列表</span></span><br><span class="line">        prev = <span class="literal">None</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            tmp = cur.<span class="built_in">next</span></span><br><span class="line">            cur.<span class="built_in">next</span> = prev</span><br><span class="line">            prev = cur</span><br><span class="line">            cur = tmp</span><br><span class="line">        <span class="keyword">return</span> prev</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<h3 id="10-22">10.22</h3>
<p>明天是运动会，所以今天就是这周上课的最后一天啦，坚持一哈</p>
<p>最近有一大堆实验报告要写，再过一个星期又是期中考试，实验室还有项目要做</p>
<p>不说了，我冲了！</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="763-划分字母区间"><a href="https://leetcode-cn.com/problems/partition-labels/">763. 划分字母区间</a></h4>
<p>难度中等</p>
<p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：S = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">输出：[9,7,8]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>S</code>的长度在<code>[1, 500]</code>之间。</li>
<li><code>S</code>只包含小写字母 <code>'a'</code> 到 <code>'z'</code> 。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>可恶，我以为是用动态规划啥的，结果最后发现是贪心法</p>
<p>本题的贪心思想</p>
<ul>
<li>
<p>从字符串头部开始，以<code>start = end = 0</code>开始尝试划分区间<code>[start, end]</code></p>
<ul>
<li>题目要求是划分的尽可能多</li>
<li>所以我们就把每个区间划分的尽量的小</li>
<li>当这个区间合法的时候就划分</li>
<li>然后令 <code>start = end + 1, end = end + 1</code></li>
<li>直到把这个字符串全部划分完</li>
</ul>
</li>
<li>
<p>怎么判断区间是否合理呢？</p>
<ol>
<li>
<p>首先需要使用哈希表或数组去记录每个字母出现的最后的位置</p>
</li>
<li>
<p>针对<code>S[start, end]</code></p>
<ul>
<li>我们知道当这个区间里的每个字母<code>i</code>的最右位置<code>right_i &lt;= end</code>的时候</li>
<li>这个区间就是合理的</li>
<li>又因为是采取了贪心策略，要保证这个区间最小</li>
<li>所以这个<code>end</code>必定是对应了这个区间中某个字母<code>k</code>的最右位置<code>right_k</code></li>
<li>且这个<code>right_k</code>一定是这个区间里的所有字母的最右位置<code>right_i</code>的最大值</li>
</ul>
</li>
<li>
<p>当<code>end == right_k</code>，就进行划分，并继续划分下一个区间</p>
</li>
<li>
<p>如果<code>end != right_k</code>，就令<code>right_k = max(right_k, right_S[end])</code></p>
</li>
</ol>
</li>
<li>
<p>大概理解思路就行，看代码就懂了</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partitionLabels</span>(<span class="params">self, S: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 找到每个字母出现的最后一个位置</span></span><br><span class="line">        dic = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S)):</span><br><span class="line">            dic[S[i]] = i</span><br><span class="line">        start, end = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> end&lt;<span class="built_in">len</span>(S):</span><br><span class="line">            max_end = dic[S[end]]  <span class="comment"># 用来记录当前这个区间里的字母需要扩的最右边界</span></span><br><span class="line">            <span class="keyword">while</span> end&lt;<span class="built_in">len</span>(S) <span class="keyword">and</span> end!=max_end:</span><br><span class="line">                <span class="comment"># 贪心法：这个区间正好合法的时候就进行划分</span></span><br><span class="line">                end += <span class="number">1</span></span><br><span class="line">                max_end = <span class="built_in">max</span>(max_end, dic[S[end]])</span><br><span class="line">            ans.append(end-start+<span class="number">1</span>)</span><br><span class="line">            start, end = end+<span class="number">1</span>, end+<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans </span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<h3 id="10-21">10.21</h3>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="925-长按键入"><a href="https://leetcode-cn.com/problems/long-pressed-name/">925. 长按键入</a></h4>
<p>难度简单</p>
<p>你的朋友正在使用键盘输入他的名字 <code>name</code>。偶尔，在键入字符 <code>c</code> 时，按键可能会被<em>长按</em>，而字符可能被输入 1 次或多次。</p>
<p>你将会检查键盘输入的字符 <code>typed</code>。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 <code>True</code>。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：name = &quot;alex&quot;, typed = &quot;aaleex&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：&#x27;alex&#x27; 中的 &#x27;a&#x27; 和 &#x27;e&#x27; 被长按。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：name = &quot;saeed&quot;, typed = &quot;ssaaedd&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：&#x27;e&#x27; 一定需要被键入两次，但在 typed 的输出中不是这样。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：name = &quot;leelee&quot;, typed = &quot;lleeelee&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：name = &quot;laiden&quot;, typed = &quot;laiden&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：长按名字中的字符并不是必要的。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>name.length &lt;= 1000</code></li>
<li><code>typed.length &lt;= 1000</code></li>
<li><code>name</code> 和 <code>typed</code> 的字符都是小写字母。</li>
</ol>
</blockquote>
<p><strong>思路</strong></p>
<p>还是比较简单的，是两年前就通过的一道老题</p>
<p>然而今天却调试了好久，刷题这么久总有种越刷越菜的感觉</p>
<ul>
<li>双指针<code>i = 0 , j = 0</code>遍历两个字符串，<code>i</code>遍历<code>name</code>，<code>j</code>遍历<code>typed</code>
<ul>
<li>如果碰到两个字母相等，两个指针都往后移一格
<ul>
<li><code>i+=1</code></li>
<li><code>j+=1</code></li>
</ul>
</li>
<li>字母不相等，检查一下是不是<code>typed[j]</code>是不是被长按出来的
<ul>
<li>发现是被长按的，就让<code>j</code>指针后移一格，继续循环</li>
</ul>
</li>
<li>如果不是被长按出来的，且字母不相等，说明无法对应，直接返回False</li>
</ul>
</li>
<li>循环到最后，如果<code>i</code>把name字符串遍历完了，说明是对应的，返回True
<ul>
<li>如果没遍历完，返回False</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isLongPressedName</span>(<span class="params">self, name: <span class="built_in">str</span>, typed: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j&lt;<span class="built_in">len</span>(typed):</span><br><span class="line">            <span class="keyword">if</span> i&lt;<span class="built_in">len</span>(name) <span class="keyword">and</span> name[i]==typed[j]:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> j&gt;<span class="number">0</span> <span class="keyword">and</span> typed[j]==typed[j-<span class="number">1</span>]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> i == <span class="built_in">len</span>(name)</span><br></pre></td></tr></table></figure>
<h3 id="10-20">10.20</h3>
<p>麻烦快进到周末</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="143-重排链表"><a href="https://leetcode-cn.com/problems/reorder-list/">143. 重排链表</a></h4>
<p>难度中等</p>
<p>给定一个单链表 <em>L</em>：<em>L</em>0→<em>L</em>1→…→<em>Ln</em>-1→<em>L</em>n ，<br>
将其重新排列后变为： <em>L</em>0→<em>Ln</em>→<em>L</em>1→<em>Ln-1→</em>L<em>2→</em>Ln-2→…</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4, 重新排列为 1-&gt;4-&gt;2-&gt;3.</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定链表 1-&gt;2-&gt;3-&gt;4-&gt;5, 重新排列为 1-&gt;5-&gt;2-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>因为要求是结点交换而不能是改变内部的值，所以用线性表的都是耍流氓</p>
<p>比较规范的解法是这样的</p>
<ul>
<li>首先用快慢指针找到中间结点
<ul>
<li>例如<code>1-&gt;2-&gt;3-&gt;4</code>的中间结点就是3</li>
</ul>
</li>
<li>把从中间结点开始的后半段链表进行翻转
<ul>
<li>翻转完之后就形成了<code>1-&gt;2-&gt;4-&gt;3</code></li>
</ul>
</li>
<li>把后半部分的结点逐个插入前半部分的结点后
<ul>
<li>4插到1后面<code>1-&gt;4-&gt;2-&gt;3</code></li>
<li>3插到2后面<code>1-&gt;4-&gt;2-&gt;3</code></li>
</ul>
</li>
<li>返回头节点</li>
</ul>
<p>具体的快慢指针找中点法和翻转链表方法就不再提了，之前已经刷过了</p>
<p>直接上代码</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reorderList</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify head in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 找到链表的中结点</span></span><br><span class="line">        <span class="keyword">while</span> fast.<span class="built_in">next</span> <span class="keyword">and</span> fast.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">        mid = slow.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span>= <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 把链表后半部分反转</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">node</span>):</span><br><span class="line">            prev = <span class="literal">None</span></span><br><span class="line">            cur = node</span><br><span class="line">            <span class="keyword">while</span> cur:</span><br><span class="line">                tmp = cur.<span class="built_in">next</span></span><br><span class="line">                cur.<span class="built_in">next</span> = prev</span><br><span class="line">                prev = cur</span><br><span class="line">                cur = tmp</span><br><span class="line">            <span class="keyword">return</span> prev</span><br><span class="line">        mid = reverse(mid)</span><br><span class="line">        <span class="comment"># 将后半部分的结点逐个插入前半部分结点后</span></span><br><span class="line">        node1 = head</span><br><span class="line">        node2 = mid</span><br><span class="line">        <span class="keyword">while</span> node2:</span><br><span class="line">            tmp1 = node1.<span class="built_in">next</span></span><br><span class="line">            tmp2 = node2.<span class="built_in">next</span></span><br><span class="line">            node1.<span class="built_in">next</span> = node2</span><br><span class="line">            node2.<span class="built_in">next</span> = tmp1</span><br><span class="line">            node1 = tmp1</span><br><span class="line">            node2 = tmp2</span><br></pre></td></tr></table></figure>
<h3 id="10-19">10.19</h3>
<p>又到周一了😭</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="844-比较含退格的字符串"><a href="https://leetcode-cn.com/problems/backspace-string-compare/">844. 比较含退格的字符串</a></h4>
<p>难度简单</p>
<p>给定 <code>S</code> 和 <code>T</code> 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 <code>#</code> 代表退格字符。</p>
<p>**注意：**如果对空文本输入退格字符，文本继续为空。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：S = &quot;ab#c&quot;, T = &quot;ad#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “ac”。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：S = &quot;ab##&quot;, T = &quot;c#d#&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “”。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：S = &quot;a##c&quot;, T = &quot;#a#c&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：S 和 T 都会变成 “c”。</span><br></pre></td></tr></table></figure>
<p><strong>示例 4：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：S = &quot;a#c&quot;, T = &quot;b&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：S 会变成 “c”，但 T 仍然是 “b”。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= S.length &lt;= 200</code></li>
<li><code>1 &lt;= T.length &lt;= 200</code></li>
<li><code>S</code> 和 <code>T</code> 只含有小写字母以及字符 <code>'#'</code>。</li>
</ol>
<p><strong>进阶：</strong></p>
<ul>
<li>你可以用 <code>O(N)</code> 的时间复杂度和 <code>O(1)</code> 的空间复杂度解决该问题吗？</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>为了实现进阶要求，很明显是用双指针
<ul>
<li>从字符串尾，同时遍历两个字符串</li>
<li>遇到退格
<ul>
<li>记录退格数+1</li>
</ul>
</li>
<li>遇到字母
<ul>
<li>有退格数就继续往前遍历</li>
<li>无退格数就结束循环，比较两个字符串当前字符是否相等</li>
</ul>
</li>
<li>一直遍历到字符串头</li>
</ul>
</li>
<li>结果我自己调试了半天还是WA</li>
</ul>
<img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20201019145219480.png" alt="image-20201019145219480" style="zoom:67%;" />
<ul>
<li>最后还是看了下题解，调整了一下代码</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backspaceCompare</span>(<span class="params">self, S: <span class="built_in">str</span>, T: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        index_S, index_T = <span class="built_in">len</span>(S)-<span class="number">1</span>, <span class="built_in">len</span>(T)-<span class="number">1</span></span><br><span class="line">        cnt_S, cnt_T = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index_T&gt;=<span class="number">0</span> <span class="keyword">or</span> index_S&gt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">while</span> index_S &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> S[index_S] == <span class="string">&quot;#&quot;</span>:</span><br><span class="line">                    cnt_S += <span class="number">1</span>  </span><br><span class="line">                    index_S -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> cnt_S&gt;<span class="number">0</span>:</span><br><span class="line">                    cnt_S -= <span class="number">1</span></span><br><span class="line">                    index_S -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">while</span> index_T &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> T[index_T] == <span class="string">&quot;#&quot;</span>:</span><br><span class="line">                    cnt_T += <span class="number">1</span>  </span><br><span class="line">                    index_T -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> cnt_T&gt;<span class="number">0</span>:</span><br><span class="line">                    cnt_T -= <span class="number">1</span></span><br><span class="line">                    index_T -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> index_S&gt;=<span class="number">0</span> <span class="keyword">and</span> index_T&gt;=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> S[index_S] != T[index_T]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> index_S&gt;=<span class="number">0</span> <span class="keyword">or</span> index_T&gt;=<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            index_S -= <span class="number">1</span></span><br><span class="line">            index_T -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> index_T&lt;=<span class="number">0</span> <span class="keyword">and</span> index_S&lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<h3 id="10-18">10.18</h3>
<p>今天是学校校庆，虽然是志愿者但是负责接待的嘉宾跟我说我可以自己忙自己的</p>
<p>那就学习呗</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="19-删除链表的倒数第N个节点"><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第N个节点</a></h4>
<p>难度中等1039</p>
<p>给定一个链表，删除链表的倒数第 <em>n</em> 个节点，并且返回链表的头结点。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<p>给定的 <em>n</em> 保证是有效的。</p>
<p><strong>进阶：</strong></p>
<p>你能尝试使用一趟扫描实现吗？</p>
</blockquote>
<p><strong>题解</strong></p>
<p>正好一个月前刷过，那就直接提交了呗</p>
<ul>
<li>
<p>快慢指针法</p>
</li>
<li>
<p>详情图解</p>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201019221741.gif" alt="leet1"></p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeNthFromEnd</span>(<span class="params">self, head: ListNode, n: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        front = ListNode(<span class="number">0</span>)</span><br><span class="line">        front.<span class="built_in">next</span> = head</span><br><span class="line">        pre, back = front, front</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> pre:</span><br><span class="line">            pre = pre.<span class="built_in">next</span></span><br><span class="line">            back = back.<span class="built_in">next</span></span><br><span class="line">        back.<span class="built_in">next</span> = back.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> front.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<h3 id="10-17">10.17</h3>
<p>今天又是复习N皇后</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="52-N皇后-II"><a href="https://leetcode-cn.com/problems/n-queens-ii/">52. N皇后 II</a></h4>
<p>难度困难</p>
<p><em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/8-queens.png" alt="img"></p>
<p>上图为 8 皇后问题的一种解法。</p>
<p>给定一个整数 <em>n</em>，返回 <em>n</em> 皇后不同的解决方案的数量。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 4 皇后问题存在如下两个不同的解法。</span><br><span class="line">[</span><br><span class="line">[&quot;.Q..&quot;,  // 解法 1</span><br><span class="line">&quot;...Q&quot;,</span><br><span class="line">&quot;Q...&quot;,</span><br><span class="line">&quot;..Q.&quot;],</span><br><span class="line"></span><br><span class="line">[&quot;..Q.&quot;,  // 解法 2</span><br><span class="line">&quot;Q...&quot;,</span><br><span class="line">&quot;...Q&quot;,</span><br><span class="line">&quot;.Q..&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><strong>皇后</strong>，是<a href="https://baike.baidu.com/item/%E5%9B%BD%E9%99%85%E8%B1%A1%E6%A3%8B">国际象棋</a>中的棋子，意味着<a href="https://baike.baidu.com/item/%E5%9B%BD%E7%8E%8B">国王</a>的妻子。皇后只做一件事，那就是“<a href="https://baike.baidu.com/item/%E5%90%83%E5%AD%90">吃子</a>”。当她遇见可以吃的棋子时，就迅速冲上去吃掉棋子。当然，她横、竖、斜都可走一或 N-1 步，可进可退。（引用自 <a href="https://baike.baidu.com/item/%E7%9A%87%E5%90%8E/15860305?fr=aladdin">百度百科 - 皇后</a> ）</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>经典的回溯法例题，和之前做的N皇后区别在于这道题求的是N皇后的解法数量</p>
<p>某种方面感觉甚至比上次还要简单，因为不用存储棋盘了</p>
<ul>
<li>整体思想递归求解</li>
<li>每次往合法的位置放一个皇后</li>
<li>成功放完N个皇后说明有一种解法</li>
<li>回溯法核心思想
<ul>
<li>考虑完该种放置皇后的可能性之后</li>
<li>调用自身的函数直接考虑下一个</li>
<li>递归到底之后（无论是能放完还是放不完N个皇后）会退出递归</li>
<li>退出递归后要把该种方法放置的皇后位置清空</li>
</ul>
</li>
<li>其中要考虑的核心点，如何判断位置是否合法？</li>
<li>如果每次都存储棋盘，看一遍每行每列每个对角线，会浪费很多时间和空间</li>
<li>因此用3个集合来保证放置皇后的合理性
<ul>
<li>保证每行只有一个
<ul>
<li>用cnt作为参数，来确保我们放皇后是按照从第0行放到第N-1行</li>
</ul>
</li>
<li>保证每列只有一个
<ul>
<li>建cols集合，存储放过的皇后的列</li>
<li>每次放到col列之前，判断col是否为1</li>
<li>如果是1就说明不能放，如果是0说明该列可以放</li>
</ul>
</li>
<li>保证每根左对角线只有一个
<ul>
<li>建立left集合</li>
<li>用<code>row+col</code>来定位皇后的左对角线
<ul>
<li>例如第1行第2列的皇后合第2行第1列的皇后是在同一条左对角线上的</li>
<li>1+2 == 2+1</li>
</ul>
</li>
</ul>
</li>
<li>保证每根左对角线只有一个
<ul>
<li>建立right集合</li>
<li>用<code>row-col</code>来定位皇后的右对角线</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">totalNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">cols, left, right, cnt</span>):</span><br><span class="line">            <span class="keyword">if</span> cnt == n:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            row = cnt</span><br><span class="line">            ans = <span class="number">0</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> cols:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                r = row-i</span><br><span class="line">                <span class="keyword">if</span> r <span class="keyword">in</span> right:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                l = row+i</span><br><span class="line">                <span class="keyword">if</span> l <span class="keyword">in</span> left:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                cols.add(i)</span><br><span class="line">                left.add(l)</span><br><span class="line">                right.add(r)</span><br><span class="line">                ans += dfs(cols, left, right, cnt+<span class="number">1</span>)</span><br><span class="line">                cols.remove(i)</span><br><span class="line">                left.remove(l)</span><br><span class="line">                right.remove(r)</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        cols = <span class="built_in">set</span>()</span><br><span class="line">        left = <span class="built_in">set</span>()</span><br><span class="line">        right = <span class="built_in">set</span>()</span><br><span class="line">        ans = dfs(cols, left, right, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="10-16">10.16</h3>
<p>好困</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="977-有序数组的平方"><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></h4>
<p>难度简单</p>
<p>给定一个按非递减顺序排序的整数数组 <code>A</code>，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[-4,-1,0,3,10]</span><br><span class="line">输出：[0,1,9,16,100]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[-7,-3,2,3,11]</span><br><span class="line">输出：[4,9,9,49,121]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 10000</code></li>
<li><code>-10000 &lt;= A[i] &lt;= 10000</code></li>
<li><code>A</code> 已按非递减顺序排序。</li>
</ol>
</blockquote>
<p><strong>思路</strong></p>
<p>去年提交过的一道题，当时还是偷懒的LYC</p>
<p>python一行用库排序返回新数组，时间复杂度是O(NlogN)</p>
<p>今天用个稍微朴素一点的双指针吧，时间复杂度是O(N)（不过提交之后发现甚至还没排序快）</p>
<ul>
<li>先遍历一遍数组，找到绝对值最小的数</li>
<li>先把这个数的平方放到ans数组</li>
<li>然后从这个数字开始往两边找
<ul>
<li>一个left指针，初始值为最小数的索引值-1</li>
<li>一个right指针，初始值为最小数的索引值+1</li>
</ul>
</li>
<li>先往左找，直到找到的数比右边大
<ul>
<li>边向左找，边把已经找到的数的平方放到ans数组中</li>
</ul>
</li>
<li>再往右找，直到找到的数比左边大
<ul>
<li>同理，边遍历边存答案</li>
</ul>
</li>
<li>直到两边都走到底</li>
<li>这里要注意，如果左边走到底了，右边直接遍历完就行，左右同理</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortedSquares</span>(<span class="params">self, A: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        min_index = <span class="number">0</span></span><br><span class="line">        min_abs = <span class="built_in">abs</span>(A[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(A)):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(A[i])&lt;min_abs:</span><br><span class="line">                min_abs = <span class="built_in">abs</span>(A[i])</span><br><span class="line">                min_index = i</span><br><span class="line">        left = min_index - <span class="number">1</span></span><br><span class="line">        right = min_index + <span class="number">1</span></span><br><span class="line">        ans = [min_abs**<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">while</span> left&gt;=<span class="number">0</span> <span class="keyword">or</span> right&lt;<span class="built_in">len</span>(A):</span><br><span class="line">            <span class="keyword">while</span> left&gt;=<span class="number">0</span> <span class="keyword">and</span> (right&gt;=<span class="built_in">len</span>(A) <span class="keyword">or</span> -A[left]&lt;=A[right]):</span><br><span class="line">                ans.append(A[left]**<span class="number">2</span>)</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> right&lt;<span class="built_in">len</span>(A) <span class="keyword">and</span> (left&lt;<span class="number">0</span> <span class="keyword">or</span> A[right]&lt;=-A[left]):</span><br><span class="line">                ans.append(A[right]**<span class="number">2</span>)</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="10-15">10.15</h3>
<p>今天又是一道老题，刷完睡午觉咯</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="116-填充每个节点的下一个右侧节点指针"><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></h4>
<p>难度中等</p>
<p>给定一个<strong>完美二叉树</strong>，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">int val;</span><br><span class="line">Node *left;</span><br><span class="line">Node *right;</span><br><span class="line">Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p>
<p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p>
<p><strong>示例：</strong></p>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/116_sample.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：&#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:6&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;val&quot;:3&#125;,&quot;val&quot;:1&#125;</span><br><span class="line"></span><br><span class="line">输出：&#123;&quot;$id&quot;:&quot;1&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;2&quot;,&quot;left&quot;:&#123;&quot;$id&quot;:&quot;3&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;4&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;5&quot;,&quot;left&quot;:null,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;6&quot;,&quot;left&quot;:null,&quot;next&quot;:null,&quot;right&quot;:null,&quot;val&quot;:7&#125;,&quot;right&quot;:null,&quot;val&quot;:6&#125;,&quot;right&quot;:null,&quot;val&quot;:5&#125;,&quot;right&quot;:null,&quot;val&quot;:4&#125;,&quot;next&quot;:&#123;&quot;$id&quot;:&quot;7&quot;,&quot;left&quot;:&#123;&quot;$ref&quot;:&quot;5&quot;&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;6&quot;&#125;,&quot;val&quot;:3&#125;,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;4&quot;&#125;,&quot;val&quot;:2&#125;,&quot;next&quot;:null,&quot;right&quot;:&#123;&quot;$ref&quot;:&quot;7&quot;&#125;,&quot;val&quot;:1&#125;</span><br><span class="line"></span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>你只能使用常量级额外空间。</li>
<li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>题目甚至给了条件是完美二叉树，直接利用自顶向下，自左向右逐层遍历的思想
<ul>
<li>定义一个<code>begin</code>结点，记录每层的最左侧的结点，就是我们每层开始遍历的结点<code>node = begin</code>
<ul>
<li>因为是完美二叉树，所以左右子节点必定成对出现，所以直接给左子节点加上next指针</li>
<li><code>node.left.next = node.left.right</code></li>
<li>因为是自顶向下的，所以我们这边是知道是否有<code>node.next</code>的</li>
<li>如果有，那么<code>node.right.next = node.next.left</code></li>
<li>继续遍历该层剩下的结点，即<code>node = node.next</code></li>
</ul>
</li>
<li>遍历完该层之后，令<code>begin=begin.left</code>，继续处理一下层</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="string">&#x27;Node&#x27;</span>:</span><br><span class="line">        begin = root</span><br><span class="line">        <span class="keyword">while</span> begin <span class="keyword">and</span> begin.left:</span><br><span class="line">            node = begin</span><br><span class="line">            <span class="keyword">while</span> node:</span><br><span class="line">                node.left.<span class="built_in">next</span> = node.right</span><br><span class="line">                <span class="keyword">if</span> node.<span class="built_in">next</span>:</span><br><span class="line">                    node.right.<span class="built_in">next</span> = node.<span class="built_in">next</span>.left</span><br><span class="line">                node = node.<span class="built_in">next</span></span><br><span class="line">            begin = begin.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h3 id="10-14">10.14</h3>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1002-查找常用字符"><a href="https://leetcode-cn.com/problems/find-common-characters/">1002. 查找常用字符</a></h4>
<p>难度简单141</p>
<p>给定仅有小写字母组成的字符串数组 <code>A</code>，返回列表中的每个字符串中都显示的全部字符（<strong>包括重复字符</strong>）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。</p>
<p>你可以按任意顺序返回答案。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[&quot;bella&quot;,&quot;label&quot;,&quot;roller&quot;]</span><br><span class="line">输出：[&quot;e&quot;,&quot;l&quot;,&quot;l&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[&quot;cool&quot;,&quot;lock&quot;,&quot;cook&quot;]</span><br><span class="line">输出：[&quot;c&quot;,&quot;o&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ol>
<li><code>1 &lt;= A.length &lt;= 100</code></li>
<li><code>1 &lt;= A[i].length &lt;= 100</code></li>
<li><code>A[i][j]</code> 是小写字母</li>
</ol>
</blockquote>
<p><strong>思路</strong></p>
<p>今天第一遍写的代码竟然还没有我2年前写的效率高</p>
<p>🙃怎么大三比大一还菜了呢</p>
<ul>
<li>主要思想
<ul>
<li>遍历第一个字符串中的不同字母</li>
<li>针对每个字母，找出该字母在所有字符串中出现的最小次数（可能为0）</li>
<li>在答案数组中置入最小次数个该字母</li>
</ul>
</li>
<li>技巧
<ul>
<li>利用set()去重</li>
<li>利用count()计算出现次数</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">commonChars</span>(<span class="params">self, A: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">set</span>(A[<span class="number">0</span>]):</span><br><span class="line">            cnts = A[<span class="number">0</span>].count(i)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(A)):</span><br><span class="line">                cnts = <span class="built_in">min</span>(A[j].count(i), cnts)</span><br><span class="line">            ans+=[i]*cnts</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="10-13">10.13</h3>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="24-两两交换链表中的节点"><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h4>
<p>难度中等</p>
<p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>这不是巧了吗，今天的每日一题是国庆刚自己刷过的一道题</p>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20201013124401755.png" alt="image-20201013124401755"></p>
<p>发现自己的方法把迭代和递归混在一起写了，今天就优化一下</p>
<ul>
<li>设置一个<code>dummy哑结点</code>，放在一开始的头节点前面
<ul>
<li>方便之后返回答案链表的头节点</li>
</ul>
</li>
<li>之后从<code>dummy</code>开始遍历
<ul>
<li>当前遍历的结点假设是0结点</li>
<li>把0-&gt;1-&gt;2换成0-&gt;2-&gt;1</li>
<li>把1作为下一个0，重复上述操作</li>
<li>当0结点之后没有结点，说明交换完毕</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">swapPairs</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        node = dummy</span><br><span class="line">        <span class="keyword">while</span> node.<span class="built_in">next</span> <span class="keyword">and</span> node.<span class="built_in">next</span>.<span class="built_in">next</span>:</span><br><span class="line">            first = node.<span class="built_in">next</span></span><br><span class="line">            second = node.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            node.<span class="built_in">next</span> = second</span><br><span class="line">            first.<span class="built_in">next</span> = second.<span class="built_in">next</span></span><br><span class="line">            second.<span class="built_in">next</span> = first</span><br><span class="line">            node = first</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<h3 id="10-12">10.12</h3>
<p>今天周一啦</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="530-二叉搜索树的最小绝对差"><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/">530. 二叉搜索树的最小绝对差</a></h4>
<p>难度简单</p>
<p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  3</span><br><span class="line"> /</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">最小绝对差为 1，其中 2 和 1 的差的绝对值为 1（或者 2 和 3）。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>树中至少有 2 个节点。</li>
<li>本题与 783 <a href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/">https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/</a> 相同</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>可恶，我竟然简单题都不会做了</p>
<p>对二叉树的中序遍历还是不太熟悉</p>
<p>因为是二叉搜索树，所以可以看作是有序数组</p>
<p>就是在一个有序数组上求两个数的最小插值</p>
<ul>
<li>把二叉树转换成数组，然后对排序好的数组求两个数值最小值</li>
<li>直接对二叉树进行递归和迭代求解
<ul>
<li>用一个pre结点记录当前结点的前一个结点</li>
<li>因为是中序遍历，所以pre结点必定是在当前结点的左边，也就是说<code>root.val&gt;pre.val</code></li>
<li>所以遍历所有结点，同时更新最小差值即可</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getMinimumDifference</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">        pre = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> ans,pre</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            dfs(root.left)</span><br><span class="line">            <span class="keyword">if</span> pre!=-<span class="number">1</span>:</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, root.val-pre)</span><br><span class="line">                pre = root.val</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = root.val</span><br><span class="line">            dfs(root.right)</span><br><span class="line">        dfs(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="10-11">10.11</h3>
<p>今天又是周日呀</p>
<p>上午实验室招新，去面试了半天，现在的学弟都这么强的吗</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="416-分割等和子集"><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h4>
<p>难度中等</p>
<p>给定一个<strong>只包含正整数</strong>的<strong>非空</strong>数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p>
<p><strong>注意:</strong></p>
<ol>
<li>每个数组中的元素不会超过 100</li>
<li>数组的大小不会超过 200</li>
</ol>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1, 5, 11, 5]</span><br><span class="line"></span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">解释: 数组可以分割成 [1, 5, 5] 和 [11].</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1, 2, 3, 5]</span><br><span class="line"></span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">解释: 数组不能分割成两个元素和相等的子集.</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>动态规划呗，我不会呗，看题解呗</li>
<li>一开始先判断和是否为偶数
<ul>
<li>是奇数直接返回False</li>
<li>是偶数就继续检查</li>
</ul>
</li>
<li>定义动态规划的dp数组
<ul>
<li><code>dp[i][j]</code>说明<code>nums[0:i]</code>中的数字中取一些加起来能否是<code>j</code></li>
<li>这里的<code>i</code>最大为nums的元素数</li>
<li>这里的<code>j</code>最大为nums的和的一半</li>
<li>最后判断<code>dp数组</code>的最后一行最后一格是否为Ture</li>
<li>注意一开始要初始化<code>dp[0][nums[0]]</code>和<code>dp[0][0]</code>为True</li>
</ul>
</li>
<li>时间优化
<ul>
<li>当判断到某一行的最后</li>
<li>若<code>dp[i][j]==True and j==sum/2</code>，可以直接返回True，因为此时已经能做到和为一半了</li>
</ul>
</li>
<li>空间优化
<ul>
<li>因为每一行的数据只和上一行数据有关，所以可以优化为一行</li>
<li>把<code>dp[i][j]</code>优化为<code>dp[j]</code></li>
<li>这里要保证是从后到前循环的，即<code>j</code>从<code>sum/2</code>循环到<code>0</code></li>
<li>原因是保证判断的时候，用的都是“上一行”的数据，而不是这一行新产生的数据</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canPartition</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        rows = <span class="built_in">len</span>(nums)</span><br><span class="line">        cols = <span class="built_in">sum</span>(nums)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cols == <span class="built_in">int</span>(cols):</span><br><span class="line">            <span class="comment"># sum为奇数说明不可能分割两个等和子集</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cols = <span class="built_in">int</span>(cols)+<span class="number">1</span></span><br><span class="line">        dp = [<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(cols)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> nums[<span class="number">0</span>]&lt;=cols:</span><br><span class="line">            dp[nums[<span class="number">0</span>]] = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> nums[i] == j:</span><br><span class="line">                    dp[j] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i]&lt;j:</span><br><span class="line">                    dp[j] = dp[j] <span class="keyword">or</span> dp[j-nums[i]]</span><br><span class="line">                <span class="keyword">if</span> j==cols-<span class="number">1</span> <span class="keyword">and</span> dp[j]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="10-10">10.10</h3>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="142-环形链表-II"><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h4>
<p>难度中等</p>
<p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p>
<p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。</p>
<p>**说明：**不允许修改给定的链表。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：tail connects to node index 1</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/circularlinkedlist.png" alt="img"></p>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：tail connects to node index 0</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/circularlinkedlist_test2.png" alt="img"></p>
<p><strong>示例 3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：no cycle</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/circularlinkedlist_test3.png" alt="img"></p>
<p><strong>进阶：</strong><br>
你是否可以不用额外空间解决此题？</p>
</blockquote>
<p><strong>思路</strong></p>
<p>一开始以为和昨天的一摸一样，后来发现还没那么简单</p>
<p>昨天的题目只要判断是否存在环形链表，今天的要返回环的头节点</p>
<p>最终还是看了大佬的题解，发现原来是数学解法</p>
<p>还是老样子，为了实现常数空间用快慢指针</p>
<ul>
<li>一开始快慢指针都从head出发</li>
<li>快指针一次走两步，慢指针一次走一步</li>
<li>这里定义
<ul>
<li>a=从头节点到入环第一个节点前的所有结点数</li>
<li>b=环中的结点数</li>
</ul>
</li>
<li>当快慢节点第一次相遇的时候
<ul>
<li>fast = 2*slow</li>
<li>slow = a+nb</li>
<li>fast = 2nb, slow = nb</li>
</ul>
</li>
<li>这时令fast回到head结点，slow不动（即slow领先fast了nb步）
<ul>
<li>两个指针都是一次走一步</li>
<li>当fast走了a步，slow就一共走了a+nb步</li>
<li>这时两者相遇因为slow正好比fast快了n圈</li>
<li>此时两者的位置也正好是入环的头节点</li>
</ul>
</li>
</ul>
<blockquote>
<p>这个方法太妙了</p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">detectCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        fast = head</span><br><span class="line">        slow = head</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> fast.<span class="built_in">next</span>:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> slow == fast:<span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 第一次相遇的时候 fast比slow多走了n圈环形链表 slow在nb的位置</span></span><br><span class="line">        fast = head</span><br><span class="line">        <span class="keyword">while</span> slow!=fast:</span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 第二次fast走到a时，slow走到了a+nb的位置，此时两者重合</span></span><br><span class="line">        <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>
<h3 id="10-9">10.9</h3>
<p>突然开学了，上课睡到流口水</p>
<p>不过今天又是简单题🤭</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="141-环形链表"><a href="https://leetcode-cn.com/problems/linked-list-cycle/">141. 环形链表</a></h4>
<p>难度简单</p>
<p>给定一个链表，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p>
<p><strong>进阶：</strong></p>
<p>你能用 <em>O(1)</em>（即，常量）内存解决此问题吗？</p>
<p><strong>示例 1：</strong></p>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/circularlinkedlist.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/circularlinkedlist_test2.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure>
<p><strong>示例 3：</strong></p>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/circularlinkedlist_test3.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：false</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>链表中节点的数目范围是 <code>[0, 104]</code></li>
<li><code>-105 &lt;= Node.val &lt;= 105</code></li>
<li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<ol>
<li>用一个哈希表存储已经访问过的结点
<ul>
<li>每遍历一个结点，就存入哈希表中</li>
<li>存的时候如果发现哈希表中存在该结点，说明遍历过，返回True</li>
<li>存到最后空指针时没有重复遍历的结点，说明没有环，返回False</li>
</ul>
</li>
<li>快慢指针遍历链表
<ul>
<li>慢指针起点为head，快指针起点为head.next</li>
<li>慢指针一次一步，快指针一次两步，相当于追及问题</li>
<li>如果快指针追上了慢指针，说明有环</li>
<li>如果快指针先走到了空指针，说明没有环</li>
</ul>
</li>
</ol>
<p><strong>代码</strong></p>
<p>就放一个快慢指针的方法吧</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hasCycle</span>(<span class="params">self, head: ListNode</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        slow, fast = head, head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> slow!=fast:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> fast.<span class="built_in">next</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            slow = slow.<span class="built_in">next</span></span><br><span class="line">            fast = fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<page>
<h3 id="10-8">10.8</h3>
<p>舒服了呀，今天是简单题</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="344-反转字符串"><a href="https://leetcode-cn.com/problems/reverse-string/">344. 反转字符串</a></h4>
<p>难度简单</p>
<p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 <code>char[]</code> 的形式给出。</p>
<p>不要给另外的数组分配额外的空间，你必须**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>修改输入数组**、使用 O(1) 的额外空间解决这一问题。</p>
<p>你可以假设数组中的所有字符都是 <a href="https://baike.baidu.com/item/ASCII">ASCII</a> 码表中的可打印字符。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">输出：[&quot;o&quot;,&quot;l&quot;,&quot;l&quot;,&quot;e&quot;,&quot;h&quot;]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[&quot;H&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;h&quot;]</span><br><span class="line">输出：[&quot;h&quot;,&quot;a&quot;,&quot;n&quot;,&quot;n&quot;,&quot;a&quot;,&quot;H&quot;]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>设置双指针前后同时开始遍历字符串</li>
<li>边遍历边交换值</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reverseString</span>(<span class="params">self, s: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify s in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        p0,p1=<span class="number">0</span>,<span class="built_in">len</span>(s)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p0&lt;p1:</span><br><span class="line">            s[p0],s[p1]=s[p1],s[p0]</span><br><span class="line">            p0+=<span class="number">1</span></span><br><span class="line">            p1-=<span class="number">1</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<h3 id="10-7">10.7</h3>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="75-颜色分类"><a href="https://leetcode-cn.com/problems/sort-colors/">75. 颜色分类</a></h4>
<p>难度中等</p>
<p>给定一个包含红色、白色和蓝色，一共 <em>n</em> 个元素的数组，**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>**对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p><strong>注意:</strong><br>
不能使用代码库中的排序函数来解决这道题。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [2,0,2,1,1,0]</span><br><span class="line">输出: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure>
<p><strong>进阶：</strong></p>
<ul>
<li>一个直观的解决方案是使用计数排序的两趟扫描算法。<br>
首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li>
<li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<ul>
<li>利用双指针，把0移到前面，把1移到0的后面</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortColors</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># p0为存储0的指针，p1是存储1的指针</span></span><br><span class="line">        p0, p1 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i]==<span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 碰到1就存放到p1指针处</span></span><br><span class="line">                nums[p1],nums[i]=nums[i],nums[p1]</span><br><span class="line">                <span class="comment"># 同时p1指针后移一格</span></span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i]==<span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 碰到0的话有可能会把前面的1移到后面去</span></span><br><span class="line">                nums[p0],nums[i]=nums[i],nums[p0]</span><br><span class="line">                <span class="keyword">if</span> p0&lt;p1:</span><br><span class="line">                    <span class="comment"># p0&lt;p1说明把一个刚刚移到前面的1移到了i处</span></span><br><span class="line">                    nums[i],nums[p1]=nums[p1],nums[i]</span><br><span class="line">                p1+=<span class="number">1</span></span><br><span class="line">                p0+=<span class="number">1</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<h3 id="10-6">10.6</h3>
<p>今天放假在家，没刷题</p>
<p>其实是我10.7回学校补的</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="834-树中距离之和"><a href="https://leetcode-cn.com/problems/sum-of-distances-in-tree/">834. 树中距离之和</a></h4>
<p>难度困难</p>
<p>给定一个无向、连通的树。树中有 <code>N</code> 个标记为 <code>0...N-1</code> 的节点以及 <code>N-1</code> 条边 。</p>
<p>第 <code>i</code> 条边连接节点 <code>edges[i][0]</code> 和 <code>edges[i][1]</code> 。</p>
<p>返回一个表示节点 <code>i</code> 与其他所有节点距离之和的列表 <code>ans</code>。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]</span><br><span class="line">输出: [8,12,6,10,10,10]</span><br><span class="line">解释: </span><br><span class="line">如下为给定的树的示意图：</span><br><span class="line">0</span><br><span class="line">/ \</span><br><span class="line">1   2</span><br><span class="line">/|\</span><br><span class="line">3 4 5</span><br><span class="line"></span><br><span class="line">我们可以计算出 dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5) </span><br><span class="line">也就是 1 + 1 + 2 + 2 + 2 = 8。 因此，answer[0] = 8，以此类推。</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong> <code>1 &lt;= N &lt;= 10000</code></p>
</blockquote>
<p><strong>代码</strong></p>
<p>参考的别人的题解，我就不写解题思路丢人了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumOfDistancesInTree</span>(<span class="params">self, N: <span class="built_in">int</span>, edges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 先构建邻接表</span></span><br><span class="line">        distance_graph = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">            distance_graph[edge[<span class="number">0</span>]].append(edge[<span class="number">1</span>])</span><br><span class="line">            distance_graph[edge[<span class="number">1</span>]].append(edge[<span class="number">0</span>])</span><br><span class="line">        node_sum = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line">        distance_sum = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">post_order</span>(<span class="params">root, parent</span>):</span><br><span class="line">            <span class="comment"># 先用后序遍历从下至上，确定每个结点的子树的结点数</span></span><br><span class="line">            <span class="comment"># 以及结点到子树所有结点的距离和</span></span><br><span class="line">            neighbours = distance_graph[root]</span><br><span class="line">            <span class="keyword">for</span> neighbour <span class="keyword">in</span> neighbours:</span><br><span class="line">                <span class="keyword">if</span> neighbour==parent:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                post_order(neighbour, root)</span><br><span class="line">                node_sum[root] += node_sum[neighbour]</span><br><span class="line">                distance_sum[root] += node_sum[neighbour]+distance_sum[neighbour]</span><br><span class="line">        <span class="comment"># 此时求出了所有结点的子树距离和以及子树结点数</span></span><br><span class="line">        <span class="comment"># 根据图可以找出规律 某一个结点到所有结点的距离和 = 根结点到所有结点距离和-该结点子树的结点数+（树的结点总数-该结点子树的结点数）  </span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">pre_order</span>(<span class="params">node, parent</span>):</span><br><span class="line">            <span class="comment"># 从上至下，确定结点到所有其余结点的距离和</span></span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> distance_graph[node]:</span><br><span class="line">                <span class="keyword">if</span> n == parent:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                distance_sum[n] = distance_sum[node]-node_sum[n]+N-node_sum[n]</span><br><span class="line">                pre_order(n, node)</span><br><span class="line">        post_order(<span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line">        pre_order(<span class="number">0</span>, -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> distance_sum</span><br></pre></td></tr></table></figure>
<page>
<h3 id="10-5">10.5</h3>
<p>我可没有偷懒噢 我只是不想写题解了</p>
<p>21岁了 😭</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="18-四数之和"><a href="https://leetcode-cn.com/problems/4sum/">18. 四数之和</a></h4>
<p>难度中等</p>
<p>给定一个包含 <em>n</em> 个整数的数组 <code>nums</code> 和一个目标值 <code>target</code>，判断 <code>nums</code> 中是否存在四个元素 *a，*<em>b，c</em> 和 <em>d</em> ，使得 <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> 的值与 <code>target</code> 相等？找出所有满足条件且不重复的四元组。</p>
<p><strong>注意：</strong></p>
<p>答案中不可以包含重复的四元组。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。</span><br><span class="line"></span><br><span class="line">满足要求的四元组集合为：</span><br><span class="line">[</span><br><span class="line">[-1,  0, 0, 1],</span><br><span class="line">[-2, -1, 1, 2],</span><br><span class="line">[-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码</strong></p>
<p>参考了官方题解，前两个数，后两个数用双指针的解法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ans = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(nums)-<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i-<span class="number">1</span>]:<span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,<span class="built_in">len</span>(nums)-<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> j&gt;i+<span class="number">1</span> <span class="keyword">and</span> nums[j]==nums[j-<span class="number">1</span>]:<span class="keyword">continue</span></span><br><span class="line">                cur_target = target - (nums[i]+nums[j])</span><br><span class="line">                start = j+<span class="number">1</span></span><br><span class="line">                end = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> start&lt;end:</span><br><span class="line">                    <span class="keyword">if</span> nums[start]+nums[end] == cur_target:</span><br><span class="line">                        ans.append([nums[i],nums[j],nums[start],nums[end]])</span><br><span class="line">                        <span class="keyword">while</span> start &lt; end <span class="keyword">and</span> nums[start]==nums[start+<span class="number">1</span>]:</span><br><span class="line">                            start+=<span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> start&lt;end <span class="keyword">and</span> nums[end]==nums[end-<span class="number">1</span>]:</span><br><span class="line">                            end-=<span class="number">1</span></span><br><span class="line">                        start+=<span class="number">1</span></span><br><span class="line">                        end-=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> nums[start]+nums[end] &lt; cur_target:</span><br><span class="line">                        start += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        end -=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="10-4">10.4</h3>
<p>好家伙，今天又是经典老题</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="2-两数相加"><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a></h4>
<p>难度中等</p>
<p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p>
<p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p>
<p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>对整个过程进行模拟</p>
<p>其实这道只考数据结构和代码的细节，其他没啥</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">addTwoNumbers</span>(<span class="params">self, l1: ListNode, l2: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        head = ListNode(<span class="number">0</span>)</span><br><span class="line">        node = head <span class="comment"># 实际结果从head.next开始存储</span></span><br><span class="line">        flag = <span class="number">0</span>  <span class="comment"># 进位标记</span></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">                <span class="comment"># 当l1和l2列表都没走完的时候 就正常进行加法</span></span><br><span class="line">                cur_sum = l1.val+l2.val+flag</span><br><span class="line">                <span class="comment"># 注意用完进位标记之后要重新判断是否需要进位</span></span><br><span class="line">                flag = <span class="number">1</span> <span class="keyword">if</span> cur_sum&gt;=<span class="number">10</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                cur_sum %= <span class="number">10</span></span><br><span class="line">                node.<span class="built_in">next</span> = ListNode(cur_sum)</span><br><span class="line">                node = node.<span class="built_in">next</span></span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">                l2 = l2.<span class="built_in">next</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> l1:</span><br><span class="line">                <span class="comment"># 如果l1走完了，就让l1代替l2走接下来的路</span></span><br><span class="line">                l1, l2 = l2, l1</span><br><span class="line">            <span class="keyword">while</span> l1:</span><br><span class="line">                <span class="comment"># 此时l2已经走完了，所以只需要对于l1剩下结点进行加法</span></span><br><span class="line">                cur_sum = l1.val+flag</span><br><span class="line">                flag = <span class="number">1</span> <span class="keyword">if</span> cur_sum&gt;=<span class="number">10</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                cur_sum %= <span class="number">10</span></span><br><span class="line">                node.<span class="built_in">next</span> = ListNode(cur_sum)</span><br><span class="line">                node = node.<span class="built_in">next</span></span><br><span class="line">                l1 = l1.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="comment"># 最后判断一下最高位是否有进位1</span></span><br><span class="line">            node.<span class="built_in">next</span> = ListNode(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> head.<span class="built_in">next</span></span><br></pre></td></tr></table></figure>
<h3 id="10-3">10.3</h3>
<p>一到国庆甚至leetcode都怠惰了，全是多年前刷过的简单题</p>
<p>直接看题把</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="1-两数之和"><a href="https://leetcode-cn.com/problems/two-sum/">1. 两数之和</a></h4>
<p>难度简单9268</p>
<p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>好家伙，原来我2年前就满足于O(N²)</p>
<p>1年前用JAVA刷了一遍估计是为了当时的期末考试吧</p>
<img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20201003090402562.png" alt="image-20201003090402562" style="zoom:50%;" />
<p>那么这道题到底该怎么做呢？</p>
<ul>
<li>用哈希表以键值对的形式，存储 值-&gt;下标</li>
<li>遍历nums</li>
<li>更新哈希表前，先看看哈希表中有没有满足的值和当前遍历的数加起来为target
<ul>
<li>如果有就直接返回两个的下标</li>
<li>如果没有就更新哈希表</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        dic = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            diff = target - nums[i]</span><br><span class="line">            <span class="keyword">if</span> diff <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> [dic[diff], i]</span><br><span class="line">            dic[nums[i]] = i        </span><br></pre></td></tr></table></figure>
<h3 id="10-2">10.2</h3>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20201002193815926.png" alt="image-20201002193815926"></p>
<p>又经历了一次高考查分</p>
<p>虽然不一定出国了，但是本来是想考满105的</p>
<p>虽然本来是想考满105，但是考试的时候阅读和听力出分26和28，我其实不报啥希望了，甚至还想着能考到100+就不错了</p>
<p>所以104对于我来说已经算比较满意了</p>
<p>好了，来刷题吧</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="771-宝石与石头"><a href="https://leetcode-cn.com/problems/jewels-and-stones/">771. 宝石与石头</a></h4>
<p>难度简单</p>
<p>给定字符串<code>J</code> 代表石头中宝石的类型，和字符串 <code>S</code>代表你拥有的石头。 <code>S</code> 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。</p>
<p><code>J</code> 中的字母不重复，<code>J</code> 和 <code>S</code>中的所有字符都是字母。字母区分大小写，因此<code>&quot;a&quot;</code>和<code>&quot;A&quot;</code>是不同类型的石头。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: J = &quot;aA&quot;, S = &quot;aAAbbbb&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: J = &quot;z&quot;, S = &quot;ZZ&quot;</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ul>
<li><code>S</code> 和 <code>J</code> 最多含有50个字母。</li>
<li><code>J</code> 中的字符不重复。</li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20201002194244919.png" alt="image-20201002194244919"></p>
<p>一晃已经过了两年了</p>
<p>一开始看见题目限制了S和J最多50个字母，便直接用暴力法，循环两遍，发现速度好慢哦</p>
<p>于是用了哈希表（我用的是字典，不过跟用集合是一个道理）</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numJewelsInStones</span>(<span class="params">self, J: <span class="built_in">str</span>, S: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        dic = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> J:</span><br><span class="line">            dic[i]=<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> dic:</span><br><span class="line">                ans+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="10-1">10.1</h3>
<p>中秋国庆快乐兄弟萌</p>
<p>leetcode的每日一题终于来到了动态规划（俺最不会的）</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="LCP-19-秋叶收藏集"><a href="https://leetcode-cn.com/problems/UlBDOe/">LCP 19. 秋叶收藏集</a></h4>
<p>难度中等</p>
<p>小扣出去秋游，途中收集了一些红叶和黄叶，他利用这些叶子初步整理了一份秋叶收藏集 <code>leaves</code>， 字符串 <code>leaves</code> 仅包含小写字符 <code>r</code> 和 <code>y</code>， 其中字符 <code>r</code> 表示一片红叶，字符 <code>y</code> 表示一片黄叶。<br>
出于美观整齐的考虑，小扣想要将收藏集中树叶的排列调整成「红、黄、红」三部分。每部分树叶数量可以不相等，但均需大于等于 1。每次调整操作，小扣可以将一片红叶替换成黄叶或者将一片黄叶替换成红叶。请问小扣最少需要多少次调整操作才能将秋叶收藏集调整完毕。</p>
<p><strong>示例 1：</strong></p>
<blockquote>
<p>输入：<code>leaves = &quot;rrryyyrryyyrr&quot;</code></p>
<p>输出：<code>2</code></p>
<p>解释：调整两次，将中间的两片红叶替换成黄叶，得到 “rrryyyyyyyyrr”</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p>输入：<code>leaves = &quot;ryr&quot;</code></p>
<p>输出：<code>0</code></p>
<p>解释：已符合要求，不需要额外操作</p>
</blockquote>
<p><strong>提示：</strong></p>
<ul>
<li><code>3 &lt;= leaves.length &lt;= 10^5</code></li>
<li><code>leaves</code> 中只包含字符 <code>'r'</code> 和字符 <code>'y'</code></li>
</ul>
<p>通过次数3,414</p>
<p>提交次数11,095</p>
</blockquote>
<p><strong>思路</strong></p>
<p>orz，我看了一分钟题目就去看了题解</p>
<p>简单总结题目</p>
<ul>
<li>调换叶子，把叶子的序列换成 红黄红</li>
</ul>
<p>动态规划</p>
<ul>
<li>
<p>将叶子分成三段，前段红，中段黄，后段红</p>
</li>
<li>
<p>建立数组存放叶子的状态和操作次数</p>
<ul>
<li><code>dp[i][0]</code>表示替换完所有leaves[0…i]中叶子后，第i片叶子为前段红色的操作次数</li>
<li><code>dp[i][1]</code>表示替换完所有leaves[0…i]中叶子后，第i片叶子为黄色的操作次数</li>
<li><code>dp[i][2]</code>表示替换完所有leaves[0…i]中叶子后，第i片叶子为后段红色的操作次数</li>
</ul>
</li>
<li>
<p>再来看状态转移方程</p>
<ul>
<li>我们定义status表示叶子的颜色，status=1表示黄色，status=0表示红色</li>
<li><code>dp[i][0]</code>，说明第i片叶子属于前段红色，那么它前面也肯定全是红色
<ul>
<li><code>dp[i][0] = dp[i][0]+status</code></li>
</ul>
</li>
<li><code>dp[i][1]</code>，此时这片叶子属于中段黄色，那么它前面可能是中段黄色也可能是前段红色，但是我们要考虑的只有总操作次数的最小值。
<ul>
<li><code>dp[i][1] = min(dp[i-1][0], dp[i-1][1])+(1-status)</code></li>
</ul>
</li>
<li><code>dp[i][2]</code>，这片叶子属于后段黄色，那么它前面只可能是中段黄色或者后段红色。不可能是前段红色的原因是题目强调了每段的叶子必须至少有一片。
<ul>
<li><code>dp[i][2] = min(dp[i-1][1], dp[i-1][2])+status</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>最后的答案就是最后一片叶子属于后段红色的操作次数，即<code>dp[len(leaves)-1][2]</code></p>
</li>
<li>
<p>要注意的是一开始要单独更新第一片叶子状态</p>
</li>
<li>
<p>以及对于所有<code>j&gt;i的dp[i][j]</code>而言，意味着叶子的颜色状态数大于该叶子前面的叶子数，所以要排除这种可能性，全部置为正无穷。</p>
<ul>
<li>例如<code>dp[1][2]</code>是不存在这种可能性的，因为第二片叶子最多只能是中段黄色，而不能是后段红色。</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumOperations</span>(<span class="params">self, leaves: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        length = <span class="built_in">len</span>(leaves)</span><br><span class="line">        dp = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length)]</span><br><span class="line">        <span class="comment"># 其中dp[i][0]表示替换完所有leaves[0...i]中叶子后，第i片叶子为前段红色的操作次数</span></span><br><span class="line">        <span class="comment"># 其中dp[i][1]表示替换完所有leaves[0...i]中叶子后，第i片叶子为黄色的操作次数</span></span><br><span class="line">        <span class="comment"># 其中dp[i][2]表示替换完所有leaves[0...i]中叶子后，第i片叶子为后段红色的操作次数</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = dp[<span class="number">0</span>][<span class="number">2</span>] = dp[<span class="number">1</span>][<span class="number">2</span>] = <span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="built_in">int</span>(leaves[<span class="number">0</span>] == <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, length):</span><br><span class="line">            <span class="keyword">if</span> leaves[i] == <span class="string">&#x27;r&#x27;</span>:</span><br><span class="line">                status = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                status = <span class="number">1</span></span><br><span class="line">            <span class="comment"># 状态更新</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>]+status</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>])+(<span class="number">1</span>-status)</span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">2</span>])+status</span><br><span class="line">        <span class="keyword">return</span> dp[length-<span class="number">1</span>][<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>刷题日志</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>2020年9月刷题日志</title>
    <url>/post/2020-09-05-Algorithm/2020%E5%B9%B49%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/</url>
    <content><![CDATA[<h3 id="9-29">9.29</h3>
<p>遍历二叉树我还是太菜，今儿个只是非递归的后序遍历我看题解都看了半天</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="145-二叉树的后序遍历"><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a></h4>
<p>难度中等</p>
<p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]  </span><br><span class="line">1</span><br><span class="line">\</span><br><span class="line">2</span><br><span class="line">/</span><br><span class="line">3 </span><br><span class="line"></span><br><span class="line">输出: [3,2,1]</span><br></pre></td></tr></table></figure>
<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
</blockquote>
<p><strong>思路</strong></p>
<p>老样子，两种解法，一种python写，另一种java写</p>
<ul>
<li>
<p>普通递归</p>
</li>
<li>
<p>思想就是写一个递归函数，先遍历左子树，再遍历后子树，最后再把结点值放到答案里。</p>
</li>
<li>
<p>不用理解后序遍历的本质就能写出来的方法</p>
</li>
<li>
<p>非递归解法</p>
</li>
<li>
<p>利用栈去存储需要遍历的结点</p>
</li>
<li>
<p>基本思想就是，先一直向左下遍历，当遍历不下去的时候，再看看右下还有没有</p>
</li>
<li>
<p>每次记录结点值得时候保证遍历的这个结点右下角没了，或者右下角全部被记录过了</p>
</li>
<li>
<p>讲不太清。。。直接看代码吧</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">postOrder</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            postOrder(root.left)</span><br><span class="line">            postOrder(root.right)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        postOrder(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// stk用来暂存遍历的结点</span></span><br><span class="line">        Deque&lt;TreeNode&gt; stk= <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// ans用来存放后序遍历的结果</span></span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        stk.push(root);</span><br><span class="line">        <span class="comment">// prev用来记录上一个遍历完成的结点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stk.isEmpty()||root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 先把左子树遍历完</span></span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="literal">null</span>)&#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.pop();</span><br><span class="line">            <span class="keyword">if</span>(root.right == <span class="literal">null</span> || root.right == prev)&#123;</span><br><span class="line">                <span class="comment">// 当右子树为空或者右子树已经记录时 记录当前结点的值</span></span><br><span class="line">                ans.add(root.val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="literal">null</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 右子树非空且没被记录过，就继续遍历右子树</span></span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-28">9.28</h3>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="117-填充每个节点的下一个右侧节点指针-II"><a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">117. 填充每个节点的下一个右侧节点指针 II</a></h4>
<p>难度中等</p>
<p>给定一个二叉树</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">int val;</span><br><span class="line">Node *left;</span><br><span class="line">Node *right;</span><br><span class="line">Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 <code>NULL</code>。</p>
<p>初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p>
<p><strong>进阶：</strong></p>
<ul>
<li>你只能使用常量级额外空间。</li>
<li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li>
</ul>
<p><strong>示例：</strong></p>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20201016192008791.png" alt="image-20201016192008791"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,3,4,5,null,7]</span><br><span class="line">输出：[1,#,2,3,#,4,5,7,#]</span><br><span class="line">解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>树中的节点数小于 <code>6000</code></li>
<li><code>-100 &lt;= node.val &lt;= 100</code></li>
</ul>
</blockquote>
<p><strong>思路</strong></p>
<p>这次的二叉树要用bfs来解</p>
<p>I am so 菜 that I 看题解</p>
<p>老样子，有两种思路，一种用python实现，一种用java实现</p>
<p><strong>空间复杂度O(N)</strong></p>
<ul>
<li>利用队列进行层序遍历</li>
<li>每次在遍历某一层的时候，设计pre结点来存储上一个遍历的结点（也就是左边最近的结点）</li>
<li>将pre.next设置为当前结点</li>
<li>将pre设置为当前结点</li>
<li>继续向右遍历</li>
<li>向右遍历的同时要把自己的左右子节点放到队列里</li>
</ul>
<p><strong>空间复杂度O(1)</strong></p>
<ul>
<li>
<p>假设我们已经遍历完第二层，那么此时计算第三层结点的右侧指针时我们可以借助第二层</p>
</li>
<li>
<p>我们从第二层的最左边结点向右遍历</p>
</li>
<li>
<p>假设第二层最左边的结点为cur</p>
</li>
<li>
<p>去判断cur.left和cur.right</p>
</li>
<li>
<p>用上面的思路，利用pre结点来设置cur.left.next和cur.right.next</p>
</li>
<li>
<p>然后遍历cur.next，直到遍历完该层</p>
</li>
<li>
<p>再把cur设置为第三层最左边的结点继续</p>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val: int = 0, left: &#x27;Node&#x27; = None, right: &#x27;Node&#x27; = None, next: &#x27;Node&#x27; = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = left</span></span><br><span class="line"><span class="string">        self.right = right</span></span><br><span class="line"><span class="string">        self.next = next</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; <span class="string">&#x27;Node&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 利用队列实现二叉树的层序遍历</span></span><br><span class="line">        queue = Queue()</span><br><span class="line">        queue.put(root)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> queue.empty():</span><br><span class="line">            <span class="comment"># level表示这一层的总结点数</span></span><br><span class="line">            level = queue.qsize()</span><br><span class="line">            pre = Node()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(level):</span><br><span class="line">                node = queue.get()</span><br><span class="line">                <span class="comment"># pre为空表示这个结点是这层第一个结点</span></span><br><span class="line">                <span class="keyword">if</span> pre:</span><br><span class="line">                    pre.<span class="built_in">next</span> = node</span><br><span class="line">                <span class="comment"># 此时的这个节点为下一个结点的pre</span></span><br><span class="line">                pre = node</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    queue.put(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    queue.put(node.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    public int val;</span></span><br><span class="line"><span class="comment">    public Node left;</span></span><br><span class="line"><span class="comment">    public Node right;</span></span><br><span class="line"><span class="comment">    public Node next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node() &#123;&#125;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    public Node(int _val) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int _val, Node _left, Node _right, Node _next) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        left = _left;</span></span><br><span class="line"><span class="comment">        right = _right;</span></span><br><span class="line"><span class="comment">        next = _next;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="comment">// cur来记录每层的最左边的结点</span></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">// dummy结点方便我们遍历下一层</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">            <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 去判断cur的左右子结点</span></span><br><span class="line">                <span class="keyword">if</span>(cur.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="comment">// 当子节点存在时，就更新pre.next结点和pre结点</span></span><br><span class="line">                    pre.next = cur.left;</span><br><span class="line">                    pre = cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(cur.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    pre.next = cur.right;</span><br><span class="line">                    pre = cur.right;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = dummy.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-27">9.27</h3>
<p>困</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="235-二叉搜索树的最近公共祖先"><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></h4>
<p>难度简单</p>
<p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p>
<p>例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]</p>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt="img"></p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 节点 2 和节点 8 的最近公共祖先是 6。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4</span><br><span class="line">输出: 2</span><br><span class="line">解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure>
<p><strong>说明:</strong></p>
<ul>
<li>所有节点的值都是唯一的。</li>
<li>p、q 为不同节点且均存在于给定的二叉搜索树中。</li>
</ul>
<p>通过次数89,309</p>
<p>提交次数136,007</p>
</blockquote>
<p><strong>思路</strong></p>
<p>参考了官方题解知道了两种解法</p>
<p><strong>解法1</strong></p>
<ul>
<li>分别找到根节点到达p的路径path_q和根节点到达q的路径path_q</li>
<li>从头开始遍历两个路径，当path_q[i] != path_p[i]时，遍历的上一个结点就是分叉点</li>
</ul>
<p><strong>解法2</strong></p>
<ul>
<li>从root开始遍历整棵树</li>
<li>如果root.val&lt;p.val且root.val&lt;q.val，就往root的右边去找分叉点</li>
<li>如果root.val&gt;p.val且root.val&gt;q.val，就往root的左边去找分叉点</li>
<li>如果都不满足，说明此时p在root的左子树，q在root的右子树，root就是分叉点</li>
</ul>
<p><strong>代码</strong></p>
<ul>
<li>java写的解法1</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        List&lt;TreeNode&gt; pathToP = getPath(root, p);</span><br><span class="line">        List&lt;TreeNode&gt; pathToQ = getPath(root, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;pathToP.size() &amp;&amp; i&lt;pathToQ.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (pathToP.get(i)==pathToQ.get(i))&#123;</span><br><span class="line">                ans = pathToP.get(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title function_">getPath</span><span class="params">(TreeNode root, TreeNode target)</span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(root!=target)&#123;</span><br><span class="line">            path.add(root);</span><br><span class="line">            <span class="keyword">if</span>(root.val&gt;target.val)&#123;</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                root = root.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        path.add(root);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>python用的是解法2</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            cur = root.val</span><br><span class="line">            <span class="keyword">if</span> cur&lt;p.val <span class="keyword">and</span> cur&lt;q.val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">elif</span> cur&gt;p.val <span class="keyword">and</span> cur&gt;q.val:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h3 id="9-26">9.26</h3>
<p>托福考完了，总分估计不太行，不过估计也不准备考第二次了吧</p>
<p>考试真的紧张死，然后还是碰到了听力加试，结果没想到听力比阅读高</p>
<p>来刷题放松一下吧</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="113-路径总和-II"><a href="https://leetcode-cn.com/problems/path-sum-ii/">113. 路径总和 II</a></h4>
<p>难度中等</p>
<p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。</p>
<p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p>
<p><strong>示例:</strong><br>
给定如下二叉树，以及目标和 <code>sum = 22</code>，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     5</span><br><span class="line">    / \</span><br><span class="line">   4   8</span><br><span class="line">  /   / \</span><br><span class="line"> 11  13  4</span><br><span class="line">/  \    / \</span><br><span class="line">7    2  5   1</span><br></pre></td></tr></table></figure>
<p>返回:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">[5,4,11,2],</span><br><span class="line">[5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>思路</strong></p>
<p>老回溯法了</p>
<p>还是比较轻松的，虽然提交的时候WA了四次</p>
<p>或者说叫dfs？</p>
<ul>
<li>向下遍历</li>
<li>如果是空结点，直接return</li>
<li>如果不是叶节点，自动继续向下遍历，同时在已遍历的路径中加入该结点的值，目标值减去该结点的值</li>
<li>如果是叶节点，同时节点值就等于当前需要的target，就把这条路径放到答案里</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pathSum</span>(<span class="params">self, root: TreeNode, <span class="built_in">sum</span>: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">isLeave</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> root <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">findPath</span>(<span class="params">path, target, root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> isLeave(root):</span><br><span class="line">                findPath(path+[root.val], target-root.val, root.left)</span><br><span class="line">                findPath(path+[root.val], target-root.val, root.right)</span><br><span class="line">            <span class="keyword">elif</span> root.val == target:</span><br><span class="line">                ans.append(path+[root.val])</span><br><span class="line">        findPath([], <span class="built_in">sum</span>,root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; <span class="string">&#x27;TreeNode&#x27;</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            cur = root.val</span><br><span class="line">            <span class="keyword">if</span> cur&lt;p.val <span class="keyword">and</span> cur&lt;q.val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">elif</span> cur&gt;p.val <span class="keyword">and</span> cur&gt;q.val:</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h3 id="9-24">9.24</h3>
<p>大概是放弃出国了，但是周六托福还得好好考啊，毕竟是2k块钱呢呜呜呜</p>
<p>今天不知道是睡多了还是什么，头很痛</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="501-二叉搜索树中的众数"><a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">501. 二叉搜索树中的众数</a></h4>
<p>难度简单197</p>
<p>给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</p>
<p>假定 BST 有如下定义：</p>
<ul>
<li>结点左子树中所含结点的值小于等于当前结点的值</li>
<li>结点右子树中所含结点的值大于等于当前结点的值</li>
<li>左子树和右子树都是二叉搜索树</li>
</ul>
<p>例如：<br>
给定 BST <code>[1,null,2,2]</code>,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p><code>返回[2]</code>.</p>
<p><strong>提示</strong>：如果众数超过1个，不需考虑输出顺序</p>
<p>**进阶：**你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p>
</blockquote>
<p><strong>代码</strong></p>
<p>没能实现常数空间，只是用了中序遍历</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMode</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        answer = []</span><br><span class="line">        last = <span class="number">0</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        maxCount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> last, cnt, maxCount, answer</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> root.left:</span><br><span class="line">                inorder(root.left)</span><br><span class="line">            <span class="keyword">if</span> root.val == last:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cnt = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt == maxCount:</span><br><span class="line">                answer.append(root.val)</span><br><span class="line">            <span class="keyword">elif</span> cnt&gt;maxCount:</span><br><span class="line">                maxCount = cnt</span><br><span class="line">                answer=[root.val]</span><br><span class="line">            last = root.val</span><br><span class="line">            <span class="keyword">if</span> root.right:</span><br><span class="line">                inorder(root.right)</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure>
<h3 id="9-23">9.23</h3>
<p>好累，痒痒鼠好非</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="617-合并二叉树"><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></h4>
<p>难度简单497</p>
<p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则<strong>不为</strong> NULL 的节点将直接作为新二叉树的节点。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">	Tree 1                     Tree 2                  </span><br><span class="line"> 1                         2                             </span><br><span class="line">/ \                       / \                            </span><br><span class="line">3   2                     1   3                        </span><br><span class="line">/                           \   \                      </span><br><span class="line">5                             4   7                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">	     3</span><br><span class="line">	    / \</span><br><span class="line">	   4   5</span><br><span class="line">	  / \   \ </span><br><span class="line">	 5   4   7</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong> 合并必须从两个树的根节点开始。</p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mergeTrees</span>(<span class="params">self, t1: TreeNode, t2: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t1:</span><br><span class="line">            <span class="keyword">return</span> t2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> t2:</span><br><span class="line">            <span class="keyword">return</span> t1</span><br><span class="line">        cur = TreeNode(t1.val + t2.val)</span><br><span class="line">        left = self.mergeTrees(t1.left,t2.left)</span><br><span class="line">        right = self.mergeTrees(t1.right, t2.right)</span><br><span class="line">        cur.left, cur.right = left, right</span><br><span class="line">        <span class="keyword">return</span> cur</span><br></pre></td></tr></table></figure>
<h3 id="9-21">9.21</h3>
<p>周六考托福啦，这周就不写题解了，直接上代码吧</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="538-把二叉搜索树转换为累加树"><a href="https://leetcode-cn.com/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a></h4>
<p>难度简单</p>
<p>给定一个二叉搜索树（Binary Search Tree），把它转换成为累加树（Greater Tree)，使得每个节点的值是原来的节点值加上所有大于它的节点值之和。</p>
<p><strong>例如：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 原始二叉搜索树:</span><br><span class="line">     5</span><br><span class="line">   /   \</span><br><span class="line">  2     13</span><br><span class="line"></span><br><span class="line">输出: 转换为累加树:</span><br><span class="line">    18</span><br><span class="line">   /   \</span><br><span class="line"> 20     13</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">convertBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">addKids</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> total</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                addKids(root.right)</span><br><span class="line">                total += root.val</span><br><span class="line">                root.val = total</span><br><span class="line">                addKids(root.left)</span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        addKids(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h3 id="9-20">9.20</h3>
<p>又是美好的周日，双休日就多刷点题吧（不过题解我就懒得多写了）</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="78-子集"><a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></h4>
<p>难度中等759</p>
<p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p>
<p>**说明：**解集不能包含重复的子集。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[3],</span><br><span class="line">[1],</span><br><span class="line">[2],</span><br><span class="line">[1,2,3],</span><br><span class="line">[1,3],</span><br><span class="line">[2,3],</span><br><span class="line">[1,2],</span><br><span class="line">[]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>题解</strong></p>
<p>经典老番</p>
<ul>
<li>数组</li>
<li>所有可能的子集</li>
</ul>
<p>dfs嘛，这道题甚至还不用剪枝</p>
<p>看到不重复就知道dfs函数里面肯定有一个参数去决定循环开始的位置</p>
<p>直接上代码</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">nums, path, begin</span>):</span><br><span class="line">            res.append(path)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(begin, <span class="built_in">len</span>(nums)):</span><br><span class="line">                dfs(nums, path + [nums[i]], i+<span class="number">1</span>)</span><br><span class="line">        dfs(nums, [], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>改成java改的我头大，果然还是太菜了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(nums, res, <span class="number">0</span>, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">int</span> begin, ArrayList&lt;Integer&gt; path)</span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">if</span>(nums.length == path.size())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin;i&lt;nums.length;i++)&#123;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            dfs(nums, res, i+<span class="number">1</span>, path);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-19">9.19</h3>
<p>leetcode的周六，i了i了</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="404-左叶子之和"><a href="https://leetcode-cn.com/problems/sum-of-left-leaves/">404. 左叶子之和</a></h4>
<p>难度简单</p>
<p>计算给定二叉树的所有左叶子之和。</p>
<p><strong>示例：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">/ \</span><br><span class="line">9  20</span><br><span class="line">/  \</span><br><span class="line">15   7</span><br><span class="line"></span><br><span class="line">在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>题解</strong></p>
<ol>
<li>遍历所有节点</li>
<li>把所有自己本身是左子节点且自己没有子节点的节点加起来</li>
</ol>
<p>总结：万能的dfs</p>
<p>这边用了一个flag位去判断该节点是不是左子节点，这么写的话递归过程比较好理解</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sumOfLeftLeaves</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">findAndAdd</span>(<span class="params">root, flag</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> flag <span class="keyword">and</span> root <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">                <span class="keyword">return</span> root.val</span><br><span class="line">            <span class="keyword">return</span> findAndAdd(root.left, <span class="literal">True</span>) + findAndAdd(root.right, <span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">return</span> findAndAdd(root, <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java就是单纯的翻译一遍上面的代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> add(root, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(TreeNode root, <span class="type">boolean</span> flag)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> add(root.left, <span class="literal">true</span>)+add(root.right, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        dfs(nums, res, <span class="number">0</span>, path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">int</span> begin, ArrayList&lt;Integer&gt; path)</span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        <span class="keyword">if</span>(nums.length == path.size())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin;i&lt;nums.length;i++)&#123;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            dfs(nums, res, i+<span class="number">1</span>, path);</span><br><span class="line">            path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-18">9.18</h3>
<p>人在图书馆 很困 想睡 晚安</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="47-全排列-II"><a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></h4>
<p>难度中等</p>
<p>给定一个可包含重复数字的序列，返回所有不重复的全排列。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,1,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[1,1,2],</span><br><span class="line">[1,2,1],</span><br><span class="line">[2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>题解</strong></p>
<p>跟组合一样，这道题还是老方法，回溯法</p>
<p>不断地递归去求排列的可能性</p>
<p>区别在于剪枝的方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> used[i]:</span><br><span class="line">    <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i-<span class="number">1</span>]:</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<p>就拿题目里的<code>[1, 1, 2]</code>来举例说明吧</p>
<ol>
<li>一开始我选第一个1
<ul>
<li>接下来我选1
<ul>
<li>由于只剩下一个2，所以构成[1,1,2]</li>
</ul>
</li>
<li>接下来我选2
<ul>
<li>由于只剩下一个1，所以构成[1,2,1]</li>
</ul>
</li>
</ul>
</li>
<li>一开始我选第二个1
<ul>
<li>这时我们知道其实这种条件下是跟上面一摸一样的，因为两个数字相同嘛</li>
<li>那么这种就没有必要继续递归求解</li>
<li>这种条件具体就是指
<ul>
<li>我现在选的这个数字已经在上一个分支里出现过</li>
<li>也就是nums[i] == nums[i-1]</li>
<li>同时我还要保证这个分支里，没有继续选上一个数 not used[i-1]</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">nums, depth, used, path,res</span>):</span><br><span class="line">            <span class="keyword">if</span> depth == <span class="built_in">len</span>(nums):</span><br><span class="line">                res.append(path.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> used[i]:</span><br><span class="line">                    <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i-<span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> used[i-<span class="number">1</span>]:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    path.append(nums[i])</span><br><span class="line">                    used[i] = <span class="number">1</span></span><br><span class="line">                    dfs(nums, depth+<span class="number">1</span>, used, path, res)</span><br><span class="line">                    used[i] = <span class="number">0</span></span><br><span class="line">                    path.pop()</span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">        res = []</span><br><span class="line">        used = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums))]</span><br><span class="line">        dfs(nums, <span class="number">0</span>, used, [], res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<h3 id="9-17">9.17</h3>
<p>人傻了，到图书馆一看，发现是困难题</p>
<p>看完题目，发现是图论，得，咱直接看题解好了</p>
<blockquote>
<h4 id="685-冗余连接-II"><a href="https://leetcode-cn.com/problems/redundant-connection-ii/">685. 冗余连接 II</a></h4>
<p>难度困难</p>
<p>在本问题中，有根树指满足以下条件的<strong>有向</strong>图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。</p>
<p>输入一个有向图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p>
<p>结果图是一个以<code>边</code>组成的二维数组。 每一个<code>边</code> 的元素是一对 <code>[u, v]</code>，用以表示<strong>有向</strong>图中连接顶点 <code>u</code> 和顶点 <code>v</code> 的边，其中 <code>u</code> 是 <code>v</code> 的一个父节点。</p>
<p>返回一条能删除的边，使得剩下的图是有N个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [[1,2], [1,3], [2,3]]</span><br><span class="line">输出: [2,3]</span><br><span class="line">解释: 给定的有向图如下:</span><br><span class="line">1</span><br><span class="line">/ \</span><br><span class="line">v   v</span><br><span class="line">2--&gt;3</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [[1,2], [2,3], [3,4], [4,1], [1,5]]</span><br><span class="line">输出: [4,1]</span><br><span class="line">解释: 给定的有向图如下:</span><br><span class="line">5 &lt;- 1 -&gt; 2</span><br><span class="line">^    |</span><br><span class="line">|    v</span><br><span class="line">4 &lt;- 3</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ul>
<li>二维数组大小的在3到1000范围内。</li>
<li>二维数组中的每个整数在1到N之间，其中 N 是二维数组的大小。</li>
</ul>
</blockquote>
<p><strong>题解</strong></p>
<p>看完<a href="https://leetcode-cn.com/problems/redundant-connection-ii/solution/bing-cha-ji-java-by-liweiwei1419/">weiwei大佬的题解</a>，发现自己好菜</p>
<p>题目的意思就是说现在给了你很多根边，要求是删除一根边，让剩下边拼到一块儿就是一个有根树</p>
<p>那怎么需要删除的边呢？</p>
<p>说到底无非就是</p>
<ul>
<li>删一条边</li>
<li>看剩下的边能不能成树</li>
</ul>
<p>那大佬总结出来怎么删的边的可能性有</p>
<ul>
<li>删掉一条入度为2的边，看还会不会构成回路</li>
<li>删掉一条入度为1的边，看还会不会构成回路</li>
</ul>
<p>那么具体要做的看上去有两件事</p>
<ul>
<li>统计每条边的入度</li>
<li>判断删掉某条边后，是否会构成回路</li>
</ul>
<p>那么判断回路还需要用到一种算法，叫做并查集。</p>
<p>可以参考这篇文章，特别好懂</p>
<p><a href="https://blog.csdn.net/qq_41593380/article/details/81146850">https://blog.csdn.net/qq_41593380/article/details/81146850</a></p>
<p>简单来说并查集就是用来快速查找某个点的根节点</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findRedundantDirectedConnection(<span class="type">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> edges.length;</span><br><span class="line">        <span class="comment">// 先记录所有点的入度</span></span><br><span class="line">        <span class="type">int</span>[] inDegree = <span class="keyword">new</span> <span class="title class_">int</span>[len+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] edge:edges)&#123;</span><br><span class="line">            inDegree[edge[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len-<span class="number">1</span>;i &gt;= <span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[edges[i][<span class="number">1</span>]] == <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">// 尝试删除入度为2的边</span></span><br><span class="line">                <span class="keyword">if</span>(!judgeCircle(edges,len,i))&#123;</span><br><span class="line">                    <span class="comment">// 删除该边后如果不形成环，说明就是要删除的那条变</span></span><br><span class="line">                    <span class="keyword">return</span> edges[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[edges[i][<span class="number">1</span>]] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">// 尝试删除入度为1的边</span></span><br><span class="line">                <span class="keyword">if</span>(!judgeCircle(edges,len,i))&#123;</span><br><span class="line">                    <span class="comment">// 同理，删除后不成环就返回边</span></span><br><span class="line">                    <span class="keyword">return</span> edges[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">judgeCircle</span><span class="params">(<span class="type">int</span>[][] edges, <span class="type">int</span> len, <span class="type">int</span> remove)</span>&#123;</span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">unionFind</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(len+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 尝试删除某条边之后 判断是否成环</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i == remove)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!unionFind.union(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>]))&#123;</span><br><span class="line">                <span class="comment">// 如果合并失败，说明edges[i][0]和edges[i][1]在一个联通分量离</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(x!=parent[x])&#123;</span><br><span class="line">                parent[x] = parent[parent[x]];</span><br><span class="line">                x = parent[x];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootX</span> <span class="operator">=</span> find(x);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootY</span> <span class="operator">=</span> find(y);</span><br><span class="line">            <span class="keyword">if</span>(rootX == rootY)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-16">9.16</h3>
<p>ohhhhh，又是简单题，赶快刷完去刷托福了</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="226-翻转二叉树"><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h4>
<p>难度简单</p>
<p>翻转一棵二叉树。</p>
<p><strong>示例：</strong></p>
<p>输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">/   \</span><br><span class="line">2     7</span><br><span class="line">/ \   / \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">/   \</span><br><span class="line">7     2</span><br><span class="line">/ \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>题解</strong></p>
<p>思路很简单，用一个递归函数去把每个节点的左子树和右子树交换一下就完事儿了</p>
<p>唯一需要提的就是python的代码会跟java的有点不一样</p>
<p>python属于自顶向下的，java属于自底向上的。</p>
<p>因为python可以直接root.left, root.right = root.right, root.left</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> invertTree(root.right);</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> invertTree(root.left);</span><br><span class="line">            root.left = left;</span><br><span class="line">            root.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">invertTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            root.left, root.right = root.right, root.left</span><br><span class="line">            reverse(root.left)</span><br><span class="line">            reverse(root.right)</span><br><span class="line">        reverse(root)      </span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<h3 id="9-15">9.15</h3>
<p>今天是困难题，有点懵</p>
<p>不过幸好今天没课</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="37-解数独"><a href="https://leetcode-cn.com/problems/sudoku-solver/">37. 解数独</a></h4>
<p>难度困难</p>
<p>编写一个程序，通过已填充的空格来解决数独问题。</p>
<p>一个数独的解法需<strong>遵循如下规则</strong>：</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</li>
</ol>
<p>空白格用 <code>'.'</code> 表示。</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png" alt="img"></p>
<p>一个数独。</p>
<p><img src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Sudoku-by-L2G-20050714_solution.svg/250px-Sudoku-by-L2G-20050714_solution.svg.png" alt="img"></p>
<p>答案被标成红色。</p>
<p><strong>Note:</strong></p>
<ul>
<li>给定的数独序列只包含数字 <code>1-9</code> 和字符 <code>'.'</code> 。</li>
<li>你可以假设给定的数独只有唯一解。</li>
<li>给定数独永远是 <code>9x9</code> 形式的。</li>
</ul>
</blockquote>
<p><strong>题解</strong></p>
<p>首先确定我们的方法，回溯法</p>
<p>基本思路就是</p>
<ul>
<li>根据当前的棋盘，在一个空格内填入可能的数字</li>
<li>在填入一个可能的解后，继续在下一个空格内填入可能的数字</li>
<li>若填入当前数字后发现没有下一个能填入的数字，就退回上一步，在该空格内填另一个可能的数字（回溯法的关键思想）</li>
<li>直到将所有空格填满</li>
</ul>
<p>我们根据数独的三个规则找到填入数字的可能性</p>
<ol>
<li>数字 <code>1-9</code> 在每一行只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一列只能出现一次。</li>
<li>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</li>
</ol>
<p>如何快速判断某一个格子能填几呢？针对三个规则，定义三个数组</p>
<ol>
<li>row数组，用来检查每行的数字的出现情况
<ul>
<li><code>row[i][j]=1</code>代表了第i+1行出现过j+1这个数字</li>
</ul>
</li>
<li>col数组，用来检查每列的数字的出现情况
<ul>
<li><code>col[i][j]=1</code>代表了第i+1列出现过j+1这个数字</li>
</ul>
</li>
<li>block数组，用来检查九个九宫格内数字的出现情况
<ul>
<li><code>block[i/3][j/3][k]=1</code>代表了第i/3行,第j/3的九宫格内出现过k+1这个数字</li>
</ul>
</li>
</ol>
<p>如何知道哪些空格需要填呢？</p>
<ul>
<li>建立一个动态数组spaces，一开始遍历棋盘找到所有空格，以<code>[i,j]</code>的格式放入spaces中</li>
</ul>
<p>解数独具体的流程</p>
<ol>
<li>遍历一遍当前棋盘，初始化row,col,block,spaces数组</li>
<li>对整个棋盘进行递归求解
<ol>
<li>如果此时已经没有空格可以填入，则退出循环，找到解</li>
<li>否则就找到需要填的空格，尝试将1-9其中满足规则的填入空格并更新三个数组</li>
<li>在调用递归函数之后，要把当前填入的整个数字给去掉，并还原三个数组</li>
</ol>
</li>
</ol>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// row[i][j] 用来记录第i+1行有没有出现过j+1这个数字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] row = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="comment">// col[i][j] 用来记录第i+1列有没有出现过j+1这个数字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] col = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">9</span>][<span class="number">9</span>]; </span><br><span class="line">    <span class="comment">// block[i][j][k] 用来记录第i+1行第j+1列的这个九宫格内是否出现过k+1这个数字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][][] block = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="comment">// spaces中的第i个数组[i,j]用来存储的是第i+1行，j+1列这个方格是否为空</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;<span class="type">int</span>[]&gt; spaces = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// valid用来判断数独是否已经完成</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solveSudoku</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j&lt;<span class="number">9</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">                    spaces.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j&#125;);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> board[i][j] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                    row[i][num] = col[j][num] = block[i/<span class="number">3</span>][j/<span class="number">3</span>][num] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(board,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == spaces.size())&#123;</span><br><span class="line">            valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur_i</span> <span class="operator">=</span> spaces.get(index)[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur_j</span> <span class="operator">=</span> spaces.get(index)[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>; num &lt;= <span class="number">9</span> &amp;&amp; !valid;num++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(row[cur_i][num-<span class="number">1</span>]==<span class="number">0</span> &amp;&amp; col[cur_j][num-<span class="number">1</span>]==<span class="number">0</span> &amp;&amp; block[cur_i/<span class="number">3</span>][cur_j/<span class="number">3</span>][num-<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">                    row[cur_i][num-<span class="number">1</span>] = col[cur_j][num-<span class="number">1</span>] = block[cur_i/<span class="number">3</span>][cur_j/<span class="number">3</span>][num-<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                    board[cur_i][cur_j] = (<span class="type">char</span>)(num+ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    dfs(board, index+<span class="number">1</span>);</span><br><span class="line">                    row[cur_i][num-<span class="number">1</span>] = col[cur_j][num-<span class="number">1</span>] = block[cur_i/<span class="number">3</span>][cur_j/<span class="number">3</span>][num-<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-14">9.14</h3>
<p>三天的数模竞赛终于结束了，头发掉光，疯狂爆痘，人快猝死了</p>
<p>算是见到了凌晨三点的苏大，24小时内只吃了一顿饭，已经没空去饿了</p>
<p>努力了 尝试了 尽力了 也可以说这次就算理想不结果也是问心无愧了</p>
<img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20200914130951082.png" alt="image-20200914130951082" style="zoom:50%;" />
<p>终于又回到了leetcode的怀抱</p>
<p>在研究了三天热学，整数规划，机理模型，从数学建模到语文建模后</p>
<p>今天的ta用美好的二叉树来欢迎我，我简直感动到热泪盈眶</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="94-二叉树的中序遍历"><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h4>
<p>难度中等</p>
<p>给定一个二叉树，返回它的<em>中序</em> 遍历。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [1,null,2,3]</span><br><span class="line">1</span><br><span class="line">\</span><br><span class="line">2</span><br><span class="line">/</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">输出: [1,3,2]</span><br></pre></td></tr></table></figure>
<p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p>
</blockquote>
<p><strong>题解</strong>1</p>
<p>首先用递归来解，很简单</p>
<p>中序遍历就是写一个递归，然后在递归函数内对结点的处理顺序就是先左结点，再父节点，最后右结点</p>
<p><strong>代码</strong>1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inorder</span>(<span class="params">root</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            inorder(root.left)</span><br><span class="line">            ans.append(root.val)</span><br><span class="line">            inorder(root.right)</span><br><span class="line">        inorder(root)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong>2</p>
<p>然后用java写一个非递归的</p>
<p>参考了官方题解，简单来说就是用stack来模拟递归</p>
<p><strong>代码</strong>2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> * Definition <span class="keyword">for</span> a binary tree node.</span><br><span class="line"> * <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"> *     <span class="type">int</span> val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stk = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!stk.isEmpty() || root!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">                stk.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.pop();</span><br><span class="line">            ans.add(root.val);</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-10">9.10</h3>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="40-组合总和-II"><a href="https://leetcode-cn.com/problems/combination-sum-ii/">40. 组合总和 II</a></h4>
<p>难度中等</p>
<p>给定一个数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的每个数字在每个组合中只能使用一次。</p>
<p><strong>说明：</strong></p>
<ul>
<li>所有数字（包括目标数）都是正整数。</li>
<li>解集不能包含重复的组合。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>题解</strong></p>
<p>总体上跟昨天的每日一题差不多</p>
<p>思路都是利用dfs或者说回溯法，逐个可能性递归求解</p>
<p>唯一的区别就是，昨天是可以重复的，今天是不能重复的</p>
<ul>
<li>java我使用的依然是昨天的方法，只是更改了一下每次递归时begin的位置，昨天是从原数字开始，今天从原数字后面一个开始递归（因为每个数字只能用一次）</li>
<li>python的话我尝试了使用哈希表（字典）来记录数字出现的次数，然后在遍历时候先把数组去重。最后在回溯的时候去增删这个数字出现的次数，来保证每个数字不会被重复使用</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        dfs(candidates, target, <span class="number">0</span>, ans, path);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, <span class="type">int</span> begin, List&lt;List&lt;Integer&gt;&gt; ans, Deque&lt;Integer&gt; path)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin;i&lt;candidates.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(candidates[i] &gt; target)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i &gt; begin  &amp;&amp; candidates[i] == candidates[i-<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    path.addLast(candidates[i]);</span><br><span class="line">                    dfs(candidates, target-candidates[i], i+<span class="number">1</span>, ans, path);</span><br><span class="line">                    path.removeLast();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum2</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ans = []</span><br><span class="line">        candidates_set = <span class="built_in">list</span>(<span class="built_in">set</span>(candidates))</span><br><span class="line">        dic = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> candidates_set:</span><br><span class="line">            dic[i] = candidates.count(i)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">nums, target, begin</span>):</span><br><span class="line">            <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">                ans.append(nums)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(begin,<span class="built_in">len</span>(candidates_set)):</span><br><span class="line">                    num = candidates_set[i]</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> dic[num]:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">elif</span> num&gt;target:</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dic[num] -= <span class="number">1</span></span><br><span class="line">                        dfs(nums+[num],target-num,i)</span><br><span class="line">                        dic[num] += <span class="number">1</span></span><br><span class="line">        dfs([], target,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="9-9">9.9</h3>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="39-组合总和"><a href="https://leetcode-cn.com/problems/combination-sum/">39. 组合总和</a></h4>
<p>难度中等884</p>
<p>给定一个<strong>无重复元素</strong>的数组 <code>candidates</code> 和一个目标数 <code>target</code> ，找出 <code>candidates</code> 中所有可以使数字和为 <code>target</code> 的组合。</p>
<p><code>candidates</code> 中的数字可以无限制重复被选取。</p>
<p><strong>说明：</strong></p>
<ul>
<li>所有数字（包括 <code>target</code>）都是正整数。</li>
<li>解集不能包含重复的组合。</li>
</ul>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：candidates = [2,3,5], target = 8,</span><br><span class="line">所求解集为：</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= candidates.length &lt;= 30</code></li>
<li><code>1 &lt;= candidates[i] &lt;= 200</code></li>
<li><code>candidate</code> 中的每个元素都是独一无二的。</li>
<li><code>1 &lt;= target &lt;= 500</code></li>
</ul>
</blockquote>
<p><strong>题解</strong></p>
<p>一看题目就知道，深搜肯定好用</p>
<p>那么首先要考虑的是递归函数的参数也就是，dfs(?)</p>
<ul>
<li>
<p>首先肯定得有一个列表去存放目前为止已经被加起来的数，那就先设定为nums吧</p>
</li>
<li>
<p>同时为了避免每次递归时都要求一次数组nums的和，还得有一个变量存储当前nums的和，就叫它cur_sum吧</p>
</li>
<li>
<p>假设我们就用这两个显然的参数来写递归</p>
<ul>
<li>考虑出递归的条件，很简单，有两种
<ol>
<li>cur_sum &gt; target</li>
<li>cur_sum == target</li>
</ol>
</li>
<li>其中第一种情况因为此时不管再怎么往nums里加数字都不可能成立，所以直接return</li>
<li>第二种情况，nums数组属于题目要求的组合，就把nums数组放到ans数组中，然后return</li>
</ul>
</li>
<li>
<p>除此之外，就是cur_sum &lt; target了</p>
<ul>
<li>
<p>这个时候很容易想到，去遍历一遍candidates数组中所有的数字，添加到nums数组里试一下就好了</p>
<ul>
<li>
<p>此时可以有一个剪枝的小办法，先判断cur_sum加上这个数字是不是小于等于target</p>
</li>
<li>
<p>如果小于等于，就继续搜</p>
</li>
<li>
<p>反之，就不用dfs了</p>
</li>
</ul>
</li>
<li>
<p>但是这样操作下来有一个问题</p>
<ul>
<li>例如candidates = [2, 3], target = 8</li>
<li>那么最后答案中会出现[2,2,3], [2,3,2], [3,2,2]</li>
<li>为什么呢？因为我们每次深搜的时候都是把整个nums数组遍历一遍，自然会出现不同顺序同样数字的组合</li>
<li>怎么解决呢？</li>
</ul>
</li>
<li>
<p>增加一个变量begin，用来存储每次遍历开始的位置</p>
<ul>
<li>用这个变量来保证每次我遍历数组，去尝试各个可能性的时候都是从至少当前数字开始往后</li>
<li>由于题目给的candidates是从小到大排序的，所以就绝对不会出现[2,3,2]这种组合了</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ans = []</span><br><span class="line">     	<span class="comment"># 存放答案</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">nums,cur_sum, begin</span>):</span><br><span class="line">            <span class="comment"># 递归深搜</span></span><br><span class="line">            <span class="keyword">if</span> cur_sum &gt; target:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">elif</span> cur_sum == target:</span><br><span class="line">                ans.append(nums)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(begin,<span class="built_in">len</span>(candidates)):</span><br><span class="line">                    cur_num = candidates[i]</span><br><span class="line">                    <span class="keyword">if</span> cur_sum+cur_num &lt;= target:</span><br><span class="line">                        dfs(nums+[cur_num], cur_sum+cur_num, i)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        dfs([],<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<h3 id="9-8">9.8</h3>
<p>又到了愉快（并不）的刷题时间啦</p>
<blockquote>
<h4 id="77-组合"><a href="https://leetcode-cn.com/problems/combinations/">77. 组合</a></h4>
<p>难度<strong>中等</strong></p>
<p>给定两个整数 <em>n</em> 和 <em>k</em>，返回 1 … <em>n</em> 中所有可能的 <em>k</em> 个数的组合。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: n = 4, k = 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">[2,4],</span><br><span class="line">[3,4],</span><br><span class="line">[2,3],</span><br><span class="line">[1,2],</span><br><span class="line">[1,3],</span><br><span class="line">[1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>题解</strong>1</p>
<p>一种解法是比较巧妙的结合了数学归纳法，评论里的大佬是真滴强</p>
<ul>
<li>利用C(m,n) = C(m-1,n) + C(m-1,n-1)，使用递归的方式</li>
</ul>
<p><strong>代码</strong>1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combine</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> k&gt;n <span class="keyword">or</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">if</span> k == n:</span><br><span class="line">            <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)]</span><br><span class="line">        </span><br><span class="line">        answer = self.combine(n-<span class="number">1</span>,k)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.combine(n-<span class="number">1</span>,k-<span class="number">1</span>):</span><br><span class="line">            i.append(n)</span><br><span class="line">            answer.append(i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure>
<p><strong>题解</strong>2</p>
<p>这种解法就非常朴实无华，总结就是dfs加剪枝</p>
<ul>
<li>
<p>举个例子，例如n=5，k=3</p>
</li>
<li>
<p>现在我的path中存放了1，2，那么我要怎么找到第三个数呢？</p>
</li>
<li>
<p>通过循环，begin值设为3，然后递增1，每次循环的时候把对应的值加到path中，最后在回溯的时候要把这个加进去的值remove掉</p>
</li>
<li>
<p>会有一个什么样的过程呢？</p>
<ul>
<li>i = begin = 3</li>
<li>path.add(3)</li>
<li>此时执行dfs</li>
<li>发现path的长度等于3，所以res.add(path)</li>
<li>然后这个时候又回到path.add(3)之后</li>
<li>因为3已经被用过了，就把3remove掉，继续循环</li>
<li>这一次 i = 4，重复以上步骤</li>
</ul>
</li>
<li>
<p>可能有点难理解，直接看代码好了</p>
</li>
</ul>
<p><strong>代码</strong>2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// res存放结果，path存放在递归过程中的临时数组</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(k&lt;=<span class="number">0</span> || k&gt;n)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(n, k, <span class="number">1</span>, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k,<span class="type">int</span> begin, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() == k)&#123;</span><br><span class="line">            <span class="comment">// 当path中有k个元素时就把path加入到结果中</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 这里处理剪枝时可以注意到i&lt;=n其实是一个过于宽泛的条件</span></span><br><span class="line">            <span class="comment">// 例如n=15，k=4，path里已经有了两个数，接下来还要选择两个数</span></span><br><span class="line">            <span class="comment">// 搜索的起点begin值最大就是14，最后一个被选的是[14,15]</span></span><br><span class="line">            <span class="comment">// 也就是说i&lt;=15条件过大，应该是i&lt;=14,这里的14 = n-(k-path里已经有的元素数) + 1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin;i&lt;=n-(k-path.size())+<span class="number">1</span>;i++)&#123;</span><br><span class="line">                path.addLast(i);</span><br><span class="line">                dfs(n, k, i+<span class="number">1</span>, path, res);</span><br><span class="line">                <span class="comment">// 每次回溯都需要把那个加进去的值删掉再继续循环</span></span><br><span class="line">                path.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-7">9.7</h3>
<p>开学第一天哦，题目不算难噢（好尬）</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="347-前-K-个高频元素"><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h4>
<p>难度<strong>中等</strong></p>
<p>给定一个非空的整数数组，返回其中出现频率前 *<strong>k*</strong> 高的元素。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1], k = 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure>
<p>提示：</p>
<ul>
<li>你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。</li>
<li>你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。</li>
<li>题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。</li>
<li>你可以按任意顺序返回答案。</li>
</ul>
</blockquote>
<p><strong>题解</strong></p>
<p>首先题目要求返回的是出现频率的前k个元素，那这个出现频率首先肯定得求出来对不对。</p>
<p>那么题目还要求时间复杂度要由于N log N，那么直接用两层循环去求每个元素的次数（python里的count方法）肯定是不满足的。（是N²了）</p>
<p>那就用字典嘛，或者说哈希表。</p>
<p>dic[i]=x，这里的i是nums数组中的数字，x是i在数组nums中出现的总次数。</p>
<p>循环一遍nums，遇到一个i就把dic[i]+1。</p>
<p>求出了出现次数之后怎么办呢，要找到前k个。</p>
<p>这里就有两种方法了</p>
<ul>
<li>
<p>一种是死办法，把所有的数字根据出现次数，直接排序，虽然是 N log N不过也能通过呢。（代码见下python）</p>
</li>
<li>
<p>一种是稍微巧妙一点的办法，建小顶堆，也就是说堆顶的那个元素的值一定是堆中最小的。</p>
<ul>
<li>把哈希表中所有的键值对一个一个丢到堆里。</li>
<li>如果堆里面装的个数小于k（题目中要求返回出现次数排序前k个的元素），就直接丢到堆里</li>
<li>如果堆的个数等于k了，就检查这个键对应value是否比堆顶的value大，如果更大，就把堆顶的丢掉，把新的一个键值对塞进堆里</li>
<li>要注意，塞进去的同时要能够保证堆顶的值一直是最小的</li>
</ul>
</li>
</ul>
<p><strong>代码</strong></p>
<p>python是纯自己写，但是java的由于学术不精，只会语法，库和包都不会用，就剽的大佬的。</p>
<p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/solution/leetcode-di-347-hao-wen-ti-qian-k-ge-gao-pin-yuan-/">大佬的题解</a></p>
<p>python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">topKFrequent</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        dic = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> dic.get(i):</span><br><span class="line">                dic[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[i] += <span class="number">1</span></span><br><span class="line">        nums = <span class="built_in">list</span>(<span class="built_in">set</span>(nums))</span><br><span class="line">        nums.sort()</span><br><span class="line">        cnts = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> dic[i]:</span><br><span class="line">                cnts.append([i,dic[i]])</span><br><span class="line">        cnts.sort(key = <span class="keyword">lambda</span> d:d[<span class="number">1</span>], reverse = <span class="literal">True</span>)</span><br><span class="line">        ans = [(cnts[i][<span class="number">0</span>]) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<p>java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(num))&#123;</span><br><span class="line">                map.put(num, map.get(num)+<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(num,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer a, Integer b)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> map.get(a)-map.get(b);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(Integer key : map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &lt; k)&#123;</span><br><span class="line">                pq.add(key);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (map.get(key) &gt; map.get(pq.peek()))&#123;</span><br><span class="line">                pq.remove();</span><br><span class="line">                pq.add(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">            res[i++] = pq.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-6">9.6</h3>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="107-二叉树的层次遍历-II"><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层次遍历 II</a></h4>
<p>难度简单</p>
<p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p>
<p>例如：<br>
给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">/ \</span><br><span class="line">9  20</span><br><span class="line">/  \</span><br><span class="line">15   7</span><br></pre></td></tr></table></figure>
<p>返回其自底向上的层次遍历为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">[15,7],</span><br><span class="line">[9,20],</span><br><span class="line">[3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>题解</strong></p>
<p>看到难度是简单就松了一口气</p>
<p>果不其然， 今天的题目也算是对一年前的数据结构的复习吧，还记得当时老师只要求画图，不要求具体的代码</p>
<p>这次就来试试看吧</p>
<p>一看到二叉树就想到了递归</p>
<p>由于个人对于dfs比较熟悉，就直接写了一个dfs递归解法</p>
<ul>
<li>用res来存储最终结果</li>
<li>当遍历到新的一层的时候（也就是depth&gt;=res数组的长度的时候），就往res里append一个空列表用于存储新的一层的结点值</li>
<li>同时往该结点对应那一层的列表里（res[depth]）append结点的值</li>
<li>对该结点的左子节点和右子节点重复以上工作</li>
</ul>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">levelOrderBottom</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">root, depth</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res)&lt;depth+<span class="number">1</span>:</span><br><span class="line">                res.append([])</span><br><span class="line">            res[depth].append(root.val)</span><br><span class="line">            dfs(root.left, depth+<span class="number">1</span>)</span><br><span class="line">            dfs(root.right, depth+<span class="number">1</span>)</span><br><span class="line">        dfs(root,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<h3 id="9-5">9.5</h3>
<p>又到新学期啦（上学期啥都没学就过去了，暑假也跟飞一样地过去了）</p>
<p>事不宜迟开始刷题吧，毕竟不管是为了实习，还是为了读研，还是为了申请出国的项目，刷题都是血赚。</p>
<p><strong>题目</strong></p>
<blockquote>
<h4 id="60-第k个排列"><a href="https://leetcode-cn.com/problems/permutation-sequence/">60. 第k个排列</a></h4>
<p>难度<strong>中等</strong></p>
<p>给出集合 <code>[1,2,3,…,*n*]</code>，其所有元素共有 <em>n</em>! 种排列。</p>
<p>按大小顺序列出所有排列情况，并一一标记，当 <em>n</em> = 3 时, 所有排列如下：</p>
<ol>
<li><code>&quot;123&quot;</code></li>
<li><code>&quot;132&quot;</code></li>
<li><code>&quot;213&quot;</code></li>
<li><code>&quot;231&quot;</code></li>
<li><code>&quot;312&quot;</code></li>
<li><code>&quot;321&quot;</code></li>
</ol>
<p>给定 <em>n</em> 和 <em>k</em>，返回第 <em>k</em> 个排列。</p>
<p><strong>说明：</strong></p>
<ul>
<li>给定 <em>n</em> 的范围是 [1, 9]。</li>
<li>给定 <em>k</em> 的范围是[1,  <em>n</em>!]。</li>
</ul>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: n = 3, k = 3</span><br><span class="line">输出: &quot;213&quot;</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: n = 4, k = 9</span><br><span class="line">输出: &quot;2314&quot;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>题解</strong></p>
<p>给定两个数字，一个n是数字的位数，一个k意思是返回所有排序中第k大的那个排序。</p>
<p>思路也不难理解，位数从大到小开始考虑。</p>
<p>举个例子就能明白，就拿示例二来讲。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: n = 4, k = 9</span><br><span class="line">输出: &quot;2314&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>n=4，k=9，我们第一个要考虑的是千位数；</p>
</li>
<li>
<p>由于是从小到大的全排列，而且我们有1 2 3 4，这四个数字；</p>
</li>
<li>
<p>那么很显然全排列中一开始一定是一些1XXX，然后是2XXX，然后是3XXX，最后是4XXX，其中每个数字开头的排列数肯定是相同的；</p>
</li>
<li>
<p>每个数字开头有多少种排列呢？</p>
<ul>
<li>1XXX有 $3!=3\times2\times1=6$种</li>
<li>同样2XXX，3XXX，4XXX也都是每个6种</li>
</ul>
</li>
<li>
<p>有了这个，加上k=9，我们就知道，我们要找的排列肯定是2开头的，因为(9/6)向上取整=2</p>
</li>
<li>
<p>当我们找到这个千位数字之后，我们就要继续找百位数了，方法跟千位数一样。循环n次即获得最终答案。</p>
</li>
<li>
<p>有一个点需要注意的就是，我们用一个数组nums去存储我们排列中可能的数字，当取用其中一个数字之后，要把它在数组中删掉</p>
</li>
</ul>
<p><strong>代码</strong></p>
<p>部分命名习惯及语法可能有所欠缺，望指出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getPermutation</span>(<span class="params">self, n: <span class="built_in">int</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">fac</span>(<span class="params">n</span>):</span><br><span class="line">            res = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">                res *= i</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        nums = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n+<span class="number">1</span>)]</span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 1.找出对应位数-1的阶乘</span></span><br><span class="line">            <span class="comment"># 2.比如找n = 3, k = 3时，一开始就是 (3-1)! = 2</span></span><br><span class="line">            <span class="comment"># 说明有2个百位为1的，2个百位为2的，2个百位为3的数字</span></span><br><span class="line">            <span class="comment"># 3.因为我们要找的是第3个，按小到大排就是百位为2的</span></span><br><span class="line">            <span class="comment"># 4.然后我们就把第2个数字就nums数组中删掉</span></span><br><span class="line">            <span class="comment"># 5.后面的数字从第一步开始重复，直到nums数组为空</span></span><br><span class="line">            cur_fac = fac(i)</span><br><span class="line">            ind = math.ceil(k/cur_fac)</span><br><span class="line">            <span class="keyword">if</span> k&gt;cur_fac:</span><br><span class="line">                k %= cur_fac</span><br><span class="line">            cur_num = nums[ind-<span class="number">1</span>]</span><br><span class="line">            res += <span class="built_in">str</span>(cur_num)</span><br><span class="line">            nums.remove(cur_num)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p>执行用时：32 ms, 在所有 Python3 提交中击败了98.22%的用户</p>
<p>内存消耗：13.7 MB, 在所有 Python3 提交中击败了46.33%的用户</p>
]]></content>
      <categories>
        <category>刷题日志</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>油猴脚本|授人以渔</title>
    <url>/post/2020-06-01-Share/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC%20%20%E6%8E%88%E4%BA%BA%E4%BB%A5%E6%B8%94/</url>
    <content><![CDATA[<p>油猴脚本是Chrome浏览器的最强扩展，没有之一。</p>
<p>具体功能包括但不限于：</p>
<ul>
<li>百度重定向功能，去广告，优化搜索界面。</li>
<li>Bilibili直播自动签到，自动领银瓜子，自定义主页排版。</li>
<li>解除B站区域限制，真正实现在B站看进击的巨人。</li>
<li>斗鱼直播网页版优化，去广告，领礼物。</li>
</ul>
<p>下载方法：<br>
直接访问油猴脚本官网，点击Stable版的下载按钮。<br>
<a href="http://www.tampermonkey.net/">点击访问油猴脚本官网</a><br>
然后会跳转至谷歌插件页面，直接点安装即可。</p>
<p>如果不能访问谷歌商店，先下载谷歌访问助手。<br>
访问<a href="https://www.ggfwzs.com/">https://www.ggfwzs.com/</a></p>
<p>点击对应的浏览器。</p>
<p><img src="https://cdn.ethanloo.cn/img/image-20201206104742225.png" alt="image-20201206104742225"></p>
<p>可以下载获得对应的zip压缩包，解压缩之后得到crx文件。</p>
<p>在谷歌浏览器中访问<a href="chrome://extensions/">chrome://extensions/</a></p>
<p>将刚刚解压的crx文件拖进去，即可安装</p>
<p>然后再访问油猴脚本的谷歌商店界面进行安装<a href="https://chrome.google.com/webstore/detail/dhdgffkkebhmkfjojejmpbldmpobfkfo">https://chrome.google.com/webstore/detail/dhdgffkkebhmkfjojejmpbldmpobfkfo</a></p>
<p>到这里你就完成了一半工作啦。这个时候你的浏览器右上角应该多了一个黑色的标志。</p>
<p><img src="https://cdn.ethanloo.cn/img/image-20201206104838445.png" alt="image-20201206104838445"></p>
<p>点击它，再点击获取新脚本。</p>
<img src="https://cdn.ethanloo.cn/img/image-20201206104929594.png" alt="image-20201206104929594" style="zoom: 67%;" />
<p>当然你也可以直接访问<a href="https://greasyfork.org/zh-CN">https://greasyfork.org/zh-CN</a></p>
<p>开始搜索你喜欢的脚本吧！</p>
<p>找到中意的脚本之后点击安装就可以啦，然后访问你的网站，享受脚本的快乐吧！</p>
<p>这里分享一下我自用的一些脚本。</p>
<blockquote>
<p>真的是全新体验</p>
</blockquote>
<p><img src="https://cdn.ethanloo.cn/img/image-20201206105229883.png" alt="image-20201206105229883"></p>
<p><img src="https://cdn.ethanloo.cn/img/image-20201206105242457.png" alt="image-20201206105242457"></p>
<blockquote>
<p>自用的整合包：<a href="https://wws.lanzous.com/igAWLj3ib3e">https://wws.lanzous.com/igAWLj3ib3e</a></p>
</blockquote>
]]></content>
      <categories>
        <category>黑科技</category>
      </categories>
      <tags>
        <tag>黑科技分享</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库课程笔记</title>
    <url>/post/2020-06-01-Basic/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="第六章-关系数据理论">第六章 关系数据理论</h2>
<h3 id="关系模式-STUDENT（Sno-Sdept-Mname-Cno-Grade）中存在的问题">关系模式 STUDENT（Sno, Sdept, Mname, Cno, Grade）中存在的问题</h3>
<ol>
<li>数据冗余度太大，浪费存储空间。<code>如系主任的名字Mname重复出现，其重复的次数与该系所有学生的所有课程成绩出现次数相同</code></li>
<li>更新异常。<code>数据冗余，更新数据时维护数据完整性代价大。如果更换系主任，系统必须修改所有与该系学生有关的每一个元组。</code></li>
<li>插入异常，该插入的数据插不进去。<code>如果新成立一个软件工程系，还没有招生，就无法把这个系及其系主任的信息存入数据库。</code></li>
<li>删除异常，不该删除的数据也删除了。<code>如果某个系得学生全部毕业，我们在删除该系学生信息的同时，把这个系及其系主任的信息也丢掉了。</code></li>
</ol>
<blockquote>
<p>解决办法：把这个单一模式分成 3 个关系模式：<br>
S(Sno, Sdept, Sno-&gt;Sdept);<br>
SC(Sno, Cno, Grade, (Sno, Cno)-&gt;Grade);<br>
DEPT(Sdept, Mname, Sdept-&gt;Mname);<br>
这 3 个模式不会发生插入异常、删除异常毛病;数据冗余得到控制。</p>
</blockquote>
<h3 id="什么是一个好的模式">什么是一个好的模式</h3>
<p>好的模式不会发生插入异常、删除异常、更新异常、数据冗余应应可能少。<br>
<code>问题的原因：</code>模式中的某些<strong>数据依赖</strong>引起</p>
<h3 id="什么是数据依赖">什么是数据依赖</h3>
<h4 id="完整性约束的一种表现形式">完整性约束的一种表现形式</h4>
<ul>
<li>限定属性取值范围：例如学生成绩必须在 0-100 之间</li>
<li>定义属性值之间的相互关联（主要体现于值的相等于否），即通过属性间值得相等于否来描述</li>
<li>是数据库模式设计的关键</li>
</ul>
<h4 id="数据依赖">数据依赖</h4>
<ul>
<li>是通过一个关系中属性间值的相等与否体现出来的数据间的相互关系</li>
<li>是现实世界属性间相互联系的抽象</li>
<li>是数据内在的性质</li>
<li>是语义的体现</li>
</ul>
<h4 id="数据依赖的主要类型">数据依赖的主要类型</h4>
<ul>
<li>函数依赖(Functional Dependency，简记为 FD)</li>
<li>多值依赖(Multivalued Dependency，简记为 MVD)</li>
<li>连接依赖</li>
</ul>
<h4 id="数据依赖对关系模式的影响">数据依赖对关系模式的影响</h4>
<ul>
<li>不合适的数据依赖会造成插入异常、删除异常、更新异常和数据冗余问题。</li>
</ul>
<h3 id="关系模式">关系模式</h3>
<h4 id="关系模式的形式化定义R-U-D-DOM-F">关系模式的形式化定义<code>R(U, D, DOM, F)</code></h4>
<ul>
<li>R：关系名，是符号化的元组语义</li>
<li>U：该关系的属性集合</li>
<li>D：属性组 U 中属性所来自的域</li>
<li>DOM：属性向域的映象集合</li>
<li>F：属性间数据的依赖关系集合</li>
</ul>
<h4 id="关系模式的简化表示R-U-F">关系模式的简化表示<code>R&lt;U, F&gt;</code></h4>
<ul>
<li>将关系模式简化为一个三元组，影响数据库模式设计的主要是 U 和 F</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">关系模式 STUDENT<span class="operator">&lt;</span>U,F<span class="operator">&gt;</span></span><br><span class="line">U <span class="operator">=</span> &#123; Sno,Sdept,Mname,Cno,Grade &#125;</span><br><span class="line">F <span class="operator">=</span>｛ Sno→Sdept, Sdept→Mname, (Sno, Cno)→Grade｝</span><br><span class="line">STUDENT（Sno,Sdept,Mname,Cno,Grade, Sno→Sdept, Sdept→Mname,(Sno, Cno)→Grade）</span><br></pre></td></tr></table></figure>
<p><img src="https://wx2.sbimg.cn/2020/06/13/1_.md.jpg#vwid=500&amp;vhei=225" alt="第1部分_为什么要学习关系数据理论讲义.jpg"></p>
<h4 id="如何解决关系模式中存在的问题">如何解决关系模式中存在的问题</h4>
<blockquote>
<p><code>规范化理论</code>–找出关系模式种不合适的数据依赖，消除它们，可以在不同程度上解决插入异常、删除异常、更新异常和数据冗余问题。</p>
</blockquote>
<h3 id="函数依赖">函数依赖</h3>
<h4 id="函数依赖定义">函数依赖定义</h4>
<p>设 R(U)是一个属性集 U 上的关系模式，X 和 Y 是 U 的子集。若对于 R(U)的任意一个可能的关系 r，r 中不可能存在两个元组在 X 上的属性值相等， 而在 Y 上的属性值不等则称“X 函数确定 Y”或“<code>Y函数依赖于X</code>”，记作<code>X→Y</code>。<br>
X 称为这个函数依赖的决定属性组，也称为<code>决定因素</code>(Determinant)。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">例： S(Sno, Sname, Ssex, Sage, Sdept)</span><br><span class="line">F＝ &#123;Sno→Sname，Sno→Ssex，Sno→Sage，Sno→Sdept&#125;</span><br></pre></td></tr></table></figure>
<h4 id="如何确定函数依赖">如何确定函数依赖</h4>
<ul>
<li>
<p>函数依赖是语义范畴的概念。只能根据数据的语义来确定函数依赖。<br>
<code>如Sname →Sno函数依赖只有在“学生不允许有重名”的条件下成立。</code></p>
</li>
<li>
<p>数据库设计者可以对现实世界作强制的规定。<br>
<code>例如设计者可以强行规定不允许学生有重名，因而使函数依赖Sname →Sno，Sname →Ssex， Sname →Sage，Sname→Sdept成立。</code></p>
</li>
<li>
<p>函数依赖是指关系模式 R 在任何时刻的关系实例均要满足的约束条件。<br>
<code>不是指某个或某些关系实例 r 满足的约束条件，而是指R的所有关系实例 r 均要满足的约束条件。</code></p>
</li>
</ul>
<h4 id="平凡函数依赖">平凡函数依赖</h4>
<ul>
<li>X→Y，Y⊈X，则称 X→Y 是非平凡的函数依赖。</li>
<li>X→Y，但 Y⊆X ，则称 X→Y 是平凡的函数依赖。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">例：在关系SC(Sno, Cno, Grade)中，</span><br><span class="line">非平凡函数依赖： (Sno, Cno) → Grade</span><br><span class="line">平凡函数依赖： (Sno, Cno) → Sno (Sno, Cno) → Cno</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义，因此若不特别声明， 我们总是讨论非平凡函数依赖。</p>
</blockquote>
<h4 id="完全函数依赖与部分函数依赖">完全函数依赖与部分函数依赖</h4>
<p>在关系模式 R(U)中，如果 X→Y，并且对于 X 的任何一个真子集 X’，都有<br>
X’↛Y, 则称 Y 完全函数依赖于 X，记作 X (F→) Y。若 X→Y，但 Y 不完全函数依<br>
赖于 X，则称 Y 部分函数依赖于 X，记作 X (P→) Y。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[例] 在关系STUDENT（Sno ,Sdept, Mname,Cno,Grade）中，</span><br><span class="line">(Sno, Cno) (F→) Grade 是完全函数依赖</span><br><span class="line">(Sno, Cno) (P→) Sdept 是部分函数依赖，因为Sno → Sdept。</span><br></pre></td></tr></table></figure>
<h4 id="传递函数依赖">传递函数依赖</h4>
<p>在 R（U）中，如果 X→Y，（Y⊈X），Y 不依赖于 X，Y→Z，则称 Z 对 X 传递函数依赖（transitive functional dependency）。记为：X (传递 →) Z。</p>
<blockquote>
<p>注意: 如果 Y→X, 即 X←→Y，则 Z 直接依赖于 X。</p>
</blockquote>
<p><code>在关系STUDENT（Sno ,Sdept, Mname,Cno,Grade）中， Sno → Sdept，Sdept → Mname，Sno (传递→) Mname</code></p>
<h3 id="码">码</h3>
<p>设 K 为关系模式 R&lt;U,F&gt;中的属性或属性组合。若 K → U，则 K 称为 R 的一个<code>候选码(Candidate Key)</code>。</p>
<ul>
<li>如果 U 部分函数依赖于 K，即 K (P→) U,则 K 称为<code>超码（Surpkey）</code></li>
<li>候选码是最小的超码，即 K 的任意一个真子集都不是候选码</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[例] S(<span class="operator">*</span><span class="operator">*</span>Sno<span class="operator">*</span><span class="operator">*</span>, Sdept, Sage)</span><br><span class="line">Sno→（Sno, Sdept，Sage）， Sno是码</span><br><span class="line">(Sno, Sdept)、 (Sno, Sage)、 (Sno, Sdept, Sage) 是超码</span><br><span class="line">SC(<span class="operator">*</span><span class="operator">*</span>Sno, Cno<span class="operator">*</span><span class="operator">*</span>, Grade)中，(Sno, Cno)是码</span><br></pre></td></tr></table></figure>
<p>若关系模式 R 有多个候选码，则选定其中一个作为<code>主码</code>(Primary key)。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[例] S(<span class="operator">*</span><span class="operator">*</span>Sno, Sname<span class="operator">*</span><span class="operator">*</span>, Sdept, Sage)， 假设学生无重名</span><br><span class="line">Sno、 Sname是候选码，选择Sno为主码。</span><br></pre></td></tr></table></figure>
<h4 id="主属性与非主属性">主属性与非主属性</h4>
<ul>
<li>包含在任何一个候选码中的属性，成为主属性。</li>
<li>不包含在任何码中的属性成为非主属性或非码属性。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[例] S(Sno, Sdept, Sage)，Sno是码， Sno是主属性， Sdept, Sage是非主属性。</span><br><span class="line">SC(Sno, Cno, Grade)中，(Sno, Cno)是码，</span><br><span class="line">Sno, Cno是主属性， Grade是非主属性</span><br></pre></td></tr></table></figure>
<h4 id="全码">全码</h4>
<ul>
<li>整个属性组是码，称为全码</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[例] 关系模式 R（P，W，A） P：演奏者 W：作品 A：听众</span><br><span class="line">语义：一个演奏者可以演奏多个作品，某一作品可被多个演奏者演奏，听众可以欣</span><br><span class="line">赏不同演奏者的不同作品</span><br><span class="line">R（P，W，A）码为(P，W，A)，即全码，<span class="keyword">All</span><span class="operator">-</span>Key。</span><br></pre></td></tr></table></figure>
<h4 id="外部码">外部码</h4>
<ul>
<li>关系模式 R&lt;U,F&gt;，U 中属性或属性组 X 并非 R 的码，但 X 是另一个关系模式的码，则称 X 是 R 的<code>外部码（Foreign key）</code>也称<code>外码</code>。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SC（Sno，Cno，Grade）中，Sno不是码，但Sno是关系模式</span><br><span class="line">S（Sno，Sdept，Sage）的码，则Sno是关系模式SC的外部码。</span><br></pre></td></tr></table></figure>
<ul>
<li>主码与外部码一起提供了表示关系间联系的手段</li>
</ul>
<h3 id="范式">范式</h3>
<ul>
<li>范式是符合某一种级别的关系模式的集合。</li>
<li>关系数据库中的关系必须满足一定的要求。</li>
<li>满足不同程度要求的为不同范式。</li>
<li>1NF \supset 2NF \supset 3NF \supset BCNF \supset 4NF \supset 5NF</li>
</ul>
<blockquote>
<p>一个低一级范式的关系模式，通过模式分解（schema decomposition）可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化（normalization）。</p>
</blockquote>
<h4 id="1NF">1NF</h4>
<ul>
<li>定义：如果一个关系模式 R 的所有属性都是不可分的基本数据项，则 R∈1NF。</li>
<li>第一范式是对关系模式的最起码的要求。不满足第一范式的数据库模式不能称为关系数据模式。</li>
</ul>
<h4 id="2NF">2NF</h4>
<ul>
<li>定义:若关系模式 R∈1NF，并且每一个非主属性都完全函数依赖于 R 的码，则 R∈2NF。</li>
</ul>
<blockquote>
<p>一个关系模式 R 不属于 2NF 会产生的问题</p>
</blockquote>
<ol>
<li>插入异常</li>
<li>删除异常</li>
<li>数据冗余度大</li>
<li>修改复杂</li>
</ol>
<blockquote>
<p>2NF 还会存在的问题</p>
</blockquote>
<ul>
<li>不能完全消除关系模式种的各种异常情况和数据冗余</li>
</ul>
<h4 id="3NF">3NF</h4>
<ul>
<li>定义:关系模式 R&lt;U，F&gt;∈1NF,若 R 中不存在这样的码 X、属性组 Y 及非主属性 Z（Y⊇ Z）,使得 X→Y，Y→Z，Y (-<code>\</code>-&gt;) X，成立，则称 R&lt;U，F&gt; ∈ 3NF。</li>
</ul>
<p><code>例如:S-D(Sno, Sdept) ∈ 3NF, D-L（Sdept， Sloc）∈ 3NF</code></p>
<h4 id="3NF-的一些性质">3NF 的一些性质</h4>
<ul>
<li>若 R∈3NF，则 R 的每一个非主属性既不部分函数依赖于候选码也不传递函数依赖于候选码。</li>
<li>采用投影分解法将一个 2NF 的关系分解为多个 3NF 的关系，可以在一定程度上解决原 2NF 关系中存在的插入异常、删除异常、数据冗余度大、修改复杂等问题。</li>
<li>将一个 2NF 关系分解为多个 3NF 的关系后，并不能完全消除关系模式中的<code>各种异常情况</code>和<code>数据冗余</code>。</li>
</ul>
<h4 id="BCNF">BCNF</h4>
<ul>
<li>定义：设关系模式 R&lt;U，F&gt;∈1NF，如果对于 R 的每个函数依赖 X→Y，且 X ⊇ Y 时，X 必含有码，那么 R∈BCNF。</li>
<li>即，在关系模式 R&lt;U，F&gt;中，如果每一个决定因素都包含码，则 R∈BCNF。</li>
</ul>
<h4 id="BCNF-的性质">BCNF 的性质</h4>
<ol>
<li>所有非主属性对每一个码都是完全函数依赖。</li>
<li>所有主属性对每一个不包含它的码也是完全函数依赖。</li>
<li>没有任何属性完全函数依赖于非码的任何一组属性。</li>
</ol>
<blockquote>
<p>如果一个关系数据库中的所有关系模式都属于 BCNF，那么在函数依赖范畴内，它已实现了模式的彻底分解，达到了最高的规范化程度，消除了操作异常诸多问题。</p>
</blockquote>
<h3 id="规范化小结">规范化小结</h3>
<ul>
<li>一个关系模式只要<code>其分量都是不可分的数据项</code>，它就是规范化的关系模式，但这只是最基本的规范化。</li>
<li>规范化程度过低的关系模式不一定能够很好地描述现实世界，可能会存在插入异常、删除异常、修改复杂、数据冗余等问题，解决方式就是对其进行规范化，转换成高级范式。</li>
<li>一个低一级范式的关系模式，通过模式分解可以转换为若干个高一级的关系模式集合，这种过程就叫关系模式的规范化。</li>
<li>关系数据库的规范化理论是数据库逻辑设计的工具。</li>
</ul>
<h4 id="关系模式规范化的基本步骤">关系模式规范化的基本步骤</h4>
<ol>
<li>1NF-&gt;2NF，消除非主属性对码的部分函数依赖</li>
<li>2NF-&gt;3NF，消除非主属性对码的传递函数依赖</li>
<li>3NF-&gt;BCNF，消除主属性对码的部分和传递函数依赖</li>
<li>BCNF-&gt;4NF，消除非平凡且非函数依赖的多值依赖</li>
</ol>
<h4 id="规范化的基本思想">规范化的基本思想</h4>
<ul>
<li>逐步消除数据依赖中不合适的部分，使模式中的个关系模式，达到某种程度的分离。</li>
<li>采用“一事一地”的模式设计原则</li>
<li>规范化实质上是概念的单一化</li>
</ul>
<h3 id="数据依赖的公理系统">数据依赖的公理系统</h3>
<ul>
<li>数据依赖的公理系统是模式分解算法的理论基础。</li>
<li>函数依赖的一个有效而完备的公理系统——Armstrong 公理系统，</li>
</ul>
<h4 id="逻辑蕴含">逻辑蕴含</h4>
<p>定义：对于满足一组函数依赖 F 的关系模式 R &lt;U，F&gt;，其任何一个关系 r，若函数依赖 X→Y 都成立（即 r 中任意两元组 t，s，若 t [X]=s [X]，则 t [Y] = s [Y]），则称 F 逻辑蕴含 X→Y。</p>
<h4 id="Armstrong-公理系统">Armstrong 公理系统</h4>
<p>设 U 为属性集总体，F 是 U 上的一组函数依赖， 于是有关系模式 R &lt;U，F &gt;。对 R &lt;U，F&gt; 来说有以下的推理规则：</p>
<ul>
<li>Al. 自反律(Reflexivity)：若 Y ⊆ X ⊆ U，则 X →Y 为 F 所蕴含。</li>
<li>A2. 增广律(Augmentation)：若 X→Y 为 F 所蕴含，且 Z ⊆ U，则 XZ→YZ 为 F 所蕴含。</li>
<li>A3. 传递律(Transitivity)：若 X→Y 及 Y→Z 为 F 所蕴含，则 X→Z 为 F 所蕴含。</li>
</ul>
<h4 id="函数依赖闭包">函数依赖闭包</h4>
<ul>
<li>在关系模式 R&lt;U，F&gt;中为 F 所逻辑蕴含的函数依赖的全体叫作 F 的闭包（closure），记为 F+。</li>
<li>设 F 为属性集 U 上的一组函数依赖，X ⊆U， XF+ ={ A|X→A 能由 F 根据 Armstrong 公理导出}，XF+称为属性集 X 关于函数依赖集 F 的闭包。</li>
</ul>
<h4 id="求属性集-X-关于-F-的闭包-XF">求属性集 X 关于 F 的闭包 XF+</h4>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">已知关系模式R<span class="operator">&lt;</span>U, F<span class="operator">&gt;</span>，其中U<span class="operator">=</span>&#123;A,B,C,D,E&#125;；</span><br><span class="line">F<span class="operator">=</span>&#123;AB<span class="operator">-</span><span class="operator">&gt;</span>C,B<span class="operator">-</span><span class="operator">&gt;</span>D,C<span class="operator">-</span><span class="operator">&gt;</span>E,EC<span class="operator">-</span><span class="operator">&gt;</span>B,AC<span class="operator">-</span><span class="operator">&gt;</span>B&#125;。</span><br><span class="line">求(AB)F<span class="operator">+</span></span><br><span class="line">设X(<span class="number">0</span>)<span class="operator">=</span>AB</span><br><span class="line">X(<span class="number">1</span>)<span class="operator">=</span>AB U CD<span class="operator">=</span>ABCD</span><br><span class="line">X(<span class="number">2</span>)<span class="operator">=</span>X(<span class="number">1</span>) U BE<span class="operator">=</span>ABCDE</span><br><span class="line">(AB)F<span class="operator">+</span><span class="operator">=</span>ABCDE</span><br><span class="line">计算X(<span class="number">1</span>)；</span><br><span class="line">因为X(<span class="number">0</span>) ≠ X(<span class="number">1</span>)，计算X(<span class="number">2</span>)；</span><br><span class="line">这时X(<span class="number">2</span>) ≠ X(<span class="number">1</span>)，但X(<span class="number">2</span>) 已等于全部属性集合U，所以</span><br></pre></td></tr></table></figure>
<h4 id="Armstrong-公理系统的有效性与完备性">Armstrong 公理系统的有效性与完备性</h4>
<ul>
<li>有效性：由 F 出发根据 Armstrong 公理推导出来的每一个函数依赖一定在 F+中</li>
<li>完备性：F+中的每一个函数依赖，必定可以由 F 出发根据 Armstrong 公理推导出来</li>
</ul>
<h4 id="函数依赖集等价的概念">函数依赖集等价的概念</h4>
<ul>
<li>如果 G+=F+，就说函数依赖集 F 覆盖 G（F 是 G 的覆盖，或 G 是 F 的覆盖），或 F 与 G 等价。</li>
</ul>
<blockquote>
<p>两个函数依赖集等价是指它们的闭包等价</p>
</blockquote>
<h4 id="最小依赖集">最小依赖集</h4>
<ul>
<li>如果函数依赖集 F 满足下列条件，则称 F 为一个最小依赖集。</li>
</ul>
<ol>
<li>F 中任一函数依赖的右部仅含有一个属性。</li>
<li>F 中不存在这样的函数依赖 X→A，使得 F 与 F-{X→A}等价。</li>
<li>F 中不存在这样的函数依赖 X→A，X 有真子集 Z 使得 F-{X→A}∪{Z→A}与 F 等价。</li>
</ol>
<h3 id="模式分解">模式分解</h3>
<ul>
<li>
<p>R&lt;U, F&gt;的一个分解是指：ρ={R1&lt;U1, F1&gt;, …, Rn&lt;Un, Fn&gt;} ，其中 U= U1∪U2∪… ∪Un，并且没有 Ui ⊆ Uj，1 ≤ i，j ≤ n，Fi 是 F 在 Ui 上的投影。</p>
</li>
<li>
<p>把低一级的关系模式分解为若干个高一级的关系模式并不是唯一的</p>
</li>
<li>
<p>在这些分解方法中，只有能够保证分解后的关系模式与原关系模式等价的方法才有意义</p>
</li>
<li>
<p>从不同的角度去观察问题，对“等价”的概念形成了 3 种不同的定义：</p>
<ol>
<li>分解具有无损连接性（lossless join）</li>
<li>分解要保持函数依赖（preserve functional dependency）</li>
<li>分解既要保持函数依赖，又要具有无损连接性</li>
</ol>
</li>
</ul>
<h4 id="具有无损连接性的模式分解">具有无损连接性的模式分解</h4>
<ul>
<li>ρ={R1&lt;U1, F1&gt;, …, Rn&lt;Un, Fn&gt;}是 R&lt;U, F&gt;的一个分解，若对<br>
R&lt;U, F&gt;的任何一个关系 r 均有 r = r 在 ρ 中各关系模式上投影的<br>
自然连接成立，则称分解 ρ 具有无损连接性。简称 ρ 为无损分解。</li>
</ul>
<blockquote>
<p>只有具有无损连接性的分解才能够保证不丢失信息。<br>
无损连接性不一定能解决插入异常、删除异常、修改复杂、数据冗余等问题。</p>
</blockquote>
<h4 id="保持函数依赖的模式分解">保持函数依赖的模式分解</h4>
<ul>
<li>ρ={R1&lt;U1, F1&gt;, …, Rn&lt;Un, Fn&gt;} 是 R&lt;U, F&gt;的一个分解，若 F 所逻辑蕴含的函数依赖一定也为分解后所有的关系模式中的函数依赖 Fi 所逻辑蕴含，即 F+ = ( F1 ∪ F2 ∪ … ∪ Fn )+，则称关系模式 R 的这个分解是保持函数依赖的（Preserve dependency）</li>
</ul>
<h4 id="分解的无损连接性和保持函数依赖性">分解的无损连接性和保持函数依赖性</h4>
<ul>
<li>如果一个分解具有无损连接性，则它能够保证不丢失信息。</li>
<li>如果一个分解保持了函数依赖，则它可以减轻或解决各种异常情况。</li>
<li>分解具有无损连接性和分解保持函数依赖是两个互相独立的标准。</li>
</ul>
<ol>
<li>若要求分解保持函数依赖，那么模式分解一定能够达到 3NF，但不一定能够达到 BCNF。</li>
<li>若要求分解既具有无损连接性，又保持函数依赖，则模式分解一定能够达到 3NF，但不一定能够达到 BCNF。</li>
<li>若要求分解具有无损连接性，那么模式分解一定能够达到 4NF。</li>
</ol>
<h2 id="数据库设计">数据库设计</h2>
<h3 id="概述">概述</h3>
<p>广义地讲，是数据库及其应用系统的设计，即设计整个数据库应用系统；<br>
狭义地讲，是设计数据库本身，即设计数据库的各级模式并建立数据库，这是数据库应用系统设计的一部分。</p>
<ul>
<li><code>定义</code>：数据库设计是指对于一个给定的应用环境，设计一个优良的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效地存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据处理求：
<ol>
<li>信息管理要求：在数据库中存储和管理需要的数据对象。</li>
<li>数据处理要求：对数据对象需要进行的处理，如查询、增删改、统计和分析等。</li>
</ol>
</li>
</ul>
<h4 id="数据库设计特点">数据库设计特点</h4>
<ol>
<li>
<p>基本规律</p>
<ul>
<li>三分技术，七分管理，十二分基础数据</li>
<li>管理包括：数据库建设项目管理和企业的业务管理。</li>
<li>基础数据：数据的收集、整理、组织和不断更新</li>
</ul>
</li>
<li>
<p>结构设计和行为设计相结合</p>
<ul>
<li>
<p>将数据库结构设计和数据处理设计相结合</p>
</li>
<li>
<p>传统的软件工程：重行为设计</p>
<blockquote>
<p>忽视对应用中数据语义的分析和抽象，只要有可能就尽量推迟数据结构设计</p>
</blockquote>
</li>
<li>
<p>早期的数据库设计：重结构设计</p>
<blockquote>
<p>致力于数据模型和数据库建模方法研究，忽视了行为设计对结构设计的影响</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h4 id="数据库设计方法">数据库设计方法</h4>
<ul>
<li>大型数据库设计是涉及多学科的综合性技术，又是一项庞大的工程项目。</li>
<li>要求多方面的知识和技术，主要包括：
<ol>
<li>计算机的基础知识</li>
<li>软件工程的原理和方法</li>
<li>程序设计的方法和技巧</li>
<li>数据库的基本知识</li>
<li>数据库设计技术</li>
<li>应用领域的知识</li>
</ol>
</li>
</ul>
<ol>
<li>手工设计法
<ul>
<li>设计质量与设计人员的经验和水平有直接关系</li>
<li>缺乏科学理论和工程方法的支持，工程的质量难以保证</li>
<li>数据库运行一段时间后常常又不同程度地发现各种问题，增加了维护代价。</li>
</ul>
</li>
<li>规范设计法</li>
</ol>
<p><code>典型方法——新奥尔良（New Orleans）方法</code> - 将数据库设计分为若干阶段和步骤 - 采用辅助手段实现每一过程 - 按设计规程用工程化方法设计数据库<br>
<code>基于E-R模型的设计方法</code> - 概念设计阶段广泛采用<br>
<code>3NF（第三范式）的设计方法</code> - 逻辑阶段可采用的有效方法<br>
<code>ODL(Object Definition Language)方法</code> - 面向对象的数据库设计方法<br>
<code>UML(Unified Modeling Language)方法</code> - 面向对象的建模方法</p>
<h4 id="数据库设计的基本步骤">数据库设计的基本步骤</h4>
<p>数据库设计分 6 个阶段</p>
<ul>
<li>独立于任何数据库管理系统
<ol>
<li>需求分析<br>
是否做得充分与准确，决定了构建数据库的速度和质量。</li>
<li>概念结构设计<br>
对用户需求进行综合、归纳与抽象，形成独立于具体 DBMS 的概念模型</li>
</ol>
</li>
<li>与选用的数据库管理系统密切相关<br>
3. 逻辑结构设计<br>
将概念结构转换为某个 DBMS 所支持的数据模型，并对其进行优化<br>
4. 物理结构设计<br>
为逻辑数据结构选取一个最适合应用环境的物理结构，包括存储结构和存取方法</li>
<li>最终阶段 5. 数据库实施<br>
根据逻辑设计和物理设计的结果构建数据库，编写与调试应用程序，组织数据入库并进行试运行。 6. 数据库运行和维护<br>
经过试运行后即可投入正式运行。<br>
在运行过程中必须不断对数据库设计进行评估、调整与修改。<br>
<img src="https://wx1.sbimg.cn/2020/06/14/2_.jpg#vwid=667&amp;vhei=349" alt="2_.jpg"></li>
</ul>
<h4 id="参与数据库设计的人员">参与数据库设计的人员</h4>
<ul>
<li>
<p>系统分析人员和数据库设计人员</p>
<blockquote>
<p>自始至终参与数据库设计</p>
</blockquote>
</li>
<li>
<p>数据库管理员和用户代表</p>
<blockquote>
<p>主要参加需求分析与数据库的运行和维护</p>
</blockquote>
</li>
<li>
<p>应用开发人员</p>
<blockquote>
<p>包括程序员和操作员<br>
在实施阶段参与进来,分别负责编制程序和准备软硬件环境</p>
</blockquote>
</li>
</ul>
<h4 id="数据库设计过程中的各级模式">数据库设计过程中的各级模式</h4>
<ul>
<li>需求分析阶段:综合各个用户的需求</li>
<li>概念设计阶段:形成独立于机器特点,独立于各个 DBMS 产品的概念模式(E-R 图)</li>
<li>逻辑设计阶段:
<ol>
<li>首先将 E-R 图转换成具体的数据库产品支持的数据模型,如关系模型,形成数据库<code>逻辑模式</code></li>
<li>然后根据用户处理的要求,安全性的考虑,在基本表的基础上再建立必要的视图(View),形成数据的<code>外模式</code></li>
</ol>
</li>
<li>物理设计阶段:根据数据库管理系统特点和处理的需要,进行物理存储安排,建立索引,形成数据库<code>内模式</code></li>
</ul>
<h3 id="需求分析">需求分析</h3>
<ul>
<li>需求分析的重要性:
<ul>
<li>结果是否准确地反映了用户的实际要求,将直接影响到后面各个阶段的设计,并影响到设计结果是否合理和实用</li>
</ul>
</li>
</ul>
<h4 id="需求分析的任务">需求分析的任务</h4>
<ul>
<li>充分了解原系统工作概况</li>
<li>详细调查要开发的应用系统的组织/部门/企业等</li>
<li>明确用户的各种需求</li>
</ul>
<h4 id="需求分析的方法">需求分析的方法</h4>
<p><img src="https://wx2.sbimg.cn/2020/06/14/2_.jpg#vwid=667&amp;vhei=349" alt="2_.jpg"></p>
<h4 id="数据字典">数据字典</h4>
<ul>
<li>
<p>定义:数据字典是关于数据库中数据的描述,称为元数据。</p>
<blockquote>
<p>它不是数据本身，而是数据的数据。</p>
</blockquote>
</li>
<li>
<p>数据字典在需求分析阶段建立，在数据库设计过程中不断修改、充实、完善。</p>
</li>
<li>
<p>数据字典是进行详细的数据收集和分析所获得主要结果。</p>
</li>
<li>
<p>数据字典的内容</p>
<ul>
<li>数据项</li>
<li>数据结构</li>
<li>数据流</li>
<li>数据存储</li>
<li>处理过程</li>
</ul>
</li>
</ul>
<blockquote>
<p>数据项是数据的最小组成单位<br>
若干个数据项可以组成一个数据结构<br>
通过对数据项和数据结构的定义来描述数据流、数据存储的逻辑内容</p>
</blockquote>
<h4 id="数据项">数据项</h4>
<ul>
<li>
<p>数据项描述 = {数据项名,数据项含义说明,别名, 数据类型,长度,取值范围,取值含义,与其他数据项的逻辑关系, 数据项之间的联系}</p>
</li>
<li>
<p>关系规范化理论为指导，用数据依赖的概念分析和抽象数据项之间的联系——函数依赖</p>
</li>
<li>
<p>“取值范围”、“与其他数据项的逻辑关系”定义了数据的完整性约束条件，是模式设计、完整性检查条件、触发器、存储过程的依据</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据项：学号</span><br><span class="line">    含义说明：  唯一标识每个学生</span><br><span class="line">    别名：      学生编号</span><br><span class="line">    类型：      字符型</span><br><span class="line">    长度：      9</span><br><span class="line">    取值范围：  0000 00 000至9999 99 999</span><br><span class="line">    取值含义:   前4位标识该学生入学年份，5、6位为所在专业系编号，后3位按顺序编号，例如2016 15 008</span><br><span class="line">    与其他数据项的逻辑关系：学号的值确定了其他数据项的值</span><br></pre></td></tr></table></figure>
<h4 id="数据结构">数据结构</h4>
<ul>
<li>
<p>数据结构反映了数据之间的组合关系。</p>
<blockquote>
<p>一个数据结构可以由若干个数据项组成，也可以由若干个数据结构组成，或由若干个数据项和数据结构混合组成。</p>
</blockquote>
</li>
<li>
<p>数据结构描述= {数据结构名，含义说明，组成: {数据项或数据结构} }</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据结构：  学生</span><br><span class="line">含义说明：  学籍管理子系统的主题数据结构，定义了一个学生的有关信息</span><br><span class="line">组成：      学号，姓名，性别，年龄，所在系，年级</span><br></pre></td></tr></table></figure>
<h4 id="数据流">数据流</h4>
<ul>
<li>数据流是数据结构在系统内部传输的路径。</li>
<li>数据流描述={ 数据流名,说明,数据流来源,数据流去向,组成: {数据结构}, 平均流量,高峰期流量 }
<ul>
<li>数据流来源：说明该数据流来自哪个处理过程/数据存储</li>
<li>数据流去向：说明该数据流将到哪个处理过程/数据存储去</li>
<li>平均流量：在单位时间（每天、每周、每月等）里的传输次数</li>
<li>高峰期流量：在高峰时期的数据流量</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据流：    体检结果</span><br><span class="line">说明：      学生参加体格检查的最终报告</span><br><span class="line">数据流来源:  体检（处理过程）</span><br><span class="line">数据流去向:  批准（处理过程</span><br><span class="line">组成：      &#123; 学号， &#123;血常规&#125;，&#123;尿常规&#125;，&#123;血液生化&#125;，&#123;心电图&#125;，&#123;B超&#125;, … … &#123;其他体检&#125; &#125;</span><br><span class="line">平均流量：   每天200</span><br><span class="line">高峰期流量： 每天400</span><br></pre></td></tr></table></figure>
<h4 id="数据存储">数据存储</h4>
<ul>
<li>数据存储是数据结构停留或保存的地方，也是数据流的来源和去向之一。</li>
<li>数据存储描述={数据存储名,说明,编号,输入的数据流 ,输出的数据流, 组成: {数据结构}, 数据量, 存取频度, 存取方式}
<ul>
<li>存取频度：每小时、每天或每周存取次数，每次存取的数据量等信息</li>
<li>存取方法：批处理 / 联机处理；检索 / 更新；顺序检索 / 随机检索</li>
<li>输入的数据流：数据来源</li>
<li>输出的数据流：数据去向</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据存储：      学生登记表</span><br><span class="line">说明:           记录学生的基本情况</span><br><span class="line">输入数据流：    每学期5000</span><br><span class="line">输出数据流：    每学期5000</span><br><span class="line">组成：          &#123;学号，姓名，性别，年龄，所在系，年级，&#123;学习成绩&#125;，&#123;体检结果&#125;，&#123;奖惩记录&#125; … … &#125;</span><br><span class="line">数据量：        每年10000张</span><br><span class="line">存取方式：      随机存取+按照专业系/班级打印</span><br></pre></td></tr></table></figure>
<h4 id="处理过程">处理过程</h4>
<ul>
<li>具体处理逻辑一般用判定表或判定树来描述。</li>
<li>数据字典中只需要描述处理过程的说明性信息。</li>
<li>处理过程描述={ 处理过程名, 说明, 输入:{数据流},输出:{数据流}, 处理:{简要说明} }</li>
<li>简要说明：说明该处理过程的功能及处理要求
<ul>
<li>功能：该处理过程用来做什么</li>
<li>处理要求：处理频度要求，如单位时间里处理多少事务，多少数据量、响应时间要求等。</li>
<li>处理要求是<code>物理设计的输入</code>及<code>性能评价的标准</code></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">处理过程：      分配宿舍</span><br><span class="line">说明：          为所有新生分配学生宿舍</span><br><span class="line">输入：          学生，宿舍</span><br><span class="line">输出：          宿舍安排</span><br><span class="line">处理：          在新生报道后，为所有新生分配学生宿舍</span><br><span class="line">要求同一间宿舍只能安排同一年级同一性别的学生。</span><br><span class="line">一个学生只能安排在一个宿舍中，每个学生的居住面积不小于6平方米。</span><br><span class="line">安排新生宿舍其处理时间应不超过15分钟。</span><br></pre></td></tr></table></figure>
<h3 id="概念模型">概念模型</h3>
<ul>
<li>
<p>什么是概念模型<br>
将需求分析得到的用户需求抽象为信息结构即概念模型的过程就是概念结构设计；<br>
概念结构是现实世界的一个真实模型。是各种数据模型的共同基础，它比数据模型更独立于机器、更抽象，从而更加稳定；<br>
概念结构设计是数据库设计的关键。</p>
</li>
<li>
<p>概念模型的用途</p>
<ul>
<li>概念模型用于信息世界的建模</li>
<li>使现实世界到机器世界的一个中间层次</li>
<li>是数据库设计的有力工具</li>
<li>是数据库设计人员和用户之间进行交流的工具</li>
</ul>
</li>
<li>
<p>对概念模型的基本要求</p>
<ul>
<li>较强的语义表达能力</li>
<li>简单、清晰、易于用户理解</li>
</ul>
</li>
</ul>
<h4 id="信息世界中的基本概念">信息世界中的基本概念</h4>
<ul>
<li>
<p>实体（Entity）<br>
客观存在并可相互区别的事物称为实体，可以是具体的人、事、物或抽象的概念。</p>
</li>
<li>
<p>属性（Attribute）<br>
实体所具有的某一特性称为属性。一个实体可以由若干个属性来刻画。</p>
</li>
<li>
<p>码（Key）<br>
唯一标识实体的属性集称为码。</p>
</li>
<li>
<p>实体型（Entity Type）<br>
用实体名及其属性名集合来抽象和刻画同类实体称为实体型</p>
</li>
<li>
<p>实体集（Entity Set）<br>
同一类型实体的集合称为实体集</p>
</li>
<li>
<p>联系（Relationship）</p>
<ul>
<li>
<p>现实世界中事物内部以及事物之间的联系在信息世界中反映为实体（型）内部的联系和实体（型）之间的联系。</p>
</li>
<li>
<p>实体内部的联系: 是指组成实体的各属性之间的联系</p>
</li>
<li>
<p>实体之间的联系: 通常是指不同实体集之间的联系</p>
<blockquote>
<p>实体之间的联系有一对一（1:1）、一对多（1:m）和多对多（m:n）等多种类型</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>实体-联系方法（Entity-Relationship Approach）<br>
<img src="https://wx2.sbimg.cn/2020/06/14/1_E-R.jpg#vwid=799&amp;vhei=417" alt="1_E-R.jpg"></p>
</li>
</ul>
<h4 id="概念结构设计">概念结构设计</h4>
<h5 id="实体与属性的划分原则">实体与属性的划分原则</h5>
<blockquote>
<p>现实世界的事物能作为属性对待的，尽量作为属性对待</p>
</blockquote>
<ul>
<li>划分实体与属性的两条准则：
<ol>
<li>作为属性，不能再具有须有描述的性质。属性必须是不可分的数据项，不能包含其他属性。</li>
<li>属性不能与其他实体具有联系。E-R 图中所表示的联系是实体与实体之间的联系。</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[例1] 职工实体：职工号、姓名、年龄是职工的属性，如何设计职称？</span><br><span class="line">- 如果不存储和处理与职称相关的工资、福利，根据准则（1）设计为职工的属性。</span><br><span class="line">- 如果需要存储或处理：与职称相关的工资、津贴、附加福利等，则职称应设计为一个实体。</span><br></pre></td></tr></table></figure>
<p><img src="https://wx2.sbimg.cn/2020/06/14/1_.jpg#vwid=746&amp;vhei=521" alt="1_.jpg"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[例<span class="number">2</span>] 医院中病人实体，如何设计病房？</span><br><span class="line"><span class="operator">-</span> 一个病人只能住在一个病房，病房号可以作为病人实体的一个属性；</span><br><span class="line"><span class="operator">-</span> 如果病房还要与医生实体发生联系，即一个医生负责若干病房的病人的医疗工作，则根据准则（<span class="number">2</span>） 病房应作为一个实体。</span><br></pre></td></tr></table></figure>
<p><img src="https://wx1.sbimg.cn/2020/06/14/1_2.jpg#vwid=1026&amp;vhei=408" alt="1_2.jpg"></p>
<h4 id="E-R-图的集成">E-R 图的集成</h4>
<ul>
<li><code>合并</code>，解决各分 E-R 图之间的冲突，将分 E-R 图合并，生成初步 E-R 图。
<ul>
<li>各个局部应用所面向的问题不同，各个子系统的 E-R 图之间必定会存在许多不一致的地方，称之为冲突。</li>
<li>子系统 E-R 图之间的冲突主要有三类： 1. 属性冲突 2. 命名冲突 3. 结构冲突</li>
</ul>
</li>
</ul>
<ol>
<li>
<p>属性冲突</p>
<ul>
<li>
<p>属性域冲突，即属性值的类型、取值范围或取值集合不同。</p>
<blockquote>
<p>例如零件号，有的部门把它定义为整数，有的部门把它定义为字符型。<br>
年龄，某些部门以出生日期形式表示职工的年龄，有的用整数表示职工的年龄。</p>
</blockquote>
</li>
<li>
<p>属性取值单位冲突。</p>
<blockquote>
<p>例如零件的重量有的以公斤为单位，有的以斤为单位，有的以克为单位。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>命名冲突</p>
<ul>
<li>
<p>同名异义，即不同意义的对象在不同的局部应用中具有相同的名字。</p>
</li>
<li>
<p>异名同义（一义多名），即同一意义的对象在不同的局部应用中具有不同的名字。</p>
<blockquote>
<p>如对科研项目，财务科称为项目，科研处称为课题，生产管理处称为工程。</p>
</blockquote>
</li>
<li>
<p>命名冲突</p>
<blockquote>
<p>可能发生在实体、联系一级上<br>
也可能发生在属性一级上<br>
通过讨论、协商等行政手段加以解决</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>结构冲突</p>
<ul>
<li>
<p>同一对象在不同应用中具有不同的抽象。</p>
<blockquote>
<p>例如，职工在某一局部应用中被当作实体，而在另一局部应用中被当作属性。<br>
解决方法：把属性变换为实体或把实体变换为属性，使同一对象具有相同的抽象。</p>
</blockquote>
</li>
<li>
<p>同一实体在不同子系统的 E-R 图中的属性个数和属性排列次序不完全相同。</p>
<blockquote>
<p>解决方法：取各子系统的 E-R 图中属性的并集，再适当调整属性的次序。</p>
</blockquote>
</li>
<li>
<p>实体间的联系在不同的 E-R 图中为不同的类型。</p>
<blockquote>
<p>例如，实体 E1 与 E2 在一个 E-R 图中是多对多联系，在另一个 E-R 图中是一对多联系<br>
解决方法是根据应用的语义对实体联系的类型进行综合或调整。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<ul>
<li>
<p><code>修改和重构</code>，消除不必要的冗余，生成基本 E-R 图。</p>
<ul>
<li>
<p>冗余的数据是指：可由基本数据导出的数据</p>
</li>
<li>
<p>冗余的联系是指：可由其他联系导出的联系</p>
</li>
<li>
<p>冗余带来的问题：破坏数据库的完整性，数据库维护困难，应当予以消除</p>
</li>
<li>
<p>消除冗余方法：</p>
<blockquote>
<p>分析方法<br>
规范化理论的方法</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>用规范化理论来消除冗余</p>
<ol>
<li>确定分 E-R 图实体之间的数据依赖。
<ul>
<li>实体之间一对一、一对多、多对多的联系可以用实体码之间的函数依赖来表示。于是有函数依赖集 FL</li>
</ul>
</li>
<li>求 FL 的最小覆盖 GL ，差集为 D= FL - GL
<ul>
<li>逐一考察 D 中的函数依赖，确定是否是冗余的联系，若是，就把它去掉</li>
</ul>
</li>
</ol>
<ul>
<li>应注意的问题：
<ul>
<li>冗余的联系一定在 D 中，而 D 中的联系不一定是冗余的；</li>
<li>当实体之间存在多种联系时，要将实体之间的联系在形式上加以区分。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="逻辑结构设计">逻辑结构设计</h3>
<p>逻辑结构设计的任务</p>
<ul>
<li>把概念结构设计阶段设计好的基本 E-R 图转换为与选用的 DNMS 产品所支持的逻辑结构</li>
<li>目前主要使用关系模型，关系模型的逻辑结构是一组关系模式的集合。</li>
</ul>
<h4 id="E-R-图向关系模式的转换">E-R 图向关系模式的转换</h4>
<ul>
<li>转换内容：将 E-R 图转换为关系模型。将实体型、实体的属性和实体型之间的联系转化为关系模式。</li>
</ul>
<ol>
<li>
<p>实体型的转换：一个实体型转换为一个关系模式</p>
<ul>
<li>关系模式的属性：实体的属性</li>
<li>关系模式的码：实体的码</li>
</ul>
</li>
<li>
<p>实体型间的 1：1 联系：</p>
<ul>
<li>
<p>可以转换为一个独立的关系模式</p>
<blockquote>
<p>关系模式的属性：与该联系相连的各实体的码以及联系本身的属性<br>
关系模式的候选码：每个实体的码均是该关系模式的候选码</p>
</blockquote>
</li>
<li>
<p>也可以与相连的任意一端对应的关系模式合并</p>
<blockquote>
<p>关系模式的属性：与某一端关系模式合并，则在该关系模式的属性中加入另一端关系模式的码和联系的属性<br>
合并后关系模式的码：不变</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>实体型间的 1：n 联系：</p>
<ul>
<li>
<p>转换为一个独立的关系模式</p>
<blockquote>
<p>关系模式的属性：与该联系相连的<code>各实体的码</code>+<code>联系本身的属性</code><br>
关系模式的码：<code>n端的实体的码</code></p>
</blockquote>
</li>
<li>
<p>与 n 端对应的关系模式合并</p>
<blockquote>
<p>合并后关系模式的属性：在 n 端关系模式中 + 1 端关系的码 + 联系本身的属性<br>
合并后关系模式的码：不变<br>
可以减少系统模式中的关系个数，一般情况下更倾向于采用这种方法</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>实体间的 m:n 联系：</p>
<ul>
<li>
<p>一个 m:n 联系转换为一个关系模式：</p>
<blockquote>
<p>关系的属性：与该联系相连的<code>各实体的码以</code>及<code>联系本身的属性</code><br>
关系的码：各实体码的组合</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>三个或三个以上实体间的一个多元联系</p>
<ul>
<li>
<p>转换为一个关系模式</p>
<blockquote>
<p>关系模式的属性：与该多元联系相连的<code>各实体的码</code>+<code>联系本身的属性</code><br>
关系模式的码：各实体码的组合</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>具有相同码的关系模式可合并</p>
<ul>
<li>
<p>目的：减少系统中的关系个数</p>
</li>
<li>
<p>合并发法：</p>
<blockquote>
<p>将其中一个关系模式的全部属性加入到另一个关系模式中<br>
然后去掉其中的同义属性（可能同名也可能不同名）<br>
适当调整属性的次序</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h4 id="数据模型的优化">数据模型的优化</h4>
<ul>
<li>
<p>数据库逻辑设计的结果不是唯一的。</p>
</li>
<li>
<p>得到初步数据据模式后，还应该适当地修改、调整数据库逻辑结构，以进一步提高数据库应用系统的性能，这就是数据模型的优化。</p>
</li>
<li>
<p>关系数据模型的优化通常以规范化理论为指导。</p>
</li>
<li>
<p>优化数据模型的方法：</p>
<ol>
<li>
<p>确定数据依赖</p>
<blockquote>
<p>按需求分析阶段所得到的语义，分别写出每个关系模式内部各属性之间的数据依赖以及不同关系模式属性之间数据依赖。</p>
</blockquote>
</li>
<li>
<p>对于各个关系模式之间的数据依赖进行极小化处理，消除冗余的联系。</p>
</li>
<li>
<p>按照数据依赖的理论对关系模式进行分析，考察是否存在部分函数依赖、传递函数依赖、多值依赖等，确定各关系模式分别属于第几范式。</p>
</li>
<li>
<p>按照需求分析阶段得到的各种应用对数据处理的要求，分析对于这样的应用环境这些模式是否合适，确定是否要对它们进行合并或分解。包括水平分解和垂直分解。</p>
</li>
</ol>
</li>
</ul>
<h4 id="设计用户子模式">设计用户子模式</h4>
<ul>
<li>数据库模式——全局模式<br>
考虑系统全局应用需求，时间效率、空间效率、易维护等。</li>
<li>用户子模式——视图机制<br>
考虑局部应用的特殊需求和用户体验。</li>
</ul>
<ol>
<li>
<p>使用更符合用户习惯的别名</p>
<blockquote>
<p>合并各分 E-R 图曾做了消除命名冲突的工作，以使数据库系统中同一关系和属性具有唯一的名字。这在设计数据库整体结构时是非常必要的。<br>
在设计用户子模式时可以设计子模式时重新定义某些属性名，使其与用户习惯一致，以方便使用。</p>
</blockquote>
</li>
<li>
<p>针对不同级别的用户定义不同的视图，提高系统的安全性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">假设有关系模式:</span><br><span class="line">产品（产品号，产品名，规格，单价，生产车间，生产负责人，产品成本，产品合格率，质量等级）</span><br><span class="line">为一般顾客、为产品销售部门和管理部门建立不同的视图。</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>简化用户对系统的使用</p>
<blockquote>
<p>某些局部应用中经常要使用一些很复杂的查询，为了方便用户，可以将这些复杂查询定义为视图。</p>
</blockquote>
</li>
</ol>
<h3 id="物理结构设计">物理结构设计</h3>
<ul>
<li>为一个给定的逻辑数据模型选取一个最适合应用要求的物理结构的过程，就是数据库的物理设计。</li>
<li>数据库在<code>物理设备上的存储结构与存取方法</code>称为数据库的物理结构，它依赖于选定的 DBMS。</li>
</ul>
<h4 id="数据库物理设计的内容和方法">数据库物理设计的内容和方法</h4>
<ul>
<li>
<p>关系数据库物理设计的内容</p>
<blockquote>
<p>为关系模式选择存取方法（建立存取路径<br>
为关系、索引、日志、备份等数据库文件选择物理存储结构</p>
</blockquote>
</li>
<li>
<p>设计物理数据库结构的准备工作</p>
<ul>
<li><code>充分了解应用环境</code>，详细分析要运行的事务，以获得选择物理数据库设计所需参数。</li>
<li><code>充分了解所用RDBMS的内部特征</code>，特别是系统提供的存取方法和存储结构。</li>
</ul>
</li>
<li>
<p>物理数据库设计参数</p>
<ul>
<li>数据库查询事务
<ul>
<li>查询所涉及的关系</li>
<li>查询条件所涉及的属性</li>
<li>连接条件所涉及的属性</li>
<li>查询的投影属性</li>
</ul>
</li>
<li>数据更新事务
<ul>
<li>被更新的关系</li>
<li>每个关系上的更新操作条件所设计的属性</li>
<li>修改操作要改变的属性值</li>
</ul>
</li>
<li>每个事务在个关系上运行的频率和性能要求</li>
</ul>
</li>
</ul>
<h4 id="关系模式的存取方法选择">关系模式的存取方法选择</h4>
<h5 id="索引方法">索引方法</h5>
<ul>
<li>
<p>为什么要建立索引<br>
提高存取的效率——查询、插入、删除、更新的效率</p>
</li>
<li>
<p>如何选择索引存取方法<br>
根据应用要求确定： &gt; 对哪些属性列建立索引 &gt; 对哪些索引要设计为唯一索引、组合索引 &gt; 选择合适的索引方法</p>
</li>
<li>
<p>创建索引的方法</p>
</li>
</ul>
<p><code>CREATE [ UNIQUE ] INDEX 索引名字 ON 表名 [ USING 索引方法 ] ( 列名1，列名2，[, ...] )；</code></p>
<p><code>CREATE UNIQUE INDEX studentname ON student USING Hash (sname)；</code></p>
<ul>
<li>
<p>RDBMS 提供的索引方法：</p>
<blockquote>
<p>B-tree（B+树），hash（散列）R-tree 、Bitmap 等。<br>
如果不指定，缺省一般是 B-tree。</p>
</blockquote>
</li>
<li>
<p>选取索引存取方法的一般规则</p>
<blockquote>
<p>如果一个（或一组）属性经常在查询条件中出现，则考虑在这个（这组）属性上建立索引（或组合索引）；<br>
如果一个属性经常作为最大值和最小值等聚集函数的参数，则考虑在这个属性上建立索引；<br>
如果一个（或一组）属性经常在连接操作的连接条件中出现，则考虑在这个（或这组）属性上建立索引</p>
</blockquote>
</li>
<li>
<p>B+树索引的特点：</p>
<ul>
<li>多分平衡树，存取效率高</li>
<li>既能随即查找，又能顺序查找</li>
<li>增删改操作，保持平衡</li>
</ul>
</li>
<li>
<p>选取 Hash 存取方法的规则<br>
如果一个关系的属性主要出现在等值连接条件中或主要出现在等值比较选择条件中，而且满足下列两个条件之一：</p>
<blockquote>
<p>该关系的大小可预知，而且不变；<br>
该关系的大小动态改变，但所选用的数据库管理系统提供了动态 Hash 存取方法。</p>
</blockquote>
</li>
<li>
<p>索引带来的额外开销</p>
<ul>
<li>维护索引的开销</li>
<li>查找索引的开销</li>
<li>存储索引的开销</li>
</ul>
</li>
</ul>
<h5 id="聚簇方法的选择">聚簇方法的选择</h5>
<ul>
<li>定义：为了提高某个属性（或属性组）的查询速度，把这个（或这些）属性上具有相同值的元组集中存放在连续的物理块中称为聚簇。</li>
<li>该属性（或属性组）称为聚簇码（cluster key）</li>
</ul>
<ol>
<li>创建一个聚簇<br>
CREATE CLUSTER &lt;聚簇名&gt; (&lt;聚簇码&gt;) SIZE (&lt;大小&gt;);</li>
<li>在聚簇上建立索引<br>
CREATE INDEX &lt;索引名&gt; ON CLUSTER &lt;聚簇名&gt;;<br>
[例]<br>
<code>CREATE CLUSTER emp_dept_cluster (deptno number(6) ) SIZE 1024;</code><br>
<code>CREATE INDEX emp_dept_cluster_index ON CLUSTER emp_dept_cluster;</code></li>
</ol>
<ul>
<li>
<p>聚簇的作用</p>
<ul>
<li>大大提高按聚簇属性进行查询的效率<br>
[例] 假设要查询计算机系的所有学生。 &gt; 学生数据表随机存放，计算机系的 500 名学生分散存储在 500 个不同的物理块上，则至少要执行 500 次 I/O 操作。 &gt; 如果按照专业系名聚簇存放，将同一系的学生元组聚簇在一起存放，则可以显著地减少了访问磁盘的次数。计算机系的 500 名学生聚簇存储在 50 个不同的物理块上，只要执行 50 次 I/O 操作。</li>
</ul>
</li>
<li>
<p>聚簇的适用范围</p>
<ul>
<li>
<p>既适用于单个关系独立聚簇，也适用于多个关系组合聚簇<br>
[例] 假设用户经常要按姓名查询学生成绩单。</p>
<blockquote>
<p>SELECT sname, cno, grade from student, sc where student.sno=sc.sno<br>
这一查询涉及学生关系和选修关系的连接操作，按学号连接这两个关系。</p>
</blockquote>
<ul>
<li>按照学号把学生表和选修表聚簇在一起。</li>
<li>相当于把多个关系按“预连接”的形式存放。</li>
<li>大大提高连接操作的效率。</li>
</ul>
</li>
<li>
<p>当 SQL 语句中包含有与聚簇码有关的 ORDER BY,GROUP BY, UNION, DISTINCT 等子句或短语时，使用聚簇特别有利，可以省去或减少对结果集的排序操作</p>
</li>
</ul>
</li>
<li>
<p>聚簇的局限性</p>
<ul>
<li>
<p>在一个基本表上最多只能建立一个聚簇索引</p>
</li>
<li>
<p>聚簇只能提高某些特定应用的性能</p>
</li>
<li>
<p>建立和维护聚簇的开销相当大</p>
<blockquote>
<p>对已有关系建立聚簇，将导致关系中元组的物理存储位置移动，并使此关系上原有的索引无效，必须重建。<br>
当一个元组的聚簇码改变时，该元组的存储位置也要相应改变。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>聚簇索引的使用条件</p>
<ol>
<li>很少对基表进行增删操作</li>
<li>很少对其中的变长列进行修改操作</li>
</ol>
</li>
</ul>
<h4 id="确定数据库的存储结构">确定数据库的存储结构</h4>
<ul>
<li>
<p>影响数据存放位置和存储结构的因素</p>
<ul>
<li>
<p>硬件环境</p>
</li>
<li>
<p>应用需求</p>
<ul>
<li>
<p>存取时间</p>
</li>
<li>
<p>存储空间利用率</p>
</li>
<li>
<p>维护代价</p>
<blockquote>
<p>这三个方面常常是相互矛盾的</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>基本原则</p>
<ul>
<li>根据应用情况将
<ul>
<li>易变部分与稳定部分分开存放</li>
<li>经常存取部分与存取频率较低部分分开存放</li>
<li>日志文件与数据库对象（表、索引等）分开存放</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>在海量数据和多用户环境下，把数据分布存放在不同的磁盘或磁盘阵列上，可以改进系统性能。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[例]</span><br><span class="line">  可以将比较大的表分别放在两个磁盘上，以加快存取速度，这在多用户环境下特别有效。</span><br><span class="line">  可以将日志文件与数据库对象（表、索引等）放在不同的磁盘以改进系统的性能。</span><br></pre></td></tr></table></figure>
<p>数据库管理系统一般都提供了一些存储分配参数 - 同时使用数据库的用户数 - 同时打开的数据库对象数 - 内存分配参数 - 缓冲区分配参数（使用的缓冲区长度、个数） - 存储分配参数 - 物理块的大小 - 物理块装填因子 - 数据库的大小 - 锁的数目等</p>
<blockquote>
<p>系统都为这些变量赋予了合理的缺省值。<br>
在进行物理设计时需要根据应用环境确定这些参数值，以使系统性能最优。<br>
在物理设计时对系统配置变量的调整只是初步的，要根据系统实际运行情况做进一步的调整，以切实改进系统性能。</p>
</blockquote>
<h4 id="评价物理结构">评价物理结构</h4>
<p>评价方法</p>
<ul>
<li>定量估算各种方案
<ul>
<li>存储空间</li>
<li>存取时间</li>
<li>维护代价</li>
</ul>
</li>
<li>对估算结果进行权衡、比较，选择出一个较优的合理的物理结构</li>
<li>返回用户 征求意见 修改设计</li>
</ul>
<h4 id="数据库物理设计的步骤">数据库物理设计的步骤</h4>
<ol>
<li>
<p>确定数据库的物理结构</p>
<blockquote>
<p>RDBMS 中主要指存取方法和存储结构;</p>
</blockquote>
</li>
<li>
<p>对物理结构进行评价，重点是时间和空间效率</p>
<blockquote>
<p>IF 评价结果满足原设计要求<br>
THEN 进入到物理实施阶段<br>
ELSE ( 重新设计 OR 修改物理结构 OR 返回逻辑设计阶段 修改数据模型)</p>
</blockquote>
</li>
</ol>
<h3 id="数据库的实施和维护">数据库的实施和维护</h3>
<h4 id="数据的载入和应用程序的调试">数据的载入和应用程序的调试</h4>
<ol>
<li>
<p>定义数据库结构</p>
<ul>
<li>
<p>用 DBMS 提供的 DDL 来创建数据库结构</p>
<blockquote>
<p>RDBMS 产生目标模式，生成数据字典</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>数据装载</p>
<ul>
<li>
<p>组织数据入库是数据库实施阶段最主要的工作</p>
</li>
<li>
<p>数据装载——ETL</p>
<ul>
<li>数据抽取</li>
<li>数据转换</li>
<li>数据载入</li>
</ul>
</li>
<li>
<p>使用 ETL 工具辅助完成</p>
<blockquote>
<p>ETL 工作是相当费力、费时的</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>编制和调试应用程序</p>
<ul>
<li>数据库应用程序的涉及应该与数据设计并行进行</li>
<li>在数据库实施阶段，编制与调试数据库的应用程序。</li>
<li>调试应用程序时由于数据入库尚未完成，可先使用模拟数据。</li>
</ul>
</li>
</ol>
<h4 id="数据库的试运行">数据库的试运行</h4>
<p>应用程序调试完成，并且已有一小部分数据入库后，就可以开始对数据库系统进行联合调试。</p>
<ul>
<li>
<p>主要工作包括：</p>
<ul>
<li>功能测试：实际运行应用程序，执行对数据库的各种操作，测试应用程序的各种功能。</li>
<li>性能测试：测量系统性能指标，分析是否符合设计目标。</li>
</ul>
</li>
<li>
<p>数据库性能指标的测量</p>
<ul>
<li>
<p>数据库物理设计阶段，评价数据库结构，估算时间、空间指标时，作了许多简化和假设，必然是近似结果。</p>
</li>
<li>
<p>数据库试运行则是要实际测量系统的各种性能指标。</p>
<blockquote>
<p>如果结果不符合设计目标，则需要返回物理设计阶段，调整物理结构，修改参数；有时甚至需要返回逻辑设计阶段，调整逻辑结构。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<ol>
<li>
<p>数据的分期入库</p>
<ul>
<li>
<p>重新设计物理结构甚至逻辑结构，会导致数据重新入库</p>
</li>
<li>
<p>由于数据入库工作量实在太大，所以可以采用分期输入数据的方法</p>
<blockquote>
<p>先输入小批量数据供先期联合调试使用<br>
待试运行基本合格后再输入大批量数据<br>
逐步增加数据量，逐步完成运行评价</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>数据库的转储和恢复</p>
<ul>
<li>在数据库试运行阶段，系统还不稳定，硬、软件故障随时都可能发生</li>
<li>系统的操作人员对新系统还不熟悉，误操作也不可避免</li>
<li>因此必须做好数据库的转储和恢复工作，尽量减少对数据库的破坏</li>
</ul>
</li>
</ol>
<h4 id="数据库的运行和维护">数据库的运行和维护</h4>
<p>在数据库运行阶段，对数据库经常性的维护工作主要是由数据库管理员完成的，包括：</p>
<ol>
<li>
<p>数据库的转储和恢复</p>
<ul>
<li>数据库管理员要针对不同的应用要求制定不同的转储计划，定期对数据库和日志文件进行备份。</li>
<li>一旦发生介质故障，即利用数据库备份及日志文件备份，尽快将数据库恢复到某种一致性状态。</li>
</ul>
</li>
<li>
<p>数据库的安全性、完整性控制</p>
<ul>
<li>初始定义
<ul>
<li>数据库管理员根据用户的实际需要授予不同的操作权限</li>
<li>根据应用环境定义不同的完整性约束条件</li>
</ul>
</li>
<li>修改定义
<ul>
<li>当应用环境发生变化，对安全性的要求也会发生变化，数据库管理员需要根据实际情况修改原有的安全性控制</li>
<li>由于应用环境发生变化，数据库的完整性约束条件也会变化，也需要数据库管理员不断修正，以满足用户要求</li>
</ul>
</li>
</ul>
</li>
<li>
<p>数据库性能的监督、分析和改进</p>
<ul>
<li>在数据库运行过程中，数据库管理员必须监督系统运行，对监测数据进行分析，找出改进系统性能的方法。
<ul>
<li>利用监测工具获取系统运行过程中一系列性能参数的值</li>
<li>通过分析这些数据，判断当前系统是否处于最佳运行状态</li>
<li>如果不是，则需要通过调整某些参数来改进数据库性能</li>
</ul>
</li>
</ul>
</li>
<li>
<p>数据库的重组织和重构造</p>
<ol>
<li>
<p>数据库的重组织</p>
<blockquote>
<p>原因：数据库运行一段时间后，由于记录的不断增、删、改，会使数据库的物理存储变坏，从而降低数据库存储空间的利用率和数据的存取效率，使数据库的性能下降。</p>
</blockquote>
<ul>
<li>
<p>主要工作：</p>
<ul>
<li>
<p>按原设计要求： - 重新安排存储位置 - 回收垃圾 - 减少指针链</p>
<blockquote>
<p>数据库的重组织不会改变原设计的数据逻辑结构和物理结构<br>
数据库管理系统一般都提供了供重组织数据库使用的实用程序，帮助数据库管理员重新组织数据库。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>数据库的重构造</p>
<blockquote>
<p>原因：数据库应用环境发生变化，会导致实体及实体间的联系也发生相应的变化，使原有的数据库设计不能很好地满足新的需求<br>
增加新的应用或新的实体<br>
取消某些已有应用<br>
改变某些已有应用</p>
</blockquote>
</li>
</ol>
<ul>
<li>
<p>数据库重构造的主要工作<br>
<code>根据新环境调整数据库的模式和内模式</code></p>
<ul>
<li>增加或删除某些数据项</li>
<li>改变数据项的类型</li>
<li>增加或删除某个表</li>
<li>改变数据库的容量</li>
<li>增加或删除某些索引</li>
</ul>
</li>
<li>
<p>重构造数据库的程度是有限的</p>
<ul>
<li>
<p>应用需求变化太大，软硬件发展太快</p>
<blockquote>
<p>无法通过重构数据库来满足新的需求，或重构数据库的代价太大，则表明现有数据库应用系统的生命周期已经结束，应该重新设计新的数据库应用系统了。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="第九章-关系查询处理和查询优化">第九章 关系查询处理和查询优化</h2>
<ul>
<li>
<p>查询处理的四个阶段：</p>
<ol>
<li>查询分析</li>
<li>查询检查</li>
<li>查询优化</li>
<li>查询执行</li>
</ol>
</li>
</ul>
<h3 id="查询分析">查询分析</h3>
<ul>
<li>查询分析的任务：对查询语句进行扫描、词法分析和语法分析
<ul>
<li>词法分析：从查询语句中识别出正确的语言符号</li>
<li>语法分析：进行语法检查</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Sname</span><br><span class="line"><span class="keyword">FROM</span> Student</span><br><span class="line"><span class="keyword">WHERE</span> Sno <span class="operator">=</span>&quot;20100017&quot;</span><br></pre></td></tr></table></figure>
<p>词法分析：</p>
<ul>
<li>保留字：SELECT， FROM， WHERE</li>
<li>变量：Sname, Student, Sno</li>
<li>常量：“20100017”</li>
<li>运算符： =</li>
</ul>
<blockquote>
<p>可以发现：拼写错误，命名错误，非法符号等。</p>
</blockquote>
<p>语法分析：</p>
<ul>
<li>按照 SQL 语言的句法解释查询语句</li>
<li>例如 SELECT Sname From Student <code>WHEN</code> Sno=&quot;20100017&quot;就是语法错误的</li>
</ul>
<h3 id="查询检查">查询检查</h3>
<ul>
<li>
<p>有效性检查：检查语句中的数据库对象，如关系名、属性名是否存在和有效</p>
</li>
<li>
<p>根据数据字典中有关的模式定义信息进行检查</p>
</li>
<li>
<p>视图转换</p>
</li>
<li>
<p>如果查询是对视图的操作，则要用<code>视图消解法</code>把对视图的操作转换成对基本表的操作</p>
</li>
<li>
<p>安全性检查：</p>
</li>
<li>
<p>根据数据字典中的用户权限对用户的存取权限进行检查</p>
</li>
<li>
<p>完整性检查：</p>
</li>
<li>
<p>根据数据字典中存储的完整性约束定义，对句子进行检查</p>
</li>
<li>
<p>例如 where Sno = 20100017 就是错误的，因为 Sno 是字符类型 Char(8)</p>
</li>
</ul>
<h3 id="查询优化">查询优化</h3>
<ul>
<li>查询优化分类
<ul>
<li>代数优化/逻辑优化：指针对关系代数表达式的优化</li>
<li>物理优化：指存取路径和底层操作算法的选择</li>
</ul>
</li>
<li>查询优化的选择依据
<ul>
<li>基于规则</li>
<li>基于代价</li>
<li>基于语义</li>
</ul>
</li>
</ul>
<h3 id="查询执行">查询执行</h3>
<ul>
<li>依据优化器得到的执行策略去生成查询执行计划 <code>自顶向下</code></li>
<li>代码生成器生成执行查询计划的代码 <code>自底向上</code></li>
</ul>
<h3 id="关系算子的实现">关系算子的实现</h3>
<p>关系代数是关系数据库的抽象语言，理解如何实现关系代数操作有助于我们理解查询优化的过程。</p>
<h4 id="选择操作的实现">选择操作的实现</h4>
<p>实现方法：</p>
<ol>
<li>全表扫描方法
<ul>
<li>对查询的基本表顺序扫描，逐一检查每个元组是否满足选择条件，把满足条件的元组作为结果输出</li>
<li>适合小表，不适合大表</li>
</ul>
</li>
<li>索引扫描方法
<ul>
<li>适合于选择条件中的属性上有索引（例如 B+树索引或 Hash 索引）</li>
<li>通过索引先找到满足条件的元组主码或元组指针，再通过元组指针直接在查询的基本表中找到元组</li>
</ul>
</li>
</ol>
<p><code>SELECT * from Student WHERE &lt;条件表达式&gt;</code><br>
考虑&lt;条件表达式&gt;的几种情况：<br>
C1：无条件；<br>
C2：Sno=‘201215121’;<br>
C3：Sage&gt;20;<br>
C4：Sdept=‘CS’ AND Sage&gt;20;</p>
<ol>
<li>
<p>全表扫描算法</p>
<ul>
<li>假设可以使用的内存为 M 块，全表扫描算法思想：</li>
</ul>
<ol>
<li>按照物理次序读 Student 的 M 块到内存</li>
<li>检查内存的每个元组 t，如果满足选择条件，则输出 t</li>
<li>如果 student 还有其他块未被处理重复 1 和 2</li>
</ol>
</li>
<li>
<p>索引扫描算法<br>
<code>SELECT * from Student WHERE Sno='201215121'</code></p>
<ul>
<li>假设 Sno 上有索引</li>
<li>算法： - 使用索引得到 Sno 为’201215121’元组的指针 - 通过元组指针在 Student 表中检索到该学生<br>
<code>SELECT * from Student WHERE Sage&gt;20</code></li>
<li>假设 Sage 上有索引</li>
<li>算法： - 使用 B+树索引找到 Sage=20 的索引项，以此为入口点在 B+树的顺序集上得到 Sage&gt;20 的所有元组指针 - 通过这些元组指针到 Student 表中检索到所有年龄大于 20 的学生<br>
<code>SELECT * from Student WHERE Sdept='CS' AND Sage&gt;20</code></li>
<li>假设 Sdept 和 Sage 上都有索引</li>
<li>算法 1：
<ul>
<li>分别用 Index Scan 找到 Sdept='CS’的一组元组指针和 Sage&gt;20 的另一组元组指针</li>
<li>求这两组指针的交际</li>
<li>到 Student 表中检索</li>
<li>得到计算机系年龄大于 20 的学生</li>
</ul>
</li>
<li>算法 2：
<ul>
<li>找到 Sdept='CS’的一组元组指针，通过这些元组指针到 Student 表中检索</li>
<li>并对得到的元组检查另一些选择条件（如 Sage&gt;20）是否满足</li>
<li>把满足条件的元组作为结果输出</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>选择算子的处理要考虑到&lt;条件表达式&gt;具体情况，采用不同的策略。</p>
<ul>
<li>C1：无条件；采用全表扫描</li>
<li>C2：Sno=‘201215121’；结果集小的情况下，利用索引</li>
<li>C3：Sage&gt;20；结果集太大的情况下，直接全表扫描</li>
<li>C4：Sdept=‘CS’ AND Sgae&gt;20；多个条件的情况下比较复杂，会分别考虑每个条件再合并结果，也可能逐一顺序考虑这些条件，甚至条件太复杂时候直接扫描表格。</li>
</ul>
<h4 id="连接操作的实现">连接操作的实现</h4>
<ul>
<li>连接操作是查询处理中最耗时的操作之一</li>
</ul>
<p><code>例: SELECT * FROM Student, SC WHERE Student.Sno=SC.Sno;</code></p>
<ol>
<li>
<p>嵌套循环算法(nested loop join)</p>
<ul>
<li>对外层循环(Student 表)的每一个元组 s，检索内层循环(SC 表)中的每一个元组(sc)</li>
<li>检查这两个元组在连接属性(Sno)上是否相等</li>
<li>如果满足连接条件，则串接后作为结果输出，直到外层循环表中的元组处理完为止。</li>
</ul>
</li>
<li>
<p>排序合并算法(merge join)</p>
<ul>
<li>
<p>如果连接的表没有排好序，先对 Student 表和 SC 表按连接属性 Sno 排序</p>
</li>
<li>
<p>取 Student 表中第一个 Sno，依次扫描 SC 表中具有相同 Sno 的元组</p>
</li>
<li>
<p>当扫描到 Sno 不相同的第一个 SC 元组时，返回 Student 表扫描它的下一个元组，再扫描 SC 表中具有相同 Sno 的元组，把它们连接起来</p>
</li>
<li>
<p>重复上述步骤直到 Student 表扫描完</p>
<blockquote>
<p>Student 表和 SC 表都只要扫描一遍<br>
如果两个表原来无序，执行时间要加上对两个表的排序时间<br>
对于大表，先排序后使用排序-合并连接算法执行连接，总时间一般仍会减少。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>索引连接算法(index join)</p>
<ol>
<li>在 SC 表上已经建立 Sno 的索引。</li>
<li>对 Student 表中每一个元组，由 Sno 值通过 SC 的索引查找相应的 SC 元组</li>
<li>把这些 SC 元组和 Student 元组连接起来</li>
<li>循环执行 2、3，直到 Student 表中的元组处理完为止。</li>
</ol>
</li>
<li>
<p>Hash Join 算法</p>
<ul>
<li>
<p>把连接属性作为 Hash 码，用同一个 hash 函数把 Student 表和 SC 表中的元组散列到 hash 表中。</p>
</li>
<li>
<p>划分阶段</p>
<ol>
<li>对包含较少元组的表（如 Student 表）进行一遍处理</li>
<li>把它的元组按 hash 函数分散到 hash 表的桶中</li>
</ol>
</li>
<li>
<p>试探阶段</p>
<ol>
<li>
<p>对另一个表（sc 表）进行一遍处理</p>
</li>
<li>
<p>把 SC 表中的元组也按同一个 hash 函数（hash 码是连接属性）进行散列</p>
</li>
<li>
<p>把 SC 元组与桶中来自 Student 表并与之相匹配的元组连接起来</p>
<blockquote>
<p>hash join 算法前提：假设两个表中较小的表在第一个阶段后可以完全放入内存的 hash 桶中</p>
</blockquote>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<h4 id="查询优化的作用">查询优化的作用</h4>
<ul>
<li>是关系数据库管理系统实现的关键技术，也是关系系统的优点所在</li>
<li>减轻了用户对于系统底层选择存取路径的负担</li>
<li>用户可以关注查询的正确表达上，而无需考虑查询的执行效率如何</li>
<li>系统优化后的程序通常可以比用户程序做得更好
<ol>
<li>优化器可以从数据字典中获取许多统计信息，而用户程序则难以获得这些信息。</li>
<li>如果数据库的物理统计信息改变了，系统可以自动对查询重新优化以选择相适应的执行计划。在非关系系统中必须重写程序，这在实际中往往是不可行的。</li>
<li>优化器可以考虑数百种不同的执行计划，程序员一般只能考虑有限的几种可能性。</li>
<li>优化器中包括了很多复杂的优化技术，这些优化技术往往只有最好的程序员才能掌握。系统的自动优化相当于使得所有人都拥有这些优化技术。</li>
</ol>
</li>
</ul>
<p>关系数据库管理系统通过某种代价模型计算出各种查询执行策略的执行代价，然后选取代价最小的执行方案。</p>
<ul>
<li>
<p>集中式数据库</p>
<ul>
<li>
<p>执行开销主要包括</p>
<ul>
<li>
<p>磁盘存取块数（I/O 代价）</p>
</li>
<li>
<p>处理及时间（CPU 代价）</p>
</li>
<li>
<p>内存空间的开销</p>
<blockquote>
<p>其中 I/O 代价是最主要的</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>分布式数据库</p>
<ul>
<li>总代价=I/O 代价+CPU 代价+内存代价+通信代价</li>
</ul>
</li>
</ul>
<p>查询优化的总目标</p>
<ul>
<li>选择有效的策略</li>
<li>求得给定关系表达式的值</li>
<li>使得查询代价最小（实际上是较小）</li>
</ul>
<blockquote>
<p>先做选择再做连接操作，这样参与连接的元组就可以大大减少，这是代数优化<br>
利用索引连接代价也较小，这是物理优化</p>
</blockquote>
<h4 id="代数优化">代数优化</h4>
<p>理想：</p>
<ol>
<li>找出查询 Q 的全部等价表达式（结果相同）E（Q）</li>
<li>对 E(Q)中的每一个表达式计算其执行代价：f(q),q∈E(Q),q 是 Q 的一个等价表达式</li>
<li>找出执行代价最小的表达式</li>
</ol>
<p>问题：成本太高</p>
<p>现实：</p>
<ol>
<li>从查询 Q 出发，按照事先确定的规则对 Q 进行变换，获得 Q1，Q1 与 Q 必须等价</li>
<li>确保 Q1 的执行代价比 Q 的执行代价低</li>
<li>直到找不到执行代价更小的等价表达式，结束</li>
</ol>
<p>问题：不一定是最优的</p>
<p>关系代数表达式的等价变换规则 - 等价的含义：指用相同的关系代替两个表达式中相应的关系所得到的结果是相同的 - 两个关系表达式 E1 和 E2 是等价的，可记为 E1≡E2</p>
<h4 id="典型的启发式规则">典型的启发式规则</h4>
<ol>
<li>选择运算应尽可能先做<br>
在优化策略中这是最重要、最基本的一条。</li>
<li>把投影运算和选择运算同时进行<br>
如有若干投影和选择运算，并且它们都对同一个关系操作，则可以在扫描此关系的同时完成所有的这些运算以避免重复扫描关系。</li>
<li>把投影同其前或其后的双目运算结合起来，没有必要为了去掉某些字段而扫描一遍关系。</li>
<li>把某些选择同在它前面要执行的笛卡尔积结合起来成为一个连接运算，连接特别是等值连接运算要比同样关系上的笛卡尔积省很多时间。</li>
<li>找出公共子表达式
<ul>
<li>如果这种重复出现的子表达式的结果不是很大的关系</li>
<li>并且从外存中读入这个关系比计算该子表达式的时间少得多</li>
<li>则先计算以此公共子表达式并把结果写入中间文件是合算的</li>
<li>当查询的视图时，定义视图的表达式就是公共子表达式的情况</li>
</ul>
</li>
</ol>
<h3 id="物理优化">物理优化</h3>
<p>物理优化就是要选择高效合理的操作算法或存取路径，求得更好的查询计划</p>
<p>物理优化方法</p>
<ul>
<li>基于规则的启发式优化
<ul>
<li>启发式规则是指那些在大多数情况下都使用，但不是在每种情况下都是适用的规则。</li>
</ul>
</li>
<li>基于代价估算的优化
<ul>
<li>优化器估算不同执行策略的代价，并选出具有最小代价的执行计划。</li>
</ul>
</li>
<li>两者结合的优化方法
<ul>
<li>常常先使用启发式规则，选取若干较优的候选方案，减少代价估算的工作量</li>
<li>然后分别计算这些候选方案的执行代价，较快地选出最终地优化方案</li>
</ul>
</li>
</ul>
<h4 id="基于启发式规则地存取路径选择优化">基于启发式规则地存取路径选择优化</h4>
<ol>
<li>
<p>选择操作地启发式规则</p>
<ul>
<li>
<p>对于小关系，使用全表顺序扫描，即使选择列上有索引</p>
</li>
<li>
<p>对于大关系，启发式规则有：</p>
<ol>
<li>
<p>对于选择条件是“主码=值”的查询</p>
<ul>
<li>查询结果最多是一个元组，可以选择主码索引</li>
<li>一般的关系数据库管理系统会自动建立主码索引</li>
</ul>
</li>
<li>
<p>对于选择条件是“非主属性=值”的查询，并且选择列上有索引</p>
<ul>
<li>要估算查询结果的元组数目</li>
<li>如果比例较小（&lt;10%）可以使用索引扫描办法</li>
<li>否则还是使用全表顺序扫描</li>
</ul>
</li>
<li>
<p>对于选择条件是属性上的非等值查询或者范围查询，并且选择列上有索引</p>
<ul>
<li>要估算查询结果的元组数目</li>
<li>如果比较小（&lt;10%）可以使用索引扫描办法</li>
<li>否则还是使用全表扫描</li>
</ul>
</li>
<li>
<p>对于用 AND 连接的合取选择条件</p>
<ul>
<li>
<p>如果有涉及这些属性的组合索引，优先采用组合索引扫描办法</p>
</li>
<li>
<p>如果某些属性上有一般的索引，可以用索引扫描办法</p>
<blockquote>
<p>通过分别查找满足每个条件的指针，求指针的交集<br>
通过索引查找满足部分条件的元组，然后再扫描这些元组时判断是否满足剩余条件</p>
</blockquote>
</li>
<li>
<p>其他情况：使用全表顺序扫描</p>
</li>
</ul>
</li>
<li>
<p>对于用 OR 连接的析取选择条件，一般使用全表顺序扫描</p>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>连接操作的启发式规则</p>
<ol>
<li>如果 2 个表都已经按照连接属性排序
<ul>
<li>选用排序-合并算法</li>
</ul>
</li>
<li>如果一个表在连接属性上有索引
<ul>
<li>选用索引连接算法</li>
</ul>
</li>
<li>如果上面 2 个规则都不适用，其中一个表较小
<ul>
<li>选用 hash join 算法</li>
</ul>
</li>
<li>可以选用嵌套循环的方法，并选择其中较小的表，确切地讲是占用的块数(b)较少的表，作为外表(外循环的表)。<br>
理由：
<ul>
<li>设连接表 R 与 S 分别占用的块数为 Br 和 Bs</li>
<li>连接操作使用的内存缓冲区块数为 K</li>
<li>分配 K-1 块给外表</li>
<li>如果 R 为外表，则嵌套循环存取的块数为 Br+BrBs/(K-1)</li>
<li>显然应该选块数小的表作为外表</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="基于代价的优化">基于代价的优化</h4>
<p>启发式规则优化是定性的选择，适合解释执行的系统</p>
<ul>
<li>解释执行的系统，优化开销包含在查询总开销之中</li>
</ul>
<p>编译执行的系统中查询优化和查询执行是分开的</p>
<ul>
<li>可以采用精细复杂一些的基于代价的优化方法</li>
</ul>
<ol>
<li>
<p>统计信息</p>
<ul>
<li>
<p>基于代价的优化方法要计算查询的各种不同执行方案的执行代价，它和数据库的状态密切相关</p>
</li>
<li>
<p>优化器需要的统计信息</p>
<ol>
<li>
<p>对每个基本表</p>
<ul>
<li>该表的元组总数(N)</li>
<li>元组长度(I)</li>
<li>占用的块数(B)</li>
<li>占用的溢出块数(BO)</li>
</ul>
</li>
<li>
<p>对基表的每个列</p>
<ul>
<li>
<p>该列不同值得个数(m)</p>
</li>
<li>
<p>列最大值、最小值</p>
</li>
<li>
<p>列上是否已经建立了索引</p>
</li>
<li>
<p>哪种索引(B+树索引、Hash 索引、聚集索引)</p>
</li>
<li>
<p>可以计算选择率(f)</p>
<blockquote>
<p>如果不同值的分布是均匀的，f=1/m<br>
如果不同值的分布不均匀，则要计算每个值的选择率，f=具有该值的元祖数/N</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>对索引</p>
<ul>
<li>索引的层数(L)</li>
<li>不同索引值的个数</li>
<li>索引的选择基数 S(有 S 个元组具有某个索引值</li>
<li>索引的叶节点数(Y)</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>代价估算实例</p>
<ol>
<li>
<p>全表扫描算法的代价估算公式</p>
<ul>
<li>如果基本表大小为 B 块，则全表扫描算法的代价 cost=B</li>
<li>如果选择条件是“码=值”，那么平均搜索代价 cost=B/2<br>
（以块的 IO 数量作为度量单位）</li>
</ul>
</li>
<li>
<p>索引扫描算法的代价估算公式</p>
<ul>
<li>如果选择条件是“码=值”
<ul>
<li>则采用该表的主索引</li>
<li>若为 B+数，层数为 L，需要存取 B+树中从根节点到节点 L 块，再加上基本表中该元组所在的那一块，所以 cost=L+1</li>
</ul>
</li>
<li>如果选择条件涉及非码属性
<ul>
<li>若为 B+树索引，选择条件是相等比较，S 是索引的选择基数(有 S 个元组买组条件)</li>
<li>满足条件的元素可能会保存在不同的块上，所以(最坏的情况)cost=L+S</li>
</ul>
</li>
<li>如果比较条件是&gt;,&gt;=,&lt;,&lt;=操作
<ul>
<li>假设有一半的元组满足条件</li>
<li>就要存取一半的叶节点</li>
<li>通过索引访问一半的表存储块</li>
<li>cost=L+Y/2+B/2</li>
<li>如果可以获得更准确的选择基数，可以进一步修正 Y/2 和 B/2</li>
</ul>
</li>
</ul>
</li>
<li>
<p>嵌套循环连接算法的代价估算公式</p>
<ul>
<li>
<p>嵌套循环连接算法的代价<br>
cost = Br+BrBs/(K-1)</p>
</li>
<li>
<p>如果需要把连接结果写回磁盘<br>
cost = Br+BrBs/(K-1)+(Frs x Nr x Ns)/Mrs</p>
<blockquote>
<p>其中 Frs 为连接选择性(join selectivity)，表示连接结果元组数的比例<br>
Mrs 是存放连接结果的快因子，表示每块中可以存放的结果元组数目</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>排序-合并连接算法的代价估算公式</p>
<ul>
<li>
<p>如果连接表已经按照连接属性排好序，则<br>
cost = Br+Bs+(Frs x Nr x Ns)/Mrs</p>
</li>
<li>
<p>如果必须对文件排序</p>
<blockquote>
<p>还需要在代价函数中加上排序的代价<br>
对于包含 B 个块的文件排序的代价大约是(2xB)+(2xBxlog(2)B)</p>
</blockquote>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<blockquote>
<p>比较复杂的查询，尤其是涉及连接和嵌套的查询<br>
不要把优化的任务全部放在关系数据库管理系统上<br>
应该找出关系数据库管理系统的优化规律，以写出适合关系数据库管理系统自动优化的 SQL 语句<br>
对于关系数据库管理系统不能优化的查询需要重写查询语句，进行手工调整以优化性能</p>
</blockquote>
<h2 id="数据库恢复技术">数据库恢复技术</h2>
<h3 id="事务">事务</h3>
<ul>
<li>
<p>事务(Transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。</p>
</li>
<li>
<p>事务和程序是两个概念</p>
<ul>
<li>在关系数据库中，一个事务可以是一条 SQL 语句，一组 SQL 语句或整个程序</li>
<li>一个程序通常包含多个事务</li>
</ul>
</li>
<li>
<p>事务是恢复和并发控制的基本单位</p>
</li>
</ul>
<p>显式定义方式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span> TRANSACTION</span><br><span class="line">  <span class="keyword">SQL</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">SQL</span> <span class="number">2</span></span><br><span class="line">  ....</span><br><span class="line"><span class="keyword">COMMIT</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span> TRANSACTION</span><br><span class="line">  <span class="keyword">SQL</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">SQL</span> <span class="number">2</span></span><br><span class="line">  ....</span><br><span class="line"><span class="keyword">ROLLBACK</span></span><br></pre></td></tr></table></figure>
<p>隐式方式<br>
当用户没有显示地定义事务时，数据库管理系统按缺省规定自动划分事务</p>
<h4 id="事物的特性-ADID-特性">事物的特性(ADID 特性)</h4>
<ul>
<li>
<p>原子性（Atomicity）</p>
<ul>
<li>事务是数据库的逻辑工作单位，事务中的诸操作要么都做，要么都不做</li>
</ul>
</li>
<li>
<p>一致性（Consistency）<br>
事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态</p>
<ul>
<li>一致性状态
<ul>
<li>数据库中只包含成功事务提交的结果</li>
</ul>
</li>
<li>不一致状态
<ul>
<li>数据库系统运行中发生故障，有些事务尚未完成就被迫中断；</li>
<li>这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态</li>
</ul>
</li>
</ul>
</li>
<li>
<p>隔离性（Isolation）<br>
一个事务的执行不能被其他事务干扰</p>
<ul>
<li>一个事务内部的操作及使用的数据对其他并发事务是隔离的</li>
<li>并发执行的各个事务之间不能相互干扰</li>
</ul>
</li>
<li>
<p>持续性（Durability）</p>
<ul>
<li>一个事务一旦提交，它对数据库中数据的改变应该是永久性的</li>
<li>接下来的其他操作或故障不应该对其执行结果有任何影响</li>
</ul>
</li>
<li>
<p>破坏事务 ACID 特性的因素</p>
<ol>
<li>多个事务并行运行时，不同事物的操作交叉执行
<ul>
<li>数据库管理系统必须保证多个事务的交叉运行不影响这些食物的隔离性</li>
</ul>
</li>
<li>事务在运行过程中被强行停止
<ul>
<li>数据库管理系统必须保证被强行终止的事务对数据库和其他事务没有任何影响</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="数据库恢复概述">数据库恢复概述</h4>
<p>故障是不可避免的</p>
<ul>
<li>计算机硬件故障</li>
<li>软件地错误</li>
<li>操作员的失误</li>
<li>恶意的破坏</li>
</ul>
<p>故障的影响</p>
<ul>
<li>运行事务非正常中断，影响数据库中数据的正确性</li>
<li>破坏数据库，全部或部分丢失数据</li>
</ul>
<p>数据库的恢复</p>
<ul>
<li>数据库管理系统必须具有把数据库从错误状态恢复到某一已知的正确状态(亦称为一致状态或完整状态)的功能，这就是数据库的恢复管理系统对故障的对策</li>
</ul>
<h4 id="故障种类">故障种类</h4>
<ol>
<li>
<p>事务内部的故障</p>
<ul>
<li>有的是可以通过事务程序本身发现的</li>
<li>有的是非预期的，不能由事务程序处理的。
<ul>
<li>运算溢出</li>
<li>并发事务发生死锁而被选中撤销该事务</li>
<li>违反了某些完整性限制而被终止</li>
</ul>
</li>
<li>意味着事务没有达到预期的终点(COMMIT 或者显示的 ROLLBACK)，数据库可能处于不正确状态</li>
<li>恢复方法：事务撤消(UNDO)
<ul>
<li>强行回滚该事务</li>
<li>撤销该事务已经做出的任何对数据库的修改，使得该事务像根本没有启动一样</li>
</ul>
</li>
</ul>
</li>
<li>
<p>系统故障<br>
称为软故障，是指造成系统停止运转的任何时间，使得系统要重新启动。</p>
<ul>
<li>
<p>特定类型的硬件错误(如 CPU 故障)</p>
</li>
<li>
<p>操作系统故障</p>
</li>
<li>
<p>数据库管理系统代码错误</p>
</li>
<li>
<p>系统断电</p>
</li>
<li>
<p>故障影响：</p>
<ul>
<li>整个系统的正常运行突然被破坏</li>
<li>所有正在运行的事务都非正常终止</li>
<li>内存中数据库缓冲区的信息全部丢失</li>
<li>不破坏数据库<br>
发生系统故障时，一些尚未完成的事务的结果可能已送入物理数据库，造成数据库可能处于不正确状态。</li>
</ul>
</li>
<li>
<p>恢复策略：系统重新启动时，恢复程序让所有非正常终止的事务回滚，强行撤销(UNDO)所有未完成事务。<br>
发生系统故障时，有些已完成的事务可能有一部分甚至全部留在缓冲区，尚未写回到磁盘上的物理数据库中，系统故障使得这些事务对数据库的修改部分或全部丢失</p>
</li>
<li>
<p>恢复策略：重新启动时撤销所有未完成的事务，重做所有已提交的事务。</p>
</li>
</ul>
</li>
<li>
<p>介质故障<br>
称为硬故障，值外存故障</p>
<ul>
<li>硬盘损坏</li>
<li>磁头碰撞</li>
<li>瞬时强磁场干扰<br>
介质故障破坏数据库或部分数据库，并影响正在存取这部分数据的所有事务<br>
介质故障比前两类故障的可能性小得多，但破坏性大得多</li>
</ul>
</li>
<li>
<p>计算机病毒</p>
<ul>
<li>一种人为的故障或破坏，是一些恶作剧者研制的一种计算机程序</li>
<li>可以繁殖和传播，造成对计算机系统包括数据库的危害</li>
</ul>
</li>
</ol>
<h4 id="故障小结">故障小结</h4>
<p>各类故障，对数据库的影响有两种可能性</p>
<ol>
<li>数据库本身被破坏</li>
<li>数据库没有被破坏，但是数据可能不正确，这是由于事务的运行被非正常终止造成的。</li>
</ol>
<p>恢复操作的基本原理：冗余</p>
<ul>
<li>利用存储在系统别处的<code>冗余数据</code>来重建数据库中已被破坏或不正确的那部分数据</li>
</ul>
<p>恢复的实现技术：复杂</p>
<ul>
<li>一个大型数据库产品，恢复子系统的代码要占全部代码的 10%以上</li>
</ul>
<h3 id="恢复的实现技术">恢复的实现技术</h3>
<h4 id="数据转储">数据转储</h4>
<ul>
<li>转储是指数据库管理员定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程</li>
<li>备用的数据文本称为后备副本(backup)或后援副本</li>
<li>数据库遭到破坏后可以将后备副本重新装入</li>
<li>重装后备副本只能将数据库恢复到转储时的状态</li>
<li>要想恢复到故障发生时的状态，必须重新运行自转储以后的所有更新事务</li>
</ul>
<p><img src="https://icon.qiantucdn.com/20200617/bab0728ced0bb6f5dcb3f714a891c52f2#vwid=1639&amp;vhei=734" alt="数据库恢复技术"></p>
<h4 id="转储方法">转储方法</h4>
<ol>
<li>静态转储
<ul>
<li>在系统中无运行事务时进行的转储操作</li>
<li>转储开始时数据库处于一致性状态</li>
<li>转储期间不允许对数据库的任何存取、修改活动</li>
<li>得到的一定是一个数据一致性的副本</li>
<li>优点：简单</li>
<li>缺点：降低了数据库的可用性
<ul>
<li>转储必须等待正运行的用户事务结束</li>
<li>新的事务必须等转储结束</li>
</ul>
</li>
</ul>
</li>
<li>动态转储
<ul>
<li>转储操作与用户事务并发进行</li>
<li>转储期间允许对数据库进行存取或修改</li>
<li>优点
<ul>
<li>不用等待正在运行的用户事务结束</li>
<li>不会影响新事务的运行</li>
</ul>
</li>
<li>缺点
<ul>
<li>不能保证副本中的数据正确有效</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>利用动态转储得到的副本进行故障恢复</p>
<ul>
<li>需要把动态转储期间各事务对数据库的修改活动记录下来，监理日志文件</li>
<li>后备副本加上日志文件就能把数据库恢复到某一时刻的正确状态</li>
</ul>
<h4 id="海量转储与增量转储">海量转储与增量转储</h4>
<ul>
<li>
<p>海量转储：每次转储全部数据库</p>
</li>
<li>
<p>增量转储：只转储上次转储后更新过的数据</p>
</li>
<li>
<p>两者比较</p>
<ul>
<li>从恢复角度看，使用海量转储得到的后备副本进行恢复往往更方便</li>
<li>如果数据库大，事务处理又十分频繁，则增量转储方式更实用更有效</li>
</ul>
</li>
</ul>
<h4 id="登记日志文件">登记日志文件</h4>
<ul>
<li>日志文件是用来记录事务对数据库的更新操作的文件</li>
</ul>
<p>日志文件的格式</p>
<ul>
<li>以记录为单位的日志文件
<ul>
<li>各个事务的开始标记(BEGIN TRANSACTION)</li>
<li>各个事务的结束标记(COMMIT 或 ROLLBACK)</li>
<li>各个事务的所有更新操作<br>
以上均作为日志文件中的一个日志记录 (log record)
<ul>
<li>事务标识（标明是哪个事务）</li>
<li>操作类型（插入、删除或修改）</li>
<li>操作对象（记录 ID、Block NO.）</li>
<li>更新前数据的旧值（对插入操作而言，此项为空值）</li>
<li>更新后数据的新值（对删除操作而言, 此项为空值）<br>
例如<br>
<code>T1 U AA 18 20</code> T1 事务更新操作 将 AA 对象的值从 18 改为 20<br>
<code>T1 I TU 1</code> T1 事务插入操作 插入值为 1 的 TU 对象<br>
<code>T1 D TV 20</code> T1 对象删除事务 删除值为 20 的 TV 对象</li>
</ul>
</li>
</ul>
</li>
<li>以数据块为单位的日志文件
<ul>
<li>事务标识</li>
<li>被更新的数据块</li>
</ul>
</li>
</ul>
<p>日志文件的作用</p>
<ul>
<li>进行事务故障恢复</li>
<li>进行系统故障恢复</li>
<li>协助后备副本进行介质故障恢复</li>
</ul>
<p>具体作用</p>
<ul>
<li>事务故障恢复和系统故障恢复必须用日志文件。</li>
<li>在动态转储方式中必须建立日志文件，后备副本和日志文件结合起来才能有效地恢复数据库。</li>
<li>在静态转储方式中，也可以建立日志文件。
<ul>
<li>故障恢复时重新装入后援副本把数据库恢复到转储时刻的正确状态</li>
<li>利用日志文件，重做已完成事务，撤销未完成的事务</li>
<li>不必重新运行那些已完成的事务程序就可把数据库恢复到故障前某一时刻的正确状态</li>
</ul>
</li>
</ul>
<p>为保证数据库是可恢复的，登记日志文件时必须遵循两条原则</p>
<ol>
<li>登记的次序严格按并发事务执行的时间次序</li>
<li>必须先写日志文件，后写数据库
<ul>
<li>写日志文件操作：把表示这个修改的日志记录写到日志文件中</li>
<li>写数据库操作：把对数据的修改写到数据库中<br>
先写日志文件的原因：</li>
<li>写数据库和写日志文件是两个不同的操作</li>
<li>在这两个操作之间可能发生故障</li>
<li>如果先写了数据库修改，而在日志文件中没有登记下这个修改，则以后就无法恢复这个修改了</li>
<li>如果先写日志，但没有修改数据库，按日志文件恢复时只不过是多执行一次不必要的 UNDO 操作，并不会影响数据库的正确性</li>
</ul>
</li>
</ol>
<h3 id="恢复策略">恢复策略</h3>
<h4 id="事务故障的恢复">事务故障的恢复</h4>
<p>事务故障：事务在运行至正常终止点前被终止</p>
<p>恢复方法</p>
<ul>
<li>由恢复子系统利用日志文件撤消（UNDO）此事务已对数据库进行的修改</li>
</ul>
<p>事务故障的恢复由系统自动完成，对用户是透明的，不需要用户干预</p>
<p>恢复步骤：</p>
<ol>
<li>反向扫描文件日志（即从最后向前扫描日志文件），查找该事务的更新操作。</li>
<li>对该事务的更新操作执行逆操作。即将日志记录中“更新前的值” 写入数据库。
<ul>
<li>插入操作， “更新前的值”为空，则相当于做删除操作</li>
<li>删除操作，“更新后的值”为空，则相当于做插入操作</li>
<li>若是修改操作，则相当于用修改前值代替修改后值</li>
</ul>
</li>
<li>继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。</li>
<li>如此处理下去，直至读到此事务的开始标记，事务故障恢复就完成了。</li>
</ol>
<h4 id="系统故障的恢复">系统故障的恢复</h4>
<p>系统故障造成数据库不一致状态的原因</p>
<ul>
<li>未完成事务对数据库的更新可能已写入数据库</li>
<li>已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库</li>
</ul>
<p>恢复方法</p>
<ol>
<li>Undo 故障发生时未完成的事务</li>
<li>Redo 已完成的事务</li>
</ol>
<blockquote>
<p>系统故障的恢复由系统在重新启动时自动完成，不需要用户干预</p>
</blockquote>
<p>系统故障的恢复步骤</p>
<ol>
<li>
<p>正向扫描日志文件（即从头扫描日志文件）</p>
<ul>
<li>
<p>重做(REDO) 队列: 在故障发生前已经提交的事务</p>
<blockquote>
<p>这些事务既有 BEGIN TRANSACTION 记录，也有 COMMIT 记录</p>
</blockquote>
</li>
<li>
<p>撤销 (UNDO)队列:故障发生时尚未完成的事务</p>
<blockquote>
<p>这些事务只有 BEGIN TRANSACTION 记录，无相应的 COMMIT 记录</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>对撤销(UNDO)队列事务进行撤销(UNDO)处理</p>
<ul>
<li>反向扫描日志文件，对每个撤销事务的更新操作执行逆操作</li>
<li>即将日志记录中“更新前的值”写入数据库</li>
</ul>
</li>
<li>
<p>对重做(REDO)队列事务进行重做(REDO)处理</p>
<ul>
<li>正向扫描日志文件，对每个重做事务重新执行登记的操作</li>
<li>即将日志记录中“更新后的值”写入数据库</li>
</ul>
</li>
</ol>
<h4 id="介质故障的恢复">介质故障的恢复</h4>
<ol>
<li>重装数据库</li>
<li>重做已完成的事务</li>
</ol>
<p>恢复步骤</p>
<ol>
<li>装入最新的后备数据库副本(离故障发生时刻最近的转储副本) ，使数据库恢复到最近一次转储时的一致性状态。
<ul>
<li>对于静态转储的数据库副本，装入后数据库即处于一致性状态</li>
<li>对于动态转储的数据库副本，还须同时装入转储时刻的日志文件副本，利用恢复系统故障的方法（即 REDO+UNDO），才能将数据库恢复到一致性状态。</li>
</ul>
</li>
<li>装入有关的日志文件副本(转储结束时刻的日志文件副本) ，重做已完成的事务。
<ul>
<li>首先扫描日志文件，找出故障发生时已提交的事务的标识，将其记入重做队列。</li>
<li>然后正向扫描日志文件，对重做队列中的所有事务进行重做处理。即将日志记录中“更新后的值”写入数据库。</li>
</ul>
</li>
</ol>
<p>介质故障的恢复需要数据库管理人员的接入</p>
<ul>
<li>数据库管理员的工作
<ul>
<li>重装最近转储的数据库副本和有关的各日志文件副本</li>
<li>执行系统提供的恢复命令</li>
</ul>
</li>
</ul>
<blockquote>
<p>具体的恢复操作仍由数据库管理系统完成</p>
</blockquote>
<h3 id="具有检查点的恢复技术">具有检查点的恢复技术</h3>
<p>问题：</p>
<ul>
<li>搜索整个日志将耗费大量的时间</li>
<li>重做处理：重新执行，浪费了大量时间</li>
</ul>
<p>检查点恢复技术</p>
<ul>
<li>在日志文件中增加检查点记录</li>
<li>增加重新开始文件</li>
<li>恢复子系统在登陆日志文件期间动态地维护日志</li>
</ul>
<h4 id="检查点技术">检查点技术</h4>
<p>检查点记录的内容</p>
<ul>
<li>建立检查点时刻所有正在执行的事务清单</li>
<li>这些事务最近一个日志记录的地址</li>
</ul>
<p>重现开始文件的内容</p>
<ul>
<li>记录各个检查点记录在日志文件中的地址</li>
</ul>
<p>动态维护日志文件的方法：<br>
周期性地执行如下操作：建立检查点，保存数据库状态。<br>
具体步骤：</p>
<ol>
<li>将当前日志缓冲区中的所有日志记录写入磁盘的日志文件上</li>
<li>在日志文件中写入一个检查点记录</li>
<li>将当前数据缓冲区的所有数据记录写入磁盘的数据库中</li>
<li>把检查点记录在日志文件中的地址写入一个重新开始文件</li>
</ol>
<p>恢复子系统可以定期或不定期地建立检查点,保存数据库状态</p>
<ul>
<li>定期
<ul>
<li>按照预定的一个时间间隔，如每隔一小时建立一个检查点</li>
</ul>
</li>
<li>不定期
<ul>
<li>按照某种规则，如日志文件已写满一半建立一个检查点</li>
</ul>
</li>
</ul>
<h4 id="使用检查点的恢复策略">使用检查点的恢复策略</h4>
<p>使用检查点方法可以改善恢复效率</p>
<ul>
<li>当事务 T 在一个检查点之前提交
<ul>
<li>数据库所做的修改已写入数据库</li>
<li>写入时间是在这个检查点建立之前或在这个检查点建立之时</li>
<li>在进行恢复处理时，没有必要对事务 T 执行重做操作</li>
</ul>
</li>
<li>当事务 T 在检查点时还没有完成
<ul>
<li>T 对数据库所做的修改已写入数据库</li>
<li>在进行恢复处理时，如果需要重做 T，重做的起始点是检查点。</li>
</ul>
</li>
</ul>
<p>利用检查点的恢复步骤</p>
<ol>
<li>从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录</li>
<li>由该检查点记录得到检查点建立时刻所有正在执行的事务清单 ACTIVE-LIST
<ul>
<li>建立两个事务队列
<ul>
<li>UNDO-LIST</li>
<li>REDO-LIST</li>
</ul>
</li>
<li>把 ACTIVE-LIST 暂时放入 UNDO-LIST 队列，REDO 队列暂为空。</li>
</ul>
</li>
<li>从检查点开始正向扫描日志文件，直到日志文件结束
<ul>
<li>如有新开始的事务 Ti，把 Ti 暂时放入 UNDO-LIST 队列</li>
<li>如有提交的事务 Tj，把 Tj 从 UNDO-LIST 队列移到 REDO-LIST 队列;直到日志文件结束</li>
</ul>
</li>
<li>对 UNDO-LIST 中的每个事务执行 UNDO 操作，对 REDO-LIST 中的每个事务执行 REDO 操作</li>
</ol>
<h3 id="数据库镜像">数据库镜像</h3>
<p>介质故障是对系统影响最为严重的一种故障，严重影响数据库的可用性</p>
<ul>
<li>介质故障恢复比较费时</li>
<li>为预防介质故障，数据库管理员必须周期性地转储数据库</li>
</ul>
<p>提高数据库可用性的解决方案</p>
<h4 id="数据库镜像（Mirror）">数据库镜像（Mirror）</h4>
<ul>
<li>数据库管理系统自动把整个数据库或其中的关键数据复制到另一个磁盘上</li>
<li>数据库管理系统自动保证镜像数据与主数据的一致性<br>
每当主数据库更新时，数据库管理系统自动把更新后的数据复制过去</li>
</ul>
<p>数据库镜像用途</p>
<ul>
<li>出现介质故障时
<ul>
<li>可由镜像磁盘继续提供使用</li>
<li>同时数据库管理系统自动利用镜像磁盘数据进行数据库的恢复</li>
<li>不需要关闭系统和重装数据库副本</li>
</ul>
</li>
<li>没有出现故障时
<ul>
<li>可用于并发操作</li>
<li>一个用户对数据加排他锁修改数据，其他用户可以读镜像数据库上的数据，而不必等待该用户释放锁</li>
</ul>
</li>
</ul>
<blockquote>
<p>频繁地复制数据自然会降低系统运行效率<br>
在实际应用中用户往往只选择对<code>关键数据</code>和<code>日志文件</code>镜像。而不是对整个数据库进行镜像</p>
</blockquote>
<h2 id="并发控制">并发控制</h2>
<p>多用户数据库系统<br>
允许多个用户同时使用的数据库系统</p>
<ul>
<li>飞机定票数据库系统</li>
<li>银行数据库系统<br>
特点：在同一时刻并发运行的事务数可达数百上千个</li>
</ul>
<p>多事务执行方式</p>
<ol>
<li>事务串行执行
<ul>
<li>每个时刻只有一个事务运行，其他事务必须等到这个事务结束以后方能运行</li>
<li>不能充分利用系统资源，发挥数据库共享资源的特点</li>
</ul>
</li>
<li>交叉并发方式
<ul>
<li>在单处理机系统中，事务的并行执行是这些并行事务的并行操作轮流交叉运行</li>
<li>单处理机系统中的并行事务并没有真正地并行运行，但能够减少处理机的空闲时间，提高系统的效率</li>
</ul>
</li>
<li>同时并发方式
<ul>
<li>多处理机系统中，每个处理机可以运行一个事务，多个处理机可以同时运行多个事务，实现多个事务真正的并行运行</li>
<li>最理想的并发方式，但受制于硬件环境</li>
<li>更复杂的并发方式机制</li>
</ul>
</li>
</ol>
<h3 id="并发控制概述">并发控制概述</h3>
<ul>
<li>事务是并发控制的基本单位</li>
<li>并发控制机制的任务
<ul>
<li>对并发操作进行正确调度</li>
<li>保证事务的隔离性</li>
<li>保证数据库的一致性</li>
</ul>
</li>
</ul>
<p>并发操作带来的数据不一致性</p>
<ol>
<li>
<p>丢失修改（Lost Update）</p>
<ul>
<li>
<p>两个事务 T1 和 T2 读入同一数据并修改，T2 的提交结果破坏了 T1 提交的结果，导致 T1 的修改被丢失。</p>
<table>
<thead>
<tr>
<th></th>
<th>T1</th>
<th>T2</th>
</tr>
</thead>
<tbody>
<tr>
<td>①</td>
<td>R(A)=16</td>
<td></td>
</tr>
<tr>
<td>②</td>
<td></td>
<td>R(A)=16</td>
</tr>
<tr>
<td>③</td>
<td>A←A-1</td>
<td></td>
</tr>
<tr>
<td></td>
<td>W(A)=15</td>
<td></td>
</tr>
<tr>
<td>④</td>
<td></td>
<td>A←A-3</td>
</tr>
<tr>
<td></td>
<td></td>
<td>W(A)=13</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>不可重复读（Non-repeatable Read）</p>
<ul>
<li>不可重复读是指事务 T1 读取数据后，事务 T2<br>
执行更新操作，使 T1 无法再现前一次读取结果。</li>
</ul>
<ol>
<li>
<p>情况 1</p>
<ul>
<li>T1 读取某一数据</li>
<li><code>T2对其做了修改</code></li>
<li>当 T1 再次读该数据时，得到与前一次不同的值<br>
<img src="https://icon.qiantucdn.com/20200617/baf0de102162c9945e54af021518b5382#vwid=873&amp;vhei=424" alt="不可重复读1"></li>
</ul>
</li>
<li>
<p>情况 2</p>
<ul>
<li>事务 T1 按一定条件从数据库中读取了某些数据记录</li>
<li><code>事务T2删除了其中部分记录</code></li>
<li>当 T1 再次按相同条件读取数据时，发现某些记录神秘地消失了。</li>
</ul>
</li>
<li>
<p>情况 3</p>
<ul>
<li>
<p>事务 T1 按一定条件从数据库中读取某些数据记录</p>
</li>
<li>
<p>事务 T2 插入了一些记录</p>
</li>
<li>
<p>当 T1 再次按相同条件读取数据时，发现多了一些记录</p>
<blockquote>
<p>后两种不可重复读有时也称为幻影现象（Phantom Row）</p>
</blockquote>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>读“脏”数据（Dirty Read）</p>
<ul>
<li>事务 T1 修改某一数据，并将其写回磁盘</li>
<li>事务 T2 读取同一数据后，T1 由于某种原因被撤销</li>
<li>这时 T1 已修改过的数据恢复原值，T2 读到的数据就与数据库中的数据不一致</li>
<li>T2 读到的数据就为“脏”数据，即不正确的数据<br>
<img src="https://icon.qiantucdn.com/20200617/f4e79a32a3a42820684700d82412d0682#vwid=875&amp;vhei=421" alt="读脏数据"></li>
</ul>
</li>
</ol>
<blockquote>
<p>数据不一致性：由于并发操作破坏了事务的隔离性<br>
并发控制就是要用正确的方式调度并发操作，使一个用户事务的执行不受其他事务的干扰，从而避免造成数据的不一致性<br>
对数据库的应用有时允许某些不一致性，可以降低对一致性的要求以减少系统开销</p>
</blockquote>
<p>并发控制的主要技术</p>
<ul>
<li>封锁(Locking)</li>
<li>时间戳(Timestamp)</li>
<li>乐观控制法</li>
<li>多版本并发控制(MVCC)</li>
</ul>
<p>并发操作带来的数据不一致性</p>
<ol>
<li>丢失修改 （修改-修改冲突）</li>
<li>不可重复读 （读-更新冲突）
<ul>
<li>修改</li>
<li>删除</li>
<li>插入</li>
</ul>
</li>
<li>读“脏”数据（修改-读冲突）</li>
</ol>
<h3 id="封锁">封锁</h3>
<p>定义：封锁就是事务 T 在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁</p>
<blockquote>
<p>加锁后事务 T 就对该数据对象有了一定的控制，在事务 T 释放它的锁之前，其它的事务不能更新此数据对象。</p>
</blockquote>
<p>基本封锁类型</p>
<ul>
<li>排它锁（Exclusive Locks，简记为 X 锁/写锁）
<ul>
<li>若事务 T 对数据对象 A 加上 X 锁，则只允许 T 读取和修改 A，其它任何事务都不能再对 A 加任何类型的锁，直到 T 释放 A 上的锁</li>
<li>保证其他事务在 T 释放 A 上的锁之前不能再读取和修改 A</li>
</ul>
</li>
<li>共享锁（Share Locks，简记为 S 锁/读锁）
<ul>
<li>若事务 T 对数据对象 A 加上 S 锁，则事务 T 可以读 A 但不能修改 A，其它事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁</li>
<li>保证其他事务可以读 A，但在 T 释放 A 上的 S 锁之前不能对 A 做任何修改</li>
</ul>
</li>
</ul>
<h3 id="封锁协议">封锁协议</h3>
<ul>
<li>在运用 X 锁和 S 锁对数据对象加锁时，需要约定一些规则，这些规则为封锁协议（Locking Protocol）。
<ul>
<li>何时申请 X 锁或 S 锁</li>
<li>持锁时间</li>
<li>何时释放</li>
</ul>
</li>
</ul>
<blockquote>
<p>对封锁方式规定不同的规则，就形成了各种不同的封锁协议，在不同的程度上保证并发操作的正确调度。</p>
</blockquote>
<p>三级封锁协议</p>
<ol>
<li>
<p>一级封锁协议</p>
<ul>
<li>事务 T 在修改数据 R 之前必须先对其加 X 锁，直到事务结束才释放。
<ul>
<li>正常结束（COMMIT）</li>
<li>非正常结束（ROLLBACK）</li>
</ul>
</li>
<li>一级封锁协议可防止丢失修改，并保证事务 T 是可恢复的。</li>
</ul>
<blockquote>
<p>在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它不能保证可重复读和不读“脏”数据。</p>
</blockquote>
</li>
<li>
<p>二级封锁协议</p>
<ul>
<li>
<p>一级封锁协议加上事务 T 在读取数据 R 之前必须先对其加 S 锁，读完后即可释放 S 锁。</p>
</li>
<li>
<p>二级封锁协议可以防止丢失修改和读“脏”数据。</p>
<blockquote>
<p>在二级封锁协议中，由于读完数据后即可释放 S 锁，所以它不能保证可重复读。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>三级封锁协议</p>
<ul>
<li>一级封锁协议加上事务 T 在读取数据 R 之前必须先对其加 S 锁，直到事务结束才释放。</li>
<li>三级封锁协议可防止丢失修改、读脏数据和不可重复读。</li>
</ul>
</li>
</ol>
<p>三级协议的主要区别</p>
<ul>
<li>
<p>什么操作需要申请封锁以及何时释放锁（即持锁时间）</p>
<blockquote>
<p>不同的封锁协议使事务达到的一致性级别不同<br>
封锁协议级别越高，一致性程度越高</p>
</blockquote>
</li>
</ul>
<h3 id="活锁和死锁">活锁和死锁</h3>
<p><img src="https://icon.qiantucdn.com/20200617/af05984c5b8b0a6976fb15c288dfc4fb2#vwid=752&amp;vhei=407" alt="活锁"></p>
<p>避免活锁：采用先来先服务的策略</p>
<ul>
<li>当多个事务请求封锁同一数据对象时</li>
<li>按请求封锁的先后次序对这些事务排队</li>
<li>该数据对象上的锁一旦释放，首先批准申请队列中第一个事务获得锁</li>
</ul>
<p><img src="https://icon.qiantucdn.com/20200617/a77bd110b23003a01868ff990fcefd6c2#vwid=701&amp;vhei=389" alt="死锁"></p>
<p>死锁的预防</p>
<ol>
<li>
<p>一次封锁法</p>
<ul>
<li>要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行</li>
</ul>
<p>问题：</p>
<ul>
<li>过早加锁，降低系统并发度</li>
<li>难于事先精确确定封锁对象
<ul>
<li>数据库中数据是不断变化的，原来不要求封锁的数据，在执行过程中可能会变成封锁对象，所以很难事先精确地确定每个事务所要封锁的数据对象。</li>
<li>解决方法：将事务在执行过程中可能要封锁的数据对象全部加锁，这就进一步降低了并发度。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>顺序封锁法</p>
<ul>
<li>预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。</li>
</ul>
<p>问题：</p>
<ul>
<li>维护成本<br>
数据库系统中封锁的数据对象极多，并且随数据的插入、删除等操作而不断地变化，要维护这样的资源的封锁顺序非常困难，<code>成本很高</code>。</li>
<li>难以实现<br>
事务的封锁请求可以随着事务的执行而动态地决定，很难事先确定每一个事务要封锁哪些对象，因此也就<code>很难按规定的顺序去施加封锁</code></li>
</ul>
</li>
</ol>
<h4 id="结论">结论</h4>
<ul>
<li>在操作系统中广为采用的预防死锁的策略不太适合数据库的特点</li>
<li>数据库管理系统在解决死锁的问题上更普遍在用的是诊断并解除死锁的方法</li>
</ul>
<h4 id="死锁的诊断和解除">死锁的诊断和解除</h4>
<p>死锁的诊断</p>
<ol>
<li>
<p>超时法<br>
如果一个事务的等待时间超过了规定的时限，就认为发生了死锁</p>
<ul>
<li>优点：实现简单</li>
<li>缺点：
<ul>
<li>有可能误判死锁</li>
<li>时限若设置得太长，死锁发生后不能及时发现</li>
</ul>
</li>
</ul>
</li>
<li>
<p>等待图法<br>
用事务等待图动态反映所有事务的等待情况</p>
<ul>
<li>事务等待图是一个有向图G=(T，U)</li>
<li>T为结点的集合，每个结点表示正运行的事务</li>
<li>U为边的集合，每条边表示事务等待的情况</li>
<li>若T1等待T2，则T1，T2之间划一条有向边，从T1指向T2</li>
<li>并发控制子系统周期性地（比如每隔数秒）生成事务等待图，检测事务。如果发现图中存在回路，则表示系统中出现了死锁。<br>
<img src="https://icon.qiantucdn.com/20200617/f4afbeb13548be19d0c144c80841bfbd2#vwid=624&amp;vhei=159" alt="等待图"></li>
</ul>
</li>
</ol>
<p>解除死锁</p>
<ul>
<li>选择一个处理死锁代价最小的事务，将其撤销</li>
<li>释放此事务持有的所有的锁，使其它事务能继续运行下去</li>
</ul>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20200617152716743.png#vwid=650&amp;vhei=172" alt="解除死锁"></p>
<h3 id="并发调度的可串行性">并发调度的可串行性</h3>
<ul>
<li>数据库管理系统对并发事务不同的调度可能会产生不同的结果</li>
<li>串行调度是正确的</li>
<li>执行结果等价于串行调度的调度也是正确的，称为可串行化调度</li>
</ul>
<h4 id="可串行化调度">可串行化调度</h4>
<ul>
<li>多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同</li>
</ul>
<h4 id="可串行性">可串行性</h4>
<ul>
<li>是并发事务正确调度的准则</li>
<li>一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度</li>
</ul>
<h4 id="冲突可串行化调度">冲突可串行化调度</h4>
<p>一个比可串行化更严格的条件</p>
<ul>
<li>
<p>冲突操作：是指不同的事务对同一数据的读写操作和写写操作</p>
<ul>
<li>Ri(x)与Wj(x) 	/事务Ti读x，Tj写x，其中i≠j/</li>
<li>Wi(x)与Wj(x)    /事务Ti写x，Tj写x，其中i≠j/</li>
</ul>
<blockquote>
<p>涉及同一个数据库元素, 并且至少有一个是写操作</p>
</blockquote>
</li>
<li>
<p>不冲突操作</p>
<ul>
<li>ri(X); rj(Y) 读</li>
<li>ri(X); wj(Y), X不等于Y</li>
<li>wi(X); rj(Y), X不等于Y</li>
<li>wi(X); wj(Y), X不等于Y</li>
</ul>
</li>
</ul>
<p>不能交换的动作：</p>
<ul>
<li>同一事务的两个操作</li>
<li>不同事务的冲突操作
<ul>
<li>Ri(x)与Wj(x)</li>
<li>Wi(x)与Wj(x)</li>
</ul>
</li>
</ul>
<p>一个调度Sc在保证冲突操作的次序不变的情况下，通过交换两个事务不冲突操作的次序得到另一个调度Sc’，如果Sc’是串行的，称调度Sc是<strong>冲突可串行化</strong>的调度</p>
<blockquote>
<p>若一个调度是冲突可串行化，则一定是可串行化的调度</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[例] </span><br><span class="line">今有3个事务的一个调度</span><br><span class="line">r3(B) r1(A) w3(B) r2(B) r2(A) w2(B) r1(B) w1(A)</span><br><span class="line">判断该调度是否是冲突可串行化的调度。</span><br><span class="line">Sc1 = r3(B) r1(A) w3(B) r2(B) r2(A) w2(B) r1(B) w1(A)</span><br><span class="line">	  r3(B) w3(B) r1(A) r2(B) r2(A) w2(B) r1(B) w1(A)</span><br><span class="line">	  r3(B) w3(B) r2(B) r2(A) w2(B) r1(A) r1(B) w1(A)</span><br><span class="line">Sc2 = r3(B) w3(B) r2(B) r2(A) w2(B) r1(A) r1(B) w1(A)</span><br><span class="line">所以Sc1是冲突可串行化的调度</span><br><span class="line">Sd = r1(A) w1(A) r2(A) w2(A) r2(B) w2(B) r1(B) w1(B)</span><br><span class="line">w1(A)和 r2(A)冲突，w2(B)和r1(B)冲突</span><br><span class="line">不能通过无冲突交换将Sd变换为串行调度</span><br><span class="line">Sd不是冲突可串行化的调度</span><br></pre></td></tr></table></figure>
<ul>
<li>冲突可串行化调度是可串行化调度的充分条件，不是必要条件。还有不满足冲突可串行化条件的可串行化调度。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[例11.4]</span><br><span class="line">有3个事务 T1=W1(Y)W1(X)，T2=W2(Y)W2(X)，T3=W3(X)</span><br><span class="line">调度L1=W1(Y)W1(X)W2(Y)W2(X)W3(X)是一个串行调度。</span><br><span class="line">调度L2=W1(Y)W2(Y)W2(X)W1(X)W3(X)不满足冲突可串行化。</span><br><span class="line">但是调度L2是可串行化的，因为L2执行的结果与调度L1相同，Y的值都等于T2的值，X的值都等于T3的值</span><br></pre></td></tr></table></figure>
<h3 id="两段锁协议">两段锁协议</h3>
<p>数据库管理系统普遍采用两段锁协议的方法实现并发调度的可串行性，从而保证调度的正确性</p>
<p><strong>两段锁协议</strong>指所有事务必须分两个阶段对数据项加锁和解锁</p>
<ul>
<li>在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁</li>
<li>在释放一个封锁之后，事务不再申请和获得任何其他封锁</li>
</ul>
<p>“两段”锁的含义</p>
<p>事务分为两个阶段</p>
<ul>
<li>第一阶段是获得封锁，也称为扩展阶段
<ul>
<li>事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁</li>
</ul>
</li>
<li>第二阶段是释放封锁，也称为收缩阶段
<ul>
<li>事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例</span><br><span class="line">事务Ti遵守两段锁协议，其封锁序列是 ：</span><br><span class="line">Slock A Slock B Xlock C Unlock B Unlock A Unlock C；</span><br><span class="line"></span><br><span class="line">事务Tj不遵守两段锁协议，其封锁序列是：</span><br><span class="line">Slock A Unlock A Slock B Xlock C Unlock C Unlock B；</span><br></pre></td></tr></table></figure>
<blockquote>
<p>遵守两段锁协议，是一个可串行化调度。</p>
<p>事务遵守两段锁协议是可串行化调度的充分条件，而不是必要条件。</p>
<p>若并发事务都遵守两段锁协议，则对这些事务的任何并发调度策略都是可串行化的。</p>
<p>若并发事务的一个调度是可串行化的，不一定所有事务都符合两段锁协议。</p>
</blockquote>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20200617160130313.png#vwid=218&amp;vhei=395" alt="image-20200617160130313"></p>
<ul>
<li>对T1和T2的调度没有遵守两段锁协议</li>
<li>但是它是可串行化的</li>
<li>L1=R1(B)W1(A)R2(A)W2(B)</li>
</ul>
<blockquote>
<p>并发事务遵守两段锁协议，对这些事务的任何并发调度策略都是可串行化的；</p>
<p>不遵守两段锁协议，对这些事务的并发调度策略可能是可串行化的，也可能不是可串行化的。</p>
</blockquote>
<ul>
<li>两段锁协议与防止死锁的一次封锁法对比
<ul>
<li>一次封锁法要求每个事物必须一次将所有要使用的数据全部加锁，否则就不能继续执行，因此一次封锁法遵守两段锁协议</li>
<li>但是两段锁协议并不要求事务必须一次将所有要使用的数据全部加锁，因此遵守两段锁协议的事务可能发生死锁</li>
</ul>
</li>
</ul>
<p>[例] 遵守两段锁协议的事务可能发生死锁</p>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20200617160402197.png#vwid=627&amp;vhei=316" alt="image-20200617160402197"></p>
<h3 id="封锁粒度">封锁粒度</h3>
<p>封锁对象的大小称为封锁粒度(Granularity)</p>
<p>封锁的对象:逻辑单元，物理单元</p>
<ul>
<li>例：关系数据库中的封锁对象
<ul>
<li>逻辑单元: 属性值、属性值的集合、元组、关系、索引项、整个索引、整个数据库等</li>
<li>物理单元：页（数据页或索引页）、物理记录等</li>
</ul>
</li>
</ul>
<p>封锁粒度与系统的并发度和并发控制的开销密切相关。</p>
<ul>
<li>封锁的粒度越大，数据库所能够封锁的数据单元就越少，并发度就越小，系统开销也越小；</li>
<li>封锁的粒度越小，并发度较高，但系统开销也就越大</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例1：事务T1需要修改元组L1 ，事务T2需要修改元组L2 ， L1和L2 位于同一个数据页面A。</span><br><span class="line">若封锁粒度是数据页，事务T1需要对数据页A加锁，T2被迫等待，直到T1释放A。</span><br><span class="line">如果封锁粒度是元组，则T1和T2可以同时对L1和L2加锁，不需要互相等待，提高了系统的并行度。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>封锁粒度越小，并发度越高。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例2：事务T3需要读取整个表</span><br><span class="line">若封锁粒度是元组，T3必须对表中的每一个元组加锁，开销极大</span><br><span class="line">若封锁粒度是关系，T3只需要一次加锁</span><br><span class="line">若锁粒度是数据页呢？</span><br></pre></td></tr></table></figure>
<blockquote>
<p>封锁粒度越小，封锁开销越大。</p>
</blockquote>
<h4 id="多粒度封锁">多粒度封锁</h4>
<p>在一个系统中同时支持多种封锁粒度供不同的事务选择</p>
<ul>
<li>
<p>同时考虑封锁开销和并发度两个因素, 适当选择封锁粒度</p>
<ul>
<li>需要处理大量元组的用户事务：以关系为封锁单元</li>
<li>需要处理多个关系的大量元组的用户事务：以数据库为封锁单位</li>
<li>只处理少量元组的用户事务：以元组为封锁单位</li>
</ul>
</li>
<li>
<p>多粒度树</p>
<ul>
<li>以树形结构来表示多级封锁粒度</li>
<li>根结点是整个数据库，表示最大的数据粒度</li>
<li>叶结点表示最小的数据粒度</li>
</ul>
</li>
</ul>
<p>例1：三级粒度树</p>
<p>根结点为数据库，数据库的子结点为关系，关系的子结点为元组。</p>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20200617161139387.png#vwid=512&amp;vhei=216" alt="image-20200617161139387"></p>
<p>例2：四级粒度树</p>
<p><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20200617161159622.png#vwid=735&amp;vhei=281" alt="image-20200617161159622"></p>
<ul>
<li>
<p>多粒度封锁协议</p>
<ul>
<li>允许多粒度树中的每个结点被独立地加锁</li>
<li>对一个结点加锁意味着这个结点的所有后裔结点也被加以同样类型的锁</li>
<li>在多粒度封锁中一个数据对象可能以两种方式封锁：<code>显式封锁和隐式封锁</code></li>
</ul>
</li>
<li>
<p>显式封锁: 直接加到数据对象上的封锁</p>
</li>
<li>
<p>隐式封锁:是该数据对象没有独立加锁，是由于其上级结点加锁而使该数据对象加上了锁</p>
</li>
</ul>
<blockquote>
<p>显式封锁和隐式封锁的效果是一样的</p>
</blockquote>
<p>系统检查封锁冲突时</p>
<ul>
<li>要检查显式封锁</li>
<li>还要检查隐式封锁</li>
</ul>
<p>对某个数据对象加锁，系统要检查</p>
<ul>
<li>该数据对象
<ul>
<li>有无显式封锁与之冲突</li>
</ul>
</li>
<li>所有上级结点
<ul>
<li>检查本事务的显式封锁是否与该数据对象上的隐式封锁冲突(由上级结点已加的封锁造成的）</li>
</ul>
</li>
<li>所有下级结点
<ul>
<li>看上面的显式封锁是否与本事务的隐式封锁（将加到下级结点的封锁）冲突</li>
</ul>
</li>
</ul>
<h4 id="意向锁">意向锁</h4>
<p>引进意向锁的目的：提高对某个数据对象加锁时系统的检查效率</p>
<ul>
<li>如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁</li>
<li>对任一结点加基本锁，必须先对它的上层结点加意向锁</li>
</ul>
<p>常用意向锁</p>
<ul>
<li>意向共享锁(Intent Share Lock，简称IS锁)
<ul>
<li>如果对一个数据对象加IS锁，表示它的后裔结点拟（意向）加S锁。</li>
<li><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20200617161851862.png#vwid=819&amp;vhei=238" alt="image-20200617161851862"></li>
</ul>
</li>
<li>意向排它锁(Intent Exclusive Lock，简称IX锁)
<ul>
<li>如果对一个数据对象加IX锁，表示它的后裔结点拟（意向）加X锁。</li>
<li><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20200617161949978.png#vwid=853&amp;vhei=225" alt="image-20200617161949978"></li>
</ul>
</li>
<li>共享意向排它锁(Share Intent Exclusive Lock，简称SIX锁)
<ul>
<li>如果对一个数据对象加SIX锁，表示对它加S锁，再加IX锁，即SIX = S + IX。</li>
<li><img src="https://gitee.com/ethanloo/markdownImage/raw/master/img/image-20200617162005637.png#vwid=794&amp;vhei=221" alt="image-20200617162005637"></li>
</ul>
</li>
</ul>
<p>锁的强度</p>
<ul>
<li>锁的强度是指它对其他锁的排斥程度</li>
<li>一个事务在申请封锁时以强锁代替弱锁是安全的，反之则不然</li>
</ul>
<p>具有意向锁的多粒度封锁方法</p>
<ul>
<li>申请封锁时应该按自上而下的次序进行</li>
<li>释放封锁时则应该按自下而上的次序进行</li>
</ul>
<p>作用</p>
<ul>
<li>提高了系统的并发度</li>
<li>减少了加锁和解锁的开销</li>
<li>在实际的数据库管理系统产品中得到广泛应用</li>
</ul>
]]></content>
      <categories>
        <category>课程笔记</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
