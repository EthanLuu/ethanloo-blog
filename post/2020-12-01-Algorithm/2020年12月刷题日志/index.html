<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>2020年12月刷题日志 | Ethanloo's</title><meta name="author" content="EthanLoo"><meta name="copyright" content="EthanLoo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="文笔很烂，逻辑一般，单纯用来记录Leetcode刷题过程"><link rel="shortcut icon" href="https://cdn.ethanloo.cn/img/favicon.png"><link rel="canonical" href="https://blog.ethanloo.cn/post/2020-12-01-Algorithm/2020%E5%B9%B412%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.clarity.ms"><link rel="manifest" href="/manifest.json"><link rel="apple-touch-icon" sizes="180x180" href="https://cdn.ethanloo.cn/img/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://cdn.ethanloo.cn/img/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="https://cdn.ethanloo.cn/img/favicon.png"><link rel="mask-icon" href="https://cdn.ethanloo.cn/img/favicon.png" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>!function(t,e,n,c,r,a,s){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/bjrte2qfwy",(s=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,s)}(window,document,"clarity","script")</script><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Noto+Sans+SC&amp;family=Noto+Serif+SC&amp;family=Roboto+Mono&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: EthanLoo","link":"链接: ","source":"来源: Ethanloo's","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"2020年12月刷题日志",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-11-26 23:46:29"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="./css/optimization.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/avatar.png" onerror='onerror=null,src="https://cdn.ethanloo.cn/img/20201202163407.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fab fa-readme"></i> <span>文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.ethanloo.cn/lab"><i class="fa-fw fas fa-meteor"></i> <span>实验室</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Ethanloo's"><span class="site-name">Ethanloo's</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fab fa-readme"></i> <span>文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.ethanloo.cn/lab"><i class="fa-fw fas fa-meteor"></i> <span>实验室</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">2020年12月刷题日志</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2020-12-01T10:43:00.000Z" title="发表于 2020-12-01 10:43:00">2020-12-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/">刷题日志</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>59分钟</span></span></div></div></div><article class="post-content" id="article-container"><p><strong>12.31</strong></p><p>再见啦，2020</p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/20201231090005.png" alt="image-20201231090004979" style="zoom:50%"><p>太困了，先睡一会儿</p><p><strong>题目</strong></p><blockquote><h4 id="435-无重叠区间"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a></h4><p>难度中等271</p><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><p><strong>注意:</strong></p><ol><li>可以认为区间的终点总是大于它的起点。</li><li>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</li></ol><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2], [2,3], [3,4], [1,3] ]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2], [1,2], [1,2] ]</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2], [2,3] ]</span><br><span class="line"></span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span><br></pre></td></tr></table></figure></blockquote><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eraseOverlapIntervals</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 贪心</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(intervals)&lt;<span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        intervals.sort(key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">        last_end = intervals[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> left, right <span class="keyword">in</span> intervals[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> left&gt;=last_end:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                last_end = right</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(intervals)-cnt</span><br></pre></td></tr></table></figure><p><strong>12.30</strong></p><p><strong>题目</strong></p><blockquote><h4 id="1046-最后一块石头的重量"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/last-stone-weight/">1046. 最后一块石头的重量</a></h4><p>难度简单</p><p>有一堆石头，每块石头的重量都是正整数。</p><p>每一回合，从中选出两块 <strong>最重的</strong> 石头，然后将它们一起粉碎。假设石头的重量分别为 <code>x</code> 和 <code>y</code>，且 <code>x &lt;= y</code>。那么粉碎的可能结果如下：</p><ul><li>如果 <code>x == y</code>，那么两块石头都会被完全粉碎；</li><li>如果 <code>x != y</code>，那么重量为 <code>x</code> 的石头将会完全粉碎，而重量为 <code>y</code> 的石头新重量为 <code>y-x</code>。</li></ul><p>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 <code>0</code>。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,7,4,1,8,1]</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，</span><br><span class="line">再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，</span><br><span class="line">接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，</span><br><span class="line">最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= stones.length &lt;= 30</code></li><li><code>1 &lt;= stones[i] &lt;= 1000</code></li></ol></blockquote><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lastStoneWeight</span>(<span class="params">self, stones: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stones = [-i <span class="keyword">for</span> i <span class="keyword">in</span> stones]</span><br><span class="line">        heapify(stones)</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">len</span>(stones)&gt;<span class="number">1</span>:</span><br><span class="line">            big, small = -heapq.heappop(stones), -heapq.heappop(stones)</span><br><span class="line">            <span class="keyword">if</span> big==small:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                heapq.heappush(stones, -(big-small))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(stones) <span class="keyword">else</span> -heapq.heappop(stones)</span><br></pre></td></tr></table></figure><p><strong>12.29</strong></p><p>老样子，期末考试期间不写题解</p><p><strong>题目</strong></p><blockquote><h4 id="330-按要求补齐数组"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/patching-array/">330. 按要求补齐数组</a></h4><p>难度困难</p><p>给定一个已排序的正整数数组 *nums，*和一个正整数 *n 。*从 <code>[1, n]</code> 区间内选取任意个数字补充到 <em>nums</em> 中，使得 <code>[1, n]</code> 区间内的任何数字都可以用 <em>nums</em> 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3], n = 6</span><br><span class="line">输出: 1 </span><br><span class="line">解释:</span><br><span class="line">根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。</span><br><span class="line">现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。</span><br><span class="line">其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。</span><br><span class="line">所以我们最少需要添加一个数字。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,5,10], n = 20</span><br><span class="line">输出: 2</span><br><span class="line">解释: 我们需要添加 [2, 4]。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,2], n = 5</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure></blockquote><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minPatches</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res, x = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        index, length = <span class="number">0</span>, <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">while</span> x&lt;=n:</span><br><span class="line">            <span class="keyword">if</span> index&lt;<span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[index]&lt;=x:</span><br><span class="line">                x += nums[index]</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                x *= <span class="number">2</span></span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>12.28</strong></p><p><strong>题目</strong></p><blockquote><h4 id="188-买卖股票的最佳时机-IV"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/">188. 买卖股票的最佳时机 IV</a></h4><p>难度困难</p><p>给定一个整数数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>k</strong> 笔交易。</p><p>**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k = 2, prices = [2,4,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：k = 2, prices = [3,2,6,5,0,3]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。</span><br><span class="line">     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= k &lt;= 10^9</code></li><li><code>0 &lt;= prices.length &lt;= 1000</code></li><li><code>0 &lt;= prices[i] &lt;= 1000</code></li></ul></blockquote><p><strong>思路</strong></p><p>动态规划</p><p>又是复习，参考着大佬的代码优化了一下</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, k: <span class="built_in">int</span>, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 动态规划</span></span><br><span class="line">        <span class="comment"># 开辟两个数组，一个存放当天结束时候没有股票，另一个存放当天结束的时候手里有股票</span></span><br><span class="line">        buy = [-<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>)]</span><br><span class="line">        sell = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,k+<span class="number">1</span>):</span><br><span class="line">                buy[j] = <span class="built_in">max</span>(sell[j-<span class="number">1</span>]-price, buy[j])</span><br><span class="line">                sell[j] = <span class="built_in">max</span>(sell[j], buy[j]+price)</span><br><span class="line">        <span class="keyword">return</span> sell[k]</span><br></pre></td></tr></table></figure><p><strong>12.27</strong></p><p><strong>题目</strong></p><blockquote><h4 id="205-同构字符串"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/isomorphic-strings/">205. 同构字符串</a></h4><p>难度简单282</p><p>给定两个字符串 <em><strong>s</strong></em> 和 *<strong>t*</strong>，判断它们是否是同构的。</p><p>如果 <em><strong>s</strong></em> 中的字符可以被替换得到 *<strong>t*</strong> ，那么这两个字符串是同构的。</p><p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;egg&quot;, t = &quot;add&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;foo&quot;, t = &quot;bar&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;paper&quot;, t = &quot;title&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><p>用两个字典互相映射</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isIsomorphic</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        dic_s, dic_t = <span class="built_in">dict</span>(), <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            cur_s, cur_t = s[i], t[i]</span><br><span class="line">            <span class="keyword">if</span> cur_s <span class="keyword">in</span> dic_s <span class="keyword">and</span> dic_s[cur_s] != cur_t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> cur_t <span class="keyword">in</span> dic_t <span class="keyword">and</span> dic_t[cur_t] != cur_s:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            dic_s[cur_s] = cur_t</span><br><span class="line">            dic_t[cur_t] = cur_s</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>12.26</strong></p><p><strong>题目</strong></p><blockquote><h4 id="85-最大矩形"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/maximal-rectangle/">85. 最大矩形</a></h4><p>难度困难</p><p>给定一个仅包含 <code>0</code> 和 <code>1</code> 、大小为 <code>rows x cols</code> 的二维二进制矩阵，找出只包含 <code>1</code> 的最大矩形，并返回其面积。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]</span><br><span class="line">输出：6</span><br><span class="line">解释：最大矩形如上图所示。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = []</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[&quot;0&quot;]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[&quot;1&quot;]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[&quot;0&quot;,&quot;0&quot;]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>rows == matrix.length</code></li><li><code>cols == matrix[0].length</code></li><li><code>0 &lt;= row, cols &lt;= 200</code></li><li><code>matrix[i][j]</code> 为 <code>'0'</code> 或 <code>'1'</code></li></ul></blockquote><p><strong>思路</strong></p><p>就算是困难题，也给你锤烂，暴力法，yyds！（其实就是自己菜）</p><ol><li><p>暴力解法</p><p>为了确定每个位置能扩展出来最大的矩形面积，我们要知道这个位置向右有多少个连续的1，向下有多少个连续的1。知道之后呢，就分别向右和向下遍历，确定矩形的最大面积即可。</p><p>以向下遍历为例，假设当前这个位置向右有5个连续的1</p><ul><li>我们初始化宽度为5，高度为1，当前的最大矩形面积是5</li><li>开始向下遍历<ul><li>向下一格之后，数字是1，向右最多有4个连续的1，因此当前宽度就只能是4，高度为2，最大矩形面积为8</li><li>再向下一格，数字是1，向右最多有3个连续的1，当前宽度就是3，高度为3，最大面积9</li><li>再向下一格，数字是0，因此停止扩展</li></ul></li><li>向右遍历也是一个道理</li></ul></li><li><p>递增栈的巧妙解法</p><blockquote><p>算法详情<a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></p></blockquote><p>首先初始化一个高度数组<code>heights</code>，去记录每列最多有多少个连续的1</p><p>按行去遍历数组，以题目里的例子为例</p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg" alt="img" style="zoom:33%"><ul><li>第一行的时候 <code>heights = [1,0,1,0,0]</code></li><li>第二行的时候 <code>heights = [2,0,2,1,1]</code></li><li>第三行的时候 <code>heights = [3,1,2,2,2]</code></li><li>以第三行为例，来当前情况下求最大的面积</li><li>为了减少判断，我们往数组里放两个哨兵 <code>heights = [0]+heights+[0]</code></li><li>初始化递增栈 <code>stk=[0]</code></li><li>从<code>j=1</code>开始遍历 <code>heights</code><ul><li>当前的<code>heights[j]=3</code>比栈顶位置的高度<code>heights[stk[-1]]=0</code>高，所以直接把<code>j</code>丢到栈里</li><li>当前的<code>heights[j]=1</code>比栈顶位置的高度<code>3</code>要小，所以我们当前就能确定以<code>3</code>为高度的最大矩形面积</li><li>我们把栈顶元素<code>pop</code>出来，它的位置是<code>1</code>，因为我们的栈是递增栈，所以当前栈里的所有元素的位置的高度必定是比<code>3</code>要小的，所以我们的宽度只能是当前遍历的位置<code>2</code>减去栈顶元素的位置<code>0</code>再减去1，乘上高度<code>3</code>，所以最大面积就是3</li><li>之后同理</li></ul></li></ul></li></ol><blockquote><p>俺只是抄题解的菜🐓罢了</p></blockquote><p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/20201226101345.png" alt="image-20201226101337858"></p><p><strong>代码</strong></p><ol><li><p>暴力</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximalRectangle</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        rows = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        cols = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 记录每个1的右边和下边最多有多少个连续的1</span></span><br><span class="line">        <span class="comment"># 先记录行</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            last = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] ==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    last += <span class="number">1</span></span><br><span class="line">                    matrix[i][j] = [<span class="string">&#x27;1&#x27;</span>, last]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    last = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            last = <span class="number">0</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j][<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    last += <span class="number">1</span></span><br><span class="line">                    matrix[i][j].append(last)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    last = <span class="number">0</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j][<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    <span class="comment"># 向下找到最大的扩展可能性</span></span><br><span class="line">                    height = <span class="number">1</span></span><br><span class="line">                    width = matrix[i][j][<span class="number">1</span>]</span><br><span class="line">                    row, col = i, j</span><br><span class="line">                    res = <span class="built_in">max</span>(res, height*width)</span><br><span class="line">                    <span class="keyword">while</span> row+<span class="number">1</span>&lt;rows <span class="keyword">and</span> matrix[row+<span class="number">1</span>][j][<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                        row += <span class="number">1</span></span><br><span class="line">                        height += <span class="number">1</span></span><br><span class="line">                        width = <span class="built_in">min</span>(width, matrix[row][j][<span class="number">1</span>])</span><br><span class="line">                        res = <span class="built_in">max</span>(width*height, res)</span><br><span class="line">                    <span class="comment"># 再向右找到最大的扩展可能性</span></span><br><span class="line">                    width = <span class="number">1</span></span><br><span class="line">                    height = matrix[i][j][<span class="number">2</span>]</span><br><span class="line">                    <span class="keyword">while</span> col+<span class="number">1</span>&lt;cols <span class="keyword">and</span> matrix[i][col+<span class="number">1</span>][<span class="number">0</span>]==<span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                        col += <span class="number">1</span></span><br><span class="line">                        width += <span class="number">1</span></span><br><span class="line">                        height = <span class="built_in">min</span>(height, matrix[row][j][<span class="number">2</span>])</span><br><span class="line">                        res = <span class="built_in">max</span>(width*height, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li><li><p>借助递增栈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximalRectangle</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        rows = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        cols = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="comment"># 每次按列记录上面有多少个连续的1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        heights = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(cols+<span class="number">2</span>)] <span class="comment"># 加入了两哨兵站</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                <span class="keyword">if</span> matrix[i][j] == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">                    heights[j+<span class="number">1</span>] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    heights[j+<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">            <span class="comment"># 更新完heights数组之后开始求最大面积</span></span><br><span class="line">            stk = [<span class="number">0</span>] <span class="comment"># stk是一个递增栈</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,cols+<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">while</span> heights[j] &lt; heights[stk[-<span class="number">1</span>]]:</span><br><span class="line">                    index = stk.pop()</span><br><span class="line">                    width = j-(stk[-<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line">                    res = <span class="built_in">max</span>(res, width*heights[index])</span><br><span class="line">                stk.append(j)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></li></ol><p><strong>12.25</strong></p><p><strong>题目</strong></p><blockquote><h4 id="455-分发饼干"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/assign-cookies/">455. 分发饼干</a></h4><p>难度简单</p><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</p><p>对每个孩子 <code>i</code>，都有一个胃口值 <code>g[i]</code>，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 <code>j</code>，都有一个尺寸 <code>s[j]</code> 。如果 <code>s[j] &gt;= g[i]</code>，我们可以将这个饼干 <code>j</code> 分配给孩子 <code>i</code> ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: g = [1,2,3], s = [1,1]</span><br><span class="line">输出: 1</span><br><span class="line">解释: </span><br><span class="line">你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><br><span class="line">虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><br><span class="line">所以你应该输出1。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: g = [1,2], s = [1,2,3]</span><br><span class="line">输出: 2</span><br><span class="line">解释: </span><br><span class="line">你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。</span><br><span class="line">你拥有的饼干数量和尺寸都足以让所有孩子满足。</span><br><span class="line">所以你应该输出2.</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= g.length &lt;= 3 * 104</code></li><li><code>0 &lt;= s.length &lt;= 3 * 104</code></li><li><code>1 &lt;= g[i], s[j] &lt;= 231 - 1</code></li></ul></blockquote><p><strong>思路</strong></p><p>双指针</p><p>先对胃口数组和饼干数组排序，升序</p><p>然后分别用<code>i,j</code>两个指针遍历数组，如果胃口大，就把饼干数组的指针右移直到能吃饱为止</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findContentChildren</span>(<span class="params">self, g: <span class="type">List</span>[<span class="built_in">int</span>], s: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        g.sort()</span><br><span class="line">        s.sort()</span><br><span class="line">        i, j, res = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;<span class="built_in">len</span>(g) <span class="keyword">and</span> j&lt;<span class="built_in">len</span>(s):</span><br><span class="line">            <span class="keyword">while</span> j&lt;<span class="built_in">len</span>(s) <span class="keyword">and</span> g[i]&gt;s[j]:</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> j&lt;<span class="built_in">len</span>(s):</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">                res += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>12.24</strong></p><p>这就是困难题吗，莫名其妙过了，爱了爱了</p><p><strong>题目</strong></p><blockquote><h4 id="135-分发糖果"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/candy/">135. 分发糖果</a></h4><p>难度困难</p><p>老师想给孩子们分发糖果，有 <em>N</em> 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。</p><p>你需要按照以下要求，帮助老师给这些孩子分发糖果：</p><ul><li>每个孩子至少分配到 1 个糖果。</li><li>相邻的孩子中，评分高的孩子必须获得更多的糖果。</li></ul><p>那么这样下来，老师至少需要准备多少颗糖果呢？</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,0,2]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 你可以分别给这三个孩子分发 2、1、2 颗糖果。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,2]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 你可以分别给这三个孩子分发 1、2、1 颗糖果。</span><br><span class="line">     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><ul><li>先从左向右遍历，保证单方面合理<ul><li>如果当前遍历的孩子的评分比左侧的分数高</li><li>我给他的糖果数就要比左侧的孩子多一个</li></ul></li><li>再从右向左遍历，保证双方面合理<ul><li>如果当前遍历的孩子的评分比右侧的分数高</li><li>我给他的糖果数就要比右侧的孩子多一个</li><li>在这次遍历决定糖果数的时候要保证，当前的糖果数不能比之前单方面考虑的时候少</li></ul></li></ul><blockquote><p>我也不知道为什么这么纯粹的贪心就 AC 了</p></blockquote><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">candy</span>(<span class="params">self, ratings: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ratings:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(ratings)</span><br><span class="line">        candy = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(ratings)):</span><br><span class="line">            <span class="keyword">if</span> ratings[i]&gt;ratings[i-<span class="number">1</span>]:</span><br><span class="line">                candy[i] = candy[i-<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ratings)-<span class="number">2</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> ratings[i]&gt;ratings[i+<span class="number">1</span>]:</span><br><span class="line">                candy[i] = <span class="built_in">max</span>(candy[i+<span class="number">1</span>]+<span class="number">1</span>, candy[i]) </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(candy)</span><br></pre></td></tr></table></figure><p><strong>12.23</strong></p><p>我可太困了😴</p><p><strong>题目</strong></p><blockquote><h4 id="387-字符串中的第一个唯一字符"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/">387. 字符串中的第一个唯一字符</a></h4><p>难度简单</p><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;leetcode&quot;</span><br><span class="line">返回 0</span><br><span class="line"></span><br><span class="line">s = &quot;loveleetcode&quot;</span><br><span class="line">返回 2</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><ul><li>哈希表计数</li><li>找到所有出现次数为1的字母</li><li>找到这些字母中位置最靠前的</li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">firstUniqChar</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dic = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> dic:</span><br><span class="line">                dic[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[i] = <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">set</span>(s):</span><br><span class="line">            <span class="keyword">if</span> dic[i] == <span class="number">1</span>:</span><br><span class="line">                res.append(s.index(i))</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(res) <span class="keyword">if</span> res <span class="keyword">else</span> -<span class="number">1</span>     </span><br></pre></td></tr></table></figure><p><strong>12.22</strong></p><p>为啥层序遍历也变成中等难度了🧐</p><p><strong>题目</strong></p><blockquote><h4 id="103-二叉树的锯齿形层序遍历"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h4><p>难度中等</p><p>给定一个二叉树，返回其节点值的锯齿形层序遍历。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。</p><p>例如：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回锯齿形层序遍历如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><p>层序遍历，根据当前遍历的层数来决定是否要倒序输出</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">zigzagLevelOrder</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        nodes, res = [],[]</span><br><span class="line">        nodes.append(root)</span><br><span class="line">        height = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> nodes:</span><br><span class="line">            tmp, cur = [],[]</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">                cur.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    tmp.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    tmp.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> height%<span class="number">2</span>==<span class="number">0</span>:</span><br><span class="line">                res.append(cur)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(cur[::-<span class="number">1</span>])</span><br><span class="line">            height += <span class="number">1</span></span><br><span class="line">            nodes = tmp</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>12.21</strong></p><p>easy cozy</p><p><strong>题目</strong></p><blockquote><h4 id="746-使用最小花费爬楼梯"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/">746. 使用最小花费爬楼梯</a></h4><p>难度简单436</p><p>数组的每个索引作为一个阶梯，第 <code>i</code>个阶梯对应着一个非负数的体力花费值 <code>cost[i]</code>(索引从0开始)。</p><p>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</p><p>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: cost = [10, 15, 20]</span><br><span class="line">输出: 15</span><br><span class="line">解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li><code>cost</code> 的长度将会在 <code>[2, 1000]</code>。</li><li>每一个 <code>cost[i]</code> 将会是一个Integer类型，范围为 <code>[0, 999]</code>。</li></ol></blockquote><p><strong>思路</strong></p><p>最纯粹的动态规划，唯一的小trick就是在原数组后面加个0</p><blockquote><p>真的搞不懂为啥设定成最后一级台阶不是楼顶</p></blockquote><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minCostClimbingStairs</span>(<span class="params">self, cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(cost)</span><br><span class="line">        cost.append(<span class="number">0</span>)</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>], dp[<span class="number">1</span>] = cost[<span class="number">0</span>], cost[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(cost)):</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i-<span class="number">1</span>], dp[i-<span class="number">2</span>])+cost[i]</span><br><span class="line">        <span class="keyword">return</span> dp[-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>12.20</strong></p><p><strong>题目</strong></p><blockquote><h4 id="316-去除重复字母"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/remove-duplicate-letters/">316. 去除重复字母</a></h4><p>难度中等</p><p>给你一个字符串 <code>s</code> ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 <strong>返回结果的字典序最小</strong>（要求不能打乱其他字符的相对位置）。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;bcabc&quot;</span><br><span class="line">输出：&quot;abc&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;cbacdcbc&quot;</span><br><span class="line">输出：&quot;acdb&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 由小写英文字母组成</li></ul></blockquote><p><strong>思路</strong></p><ul><li><p>边遍历<code>s</code>，边考虑我们要保留哪些字母，丢弃哪些字母</p></li><li><p>用一个栈去存储我们选择保留的字母</p></li><li><p>假设当前遍历的是<code>s</code></p><ul><li>如果<code>s</code>已经在栈中，就忽略</li><li>否则就保留<code>s</code></li><li>但是为了最后的输出字典序最小，我们需要尽可能地删掉和<code>s</code>相邻且比<code>s</code>还要大的字母</li><li>在删除的同时，还要保证不能太贪了，如果要准备删的字母是它最后一次出现了，就停手</li></ul><blockquote><p>感觉有点像满门抄斩，但是给留个独苗</p></blockquote></li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicateLetters</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        dic = collections.Counter(s)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> res:</span><br><span class="line">                <span class="keyword">while</span> res <span class="keyword">and</span> res[-<span class="number">1</span>]&gt;i <span class="keyword">and</span> dic[res[-<span class="number">1</span>]]&gt;<span class="number">0</span>:</span><br><span class="line">                    res.pop()</span><br><span class="line">                res.append(i)</span><br><span class="line">            dic[i] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(res)</span><br></pre></td></tr></table></figure><p><strong>12.19</strong></p><p><strong>题目</strong></p><blockquote><h4 id="48-旋转图像"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/rotate-image/">48. 旋转图像</a></h4><p>难度中等</p><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵表示一个图像。</p><p>将图像顺时针旋转 90 度。</p><p><strong>说明：</strong></p><p>你必须在**<a target="_blank" rel="noopener external nofollow noreferrer" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>**旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong>使用另一个矩阵来旋转图像。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix = </span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定 matrix =</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">], </span><br><span class="line"></span><br><span class="line">原地旋转输入矩阵，使其变为:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><p>好家伙，给我人转晕了，我们慢慢分析，找一下规律</p><ul><li>假设矩阵行数=<code>n</code>，列数=<code>n</code><ul><li>以第二个矩阵为例，行数=4，列数=4，经过旋转</li><li><code>(1,0)=&gt;(0,2)</code></li><li><code>(1,1)=&gt;(1,2)</code></li><li><code>(1,2)=&gt;(2,2)</code></li><li><code>(1,3)=&gt;(3,1)</code></li></ul></li><li>矩阵中的<code>(row,col)</code>在旋转90°之后，到了<code>(col,n-row-1)</code><ul><li>即<code>(row,col)=&gt;(col,n-row-1)</code></li></ul></li><li>根据这个规律可以有两种实现矩阵原地旋转的方式</li></ul><ol><li><p>设缓存量，逐个交换</p><p>每次的旋转都可以把元素分成四个一组，将四个元素的值逐个交换</p><p>这四个元素分别是</p><ul><li><code>matrix[row][col]</code></li><li><code>matrix[col,n-row-1]</code></li><li><code>matrix[n-row-1,n-col-1]</code></li><li><code>matrix[n-col-1,row]</code></li></ul><p>只要让第一个值到第二个位置去，第二个值到第三个位置去，第三个值到第四个位置去，第四个值到第一个位置去即可</p><p>要实现这个，可以设一个缓存量<code>tmp</code>，来实现四个元素的值的交换（python也可以直接交换，但是我个人觉得代码可读性太差了）</p><p>还有一个问题是应该分成哪些组呢？</p><p>偶数情况就是平均分成四块，<code>n^2 = 4*(n/2)*(n/2)</code></p><p>奇数情况需要分解成<code>n^2 = 4*((n-1)/2)*((n+1)/2)+1</code>直接看官方题解的图吧</p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://assets.leetcode-cn.com/solution-static/48/2.png" alt="fig2" style="zoom:25%"></li><li><p>巧翻转</p><p>首先将矩阵按水平轴翻转，即上下翻转</p><p><code>matrix[row][col]=matrix[n-row-1][col]</code></p><p>再将矩阵根据主对角线翻转，即右上的元素到左下</p><p><code>matrix[n-row-1][col]=matrix[col][n-row-1]</code></p><p>因此最后实现的是</p><p><code>matrix[row][col]=&gt;matrix[col][n-row-1]</code></p><p>正好是我们要求的变换</p></li></ol><p><strong>代码</strong></p><ol><li><p>逐个交换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>((n+<span class="number">1</span>)//<span class="number">2</span>):</span><br><span class="line">                tmp = matrix[i][j]</span><br><span class="line">                matrix[i][j] = matrix[n-j-<span class="number">1</span>][i]</span><br><span class="line">                matrix[n-j-<span class="number">1</span>][i] = matrix[n-i-<span class="number">1</span>][n-j-<span class="number">1</span>]</span><br><span class="line">                matrix[n-i-<span class="number">1</span>][n-j-<span class="number">1</span>] = matrix[j][n-i-<span class="number">1</span>]</span><br><span class="line">                matrix[j][n-i-<span class="number">1</span>] = tmp</span><br></pre></td></tr></table></figure></li><li><p>翻转</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(matrix)</span><br><span class="line">        <span class="comment"># 上下翻转</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n//<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                matrix[i][j], matrix[n-i-<span class="number">1</span>][j] = matrix[n-i-<span class="number">1</span>][j], matrix[i][j]</span><br><span class="line">        <span class="comment"># 对角线翻转</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]</span><br></pre></td></tr></table></figure></li></ol><p><strong>12.18</strong></p><p><strong>题目</strong></p><blockquote><h4 id="389-找不同"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/find-the-difference/">389. 找不同</a></h4><p>难度简单</p><p>给定两个字符串 <em><strong>s</strong></em> 和 <em><strong>t</strong></em>，它们只包含小写字母。</p><p>字符串 *<strong>t*</strong> 由字符串 *<strong>s*</strong> 随机重排，然后在随机位置添加一个字母。</p><p>请找出在 <em><strong>t</strong></em> 中被添加的字母。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcd&quot;, t = &quot;abcde&quot;</span><br><span class="line">输出：&quot;e&quot;</span><br><span class="line">解释：&#x27;e&#x27; 是那个被添加的字母。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;&quot;, t = &quot;y&quot;</span><br><span class="line">输出：&quot;y&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ae&quot;, t = &quot;aea&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 1000</code></li><li><code>t.length == s.length + 1</code></li><li><code>s</code> 和 <code>t</code> 只包含小写字母</li></ul></blockquote><p><strong>思路</strong></p><p>哈，都可以哈</p><p>用一个字典统计字母出现次数，s中出现了就-1，t出现了就+1</p><p>最后value为1对应的key就是我们要找的字母</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findTheDifference</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        dic_t = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">            dic_t[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            dic_t[i] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dic_t.keys():</span><br><span class="line">            <span class="keyword">if</span> dic_t[i]&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><p><strong>12.17</strong></p><p>正好复习一下两个星期前看的labuladong的算法小抄</p><p><strong>题目</strong></p><blockquote><h4 id="714-买卖股票的最佳时机含手续费"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/">714. 买卖股票的最佳时机含手续费</a></h4><p>难度中等</p><p>给定一个整数数组 <code>prices</code>，其中第 <code>i</code> 个元素代表了第 <code>i</code> 天的股票价格 ；非负整数 <code>fee</code> 代表了交易股票的手续费用。</p><p>你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</p><p>返回获得利润的最大值。</p><p>**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: prices = [1, 3, 2, 8, 4, 9], fee = 2</span><br><span class="line">输出: 8</span><br><span class="line">解释: 能够达到的最大利润:  </span><br><span class="line">在此处买入 prices[0] = 1</span><br><span class="line">在此处卖出 prices[3] = 8</span><br><span class="line">在此处买入 prices[4] = 4</span><br><span class="line">在此处卖出 prices[5] = 9</span><br><span class="line">总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><p><code>0 &lt; prices.length &lt;= 50000</code>.</p></li><li><p><code>0 &lt; prices[i] &lt; 50000</code>.</p></li><li><p><code>0 &lt;= fee &lt; 50000</code>.</p></li></ul></blockquote><p><strong>思路</strong></p><p>动态规划三要素</p><ol><li><p><code>dp</code>数组定义</p><p>因为我们每天结束的时候最多两个状态</p><ul><li>手里没股票</li><li>手里有股票</li></ul><p>所以就定义</p><ul><li><p><code>dp[i][0]</code>表示第<code>i</code>天结束的时候手里没股票时的最大利润</p></li><li><p><code>dp[i][1]</code>表示第<code>i</code>天结束的时候手里有股票时的最大利润</p></li></ul></li><li><p>base case</p><p>一开始每天的利润初始化为0</p><p>根据数组定义，第0天的状态就是<code>dp[0][0]=0,dp[0][1]=-prices[0]</code></p></li><li><p>状态转移方程</p><p>如果当天结束的时候没有股票，有两种可能</p><ul><li>当天卖出了股票</li><li>当天开始的时候就没有股票</li></ul><p>如果当天结束的时候有股票</p><ul><li>当天新买的股票</li><li>当天开始的时候已经持有了股票</li></ul><p>因此，考虑到手续费，状态转移方程为</p><p><code>dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i]-fee)</code></p><p><code>dp[i][1] = max(dp[i-1][1], dp[i-1][0]-prices[i])</code></p></li></ol><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>], fee: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 动态规划</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>], dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>, -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>]+prices[i]-fee)</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">1</span>][<span class="number">0</span>]-prices[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[-<span class="number">1</span>][<span class="number">0</span>], dp[-<span class="number">1</span>][<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p>优化一下空间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>], fee: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 动态规划</span></span><br><span class="line">        n = <span class="built_in">len</span>(prices)</span><br><span class="line">        dp = [[<span class="number">0</span>,<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment"># base case</span></span><br><span class="line">        dp0, dp1 = <span class="number">0</span>, -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            dp0, dp1 = <span class="built_in">max</span>(dp0, dp1+prices[i]-fee), <span class="built_in">max</span>(dp1, dp0-prices[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp0, dp1)</span><br></pre></td></tr></table></figure><p><strong>12.16</strong></p><p><strong>题目</strong></p><blockquote><h4 id="290-单词规律"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/word-pattern/">290. 单词规律</a></h4><p>难度简单237</p><p>给定一种规律 <code>pattern</code> 和一个字符串 <code>str</code> ，判断 <code>str</code> 是否遵循相同的规律。</p><p>这里的 <strong>遵循</strong> 指完全匹配，例如， <code>pattern</code> 里的每个字母和字符串 <code>str</code> 中的每个非空单词之间存在着双向连接的对应规律。</p><p><strong>示例1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: pattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: pattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>说明:</strong><br>你可以假设 <code>pattern</code> 只包含小写字母， <code>str</code> 包含了由单个空格分隔的小写字母。</p></blockquote><p><strong>思路</strong></p><p>两个哈希表互相找，一个以<code>pattern</code>中的字母为key，一个以<code>str</code>中的单词为key</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wordPattern</span>(<span class="params">self, pattern: <span class="built_in">str</span>, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        dic_p = <span class="built_in">dict</span>()</span><br><span class="line">        dic_w = <span class="built_in">dict</span>()</span><br><span class="line">        words = s.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(words) != <span class="built_in">len</span>(pattern):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(words)):</span><br><span class="line">            p = pattern[i]</span><br><span class="line">            w = words[i]</span><br><span class="line">            <span class="keyword">if</span> p <span class="keyword">not</span> <span class="keyword">in</span> dic_p <span class="keyword">and</span> w <span class="keyword">not</span> <span class="keyword">in</span> dic_w:</span><br><span class="line">                dic_p[p] = w</span><br><span class="line">                dic_w[w] = p</span><br><span class="line">            <span class="keyword">elif</span> p <span class="keyword">not</span> <span class="keyword">in</span> dic_p <span class="keyword">or</span> w <span class="keyword">not</span> <span class="keyword">in</span> dic_w:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> dic_p[p] != w <span class="keyword">or</span> dic_w[w]!=p:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>12.15</strong></p><p><strong>题目</strong></p><blockquote><h4 id="738-单调递增的数字"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/monotone-increasing-digits/">738. 单调递增的数字</a></h4><p>难度中等</p><p>给定一个非负整数 <code>N</code>，找出小于或等于 <code>N</code> 的最大的整数，同时这个整数需要满足其各个位数上的数字是单调递增。</p><p>（当且仅当每个相邻位数上的数字 <code>x</code> 和 <code>y</code> 满足 <code>x &lt;= y</code> 时，我们称这个整数是单调递增的。）</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: N = 10</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: N = 1234</span><br><span class="line">输出: 1234</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: N = 332</span><br><span class="line">输出: 299</span><br></pre></td></tr></table></figure><p><strong>说明:</strong> <code>N</code> 是在 <code>[0, 10^9]</code> 范围内的一个整数。</p></blockquote><p><strong>思路</strong></p><p>用递增栈存数字，然后贪！</p><p>我们首先来找一下思路</p><ol><li><p>如果原来的数字能顺利的存放到递增栈中，那挺好，直接返回就行。</p></li><li><p>但是大部分情况下都不是这样的，例如<code>3455521</code>，它在第6位，即<code>2</code>开始不是递增的了，这个时候该怎么办呢？</p><p>这个时候肯定应该丢掉栈顶的一部分数字，然后把栈顶的一个数字减小1，来保证我最后的结果比原数字小。</p><p>然后放尽可能多的9到栈里，来保证最后我的结果最大。</p></li></ol><p>OK，现在来思考要丢掉几个数字，放几个9</p><ul><li>可以看到，当我尝试放<code>2</code>的时候，我的栈应该是<code>[3, 4, 5, 5, 5]</code></li><li>这个时候，如果只丢掉一个<code>5</code>，就变成<code>[3, 4, 5, 5]</code>，这个时候把栈顶元素减小1，那就不是递增的了呀</li><li>所以我们要让栈顶丢到只剩一个<code>5</code>，然后把<code>5</code>变成<code>4</code>放到栈里面去</li><li>再补<code>9</code>，<code>9</code>的个数应该是当前原数字的长度减掉当前栈的长度</li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">monotoneIncreasingDigits</span>(<span class="params">self, N: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 贪心法</span></span><br><span class="line">        N = <span class="built_in">str</span>(N)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(N)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">or</span> <span class="built_in">int</span>(N[i])&gt;=<span class="built_in">int</span>(res[-<span class="number">1</span>]):</span><br><span class="line">                res.append(N[i])</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(res)&gt;=<span class="number">2</span> <span class="keyword">and</span> res[-<span class="number">1</span>]==res[-<span class="number">2</span>]:</span><br><span class="line">                res.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">int</span>(res[-<span class="number">1</span>])&gt;<span class="number">0</span>:</span><br><span class="line">                res[-<span class="number">1</span>] = <span class="built_in">str</span>(<span class="built_in">int</span>(res[-<span class="number">1</span>])-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.pop()</span><br><span class="line">            <span class="keyword">while</span> <span class="built_in">len</span>(res)&lt;<span class="built_in">len</span>(N):</span><br><span class="line">                res.append(<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(<span class="string">&#x27;&#x27;</span>.join(res))</span><br></pre></td></tr></table></figure><p><strong>12.14</strong></p><p>昨天csp熬了三个多小时才200多分 💢</p><p><strong>题目</strong></p><blockquote><h4 id="49-字母异位词分组"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/group-anagrams/">49. 字母异位词分组</a></h4><p>难度中等</p><p>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>所有输入均为小写字母。</li><li>不考虑答案输出的顺序。</li></ul></blockquote><p><strong>思路</strong></p><p>无非就是建一个字典，定义一个key，然后把所有字母异位词放到一个value里。</p><ol><li><p>手动哈希</p><p>把所有的字符串转换成自定义的键值</p><p>例如“sssdda”我就转换成“a1d2s3”，这样就可以很方便地存取</p></li><li><p>排序</p><p>所有字符串都按字母序排一遍序，这样子字母异位词就是同一个词了</p><p>事实证明排序比上面第一种方法快得多</p></li></ol><p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/20201214095351.png" alt="image-20201214095207104"></p><p>​ 排序🐂🍺嗷</p><p><strong>代码</strong></p><ol><li>哈希</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">groupAnagrams</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        <span class="comment"># 手动哈希</span></span><br><span class="line">        dic = <span class="built_in">dict</span>()</span><br><span class="line">        words = <span class="string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> strs:</span><br><span class="line">            hash_code = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">                <span class="keyword">if</span> word.count(w)&gt;<span class="number">0</span>:</span><br><span class="line">                    hash_code += w+<span class="built_in">str</span>(word.count(w))</span><br><span class="line">            <span class="keyword">if</span> hash_code <span class="keyword">in</span> dic:</span><br><span class="line">                dic[hash_code].append(word)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[hash_code] = [word]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(dic.values())</span><br></pre></td></tr></table></figure><ol start="2"><li>排序</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">groupAnagrams</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        <span class="comment"># 排序</span></span><br><span class="line">        dic = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> strs:</span><br><span class="line">            hash_code = <span class="string">&quot;&quot;</span>.join(<span class="built_in">sorted</span>(word))</span><br><span class="line">            <span class="keyword">if</span> hash_code <span class="keyword">in</span> dic:</span><br><span class="line">                dic[hash_code].append(word)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[hash_code] = [word]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(dic.values())</span><br></pre></td></tr></table></figure><p><strong>12.13</strong></p><p>嚯，今天考csp，leetcode竟然给我放假</p><p><strong>题目</strong></p><blockquote><h4 id="217-存在重复元素"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/contains-duplicate/">217. 存在重复元素</a></h4><p>难度简单</p><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果任意一值在数组中出现至少两次，函数返回 <code>true</code> 。如果数组中每个元素都不相同，则返回 <code>false</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,1,1,3,3,4,3,2,4,2]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><ul><li>哈希表</li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)!=<span class="built_in">len</span>(<span class="built_in">set</span>(nums))</span><br></pre></td></tr></table></figure><p><strong>12.12</strong></p><p>美好的周末从看题解开始</p><p><strong>题目</strong></p><blockquote><h4 id="376-摆动序列"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/wiggle-subsequence/">376. 摆动序列</a></h4><p>难度中等</p><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为**摆动序列。**第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p><p>例如， <code>[1,7,4,9,2,5]</code> 是一个摆动序列，因为差值 <code>(6,-3,5,-7,3)</code> 是正负交替出现的。相反, <code>[1,4,7,2,5]</code> 和 <code>[1,7,4,5,5]</code> 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,7,4,9,2,5]</span><br><span class="line">输出: 6 </span><br><span class="line">解释: 整个序列均为摆动序列。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,17,5,10,13,15,10,5,16,8]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7,8,9]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>进阶:</strong><br>你能否用 O(<em>n</em>) 时间复杂度完成此题</p></blockquote><p><strong>思路</strong></p><p>动态规划</p><ul><li><p>建立两个数组<code>up,down</code></p></li><li><p><code>up[i],down[i]</code>分别表示<code>nums</code>的前<code>i</code>个数字能够组成的最长子序列长度</p></li><li><p>其中<code>up</code>数组存储的子序列要求最后是上升的，<code>down</code>数组的子序列最后是下降的</p></li><li><p>base case</p><ul><li><code>up[0], down[0] = 1, 1</code></li></ul></li><li><p>状态转移</p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/image-20201212091344652.png" alt="image-20201212091344652" style="zoom:67%"></li><li><p>最后比较这两个数组中的最后一个值，大的那个就是答案</p></li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wiggleMaxLength</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        up = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        down = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        <span class="comment"># 这两个数组用来记录遍历到i时的最大子序列长度</span></span><br><span class="line">        up[<span class="number">0</span>], down[<span class="number">0</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&lt;nums[i-<span class="number">1</span>]:</span><br><span class="line">                up[i] = up[i-<span class="number">1</span>]</span><br><span class="line">                down[i] = <span class="built_in">max</span>(down[i-<span class="number">1</span>], up[i-<span class="number">1</span>]+<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">elif</span> nums[i]&gt;nums[i-<span class="number">1</span>]:</span><br><span class="line">                up[i] = <span class="built_in">max</span>(down[i-<span class="number">1</span>]+<span class="number">1</span>, up[i-<span class="number">1</span>])</span><br><span class="line">                down[i] = down[i-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                up[i] = up[i-<span class="number">1</span>]</span><br><span class="line">                down[i] = down[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(down[n-<span class="number">1</span>], up[n-<span class="number">1</span>])</span><br></pre></td></tr></table></figure><p><strong>12.11</strong></p><p><strong>题目</strong></p><blockquote><h4 id="649-Dota2-参议院"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/dota2-senate/">649. Dota2 参议院</a></h4><p>难度中等</p><p>Dota2 的世界里有两个阵营：<code>Radiant</code>(天辉)和 <code>Dire</code>(夜魇)</p><p>Dota2 参议院由来自两派的参议员组成。现在参议院希望对一个 Dota2 游戏里的改变作出决定。他们以一个基于轮为过程的投票进行。在每一轮中，每一位参议员都可以行使两项权利中的<code>**一**</code>项：</p><ol><li><p><code>禁止一名参议员的权利</code>：</p><p>参议员可以让另一位参议员在这一轮和随后的几轮中丧失<strong>所有的权利</strong>。</p></li><li><p><code>宣布胜利</code>：</p></li></ol><p>​ 如果参议员发现有权利投票的参议员都是<strong>同一个阵营的</strong>，他可以宣布胜利并决定在游戏中的有关变化。</p><p>给定一个字符串代表每个参议员的阵营。字母 “R” 和 “D” 分别代表了 <code>Radiant</code>（天辉）和 <code>Dire</code>（夜魇）。然后，如果有 <code>n</code> 个参议员，给定字符串的大小将是 <code>n</code>。</p><p>以轮为基础的过程从给定顺序的第一个参议员开始到最后一个参议员结束。这一过程将持续到投票结束。所有失去权利的参议员将在过程中被跳过。</p><p>假设每一位参议员都足够聪明，会为自己的政党做出最好的策略，你需要预测哪一方最终会宣布胜利并在 Dota2 游戏中决定改变。输出应该是 <code>Radiant</code> 或 <code>Dire</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;RD&quot;</span><br><span class="line">输出：&quot;Radiant&quot;</span><br><span class="line">解释：第一个参议员来自 Radiant 阵营并且他可以使用第一项权利让第二个参议员失去权力，因此第二个参议员将被跳过因为他没有任何权利。然后在第二轮的时候，第一个参议员可以宣布胜利，因为他是唯一一个有投票权的人</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;RDD&quot;</span><br><span class="line">输出：&quot;Dire&quot;</span><br><span class="line">解释：</span><br><span class="line">第一轮中,第一个来自 Radiant 阵营的参议员可以使用第一项权利禁止第二个参议员的权利</span><br><span class="line">第二个来自 Dire 阵营的参议员会被跳过因为他的权利被禁止</span><br><span class="line">第三个来自 Dire 阵营的参议员可以使用他的第一项权利禁止第一个参议员的权利</span><br><span class="line">因此在第二轮只剩下第三个参议员拥有投票的权利,于是他可以宣布胜利</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>给定字符串的长度在 <code>[1, 10,000]</code> 之间.</li></ul></blockquote><p><strong>思路</strong></p><p>双队列模拟投票即可，好困，睡了</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predictPartyVictory</span>(<span class="params">self, senate: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        senate_r, senate_d = [], []</span><br><span class="line">        n = <span class="built_in">len</span>(senate)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> senate[i] == <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">                senate_d.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                senate_r.append(i)</span><br><span class="line">        <span class="keyword">while</span> senate_r <span class="keyword">and</span> senate_d:</span><br><span class="line">            <span class="keyword">if</span> senate_r[<span class="number">0</span>] &lt; senate_d[<span class="number">0</span>]:</span><br><span class="line">                senate_r.append(senate_r[<span class="number">0</span>]+n)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                senate_d.append(senate_d[<span class="number">0</span>]+n)</span><br><span class="line">            senate_d.pop(<span class="number">0</span>)</span><br><span class="line">            senate_r.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> senate_r: <span class="keyword">return</span> <span class="string">&quot;Radiant&quot;</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="keyword">return</span> <span class="string">&quot;Dire&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>12.10</strong></p><p><strong>题目</strong></p><blockquote><h4 id="860-柠檬水找零"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/lemonade-change/">860. 柠檬水找零</a></h4><p>难度简单</p><p>在柠檬水摊上，每一杯柠檬水的售价为 <code>5</code> 美元。</p><p>顾客排队购买你的产品，（按账单 <code>bills</code> 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>如果你能给每位顾客正确找零，返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：[5,5,5,10,20]</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。</span><br><span class="line">第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。</span><br><span class="line">第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。</span><br><span class="line">由于所有客户都得到了正确的找零，所以我们输出 true。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[5,5,10]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[10,10]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：[5,5,10,10,20]</span><br><span class="line">输出：false</span><br><span class="line">解释：</span><br><span class="line">前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。</span><br><span class="line">对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。</span><br><span class="line">对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。</span><br><span class="line">由于不是每位顾客都得到了正确的找零，所以答案是 false。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= bills.length &lt;= 10000</code></li><li><code>bills[i]</code> 不是 <code>5</code> 就是 <code>10</code> 或是 <code>20</code></li></ul></blockquote><p><strong>思路</strong></p><p>经典老番，模拟即可</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lemonadeChange</span>(<span class="params">self, bills: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        dic = <span class="built_in">dict</span>()</span><br><span class="line">        dic[<span class="number">5</span>], dic[<span class="number">10</span>] = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> bills:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">5</span>:</span><br><span class="line">                dic[<span class="number">5</span>] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> i == <span class="number">10</span>:</span><br><span class="line">                <span class="keyword">if</span> dic[<span class="number">5</span>]==<span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dic[<span class="number">5</span>] -= <span class="number">1</span></span><br><span class="line">                    dic[<span class="number">10</span>] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> dic[<span class="number">10</span>]&gt;<span class="number">0</span> <span class="keyword">and</span> dic[<span class="number">5</span>]&gt;<span class="number">0</span>:</span><br><span class="line">                    dic[<span class="number">10</span>] -=<span class="number">1</span></span><br><span class="line">                    dic[<span class="number">5</span>]-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> dic[<span class="number">5</span>]&gt;=<span class="number">3</span>:</span><br><span class="line">                    dic[<span class="number">5</span>] -=<span class="number">3</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>12.9</strong></p><p><strong>题目</strong></p><blockquote><h4 id="62-不同路径"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a></h4><p>难度中等</p><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 7</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向右 -&gt; 向下</span><br><span class="line">2. 向右 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向右</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 7, n = 3</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：m = 3, n = 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li><li>题目数据保证答案小于等于 <code>2 * 109</code></li></ul></blockquote><p><strong>思路</strong></p><p>蛮经典的题目，一开始直接套递归，结果超时了</p><p>动态规划轻松ac</p><ul><li><p>定义dp数组</p><ul><li><code>dp[i][j]代表了从0,0到i,j有多少种走法</code></li></ul></li><li><p>状态转移</p><ul><li>因为只能向下走或者向右走，所以每格的走法就是上面一格的走法加左边一格的走法</li><li><code>dp[i][j]=dp[i-1][j]+dp[i][j-1]</code></li></ul></li><li><p>base case</p><ul><li>将<code>dp[0,0]</code>定义为1，因为我们从起点出发，就一种走法</li></ul></li><li><p>遍历更新整个<code>dp</code>数组即可，最后<code>dp[m-1][n-1]</code>就是我们的答案</p></li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        paths = [[<span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        paths[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                tmp = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">and</span> j==<span class="number">0</span>:</span><br><span class="line">                    tmp += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> i&gt;<span class="number">0</span>:</span><br><span class="line">                    tmp += paths[i-<span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">if</span> j&gt;<span class="number">0</span>:</span><br><span class="line">                    tmp += paths[i][j-<span class="number">1</span>]</span><br><span class="line">                paths[i][j] = tmp</span><br><span class="line">        <span class="keyword">return</span> paths[m-<span class="number">1</span>][n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>12.8</strong></p><p>巧了嘛这不是，昨天刚好在复习回溯法解N皇后</p><p><strong>题目</strong></p><blockquote><h4 id="842-将数组拆分成斐波那契序列"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence/">842. 将数组拆分成斐波那契序列</a></h4><p>难度中等</p><p>给定一个数字字符串 <code>S</code>，比如 <code>S = &quot;123456579&quot;</code>，我们可以将它分成斐波那契式的序列 <code>[123, 456, 579]</code>。</p><p>形式上，斐波那契式序列是一个非负整数列表 <code>F</code>，且满足：</p><ul><li><code>0 &lt;= F[i] &lt;= 2^31 - 1</code>，（也就是说，每个整数都符合 32 位有符号整数类型）；</li><li><code>F.length &gt;= 3</code>；</li><li>对于所有的<code>0 &lt;= i &lt; F.length - 2</code>，都有 <code>F[i] + F[i+1] = F[i+2]</code> 成立。</li></ul><p>另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。</p><p>返回从 <code>S</code> 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 <code>[]</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;123456579&quot;</span><br><span class="line">输出：[123,456,579]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;11235813&quot;</span><br><span class="line">输出: [1,1,2,3,5,8,13]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;112358130&quot;</span><br><span class="line">输出: []</span><br><span class="line">解释: 这项任务无法完成。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;0123&quot;</span><br><span class="line">输出：[]</span><br><span class="line">解释：每个块的数字不能以零开头，因此 &quot;01&quot;，&quot;2&quot;，&quot;3&quot; 不是有效答案。</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;1101111&quot;</span><br><span class="line">输出: [110, 1, 111]</span><br><span class="line">解释: 输出 [11,0,11,11] 也同样被接受。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= S.length &lt;= 200</code></li><li>字符串 <code>S</code> 中只含有数字。</li></ol></blockquote><p><strong>思路</strong></p><p>就是常规的深搜+剪枝</p><ul><li><p><code>result</code>用来存放可能的序列</p></li><li><p><code>nums</code>数组中存放已经存入当前序列的数字</p></li><li><p><code>index</code>用来标记当前应该从<code>S</code>的哪个位置开始遍历</p></li><li><p>递归函数<code>dfs</code></p><ul><li>结束条件<ul><li>当前的<code>index</code>已经为<code>S</code>的长度时，说明我们已经遍历完整个字符串了</li><li>如果当前的<code>nums</code>的长度≥3，说明这个序列是合理的，放到<code>result</code>中</li><li>无论合理不合理，最后都需要退出递归</li></ul></li><li>可能路径<ul><li>如果当前<code>nums</code>的长度小于2，则从<code>index</code>开始，后面能组成的数字都是合理的，都可以加入路径继续搜索</li><li>如果<code>nums</code>的长度≥2，则需要保证后面的数字是等于<code>nums</code>数组中最后两个数字之和，才可以加入路径继续搜索</li></ul></li><li>剪枝<ul><li>按照题目说明，如果我现在组成的数字是<code>0</code>开头，且长度大于1，就直接退出递归</li><li>同理，如果当前尝试组成的数字大于2^31-1，也要退出递归</li><li>同时，如果我当前组成的数字，已经超过了<code>nums</code>数组中最后两个数字之和，也是退出递归</li></ul></li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">splitIntoFibonacci</span>(<span class="params">self, S: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">nums, index</span>):</span><br><span class="line">            <span class="keyword">if</span> index == <span class="built_in">len</span>(S) <span class="keyword">and</span> <span class="built_in">len</span>(nums)&gt;=<span class="number">3</span>:</span><br><span class="line">                res.append(nums)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">elif</span> index&gt;= <span class="built_in">len</span>(S):</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;<span class="number">2</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index+<span class="number">1</span>, <span class="built_in">len</span>(S)+<span class="number">1</span>):</span><br><span class="line">                    cur_num = <span class="built_in">int</span>(S[index:i])</span><br><span class="line">                    <span class="keyword">if</span> i&gt;index+<span class="number">1</span> <span class="keyword">and</span> S[index]==<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> cur_num&gt;<span class="number">2147483647</span>:</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    dfs(nums+[cur_num], i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                target = nums[-<span class="number">1</span>]+nums[-<span class="number">2</span>]</span><br><span class="line">                <span class="keyword">if</span> target&gt;<span class="number">2147483647</span>:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(index+<span class="number">1</span>, <span class="built_in">len</span>(S)+<span class="number">1</span>):</span><br><span class="line">                    cur_num = <span class="built_in">int</span>(S[index:i])</span><br><span class="line">                    <span class="keyword">if</span> (i&gt;index+<span class="number">1</span> <span class="keyword">and</span> S[index]==<span class="string">&#x27;0&#x27;</span>):</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    <span class="keyword">if</span> cur_num&lt;target:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">elif</span> cur_num == target:</span><br><span class="line">                        dfs(nums+[cur_num], i)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">        dfs([], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res[<span class="number">0</span>] <span class="keyword">if</span> res <span class="keyword">else</span> []</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p><strong>12.7</strong></p><blockquote><h4 id="861-翻转矩阵后的得分"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/score-after-flipping-matrix/">861. 翻转矩阵后的得分</a></h4><p>难度中等</p><p>有一个二维矩阵 <code>A</code> 其中每个元素的值为 <code>0</code> 或 <code>1</code> 。</p><p>移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 <code>0</code> 都更改为 <code>1</code>，将所有 <code>1</code> 都更改为 <code>0</code>。</p><p>在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。</p><p>返回尽可能高的分数。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]</span><br><span class="line">输出：39</span><br><span class="line">解释：</span><br><span class="line">转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]</span><br><span class="line">0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 20</code></li><li><code>1 &lt;= A[0].length &lt;= 20</code></li><li><code>A[i][j]</code> 是 <code>0</code> 或 <code>1</code></li></ol></blockquote><p><strong>思路</strong></p><p>贪心法</p><ul><li>首先通过行的移动保证每行第一个元素为1</li><li>然后对第一列以后的所有列进行移动<ul><li>保证每列的1比0多</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">matrixScore</span>(<span class="params">self, A: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 先通过行变化把第一列全部变成1</span></span><br><span class="line">        rows, cols = <span class="built_in">len</span>(A), <span class="built_in">len</span>(A[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">            <span class="keyword">if</span> A[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                    A[i][j] = <span class="number">1</span>-A[i][j]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 再进行列变化使后面的列的1的个数尽可能多</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,cols):</span><br><span class="line">            cnt_one, cnt_zero = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">                <span class="keyword">if</span> A[i][j] == <span class="number">1</span>: cnt_one += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>: cnt_zero += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt_zero&gt;cnt_one:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):</span><br><span class="line">                    A[i][j] = <span class="number">1</span>-A[i][j]</span><br><span class="line">        <span class="comment"># 求和</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> A:</span><br><span class="line">            tmp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):</span><br><span class="line">                tmp += row[j]*<span class="number">2</span>**(cols-j-<span class="number">1</span>)</span><br><span class="line">            res += tmp</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>12.6</strong></p><p>好久没做简单题了👶</p><p><strong>题目</strong></p><blockquote><h4 id="118-杨辉三角"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/pascals-triangle/">118. 杨辉三角</a></h4><p>难度简单</p><p>给定一个非负整数 *numRows，*生成杨辉三角的前 <em>numRows</em> 行。</p><p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif" alt="img"></p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: 5</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">     [1],</span><br><span class="line">    [1,1],</span><br><span class="line">   [1,2,1],</span><br><span class="line">  [1,3,3,1],</span><br><span class="line"> [1,4,6,4,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><ul><li><p>没啥思路，模拟就完事儿了</p><blockquote><p>因为不小心把两层循环都写成了<code>i</code>，调试了半天😓</p></blockquote></li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate</span>(<span class="params">self, numRows: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        last_row= []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(numRows):</span><br><span class="line">            cur_row = [<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(last_row)-<span class="number">1</span>):</span><br><span class="line">                cur_row.append(last_row[j]+last_row[j+<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span>:</span><br><span class="line">                cur_row.append(<span class="number">1</span>)</span><br><span class="line">            res.append(cur_row)</span><br><span class="line">            last_row = cur_row</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>12.5</strong></p><p><strong>题目</strong></p><blockquote><h4 id="621-任务调度器"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/task-scheduler/">621. 任务调度器</a></h4><p>难度中等</p><p>给你一个用字符数组 <code>tasks</code> 表示的 CPU 需要执行的任务列表。其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。</p><p>然而，两个 <strong>相同种类</strong> 的任务之间必须有长度为整数 <code>n</code> 的冷却时间，因此至少有连续 <code>n</code> 个单位时间内 CPU 在执行不同的任务，或者在待命状态。</p><p>你需要计算完成所有任务所需要的 <strong>最短时间</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 2</span><br><span class="line">输出：8</span><br><span class="line">解释：A -&gt; B -&gt; (待命) -&gt; A -&gt; B -&gt; (待命) -&gt; A -&gt; B</span><br><span class="line">     在本示例中，两个相同类型任务之间必须间隔长度为 n = 2 的冷却时间，而执行一个任务只需要一个单位时间，所以中间出现了（待命）状态。 </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;], n = 0</span><br><span class="line">输出：6</span><br><span class="line">解释：在这种情况下，任何大小为 6 的排列都可以满足要求，因为 n = 0</span><br><span class="line">[&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;B&quot;,&quot;B&quot;]</span><br><span class="line">[&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;,&quot;A&quot;,&quot;B&quot;]</span><br><span class="line">[&quot;B&quot;,&quot;B&quot;,&quot;B&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;]</span><br><span class="line">...</span><br><span class="line">诸如此类</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：tasks = [&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;], n = 2</span><br><span class="line">输出：16</span><br><span class="line">解释：一种可能的解决方案是：</span><br><span class="line">     A -&gt; B -&gt; C -&gt; A -&gt; D -&gt; E -&gt; A -&gt; F -&gt; G -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A -&gt; (待命) -&gt; (待命) -&gt; A</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= task.length &lt;= 104</code></li><li><code>tasks[i]</code> 是大写英文字母</li><li><code>n</code> 的取值范围为 <code>[0, 100]</code></li></ul></blockquote><p><strong>思路</strong></p><p>自己写了个模拟的方法，时间复杂度O(nlogn)，结果超过8%😓</p><p>标准数学解法的时间复杂度是O(N)</p><ul><li>我们把时间分成一块儿一块儿的，每一块为n+1<ul><li>完成任务相当于往每个时间快内加入一个任务</li><li>这样做的话，最后一个时间块内(最后一个时间块长度&lt;=n+1)，我们必定需要完成那个次数最多的任务<ul><li>比如我总共需要做3次A，2次B，1次C，n设为3，那么我最后一个时间块内必定要完成A任务，且只需要完成A任务即可结束</li></ul></li><li>所以，我们只要求出某个任务出现的最大次数，就能知道我们要分多少个块</li><li>求出块数之后，只要确定最后一个时间块的大小，即可确定完成所有任务所需时间</li></ul></li><li>最后一个时间块的大小 = 出现次数为最大次数的任务个数<ul><li>比如3次A，2次B，1次C，那么最后一个时间块只需要完成一个A</li><li>3次A，10次B，10次C，那么最后一个时间块内就需要完成B和C</li></ul></li><li>因此，我们只需要确定任务出现的最大次数，以及最大次数的任务个数，即可直接求出所需要总时间</li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">leastInterval</span>(<span class="params">self, tasks: <span class="type">List</span>[<span class="built_in">str</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dic = collections.defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> tasks:</span><br><span class="line">            dic[i] += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 任务的最大次数</span></span><br><span class="line">        max_cnt = <span class="built_in">max</span>(dic.values())</span><br><span class="line">        <span class="comment"># 最大次数任务的个数</span></span><br><span class="line">        max_job = <span class="built_in">len</span>([i <span class="keyword">for</span> i <span class="keyword">in</span> dic <span class="keyword">if</span> dic[i]==max_cnt])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>((n+<span class="number">1</span>)*(max_cnt-<span class="number">1</span>)+max_job, <span class="built_in">len</span>(tasks))</span><br></pre></td></tr></table></figure><p><strong>12.4</strong></p><p><strong>题目</strong></p><blockquote><h4 id="659-分割数组为连续子序列"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/split-array-into-consecutive-subsequences/">659. 分割数组为连续子序列</a></h4><p>难度中等</p><p>给你一个按升序排序的整数数组 <code>num</code>（可能包含重复数字），请你将它们分割成一个或多个子序列，其中每个子序列都由连续整数组成且长度至少为 3 。</p><p>如果可以完成上述分割，则返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,3,4,5]</span><br><span class="line">输出: True</span><br><span class="line">解释:</span><br><span class="line">你可以分割出这样两个连续子序列 : </span><br><span class="line">1, 2, 3</span><br><span class="line">3, 4, 5</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,3,4,4,5,5]</span><br><span class="line">输出: True</span><br><span class="line">解释:</span><br><span class="line">你可以分割出这样两个连续子序列 : </span><br><span class="line">1, 2, 3, 4, 5</span><br><span class="line">3, 4, 5</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,4,5]</span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>输入的数组长度范围为 [1, 10000]</li></ol></blockquote><p><strong>思路</strong></p><ul><li>贪心法<ul><li>构建两个字典<ul><li>一个计数字典<code>nc</code></li><li>一个子序列字典<code>tail</code><ul><li><code>tail[num]=i表示有i个以num为结尾的子序列</code></li></ul></li></ul></li><li>遍历<code>nums</code><ul><li>设当前遍历的数为<code>num</code></li><li>如果当前这个数字已经被用掉了，即<code>nc[num]==0</code>，直接跳过</li><li>否则，查看一下有没有以<code>num-1</code>为结尾的子序列，即<code>tail[num-1]&gt;0</code><ul><li>如果有，则增加一条以<code>num</code>为结尾的子序列，同时要去掉一条以<code>num-1</code>为结尾的子序列</li></ul></li><li>如果没有，就尝试构建一条新的子序列，以<code>num</code>为首部，跟上<code>num+1</code>和<code>num+2</code>，用掉对应的数字，然后增加一条以<code>num+2</code>为结尾的子序列</li><li>如果无法延长已有子序列也无法构建新序列，就返回False</li></ul></li><li>成功遍历完，就返回True</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isPossible</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        nc, tail = defaultdict(<span class="built_in">int</span>), defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            nc[num] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> nc[num] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">elif</span> tail[num-<span class="number">1</span>]:</span><br><span class="line">                nc[num] -= <span class="number">1</span></span><br><span class="line">                tail[num-<span class="number">1</span>] -=<span class="number">1</span></span><br><span class="line">                tail[num] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="keyword">not</span> tail[num-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> nc[num] <span class="keyword">and</span> nc[num+<span class="number">1</span>] <span class="keyword">and</span> nc[num+<span class="number">2</span>]:</span><br><span class="line">                    tail[num+<span class="number">2</span>] += <span class="number">1</span></span><br><span class="line">                    nc[num] -= <span class="number">1</span></span><br><span class="line">                    nc[num+<span class="number">1</span>] -=<span class="number">1</span></span><br><span class="line">                    nc[num+<span class="number">2</span>] -=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure><p><strong>12.3</strong></p><blockquote><h4 id="204-计数质数"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/count-primes/">204. 计数质数</a></h4><p>难度简单</p><p>统计所有小于非负整数 <em><code>n</code></em> 的质数的数量。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 10</span><br><span class="line">输出：4</span><br><span class="line">解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 5 * 106</code></li></ul></blockquote><p><strong>思路</strong></p><ul><li>假设2为质数，那么2的倍数就都不是质数</li><li>假设3为质数，那么3的倍数就都不是质数</li><li>低效率的实现方法（我一开始写的）<ul><li>新建一个集合<code>nums</code>，把<code>[2,n-1]</code>中的全部数字放进去</li><li>然后遍历<code>[2,n-1]</code><ul><li>如果当前遍历的数字<code>x</code>还在<code>nums</code>中，就把<code>x</code>的倍数全部删掉</li><li>同时统计删除的个数</li></ul></li><li>计算总共删掉的个数和总的数字个数，得出素数个数</li></ul></li><li>改进后的方法<ul><li>新建一个数组<code>nums</code>，长度为<code>n</code>，初始化所有元素为1</li><li>遍历<code>[2,n-1]</code><ul><li>如果<code>nums[x]==1</code>，说明这个数字为质数，计数器+1</li><li>因为这个数字是质数，所以对它的倍数进行删除操作，全部置为0</li></ul></li><li>最后返回计数器</li></ul></li></ul><blockquote><p>一开始我以为是集合导致的速度慢，但是我把方法1改成了数组实现还是很慢</p><p>应该是进行了太多次加减计算？</p></blockquote><p><strong>代码</strong></p><ul><li>方法1</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nums = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n):</span><br><span class="line">            nums.add(i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">del_num</span>(<span class="params">nums, num</span>):</span><br><span class="line">            cnt = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">not</span> <span class="keyword">in</span> nums: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*num,n+<span class="number">1</span>,num):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> nums:</span><br><span class="line">                    nums.remove(i)</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> cnt</span><br><span class="line">        res = n-<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n):</span><br><span class="line">            res -= del_num(nums, i)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><ul><li>方法2</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countPrimes</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,n):</span><br><span class="line">            <span class="keyword">if</span> nums[i]:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>*i,n,i):</span><br><span class="line">                    nums[j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><p><strong>12.2</strong></p><p>手动裂开（自行脑补微信新表情）</p><p><strong>题目</strong></p><blockquote><h4 id="321-拼接最大数"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/create-maximum-number/">321. 拼接最大数</a></h4><p>难度困难</p><p>给定长度分别为 <code>m</code> 和 <code>n</code> 的两个数组，其元素由 <code>0-9</code> 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 <code>k (k &lt;= m + n)</code> 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。</p><p>求满足该条件的最大数。结果返回一个表示该最大数的长度为 <code>k</code> 的数组。</p><p><strong>说明:</strong> 请尽可能地优化你算法的时间和空间复杂度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 = [3, 4, 6, 5]</span><br><span class="line">nums2 = [9, 1, 2, 5, 8, 3]</span><br><span class="line">k = 5</span><br><span class="line">输出:</span><br><span class="line">[9, 8, 6, 5, 3]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 = [6, 7]</span><br><span class="line">nums2 = [6, 0, 4]</span><br><span class="line">k = 5</span><br><span class="line">输出:</span><br><span class="line">[6, 7, 6, 0, 4]</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 = [3, 9]</span><br><span class="line">nums2 = [8, 9]</span><br><span class="line">k = 3</span><br><span class="line">输出:</span><br><span class="line">[9, 8, 9]</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><p>是真的看不出来该怎么做</p><p>根据题解写个大概思路</p><ul><li><p>参考了<a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/create-maximum-number/solution/pin-jie-zui-da-shu-by-leetcode-solution/">官方题解</a>和<a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/create-maximum-number/solution/321pin-jie-zui-da-shu-by-heydom/">这个兄弟的题解</a></p></li><li><p>要从两个数组中挑选<code>k</code>个数字出来，拼成最大序列，总体来说需要两步</p><ol><li>从第一个数组中挑选<code>i</code>个数字组成最大子序列<code>seq1</code>，从第二个数组中挑选<code>k-i</code>个数字组成最大子序列<code>seq2</code></li><li>根据某种规则，把这两个最大子序列合并成一个最大子序列</li></ol></li><li><p>✨从数组<code>nums</code>中，找出长度为<code>size</code>的最大子序列方法</p><ul><li>新建一个空栈<code>stk</code></li><li>设定一个最大抛弃值<code>drop</code><ul><li><code>drop=数组的长度-size</code></li></ul></li><li>遍历<code>nums</code>中的数字<ul><li>如果栈非空，且当前遍历的数字比栈顶元素大<ul><li>就一直抛弃栈顶元素，每次抛弃一个元素，<code>drop -= 1</code></li><li>直到栈空或者<code>drop=0</code></li></ul></li><li>把当前遍历的这个数字放到栈里</li></ul></li><li>返回栈的前<code>size</code>个数字，就是最大子序列</li></ul></li><li><p>✨把两个最大子序列<code>seq1和seq2</code>合并成一个最大子序列的方法</p><ul><li><p>不断从<code>seq1</code>或者<code>seq2</code>中取首部的数字</p><ul><li><p>每次从字典序大的那个子序列中取数字</p></li><li><p>python中两个数组直接对比，获得是按字典序比较的结果</p><blockquote><p>比如[2,7,1,4]&gt;[2,3,3,6]，因为这里的第0位相等，第1位上3&gt;1</p></blockquote></li><li><p>这么做的原因是能保证每次取完数字之后，下一次比较的时候能取到尽可能大的数</p><blockquote><p>如果我先从[2,3,3,6]中取了首数字，第二步就变成了从[3,3,6]和[2,7,1,4]中取数字</p><p>这样合并出来的子序列就从<code>2-&gt;7</code>变成了<code>2-&gt;3</code>，那就不是最大子序列了</p></blockquote></li></ul></li><li><p>每次取完首部数字之后，记得要把这个数字给移除</p></li></ul></li></ul><blockquote><p>小生愚钝，不吝赐教，欢迎指教</p></blockquote><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxNumber</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 找到最大子序列的方法</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">get_max_sequence</span>(<span class="params">nums, size</span>):</span><br><span class="line">            <span class="comment"># 从nums数组中，找到长度为size的最大子序列</span></span><br><span class="line">            <span class="comment"># 利用栈</span></span><br><span class="line">            stk = []</span><br><span class="line">            <span class="comment"># drop是用来保证最后的子序列长度不小于size</span></span><br><span class="line">            drop = <span class="built_in">len</span>(nums)-size</span><br><span class="line">            <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">while</span> drop <span class="keyword">and</span> stk <span class="keyword">and</span> stk[-<span class="number">1</span>]&lt;num:</span><br><span class="line">                    stk.pop()</span><br><span class="line">                    drop -=<span class="number">1</span></span><br><span class="line">                stk.append(num)</span><br><span class="line">            <span class="keyword">return</span> stk[:size]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">seq1, seq2</span>):</span><br><span class="line">            <span class="comment"># 把两个最大子序列合并成一个最大子序列</span></span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">while</span> seq1 <span class="keyword">or</span> seq2:</span><br><span class="line">                <span class="comment"># 每次加入一个较大子序列的首位数</span></span><br><span class="line">                tmp = seq1 <span class="keyword">if</span> seq1&gt;seq2 <span class="keyword">else</span> seq2</span><br><span class="line">                res.append(tmp[<span class="number">0</span>])</span><br><span class="line">                <span class="comment"># 插入一个数字之后要删掉原序列中的数字</span></span><br><span class="line">                tmp.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 循环两个子序列的可能长度</span></span><br><span class="line">        res = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i&lt;=<span class="built_in">len</span>(nums1) <span class="keyword">and</span> k-i&lt;=<span class="built_in">len</span>(nums2):</span><br><span class="line">                tmp = merge(get_max_sequence(nums1, i), get_max_sequence(nums2, k-i))</span><br><span class="line">                res = <span class="built_in">max</span>(res, tmp)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>12.1</strong></p><p>美好的一天从偷懒开始</p><p><strong>题目</strong></p><blockquote><h4 id="34-在排序数组中查找元素的第一个和最后一个位置"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h4><p>难度中等691</p><p>给定一个按照升序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p><strong>进阶：</strong></p><ul><li>你可以设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题吗？</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>nums</code> 是一个非递减数组</li><li><code>-109 &lt;= target &lt;= 109</code></li></ul></blockquote><p><strong>思路</strong></p><ul><li>面试官觉得很无聊的两个思路<ol><li>从头开始遍历，从尾部开始遍历，找到数字出现的两个位置</li><li>用python封装好的方法，先正序用index方法找到target的第一次出现位置，再把数组逆序一下找到target的第一次出现位置</li></ol></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> target <span class="keyword">not</span> <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>, -<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [nums.index(target), <span class="built_in">len</span>(nums)-<span class="number">1</span>-nums[::-<span class="number">1</span>].index(target)]</span><br></pre></td></tr></table></figure><ul><li><p>但止步于这两个无脑方法肯定是不行的</p></li><li><p>看进阶的时间复杂度要求 <code>O(log n)</code>就知道肯定是二分，相当于把python封装的方法自己实现一遍</p><blockquote><p>自己写一个二分能因为细节提交错好多次</p></blockquote></li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchRange</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>,-<span class="number">1</span>]</span><br><span class="line">        left, right = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        index = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;=right:</span><br><span class="line">            mid = (left+right+<span class="number">1</span>)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]==target:</span><br><span class="line">                index = mid</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid]&gt;target:</span><br><span class="line">                right = mid-<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> index==-<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [-<span class="number">1</span>,-<span class="number">1</span>]</span><br><span class="line">        start, end = index, index</span><br><span class="line">        <span class="keyword">while</span> start&gt;=<span class="number">0</span> <span class="keyword">and</span> nums[start]==target:</span><br><span class="line">            start -= <span class="number">1</span></span><br><span class="line">        start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> end&lt;<span class="built_in">len</span>(nums) <span class="keyword">and</span> nums[end]==target:</span><br><span class="line">            end+=<span class="number">1</span></span><br><span class="line">        end-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> [start, end]</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://blog.ethanloo.cn">EthanLoo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://blog.ethanloo.cn/post/2020-12-01-Algorithm/2020%E5%B9%B412%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/">https://blog.ethanloo.cn/post/2020-12-01-Algorithm/2020年12月刷题日志/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.ethanloo.cn" target="_blank">Ethanloo's</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/leetcode/">leetcode</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/2020-12-06-Algorithm/%E7%AC%AC1%E7%AB%A0%20%E6%A0%B8%E5%BF%83%E5%A5%97%E8%B7%AF/" title="算法小抄 | 第1章"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/20201214155356.webp" onerror='onerror=null,src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">算法小抄 | 第1章</div></div></a></div><div class="next-post pull-right"><a href="/post/2020-11-26-Algorithm/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%B9%98/" title="Java实现多线程矩阵相乘"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/20201216101954.webp" onerror='onerror=null,src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java实现多线程矩阵相乘</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/2021-06-02-Algorithm/2021%E5%B9%B46%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/" title="2021年6月刷题日志"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/20210602143312.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-02</div><div class="title">2021年6月刷题日志</div></div></a></div><div><a href="/post/2021-05-05-Algorithm/2021%E5%B9%B45%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/" title="2021年5月刷题日志"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/image-20201204232217281.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-05</div><div class="title">2021年5月刷题日志</div></div></a></div><div><a href="/post/2021-04-01-Algorithm/2021%E5%B9%B44%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/" title="2021年4月刷题日志"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="/img/cover/l.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-01</div><div class="title">2021年4月刷题日志</div></div></a></div><div><a href="/post/2021-03-01-Algorithm/2021%E5%B9%B43%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/" title="2021年3月刷题日志"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="/img/cover/l.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-01</div><div class="title">2021年3月刷题日志</div></div></a></div><div><a href="/post/2021-02-01-Algorithm/2021%E5%B9%B42%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/" title="2021年2月刷题日志"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="/img/cover/l.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-01</div><div class="title">2021年2月刷题日志</div></div></a></div><div><a href="/post/2021-01-01-Algorithm/2021%E5%B9%B41%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/" title="2021年1月刷题日志"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="/img/cover/l.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-01</div><div class="title">2021年1月刷题日志</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/avatar.png" onerror='this.onerror=null,this.src="https://cdn.ethanloo.cn/img/20201202163407.gif"' alt="avatar"></div><div class="author-info__name">EthanLoo</div><div class="author-info__description">不过是用输出倒逼输入罢了👶</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/EthanLuu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/EthanLuu" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:ethanlooo@outlook.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=952792901&amp;site=qq&amp;menu=yes" rel="external nofollow noreferrer" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><span>公告</span></div><div class="announcement_content">好好吃饭🍣 好好睡觉💤<br>敲敲代码💻 谈谈恋爱💑</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4"><span class="toc-text">435. 无重叠区间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1046-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F"><span class="toc-text">1046. 最后一块石头的重量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#330-%E6%8C%89%E8%A6%81%E6%B1%82%E8%A1%A5%E9%BD%90%E6%95%B0%E7%BB%84"><span class="toc-text">330. 按要求补齐数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#188-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-IV"><span class="toc-text">188. 买卖股票的最佳时机 IV</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#205-%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">205. 同构字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#85-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2"><span class="toc-text">85. 最大矩形</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="toc-text">455. 分发饼干</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C"><span class="toc-text">135. 分发糖果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#387-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%94%AF%E4%B8%80%E5%AD%97%E7%AC%A6"><span class="toc-text">387. 字符串中的第一个唯一字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#103-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%94%AF%E9%BD%BF%E5%BD%A2%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">103. 二叉树的锯齿形层序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-text">746. 使用最小花费爬楼梯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D"><span class="toc-text">316. 去除重复字母</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="toc-text">48. 旋转图像</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#389-%E6%89%BE%E4%B8%8D%E5%90%8C"><span class="toc-text">389. 找不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#714-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9"><span class="toc-text">714. 买卖股票的最佳时机含手续费</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#290-%E5%8D%95%E8%AF%8D%E8%A7%84%E5%BE%8B"><span class="toc-text">290. 单词规律</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#738-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97"><span class="toc-text">738. 单调递增的数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84"><span class="toc-text">49. 字母异位词分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#217-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="toc-text">217. 存在重复元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97"><span class="toc-text">376. 摆动序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#649-Dota2-%E5%8F%82%E8%AE%AE%E9%99%A2"><span class="toc-text">649. Dota2 参议院</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6"><span class="toc-text">860. 柠檬水找零</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84"><span class="toc-text">62. 不同路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#842-%E5%B0%86%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%E6%88%90%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%BA%8F%E5%88%97"><span class="toc-text">842. 将数组拆分成斐波那契序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#861-%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5%E5%90%8E%E7%9A%84%E5%BE%97%E5%88%86"><span class="toc-text">861. 翻转矩阵后的得分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><span class="toc-text">118. 杨辉三角</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#621-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-text">621. 任务调度器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#659-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E4%B8%BA%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">659. 分割数组为连续子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#204-%E8%AE%A1%E6%95%B0%E8%B4%A8%E6%95%B0"><span class="toc-text">204. 计数质数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#321-%E6%8B%BC%E6%8E%A5%E6%9C%80%E5%A4%A7%E6%95%B0"><span class="toc-text">321. 拼接最大数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="toc-text">34. 在排序数组中查找元素的第一个和最后一个位置</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/2023-11-26-Weber/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%88%E4%BA%8C%EF%BC%89/" title="前端开发的十万个为什么（二）"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/Exploring-Different-Types-of-Landforms-_1_.webp" onerror='this.onerror=null,this.src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="前端开发的十万个为什么（二）"></a><div class="content"><a class="title" href="/post/2023-11-26-Weber/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%88%E4%BA%8C%EF%BC%89/" title="前端开发的十万个为什么（二）">前端开发的十万个为什么（二）</a><time datetime="2023-11-26T21:05:10.000Z" title="发表于 2023-11-26 21:05:10">2023-11-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2023-11-22-Vue/%E9%9D%A2%E5%90%91%20Vue%20%E4%B8%AD%20VNode%20%E7%9A%84%E4%B8%80%E6%AC%A1%20Deep%20Dive/" title="面向 Vue 中 VNode 的一次 Deep Dive"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/202311221935387.png" onerror='this.onerror=null,this.src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="面向 Vue 中 VNode 的一次 Deep Dive"></a><div class="content"><a class="title" href="/post/2023-11-22-Vue/%E9%9D%A2%E5%90%91%20Vue%20%E4%B8%AD%20VNode%20%E7%9A%84%E4%B8%80%E6%AC%A1%20Deep%20Dive/" title="面向 Vue 中 VNode 的一次 Deep Dive">面向 Vue 中 VNode 的一次 Deep Dive</a><time datetime="2023-11-22T15:41:10.000Z" title="发表于 2023-11-22 15:41:10">2023-11-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2023-07-24-Weber/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%88%E4%B8%80%EF%BC%89/" title="前端开发的十万个为什么（一）"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/Exploring-Different-Types-of-Landforms-_1_.webp" onerror='this.onerror=null,this.src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="前端开发的十万个为什么（一）"></a><div class="content"><a class="title" href="/post/2023-07-24-Weber/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%88%E4%B8%80%EF%BC%89/" title="前端开发的十万个为什么（一）">前端开发的十万个为什么（一）</a><time datetime="2023-07-24T15:41:10.000Z" title="发表于 2023-07-24 15:41:10">2023-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2022-11-24-Paper/YuZu%20-%20Neural-Enhanced%20Volumetric%20Video%20Streaming/" title="NSDI22 - YuZu：Neural-Enhanced Volumetric Video Streaming"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/202302041759590.webp" onerror='this.onerror=null,this.src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="NSDI22 - YuZu：Neural-Enhanced Volumetric Video Streaming"></a><div class="content"><a class="title" href="/post/2022-11-24-Paper/YuZu%20-%20Neural-Enhanced%20Volumetric%20Video%20Streaming/" title="NSDI22 - YuZu：Neural-Enhanced Volumetric Video Streaming">NSDI22 - YuZu：Neural-Enhanced Volumetric Video Streaming</a><time datetime="2022-11-24T11:33:08.000Z" title="发表于 2022-11-24 11:33:08">2022-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2022-11-10-Paper/Collaborative%20Service%20Placement%20for%20Edge%20Computing%20in%20Dense%20Small%20Cell%20Networks/" title="TMC21 - Collaborative Service Placement for Edge Computing in Dense Small Cell Networks"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/202302041758847.webp" onerror='this.onerror=null,this.src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="TMC21 - Collaborative Service Placement for Edge Computing in Dense Small Cell Networks"></a><div class="content"><a class="title" href="/post/2022-11-10-Paper/Collaborative%20Service%20Placement%20for%20Edge%20Computing%20in%20Dense%20Small%20Cell%20Networks/" title="TMC21 - Collaborative Service Placement for Edge Computing in Dense Small Cell Networks">TMC21 - Collaborative Service Placement for Edge Computing in Dense Small Cell Networks</a><time datetime="2022-11-10T11:47:01.000Z" title="发表于 2022-11-10 11:47:01">2022-11-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By EthanLoo</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">苏ICP备2020057383号</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://ethanloo-blog-waline.vercel.app',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  if (typeof Waline === 'object') initWaline()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css').then(() => {
      getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js').then(initWaline)
    })
  }
}

if ('Waline' === 'Waline' || !true) {
  if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><div async class="app-refresh" id="app-refresh"><div class="app-refresh-wrap"><label>✨ 网站更新啦 👉</label> <a href="javascript:void(0)" rel="external nofollow noreferrer" onclick="location.reload()">点击刷新</a></div></div><script>function showNotification(){if(GLOBAL_CONFIG.Snackbar){var t="light"===document.documentElement.getAttribute("data-theme")?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e=GLOBAL_CONFIG.Snackbar.position;Snackbar.show({text:"已更新最新版本",backgroundColor:t,duration:5e5,pos:e,actionText:"點擊刷新",actionTextColor:"#fff",onActionClick:function(t){location.reload()}})}else{var o=`top: 0; background: ${"light"===document.documentElement.getAttribute("data-theme")?"#49b1f5":"#1f1f1f"};`;document.getElementById("app-refresh").style.cssText=o}}"serviceWorker"in navigator&&(navigator.serviceWorker.controller&&navigator.serviceWorker.addEventListener("controllerchange",function(){showNotification()}),window.addEventListener("load",function(){navigator.serviceWorker.register("/sw.js")}));</script><script async src="./js/background.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>