<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>2020年11月刷题日志 | Ethanloo's</title><meta name="author" content="EthanLoo"><meta name="copyright" content="EthanLoo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="文笔很烂，逻辑一般，单纯用来记录Leetcode刷题过程"><link rel="shortcut icon" href="https://cdn.ethanloo.cn/img/favicon.png"><link rel="canonical" href="https://blog.ethanloo.cn/post/2020-11-01-Algorithm/2020%E5%B9%B411%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.clarity.ms"><link rel="manifest" href="/manifest.json"><link rel="apple-touch-icon" sizes="180x180" href="https://cdn.ethanloo.cn/img/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://cdn.ethanloo.cn/img/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="https://cdn.ethanloo.cn/img/favicon.png"><link rel="mask-icon" href="https://cdn.ethanloo.cn/img/favicon.png" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>!function(t,e,n,c,r,a,s){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/bjrte2qfwy",(s=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,s)}(window,document,"clarity","script")</script><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Noto+Sans+SC&amp;family=Noto+Serif+SC&amp;family=Roboto+Mono&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: EthanLoo","link":"链接: ","source":"来源: Ethanloo's","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"2020年11月刷题日志",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-11-26 23:46:29"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="./css/optimization.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/avatar.png" onerror='onerror=null,src="https://cdn.ethanloo.cn/img/20201202163407.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fab fa-readme"></i> <span>文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.ethanloo.cn/lab"><i class="fa-fw fas fa-meteor"></i> <span>实验室</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Ethanloo's"><span class="site-name">Ethanloo's</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fab fa-readme"></i> <span>文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.ethanloo.cn/lab"><i class="fa-fw fas fa-meteor"></i> <span>实验室</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">2020年11月刷题日志</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2020-11-01T10:43:00.000Z" title="发表于 2020-11-01 10:43:00">2020-11-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/">刷题日志</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>56分钟</span></span></div></div></div><article class="post-content" id="article-container"><p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201130093802.png" alt="image-20201130093755634"></p><h3 id="11-30">11.30</h3><p>美好的一周从周一刷题开始结束</p><p><strong>题目</strong></p><blockquote><h4 id="767-重构字符串"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/reorganize-string/">767. 重构字符串</a></h4><p>难度中等</p><p>给定一个字符串<code>S</code>，检查是否能重新排布其中的字母，使得两相邻的字符不同。</p><p>若可行，输出任意可行的结果。若不可行，返回空字符串。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: S = &quot;aab&quot;</span><br><span class="line">输出: &quot;aba&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: S = &quot;aaab&quot;</span><br><span class="line">输出: &quot;&quot;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>S</code> 只包含小写字母并且长度在<code>[1, 500]</code>区间内。</li></ul></blockquote><p><strong>思路</strong></p><p>参考了<a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/reorganize-string/solution/c-tong-ji-ci-shu-pai-xu-dai-zhu-shi-by-xiao-fu-zi-/">大佬的c++题解</a></p><p>说白了就是贪心</p><ul><li>用字典统计字母出现次数<ul><li>这里如果某个字母出现的次数超过了字符串长度的一半</li><li>那肯定是无法重构的，因为最后必然会剩下两个同字符相邻</li></ul></li><li>再根据字母的出现次数升序排列</li><li>构建一个数组，初始化每个位置为0</li><li>从index = 1的位置开始逐个插入字母，从出现次数最少的开始</li><li>index逐次递增2，插入字母，index出界了就从0开始重新插，插到最后就是答案</li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reorganizeString</span>(<span class="params">self, S: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        dic = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> S:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> dic:</span><br><span class="line">                dic[i] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> dic[i] &gt; (<span class="built_in">len</span>(S)+<span class="number">1</span>)//<span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        inds = <span class="built_in">list</span>(<span class="built_in">set</span>(S))</span><br><span class="line">        inds.sort(key = <span class="keyword">lambda</span> x:dic[x])</span><br><span class="line">        res = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(S))]</span><br><span class="line">        index = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> inds:</span><br><span class="line">            cnt = dic[i]</span><br><span class="line">            char = i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cnt):</span><br><span class="line">                <span class="keyword">if</span> index&gt;=<span class="built_in">len</span>(S):</span><br><span class="line">                    index = <span class="number">0</span></span><br><span class="line">                res[index] = char</span><br><span class="line">                index += <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(res)</span><br></pre></td></tr></table></figure><h3 id="11-29">11.29</h3><p>美好的周日从实验室开会和简单题开始</p><p><strong>题目</strong></p><blockquote><h4 id="976-三角形的最大周长"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/largest-perimeter-triangle/">976. 三角形的最大周长</a></h4><p>难度简单</p><p>给定由一些正数（代表长度）组成的数组 <code>A</code>，返回由其中三个长度组成的、<strong>面积不为零</strong>的三角形的最大周长。</p><p>如果不能形成任何面积不为零的三角形，返回 <code>0</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,1,2]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,2,3,4]</span><br><span class="line">输出：10</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,6,2,3]</span><br><span class="line">输出：8</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>3 &lt;= A.length &lt;= 10000</code></li><li><code>1 &lt;= A[i] &lt;= 10^6</code></li></ol></blockquote><p><strong>思路</strong></p><p>真·简单题</p><ul><li>对边进行排序，最大的周长必定是数组中三个连续的边长组成的（贪心）</li><li>所以从后往前遍历三条边，找到能组成三角形的情况，返回周长即最大周长</li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largestPerimeter</span>(<span class="params">self, A: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        A.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(A)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> A[i+<span class="number">2</span>]&gt;=A[i+<span class="number">1</span>]+A[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> A[i]+A[i+<span class="number">1</span>]+A[i+<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="11-28">11.28</h3><p>这一天，又是体测又是知识竞赛又是互联网+路演ppt，人晕了😵</p><p><strong>题目</strong></p><blockquote><h4 id="493-翻转对"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/reverse-pairs/">493. 翻转对</a></h4><p>难度困难</p><p>给定一个数组 <code>nums</code> ，如果 <code>i &lt; j</code> 且 <code>nums[i] &gt; 2*nums[j]</code> 我们就将 <code>(i, j)</code> 称作一个*<strong>重要翻转对*</strong>。</p><p>你需要返回给定数组中的重要翻转对的数量。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,2,3,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,4,3,5,1]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>给定数组的长度不会超过<code>50000</code>。</li><li>输入数组中的所有数字都在32位整数的表示范围内。</li></ol></blockquote><p><strong>思路</strong></p><p>别问，问就是抄的大佬题解</p><ul><li>归并排序<ul><li>边排序边计算反转对的数量</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find_pairs</span>(<span class="params">self, nums, left, right</span>):</span><br><span class="line">        <span class="comment"># 计算可用对数</span></span><br><span class="line">        <span class="comment"># 假设nums[left:mid]和nums[mid+1:right]都是升序排列</span></span><br><span class="line">        res, mid = <span class="number">0</span>, (left+right)//<span class="number">2</span></span><br><span class="line">        <span class="comment"># 利用双指针去计算当前可以有多少个匹配项</span></span><br><span class="line">        j = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(left, mid+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">while</span> j&lt;=right <span class="keyword">and</span> nums[i]&gt;<span class="number">2</span>*nums[j]:</span><br><span class="line">                <span class="comment"># 当右边找到的数比左边的数两倍还大的时候</span></span><br><span class="line">                <span class="comment"># 说明左边数组i位置和剩下的数字都可以和j自称翻转对</span></span><br><span class="line">                <span class="comment"># 那就加上这么多对,继续考虑j之后的数字</span></span><br><span class="line">                res += mid-i+<span class="number">1</span></span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 当j对应的数字太大了,说明需要增加i对应的数字的大小</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">self, nums, nums_sorted, l, r</span>):</span><br><span class="line">        <span class="keyword">if</span> l&gt;= r:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        mid = (l+r)//<span class="number">2</span></span><br><span class="line">        <span class="comment"># 每次递归的值就是左数组中的翻转对+右数组中的翻转对+两个数组中交叉的翻转对</span></span><br><span class="line">        res = self.merge_sort(nums, nums_sorted, l, mid)+self.merge_sort(nums, nums_sorted, mid+<span class="number">1</span>, r)+self.find_pairs(nums, l, r)</span><br><span class="line">        <span class="comment"># 接下来进行归并排序,把左数组和右数组合并成有序的数组</span></span><br><span class="line">        i, j, k = l, mid+<span class="number">1</span>, l</span><br><span class="line">        <span class="keyword">while</span> i&lt;= mid <span class="keyword">and</span> j&lt;= r:</span><br><span class="line">            <span class="keyword">if</span> nums[i]&lt;=nums[j]:</span><br><span class="line">                nums_sorted[k] = nums[i]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums_sorted[k] = nums[j]</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i&lt;=mid:</span><br><span class="line">            nums_sorted[k] = nums[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j&lt;= r:</span><br><span class="line">            nums_sorted[k] = nums[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(l, r+<span class="number">1</span>):</span><br><span class="line">            nums[k] = nums_sorted[k]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reversePairs</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 归并排序解决问题</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        nums_sorted = [<span class="number">0</span>] * <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">return</span> self.merge_sort(nums, nums_sorted, <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="11-27">11.27</h3><p><strong>题目</strong></p><blockquote><h4 id="454-四数相加-II"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/4sum-ii/">454. 四数相加 II</a></h4><p>难度中等</p><p>给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 <code>(i, j, k, l)</code> ，使得 <code>A[i] + B[j] + C[k] + D[l] = 0</code>。</p><p>为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。</p><p><strong>例如:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">A = [ 1, 2]</span><br><span class="line">B = [-2,-1]</span><br><span class="line">C = [-1, 2]</span><br><span class="line">D = [ 0, 2]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">两个元组如下:</span><br><span class="line">1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</span><br><span class="line">2. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><p>蛮可惜的，这个思路应该很容易想，但是我却看了题解标题才想出来</p><ul><li>存两个哈希表（只存一个也可以），一个放A和B中间元素可能的和，另一个放C和D可能的和</li><li>然后遍历第一个哈希表的键，去看它的相反数在B中的出现次数</li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSumCount</span>(<span class="params">self, A: <span class="type">List</span>[<span class="built_in">int</span>], B: <span class="type">List</span>[<span class="built_in">int</span>], C: <span class="type">List</span>[<span class="built_in">int</span>], D: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dic1, dic2 = <span class="built_in">dict</span>(), <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># A和B可能的和存入dic1中，C和D可能的和存入dic2中</span></span><br><span class="line">        n = <span class="built_in">len</span>(A)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                a, b, c, d = A[i], B[j], C[i], D[j]</span><br><span class="line">                <span class="keyword">if</span> a+b <span class="keyword">in</span> dic1:</span><br><span class="line">                    dic1[a+b] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dic1[a+b] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> c+d <span class="keyword">in</span> dic2:</span><br><span class="line">                    dic2[c+d] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dic2[c+d] = <span class="number">1</span></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> dic1.keys():</span><br><span class="line">            <span class="keyword">if</span> -i <span class="keyword">in</span> dic2:</span><br><span class="line">                res += dic1[i]*dic2[-i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h3 id="11-26">11.26</h3><p><strong>题目</strong></p><blockquote><h4 id="164-最大间距"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/maximum-gap/">164. 最大间距</a></h4><p>难度困难</p><p>给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。</p><p>如果数组元素个数小于 2，则返回 0。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,6,9,1]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [10]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 数组元素个数小于 2，因此返回 0。</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。</li><li>请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。</li></ul></blockquote><p><strong>思路</strong></p><p>如果忽略线性时间复杂度的说明，则直接排序完遍历数组求相邻元素的最大差距即可</p><p>然而困难题显然不是这么简单的（虽然按题解来写的程序时间复杂度O(N)会比库函数排序慢）</p><ul><li><p>利用桶排序</p><ol><li>创建很多个桶</li><li>把所有的数字放到合适的桶里</li><li>计算相邻非空桶之间的最大差值</li></ol></li><li><p>比如<code>nums = [3,6,9,1]</code></p><ul><li>每个桶装的数字距离就是 (9-1)/(4-1) = 2</li><li>意味着我们会有这么多个桶，能装的数字范围为<ol><li>[0,2)</li><li>[2,4)</li><li>[4,6)</li><li>[6,8)</li><li>[8,10)</li></ol></li><li>然后遍历<code>nums</code>把数字分别装入桶中</li><li>最后桶的状态<ol><li>[1]</li><li>[3]</li><li>[]</li><li>[6]</li><li>[9]</li></ol></li><li>最后我们发现3-1=2，6-3=3，9-6=3，所以最大差值是3</li></ul></li><li><p>那为什么这么干就是O(N)了呢？</p><ul><li>我们在把数字装入桶里的时候，只遍历了一边数组</li><li>在确定最大差值的时候，只遍历了一遍桶</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumGap</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 利用桶排序解题</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;<span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 首先确定桶的长度，每个桶都是等间距</span></span><br><span class="line">        buckt_len = <span class="built_in">max</span>(<span class="number">1</span>, (<span class="built_in">max</span>(nums)-<span class="built_in">min</span>(nums))//(<span class="built_in">len</span>(nums)-<span class="number">1</span>))</span><br><span class="line">        <span class="comment"># 最多可能要把数字放到这么多个桶中</span></span><br><span class="line">        buckt_num = (<span class="built_in">max</span>(nums)-<span class="built_in">min</span>(nums))//buckt_len+<span class="number">1</span></span><br><span class="line">        buckets = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(buckt_num)]</span><br><span class="line">        <span class="comment"># 然后把所有的数字放到桶中</span></span><br><span class="line">        min_num = <span class="built_in">min</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            buckets[(num-min_num)//buckt_len].append(num)</span><br><span class="line">        <span class="comment"># 然后计算相邻非空桶之间的最大差值</span></span><br><span class="line">        prev = min_num</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> bucket:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">min</span>(bucket)-prev)</span><br><span class="line">            prev = <span class="built_in">max</span>(bucket)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="11-25">11.25</h3><p><strong>题目</strong></p><blockquote><h4 id="1370-上升下降字符串"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/increasing-decreasing-string/">1370. 上升下降字符串</a></h4><p>难度简单</p><p>给你一个字符串 <code>s</code> ，请你根据下面的算法重新构造字符串：</p><ol><li>从 <code>s</code> 中选出 <strong>最小</strong> 的字符，将它 <strong>接在</strong> 结果字符串的后面。</li><li>从 <code>s</code> 剩余字符中选出 <strong>最小</strong> 的字符，且该字符比上一个添加的字符大，将它 <strong>接在</strong> 结果字符串后面。</li><li>重复步骤 2 ，直到你没法从 <code>s</code> 中选择字符。</li><li>从 <code>s</code> 中选出 <strong>最大</strong> 的字符，将它 <strong>接在</strong> 结果字符串的后面。</li><li>从 <code>s</code> 剩余字符中选出 <strong>最大</strong> 的字符，且该字符比上一个添加的字符小，将它 <strong>接在</strong> 结果字符串后面。</li><li>重复步骤 5 ，直到你没法从 <code>s</code> 中选择字符。</li><li>重复步骤 1 到 6 ，直到 <code>s</code> 中所有字符都已经被选过。</li></ol><p>在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。</p><p>请你返回将 <code>s</code> 中字符重新排序后的 <strong>结果字符串</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aaaabbbbcccc&quot;</span><br><span class="line">输出：&quot;abccbaabccba&quot;</span><br><span class="line">解释：第一轮的步骤 1，2，3 后，结果字符串为 result = &quot;abc&quot;</span><br><span class="line">第一轮的步骤 4，5，6 后，结果字符串为 result = &quot;abccba&quot;</span><br><span class="line">第一轮结束，现在 s = &quot;aabbcc&quot; ，我们再次回到步骤 1</span><br><span class="line">第二轮的步骤 1，2，3 后，结果字符串为 result = &quot;abccbaabc&quot;</span><br><span class="line">第二轮的步骤 4，5，6 后，结果字符串为 result = &quot;abccbaabccba&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;rat&quot;</span><br><span class="line">输出：&quot;art&quot;</span><br><span class="line">解释：单词 &quot;rat&quot; 在上述算法重排序以后变成 &quot;art&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;leetcode&quot;</span><br><span class="line">输出：&quot;cdelotee&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ggggggg&quot;</span><br><span class="line">输出：&quot;ggggggg&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;spo&quot;</span><br><span class="line">输出：&quot;ops&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li><code>s</code> 只包含小写英文字母。</li></ul></blockquote><p><strong>思路</strong></p><p>就按照题目的要求模拟整个过程即可</p><p>利用字典来统计每个字母出现的次数，然后对出现的字母进行排序（python里的sort可以直接实现按字典序排序）</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortString</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        dic = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">set</span>(s):</span><br><span class="line">            dic[i] = s.count(i)</span><br><span class="line">        keys = <span class="built_in">sorted</span>(<span class="built_in">list</span>(<span class="built_in">set</span>(s)))</span><br><span class="line">        res = <span class="string">&quot;&quot;</span></span><br><span class="line">        cnt = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">while</span> cnt&gt;<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> keys:</span><br><span class="line">                <span class="keyword">if</span> dic[key]&gt;<span class="number">0</span>:</span><br><span class="line">                    res += key</span><br><span class="line">                    dic[key] -= <span class="number">1</span></span><br><span class="line">                    cnt -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> key <span class="keyword">in</span> keys[::-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> dic[key]&gt;<span class="number">0</span>:</span><br><span class="line">                    res += key</span><br><span class="line">                    dic[key] -= <span class="number">1</span></span><br><span class="line">                    cnt -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="11-24">11.24</h3><p><strong>题目</strong></p><blockquote><h4 id="222-完全二叉树的节点个数"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h4><p>难度中等</p><p>给出一个<strong>完全二叉树</strong>，求出该树的节点个数。</p><p><strong>说明：</strong></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin">完全二叉树</a>的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \  /</span><br><span class="line">4  5 6</span><br><span class="line"></span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><ul><li>我不讲武德，直接忽略完全二叉树，广搜直接求结点数<ul><li>时间复杂度O(N)</li></ul></li><li>标准答案思路<ul><li>先求出层数</li><li>然后根据层数算出结点的上下限</li><li>根据上下限来进行二分确定结点数</li><li>二分的时候，利用位运算去判断某个结点存不存在</li><li>时间复杂度O(log²N)</li></ul></li></ul><p><strong>思路</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countNodes</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">exist</span>(<span class="params">root, level, mid</span>):</span><br><span class="line">            bits, node = <span class="number">1</span> &lt;&lt; (level-<span class="number">1</span>), root</span><br><span class="line">            <span class="keyword">while</span> node <span class="keyword">and</span> bits&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> bits&amp;mid:</span><br><span class="line">                    node = node.right</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node = node.left</span><br><span class="line">                bits&gt;&gt;=<span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> node</span><br><span class="line">        level = <span class="number">0</span></span><br><span class="line">        node = root</span><br><span class="line">        <span class="keyword">while</span> node <span class="keyword">and</span> node.left:</span><br><span class="line">            node, level = node.left, level+<span class="number">1</span></span><br><span class="line">        low, high = <span class="number">1</span>&lt;&lt;level, (<span class="number">1</span>&lt;&lt;(level+<span class="number">1</span>)) -<span class="number">1</span></span><br><span class="line">        mid = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> low&lt;high:</span><br><span class="line">            mid = (high-low+<span class="number">1</span>)//<span class="number">2</span> + low</span><br><span class="line">            <span class="keyword">if</span> exist(root, level, mid):</span><br><span class="line">                low = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid-<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(low, mid)</span><br></pre></td></tr></table></figure><h3 id="11-23">11.23</h3><p><strong>题目</strong></p><blockquote><h4 id="452-用最少数量的箭引爆气球"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/">452. 用最少数量的箭引爆气球</a></h4><p>难度中等</p><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。</p><p>一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 <code>x``start</code>，<code>x``end</code>， 且满足 <code>xstart ≤ x ≤ x``end</code>，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><p>给你一个数组 <code>points</code> ，其中 <code>points [i] = [xstart,xend]</code> ，返回引爆所有气球所必须射出的最小弓箭数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[10,16],[2,8],[1,6],[7,12]]</span><br><span class="line">输出：2</span><br><span class="line">解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[1,2],[3,4],[5,6],[7,8]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[1,2],[2,3],[3,4],[4,5]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[1,2]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[2,3],[2,3]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= points.length &lt;= 104</code></li><li><code>points[i].length == 2</code></li><li><code>-231 &lt;= xstart &lt; xend &lt;= 231 - 1</code></li></ul></blockquote><p><strong>思路</strong></p><ul><li>贪心算法，只要保证每次射出的箭追求最大利益的方式即可保证最后花最少的箭</li><li>怎么保证利益最大呢？<ul><li>假设我们有4个气球是<code>[0,2], [1,3], [2, 4]，[4,5]</code></li><li>一开始我为了射爆第一个气球，至少需要花一根箭，那这个位置无所谓<code>[0,2]</code>中间任意一个整数即可</li><li>所以我们一开始<code>left = 0, right =2</code></li><li>再来看第二个气球，<code>[1,3]</code> ，我们发现他的左边界是1，右边界是3，和当前的可射范围<code>[0,2]</code>是有交集的</li><li>所以我们当前仍只需要一根箭，不过范围缩小到<code>left = 1, right = 2</code>，左边取大的，右边取小的</li><li>第三个气球依然可以用同一根箭射爆，<code>left = 2, right = 2</code></li><li>到第四个气球的时候，我们发现无法用这根箭射穿了，所以我们需要多花一根箭，同时当前的范围重置为<code>left = 4，right = 5</code></li><li>因此，射爆这四个气球所需要花的最少箭数为2</li></ul></li><li>可以看到这里我们气球的排序是按照右边界从小到大来排序的，这样子才能保证用的箭尽可能少，而且通过一遍遍历就可以求出箭的个数<ul><li>因为这样排序之后，我们箭的发射位置是从最左往最右考虑的，而且是以连续的方式，所以每根箭会考虑尽可能射穿所有相邻的气球</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMinArrowShots</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 按照气球结束坐标的大小排序</span></span><br><span class="line">        points.sort(key = <span class="keyword">lambda</span> x:x[<span class="number">1</span>])</span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        length = <span class="built_in">len</span>(points)</span><br><span class="line">        <span class="keyword">if</span> length&lt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left, right = points[<span class="number">0</span>]</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;<span class="built_in">len</span>(points):</span><br><span class="line">            cur_left, cur_right = points[i]</span><br><span class="line">            <span class="keyword">if</span> cur_left&gt;right:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                left,right = cur_left, cur_right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = <span class="built_in">max</span>(cur_left, left)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><h3 id="11-22">11.22</h3><p>回家度了一天半的假，继续开工</p><p><strong>题目</strong></p><blockquote><h4 id="242-有效的字母异位词"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/valid-anagram/">242. 有效的字母异位词</a></h4><p>难度简单</p><p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>说明:</strong><br>你可以假设字符串只包含小写字母。</p><p><strong>进阶:</strong><br>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p></blockquote><p><strong>思路</strong></p><p>就用哈希表（字典）去存取每个字符串中字母出现的次数就行了</p><p>这里有一个比较节省空间的技巧是只开辟一个字典</p><p>同时遍历两个字符串，将<code>s</code>中字符对应的键值+1，<code>t</code>中字符对应的键值-1</p><p>最后遍历字典的key值，如果有不等于0的key就返回false，全为0则返回true</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        dic_s, dic_t = defaultdict(<span class="built_in">int</span>), defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="built_in">len</span>(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s)):</span><br><span class="line">            dic_s[s[i]] += <span class="number">1</span></span><br><span class="line">            dic_t[t[i]] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> dic_s == dic_t</span><br></pre></td></tr></table></figure><h3 id="11-21">11.21</h3><p><strong>题目</strong></p><blockquote><h4 id="148-排序链表"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/sort-list/">148. 排序链表</a></h4><p>难度中等</p><p>给你链表的头结点 <code>head</code> ，请将其按 <strong>升序</strong> 排列并返回 <strong>排序后的链表</strong> 。</p><p><strong>进阶：</strong></p><ul><li>你可以在 <code>O(n log n)</code> 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</li></ul><p><strong>示例 1：</strong></p><p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [4,2,1,3]</span><br><span class="line">输出：[1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [-1,5,3,4,0]</span><br><span class="line">输出：[-1,0,3,4,5]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 5 * 104]</code> 内</li><li><code>-105 &lt;= Node.val &lt;= 105</code></li></ul></blockquote><p><strong>思路</strong></p><p>刷了这么久的题，第一个想法仍然是用内置的sort函数，果然是中了偷🐔的毒</p><p>只能看正经的题解</p><ul><li>递归版归并排序<ul><li>时间复杂度O(NlogN)，空间复杂度O(logN)</li></ul></li><li>迭代版归并排序<ul><li>时间复杂度O(NlogN)，空间复杂度O(1)</li></ul></li><li>不思进取，我今天只追求能看懂递归版的</li><li>首先归并排序的整体思路是<ul><li>把需要排列的链表看成两段</li><li>前半段和后半段</li><li>如果前半段是有序的，后半段是有序的，我就可以将两段有序的链表合并成一个有序的链表</li><li>此处假设前后半段均为有序即递归</li></ul></li><li>每次需要做的就是<ul><li>先用快满指针把两个链表切成两端</li><li>利用递归确定好两个排完序的链表的头节点</li><li>利用双指针，将两个有序链表合并成一个有序链表</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="comment"># 首先用快慢指针将链表分成两段</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.<span class="built_in">next</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        slow,fast=head,head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.<span class="built_in">next</span>:</span><br><span class="line">            slow=slow.<span class="built_in">next</span></span><br><span class="line">            fast=fast.<span class="built_in">next</span>.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># 此时slow指向中间结点或者是前半部分的最后一个结点</span></span><br><span class="line">        tmp = slow.<span class="built_in">next</span></span><br><span class="line">        slow.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">        <span class="comment"># 将前后段链表进行排序</span></span><br><span class="line">        left, right = self.sortList(head), self.sortList(tmp)</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        new_head = dummy</span><br><span class="line">        <span class="comment"># 利用双指针合并两个有序链表</span></span><br><span class="line">        <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">if</span> left.val&lt;right.val:</span><br><span class="line">                new_head.<span class="built_in">next</span> = left</span><br><span class="line">                left = left.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                new_head.<span class="built_in">next</span> = right</span><br><span class="line">                right = right.<span class="built_in">next</span></span><br><span class="line">            new_head = new_head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            new_head.<span class="built_in">next</span> = left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_head.<span class="built_in">next</span> = right</span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span>        </span><br></pre></td></tr></table></figure><h3 id="11-20">11.20</h3><p><strong>题目</strong></p><blockquote><h4 id="147-对链表进行插入排序"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/insertion-sort-list/">147. 对链表进行插入排序</a></h4><p>难度中等</p><p>对链表进行插入排序。</p><p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" alt="img"><br>插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。<br>每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。</p><p><strong>插入排序算法：</strong></p><ol><li>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。</li><li>每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。</li><li>重复直到所有输入数据插入完为止。</li></ol><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 4-&gt;2-&gt;1-&gt;3</span><br><span class="line">输出: 1-&gt;2-&gt;3-&gt;4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -1-&gt;5-&gt;3-&gt;4-&gt;0</span><br><span class="line">输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><p>一开始自己写，虽然过了，但是插入排序写了四十多行的代码简直了🤮</p><p>看题解优化了一下自己的解法</p><p>自己主要是没设置dummyhead导致的代码丑陋</p><p>改了之后好看多了</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insertionSortList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.<span class="built_in">next</span> = head</span><br><span class="line">        cur_node = head.<span class="built_in">next</span></span><br><span class="line">        last_node = head</span><br><span class="line">        <span class="keyword">while</span> cur_node:</span><br><span class="line">            <span class="keyword">if</span> cur_node.val&gt;=last_node.val:</span><br><span class="line">                last_node  = last_node.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prev = dummy</span><br><span class="line">                <span class="keyword">while</span> prev.<span class="built_in">next</span>.val&lt;cur_node.val:</span><br><span class="line">                    prev = prev.<span class="built_in">next</span></span><br><span class="line">                last_node.<span class="built_in">next</span> = cur_node.<span class="built_in">next</span></span><br><span class="line">                cur_node.<span class="built_in">next</span> = prev.<span class="built_in">next</span></span><br><span class="line">                prev.<span class="built_in">next</span> = cur_node</span><br><span class="line">            cur_node = last_node.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><h3 id="11-19">11.19</h3><p>完了嘛这不是，简单题都不会做了</p><p><strong>题目</strong></p><blockquote><h4 id="283-移动零"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/move-zeroes/">283. 移动零</a></h4><p>难度简单</p><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>说明</strong>:</p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol></blockquote><p><strong>思路</strong></p><p>又看了题解</p><ul><li><p>将非零的数字移到数组前部，然后将后面的位置全部置零即可</p></li><li><p>双指针</p><ul><li>新建两个指针指向头部<code>i,j=0,0</code></li><li><code>i</code>表示当前遍历到的非零的数字的个数</li><li><code>j</code>表示当前遍历的所有数字的个数</li></ul></li><li><p>利用<code>j</code>去遍历所有的数字，然后把所有非零的数字填充到<code>i</code>的位置</p></li><li><p>每次填充的时候令<code>i</code>指针后移</p></li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">moveZeroes</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j&lt;<span class="built_in">len</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[j]!=<span class="number">0</span>:</span><br><span class="line">                nums[i] = nums[j]</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i, <span class="built_in">len</span>(nums)):</span><br><span class="line">            nums[k] = <span class="number">0</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="11-18">11.18</h3><p><strong>题目</strong></p><blockquote><h4 id="134-加油站"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/gas-station/">134. 加油站</a></h4><p>难度中等488</p><p>在一条环路上有 <em>N</em> 个加油站，其中第 <em>i</em> 个加油站有汽油 <code>gas[i]</code> 升。</p><p>你有一辆油箱容量无限的的汽车，从第 <em>i</em> 个加油站开往第 <em>i+1</em> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><p><strong>说明:</strong></p><ul><li>如果题目有解，该答案即为唯一答案。</li><li>输入数组均为非空数组，且长度相同。</li><li>输入数组中的元素均为非负数。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">gas  = [1,2,3,4,5]</span><br><span class="line">cost = [3,4,5,1,2]</span><br><span class="line"></span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入: </span><br><span class="line">gas  = [2,3,4]</span><br><span class="line">cost = [3,4,3]</span><br><span class="line"></span><br><span class="line">输出: -1</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油</span><br><span class="line">你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><ul><li>别的不会，就会死算，直接模拟了一遍从每个加油站出发的情况</li><li>时间复杂度是O(N²)</li><li>以为过不了，结果</li></ul><p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201118150326.png" alt="image-20201118150326517"></p><ul><li>看了题解发现这原来是一道脑筋急转弯的题目</li><li>或者用数学可以证明<ul><li>假设从加油站<code>i</code>出发，到<code>j</code>加油站的发现油不够了</li><li>则无论从<code>i~j-1</code>之间，任意一个加油站出发，最终到<code>j</code>加油站都会不够油<ul><li>因为之前<code>i</code>出发肯定剩余油量&gt;=0嘛，在<code>i</code>之后出发甚至连之前剩余的油都没了</li></ul></li><li>所以我们可以直接从<code>j</code>开始重新尝试出发</li></ul></li><li>如果最后尝试的起点超过了终点，则说明无法环路行驶</li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canCompleteCircuit</span>(<span class="params">self, gas: <span class="type">List</span>[<span class="built_in">int</span>], cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        diffs = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(gas)):</span><br><span class="line">            diffs.append(gas[i]-cost[i])</span><br><span class="line">        <span class="comment"># 找到一段累加和一直为0的一段序列</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> start&lt;<span class="built_in">len</span>(diffs):</span><br><span class="line">            tmp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(diffs)):</span><br><span class="line">                index = (start+i)%<span class="built_in">len</span>(diffs)</span><br><span class="line">                tmp += diffs[index]</span><br><span class="line">                <span class="keyword">if</span> tmp&lt;<span class="number">0</span>:</span><br><span class="line">                    start = start + i + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="11-17">11.17</h3><p>ohhh 简单题</p><p><strong>题目</strong></p><blockquote><h4 id="1030-距离顺序排列矩阵单元格"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/matrix-cells-in-distance-order/">1030. 距离顺序排列矩阵单元格</a></h4><p>难度简单</p><p>给出 <code>R</code> 行 <code>C</code> 列的矩阵，其中的单元格的整数坐标为 <code>(r, c)</code>，满足 <code>0 &lt;= r &lt; R</code> 且 <code>0 &lt;= c &lt; C</code>。</p><p>另外，我们在该矩阵中给出了一个坐标为 <code>(r0, c0)</code> 的单元格。</p><p>返回矩阵中的所有单元格的坐标，并按到 <code>(r0, c0)</code> 的距离从最小到最大的顺序排，其中，两单元格<code>(r1, c1)</code> 和 <code>(r2, c2)</code> 之间的距离是曼哈顿距离，<code>|r1 - r2| + |c1 - c2|</code>。（你可以按任何满足此条件的顺序返回答案。）</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：R = 1, C = 2, r0 = 0, c0 = 0</span><br><span class="line">输出：[[0,0],[0,1]]</span><br><span class="line">解释：从 (r0, c0) 到其他单元格的距离为：[0,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：R = 2, C = 2, r0 = 0, c0 = 1</span><br><span class="line">输出：[[0,1],[0,0],[1,1],[1,0]]</span><br><span class="line">解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2]</span><br><span class="line">[[0,1],[1,1],[0,0],[1,0]] 也会被视作正确答案。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：R = 2, C = 3, r0 = 1, c0 = 2</span><br><span class="line">输出：[[1,2],[0,2],[1,1],[0,1],[1,0],[0,0]]</span><br><span class="line">解释：从 (r0, c0) 到其他单元格的距离为：[0,1,1,2,2,3]</span><br><span class="line">其他满足题目要求的答案也会被视为正确，例如 [[1,2],[1,1],[0,2],[1,0],[0,1],[0,0]]。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= R &lt;= 100</code></li><li><code>1 &lt;= C &lt;= 100</code></li><li><code>0 &lt;= r0 &lt; R</code></li><li><code>0 &lt;= c0 &lt; C</code></li></ol></blockquote><p><strong>思路</strong></p><ul><li>对所有需要考虑的点进行排序即可</li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">allCellsDistOrder</span>(<span class="params">self, R: <span class="built_in">int</span>, C: <span class="built_in">int</span>, r0: <span class="built_in">int</span>, c0: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res= []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(R):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(C):</span><br><span class="line">                res.append([i,j])</span><br><span class="line">        res.sort(key = <span class="keyword">lambda</span> x: (<span class="built_in">abs</span>(x[<span class="number">0</span>]-r0)+<span class="built_in">abs</span>(x[<span class="number">1</span>]-c0)))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="11-16">11.16</h3><p>another and another vegetable day</p><p><strong>题目</strong></p><blockquote><h4 id="406-根据身高重建队列"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/queue-reconstruction-by-height/">406. 根据身高重建队列</a></h4><p>难度中等</p><p>假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对<code>(h, k)</code>表示，其中<code>h</code>是这个人的身高，<code>k</code>是排在这个人前面且身高大于或等于<code>h</code>的人数。 编写一个算法来重建这个队列。</p><p><strong>注意：</strong><br>总人数少于1100人。</p><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]]</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><p>又要看题解做题 🤨</p><ul><li>贪心法<ul><li>从矮到高一个个分配位置</li><li>这样可以保证先放的人的位置不会对后放的人的位置造成影响</li><li>因为每个人的整数对（h, k）只记录了在ta前面的身高大于ta的人数</li><li>因为这道题一定有解，所以按照一定的规则逐个插入就能得到合法解</li></ul></li><li>利用python自带的排序方法，按照优先考虑h，再考虑k的方法进行排序<ul><li>把身高低的人拍到前面</li><li>如果身高相同，就把k大的先放到前面<ul><li>这里也是贪心法的思想，因为需要先插入这些k值大的人</li></ul></li></ul></li><li>例如<ul><li><code>[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]</code></li></ul></li><li>排序完之后就会变成<ul><li><code>[[4,4], [5,2], [5,0], [6,1], [7,1], [7,0]]</code></li></ul></li><li>然后初始化一个最后的排序完的数组<code>res</code><ul><li><code>res = [0, 0, 0, 0, 0, 0]</code></li><li>0说明这个位置还没有人</li></ul></li><li>然后按照排序完之后的人员来进行插入<ul><li>此时不需要考虑身高，因为已经是按照从矮到高排序</li><li>根据k值，从头开始遍历<code>res</code>数组</li><li>找到k个0之后的一个空位，就是自己需要插入的位置</li></ul></li><li><code>[4.4]</code>第一个进行插入操作，一开始数组里都是空位，所以ta找到4个空位后，自然会插入第5个空位<ul><li><code>res = [0, 0, 0, 0, [4,4], 0]</code></li></ul></li><li>这个时候开始找第二个人的位置，ta是<code>[5,2]</code>，所以从头开始找到两个空位之后，就会插入第三个空位<ul><li><code>res = [0, 0, [5，2], 0, [4,4], 0]</code></li></ul></li><li>直到把所有人都安排好位置，就可以返回数组<code>res</code></li><li>本题贪心法思想理解<ul><li>其实每次插入一个人的时候，队伍里的人的身高都不超过ta</li><li>又由于我们是根据k值降序，所以和ta同样身高的人，如果k比ta大，那么肯定已经被插到队伍的后面去了，所以不用管</li><li>如果k比ta小，那么之后自然会插入ta的前面</li><li>所以ta能够不顾及他人的身高，只看空位数就能找到自己应该待的位置</li><li>一言以蔽之，把越是不会影响其他人的位置的人越先插到队伍里</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">reconstructQueue</span>(<span class="params">self, people: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="comment"># 首先将所有人按身高的从低到高排序</span></span><br><span class="line">        people.sort(key = <span class="keyword">lambda</span> x: (x[<span class="number">0</span>], -x[<span class="number">1</span>]))</span><br><span class="line">        length = <span class="built_in">len</span>(people)</span><br><span class="line">        res = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length)]</span><br><span class="line">        <span class="keyword">for</span> person <span class="keyword">in</span> people:</span><br><span class="line">            <span class="comment"># 找空插入这个人</span></span><br><span class="line">            space = person[<span class="number">1</span>]+<span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> res[i]:</span><br><span class="line">                    space -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> space == <span class="number">0</span>:</span><br><span class="line">                        res[i] = person</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="11-15">11.15</h3><p>another vegetable day</p><p><strong>题目</strong></p><blockquote><h4 id="402-移掉K位数字"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/remove-k-digits/">402. 移掉K位数字</a></h4><p>难度中等</p><p>给定一个以字符串表示的非负整数 <em>num</em>，移除这个数中的 <em>k</em> 位数字，使得剩下的数字最小。</p><p><strong>注意:</strong></p><ul><li><em>num</em> 的长度小于 10002 且 ≥ <em>k。</em></li><li><em>num</em> 不会包含任何前导零。</li></ul><p><strong>示例 1 :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: num = &quot;1432219&quot;, k = 3</span><br><span class="line">输出: &quot;1219&quot;</span><br><span class="line">解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。</span><br></pre></td></tr></table></figure><p><strong>示例 2 :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: num = &quot;10200&quot;, k = 1</span><br><span class="line">输出: &quot;200&quot;</span><br><span class="line">解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</span><br></pre></td></tr></table></figure><p>示例 <strong>3 :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: num = &quot;10&quot;, k = 2</span><br><span class="line">输出: &quot;0&quot;</span><br><span class="line">解释: 从原数字移除所有的数字，剩余为空就是0。</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><ul><li>从数字的最左侧开始维护一个递增栈，最后返回整个递增栈能构成的数字并去除前导零<ul><li>例如num=‘12342013’, k=2</li><li>我们要去掉的就是34</li></ul></li><li>首先开辟一个栈</li><li>往栈里开始放数字<ul><li>[1]</li><li>[1,2]</li><li>[1,2,3]</li><li>[1,2,3,4]</li></ul></li><li>此时我们发现，现在要放的数字是2，但是把2放进这个栈，那这个栈就不是递增的了呀</li><li>所以，我们就要把栈顶元素pop掉，每pop一个数，代表了我们就用掉了一次移出数字的机会</li><li>当我们没有移除数字的机会（k==0）或者现在栈顶元素已经比我们当前这个数字小的时候</li><li>就可以继续往栈里放数字啦</li><li>直到把整个num字符串遍历完为止</li><li>如果我们在遍历完之后还有删除数字的机会，那我们就把最后放到栈里的几个数字去掉即可</li><li>最后把栈拼接成一个字符串并去除前导零</li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeKdigits</span>(<span class="params">self, num: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> num:</span><br><span class="line">            <span class="keyword">while</span> nums <span class="keyword">and</span> i&lt;nums[-<span class="number">1</span>] <span class="keyword">and</span> k:</span><br><span class="line">                nums.pop()</span><br><span class="line">                k-=<span class="number">1</span></span><br><span class="line">            nums.append(i)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> k&gt;<span class="number">0</span>:</span><br><span class="line">            nums = nums[:-k]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(nums).lstrip(<span class="string">&#x27;0&#x27;</span>) <span class="keyword">or</span> <span class="string">&quot;0&quot;</span></span><br></pre></td></tr></table></figure><h3 id="11-14">11.14</h3><p>芜湖，周末简单题</p><p><strong>题目</strong></p><blockquote><h4 id="1122-数组的相对排序"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/relative-sort-array/">1122. 数组的相对排序</a></h4><p>难度简单</p><p>给你两个数组，<code>arr1</code> 和 <code>arr2</code>，</p><ul><li><code>arr2</code> 中的元素各不相同</li><li><code>arr2</code> 中的每个元素都出现在 <code>arr1</code> 中</li></ul><p>对 <code>arr1</code> 中的元素进行排序，使 <code>arr1</code> 中项的相对顺序和 <code>arr2</code> 中的相对顺序相同。未在 <code>arr2</code> 中出现过的元素需要按照升序放在 <code>arr1</code> 的末尾。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]</span><br><span class="line">输出：[2,2,2,1,4,3,3,9,6,7,19]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>arr1.length, arr2.length &lt;= 1000</code></li><li><code>0 &lt;= arr1[i], arr2[i] &lt;= 1000</code></li><li><code>arr2</code> 中的元素 <code>arr2[i]</code> 各不相同</li><li><code>arr2</code> 中的每个元素 <code>arr2[i]</code> 都出现在 <code>arr1</code> 中</li></ul></blockquote><p><strong>思路</strong></p><ul><li>没啥好写的，上代码吧</li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">relativeSortArray</span>(<span class="params">self, arr1: <span class="type">List</span>[<span class="built_in">int</span>], arr2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        dic = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 第一遍遍历arr1 统计每个元素的出现次数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr1:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> dic:</span><br><span class="line">                dic[i] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[i] += <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="comment"># 第一遍遍历arr2 输出对应元素</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr2:</span><br><span class="line">            res += dic[i]*[i]</span><br><span class="line">            dic[i] = <span class="number">0</span></span><br><span class="line">        <span class="comment"># 第二遍遍历arr1 输出未在arr2中出现的元素</span></span><br><span class="line">        tmp = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr1:</span><br><span class="line">            <span class="keyword">if</span> dic[i]&gt;<span class="number">0</span>:</span><br><span class="line">                tmp.append(i)</span><br><span class="line">        <span class="keyword">return</span> res+<span class="built_in">sorted</span>(tmp)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="11-13">11.13</h3><p><strong>题目</strong></p><blockquote><h4 id="328-奇偶链表"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/odd-even-linked-list/">328. 奇偶链表</a></h4><p>难度中等</p><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL </span><br><span class="line">输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>应当保持奇数节点和偶数节点的相对顺序。</li><li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li></ul></blockquote><p><strong>思路</strong></p><p>可恶，要原地算法，偷不了🐔了</p><ul><li>一个odd结点指向head，一个even结点指向head.next，一个even_head结点指向head.next</li><li>两个结点向后遍历，例如1-&gt;2-&gt;3-&gt;4<ul><li>把even的下一个结点作为odd的下一个结点<ul><li>1-&gt;3</li></ul></li><li>把odd指针后移<ul><li>odd = 3</li></ul></li><li>把odd的后一个结点作为even的下一个结点<ul><li>2-&gt;4</li></ul></li><li>把even指针后移<ul><li>even = 4</li></ul></li><li>当前遍历完之后就变成了1-&gt;3, 2-&gt;4</li></ul></li><li>直到遍历到even结点为空或者even没有下一个结点</li><li>最后把odd的next指针指向even_head即可</li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">oddEvenList</span>(<span class="params">self, head: ListNode</span>) -&gt; ListNode:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        odd = head</span><br><span class="line">        even = head.<span class="built_in">next</span></span><br><span class="line">        even_head = head.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">while</span> even <span class="keyword">and</span> even.<span class="built_in">next</span>:</span><br><span class="line">            odd.<span class="built_in">next</span> = even.<span class="built_in">next</span></span><br><span class="line">            odd = odd.<span class="built_in">next</span></span><br><span class="line">            even.<span class="built_in">next</span> = odd.<span class="built_in">next</span></span><br><span class="line">            even = even.<span class="built_in">next</span></span><br><span class="line">        odd.<span class="built_in">next</span> = even_head</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure><h3 id="11-12">11.12</h3><p><strong>题目</strong></p><blockquote><h4 id="922-按奇偶排序数组-II"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/sort-array-by-parity-ii/">922. 按奇偶排序数组 II</a></h4><p>难度简单</p><p>给定一个非负整数数组 <code>A</code>， A 中一半整数是奇数，一半整数是偶数。</p><p>对数组进行排序，以便当 <code>A[i]</code> 为奇数时，<code>i</code> 也是奇数；当 <code>A[i]</code> 为偶数时， <code>i</code> 也是偶数。</p><p>你可以返回任何满足上述条件的数组作为答案。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[4,2,5,7]</span><br><span class="line">输出：[4,5,2,7]</span><br><span class="line">解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>2 &lt;= A.length &lt;= 20000</code></li><li><code>A.length % 2 == 0</code></li><li><code>0 &lt;= A[i] &lt;= 1000</code></li></ol></blockquote><p><strong>思路</strong></p><p>既然对空间复杂度没有要求我就直接偷懒了</p><ul><li>新建数组<code>tmp1,tmp2</code></li><li>遍历数组A，把里面的奇数放到tmp1里，偶数放到tmp2里</li><li>然后最后循环从tmp1里取一个，tmp2里取一个，生成答案数组</li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortArrayByParityII</span>(<span class="params">self, A: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        tmp1, tmp2 = [], []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">            <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">1</span>:</span><br><span class="line">                tmp1.append(i)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp2.append(i)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tmp1)):</span><br><span class="line">            res+=[tmp2[i], tmp1[i]]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h3 id="11-11">11.11</h3><p>没想到剁完手还能敲代码，差点忘了这每日一题</p><blockquote><h4 id="514-自由之路"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/freedom-trail/">514. 自由之路</a></h4><p>难度困难143</p><p>电子游戏“辐射4”中，任务“通向自由”要求玩家到达名为“Freedom Trail Ring”的金属表盘，并使用表盘拼写特定关键词才能开门。</p><p>给定一个字符串 <strong>ring</strong>，表示刻在外环上的编码；给定另一个字符串 <strong>key</strong>，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的<strong>最少</strong>步数。</p><p>最初，<strong>ring</strong> 的第一个字符与12:00方向对齐。您需要顺时针或逆时针旋转 ring 以使 <strong>key</strong> 的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 <strong>key</strong> 中的所有字符。</p><p>旋转 <strong>ring</strong> 拼出 key 字符 <strong>key[i]</strong> 的阶段中：</p><ol><li>您可以将 <strong>ring</strong> 顺时针或逆时针旋转<strong>一个位置</strong>，计为1步。旋转的最终目的是将字符串 <strong>ring</strong> 的一个字符与 12:00 方向对齐，并且这个字符必须等于字符 <strong>key[i] 。</strong></li><li>如果字符 <strong>key[i]</strong> 已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 <strong>1 步</strong>。按完之后，您可以开始拼写 <strong>key</strong> 的下一个字符（下一阶段）, 直至完成所有拼写。</li></ol><p><strong>示例：</strong></p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/ring.jpg" alt="img" style="zoom:50%"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: ring = &quot;godding&quot;, key = &quot;gd&quot;</span><br><span class="line">输出: 4</span><br><span class="line">解释:</span><br><span class="line"> 对于 key 的第一个字符 &#x27;g&#x27;，已经在正确的位置, 我们只需要1步来拼写这个字符。 </span><br><span class="line"> 对于 key 的第二个字符 &#x27;d&#x27;，我们需要逆时针旋转 ring &quot;godding&quot; 2步使它变成 &quot;ddinggo&quot;。</span><br><span class="line"> 当然, 我们还需要1步进行拼写。</span><br><span class="line"> 因此最终的输出是 4。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><strong>ring</strong> 和 <strong>key</strong> 的字符串长度取值范围均为 1 至 100；</li><li>两个字符串中都只有小写字符，并且均可能存在重复字符；</li><li>字符串 <strong>key</strong> 一定可以由字符串 <strong>ring</strong> 旋转拼出。</li></ol></blockquote><p><strong>题解</strong></p><p>在这里先推荐一个<a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/freedom-trail/solution/python3-lai-ba-zhan-shi-shi-shi-ju-zhuquan-guo-zui/">大佬的题解</a>，看完之后半小时以内就能自己敲出来</p><p>整体采取<strong>动态规划</strong>和<strong>bfs</strong>的思路</p><ul><li>我们要确保的是最后最优解，中途只要尽量最优即可</li><li>最重要的是保存多种可能路径，还得保证不去记录肯定不可能是最优解的路径</li></ul><p>这次要用的关键数据结构是字典</p><ul><li><p>首先我们建立一个空字典<code>dic</code></p><ul><li>这个字典用来存放每个字母的位置</li></ul></li><li><p>遍历<code>ring</code>来初始化<code>dic</code>字典</p><ul><li><p><code>dic</code>的所有<code>keys</code>就是<code>ring</code>中出现过的字母</p></li><li><p>每种字母对应key也是一个字典</p><ul><li>这个字典记录的是：这种字母出现的位置和已经操作的步数（初始化时步数均为0）</li></ul></li><li><p>例如<code>ring = abcdac</code></p></li><li><p>初始化字典后<code>dic = &#123;'a':&#123;0:0, 4:0&#125;, 'b'：&#123;1:0&#125;, 'c':&#123;2:0,5:0&#125;, 'd':&#123;3:0&#125;&#125;</code></p></li></ul></li><li><p>然后去遍历<code>key</code></p><ul><li>根据每个字母和上一次出现的字母，去更新<code>dic</code></li><li>例如<code>key = cab</code></li><li>假设我们当前遍历的是<code>c</code>，那么我们可以看到<code>dic[‘c’]=&#123;2:0,5:0&#125;</code></li><li>我们遍历的上一个位置是0（即起点开始），我们知道走到2至少要2步（向右走），走到5至少要1步（向左走）</li><li>所以我们更新<code>dic['c']=&#123;2:3, 5:2&#125;</code>（走步数+按1步）</li><li>接下去找下一个字母<code>a</code></li><li>我们可以看到<code>dic['a']=&#123;0:0, 4:0&#125;</code>，要走到0，至少要1步（从5出发），要走到4也是至少1步（从5出发）</li><li>所以我们更新<code>dic['a']=&#123;0:1+2+1, 4:1+2+1&#125;</code>（本次走的步数+之前走的步数+按1步）</li></ul></li><li><p>遍历完整个<code>key</code>之后，字典中对应的<code>key</code>的最后一个字母的字典的<code>values</code>中的最小值，就是答案</p></li><li><p>这边有两个小技巧没提及，代码里实现了，读者可以自己思考</p><ul><li>如何找到最短步数</li><li>如何保证一开始是从0出发</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findRotateSteps</span>(<span class="params">self, ring: <span class="built_in">str</span>, key: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dic = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 首先初始化字典，把每种字母转换成一个字典</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> <span class="built_in">set</span>(<span class="built_in">list</span>(ring)):</span><br><span class="line">            <span class="comment"># dic[&#x27;a&#x27;] = &#123;a出现的第一个位置: 0, a出现的第二个位置: 0...&#125;</span></span><br><span class="line">            tmp = <span class="built_in">dict</span>()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(ring)):</span><br><span class="line">                <span class="keyword">if</span> ring[i] == word:</span><br><span class="line">                    tmp[i] = <span class="number">0</span></span><br><span class="line">            dic[word] = tmp</span><br><span class="line">        <span class="comment"># 然后根据当前的字典去找最短路</span></span><br><span class="line">        last_word = ring[<span class="number">0</span>]</span><br><span class="line">        head = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> key:</span><br><span class="line">            <span class="comment"># 每次更新dic[word]对应的字典</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> dic[word].keys():</span><br><span class="line">                min_dis = <span class="built_in">float</span>(<span class="string">&quot;inf&quot;</span>)</span><br><span class="line">                target = i</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> dic[last_word].keys():</span><br><span class="line">                    start = j</span><br><span class="line">                    last_dis = dic[last_word][j]</span><br><span class="line">                    <span class="keyword">if</span> head:</span><br><span class="line">                        start = <span class="number">0</span></span><br><span class="line">                    <span class="comment"># 正向走到对应字母所需要的距离</span></span><br><span class="line">                    foward_dis  = <span class="built_in">abs</span>(start-target)</span><br><span class="line">                    <span class="comment"># 逆向</span></span><br><span class="line">                    backword_dis = <span class="built_in">len</span>(ring)-foward_dis</span><br><span class="line">                    min_dis = <span class="built_in">min</span>(min_dis,backword_dis+last_dis, foward_dis+last_dis)</span><br><span class="line">                dic[word][i] = min_dis+<span class="number">1</span></span><br><span class="line">            head = <span class="literal">False</span></span><br><span class="line">            last_word = word</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(dic[key[-<span class="number">1</span>]].values())</span><br></pre></td></tr></table></figure><h3 id="11-10">11.10</h3><p><strong>题目</strong></p><blockquote><h4 id="31-下一个排列"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/next-permutation/">31. 下一个排列</a></h4><p>难度中等</p><p>实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</p><p>如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</p><p>必须**<a target="_blank" rel="noopener external nofollow noreferrer" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>**修改，只允许使用额外常数空间。</p><p>以下是一些例子，输入位于左侧列，其相应输出位于右侧列。<br><code>1,2,3</code> → <code>1,3,2</code><br><code>3,2,1</code> → <code>1,2,3</code><br><code>1,1,5</code> → <code>1,5,1</code></p></blockquote><p><strong>思路</strong></p><p>想了半天，最终还是看了题解</p><ul><li><p>整体思想是找到一个小数和一个大数，要保证这个大数在小数后面，然后交换</p></li><li><p>首先从后往前遍历，找到我们需要交换的一个小数</p><ul><li>例如1,2,3,4,8,7,3</li><li>可以看到7到3是降序，8到7也是降序</li><li>但是4到6是升序</li><li>那么就取4作为我们的小数</li></ul></li><li><p>然后从后往前，找一个大数</p><ul><li>首先看到3，3比4小，不能作为大数</li><li>7比4大，所以就选它作为大数</li></ul></li><li><p>交换大数和小数</p><ul><li>变成1,2,3,7,8,4,3</li></ul></li><li><p>但是我们可以看到，这样子并不是严格的下一个排列</p><ul><li>因为1,2,3,7,3,4,8才是</li></ul></li><li><p>所以需要给现在大数的所在位置即7的位置之后的序列，重新排序，排列成升序</p></li><li><p>由于我们知道8 4 3是降序排列的，所以从两边开始两两调换元素的位置就能变成升序序列</p></li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextPermutation</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        i = <span class="built_in">len</span>(nums)-<span class="number">2</span></span><br><span class="line">        <span class="comment"># 从后往前找需要交换的小数</span></span><br><span class="line">        <span class="keyword">while</span> i&gt;=<span class="number">0</span> <span class="keyword">and</span> nums[i]&gt;nums[i+<span class="number">1</span>]:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 此时nums[i+1:]都是降序 且num[i]&lt;nums[i+1]</span></span><br><span class="line">        <span class="comment"># i位置的数就是我们要找的小数</span></span><br><span class="line">        <span class="comment"># 从后往前找 找到尽可能小的大数</span></span><br><span class="line">        <span class="keyword">if</span> i&gt;=<span class="number">0</span>:</span><br><span class="line">            j = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j&gt;=<span class="number">0</span> <span class="keyword">and</span> nums[i]&gt;=nums[j]:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="comment"># 将小数后面进行升序排列</span></span><br><span class="line">        left = i+<span class="number">1</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;right:</span><br><span class="line">            nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">            right -= <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="11-9">11.9</h3><p>😴</p><p><strong>题目</strong></p><blockquote><h4 id="973-最接近原点的-K-个点"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/k-closest-points-to-origin/">973. 最接近原点的 K 个点</a></h4><p>难度中等</p><p>我们有一个由平面上的点组成的列表 <code>points</code>。需要从中找出 <code>K</code> 个距离原点 <code>(0, 0)</code> 最近的点。</p><p>（这里，平面上两点之间的距离是欧几里德距离。）</p><p>你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[1,3],[-2,2]], K = 1</span><br><span class="line">输出：[[-2,2]]</span><br><span class="line">解释： </span><br><span class="line">(1, 3) 和原点之间的距离为 sqrt(10)，</span><br><span class="line">(-2, 2) 和原点之间的距离为 sqrt(8)，</span><br><span class="line">由于 sqrt(8) &lt; sqrt(10)，(-2, 2) 离原点更近。</span><br><span class="line">我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[3,3],[5,-1],[-2,4]], K = 2</span><br><span class="line">输出：[[3,3],[-2,4]]</span><br><span class="line">（答案 [[-2,4],[3,3]] 也会被接受。）</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= K &lt;= points.length &lt;= 10000</code></li><li><code>-10000 &lt; points[i][0] &lt; 10000</code></li><li><code>-10000 &lt; points[i][1] &lt; 10000</code></li></ol></blockquote><p><strong>思路</strong></p><p>要偷懒还是很好偷的</p><p>直接用个库函数排序然后切片就解决问题了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kClosest</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], K: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        points.sort(key = <span class="keyword">lambda</span> x:x[<span class="number">0</span>]**<span class="number">2</span>+x[<span class="number">1</span>]**<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> points[:K]</span><br></pre></td></tr></table></figure><p>但这不就是耍流氓吗 还是用优先队列吧</p><p>简单来说就是用优先队列（大根堆）这个数据结构来维护一组点</p><p>保证这组点的数量一直小于等于K，且他们是当前遍历到的离原点最近的点</p><p>具体怎么做到呢</p><ul><li><p>先往堆里放前K个点，按照<code>(-距离平方，点的index)</code>的格式</p><ul><li>之所以是距离平方是因为，python里优先队列是小根堆，所以为了把距离过长的在维护堆得时候去掉，就要取相反数</li></ul></li><li><p>再继续遍历剩下的点</p><ul><li>碰到距离比小根堆顶（也就是-距离平方最小的点）要小的<ul><li>就放到小根堆里</li><li>并移除堆顶元素</li></ul></li></ul></li><li><p>直到遍历结束</p></li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">kClosest</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], K: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(K):</span><br><span class="line">            x,y = points[i]</span><br><span class="line">            res.append((-x**<span class="number">2</span>-y**<span class="number">2</span>,i))</span><br><span class="line">        heapq.heapify(res)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(K,<span class="built_in">len</span>(points)):</span><br><span class="line">            x,y = points[i]</span><br><span class="line">            dis = -x**<span class="number">2</span>-y**<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> dis&gt;res[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">                heapq.heappushpop(res, (dis, i))</span><br><span class="line">        <span class="keyword">return</span> [points[i[<span class="number">1</span>]] <span class="keyword">for</span> i <span class="keyword">in</span> res]</span><br></pre></td></tr></table></figure><h3 id="11-8">11.8</h3><p><strong>题目</strong></p><blockquote><h4 id="122-买卖股票的最佳时机-II"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></h4><p>难度简单938</p><p>给定一个数组，它的第 <em>i</em> 个元素是一支给定股票第 <em>i</em> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 10 ^ 4</code></li><li><code>0 &lt;= prices[i] &lt;= 10 ^ 4</code></li></ul></blockquote><p><strong>思路</strong></p><p>虽然是简单题，但是最后还是看了题解</p><p>果然还是没能理解动归的精髓</p><ul><li><p>用两个变量来记录</p><ul><li>某一天不拥有股票时的最大利润 = <code>d0</code></li><li>某一天拥有股票时的最大利润 = <code>d1</code></li></ul></li><li><p>遍历整个prices数组，并动态更新这两个变量</p></li><li><p>某一天不拥有股票有两种可能</p><ol><li>当天卖出了股票</li><li>当天和前一天都未买入</li></ol><p><code>dp0=max(dp0,dp1+prices[i])</code></p></li><li><p>某一天拥有股票有两种可能</p><ol><li>当天买入了股票</li><li>之前买入了股票</li></ol><p><code>dp1=max(dp0-prices[i],dp1)</code></p></li><li><p>遍历完数组后，<code>dp0</code>就是最后的最大收益值</p></li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 动态规划</span></span><br><span class="line">        dp0, dp1 = <span class="number">0</span>, -prices[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 用两个变量来存储某一天手中无股票和手中有股票时的最大利润</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            dp0 = <span class="built_in">max</span>(dp1+price, dp0)</span><br><span class="line">            dp1 = <span class="built_in">max</span>(dp1, dp0-price)</span><br><span class="line">        <span class="keyword">return</span> dp0</span><br></pre></td></tr></table></figure><h3 id="11-7">11.7</h3><p>life sucks</p><h3 id="11-6">11.6</h3><p>计网人，咬咬牙</p><p><strong>题目</strong></p><blockquote><h4 id="1356-根据数字二进制下-1-的数目排序"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/sort-integers-by-the-number-of-1-bits/">1356. 根据数字二进制下 1 的数目排序</a></h4><p>难度简单37</p><p>给你一个整数数组 <code>arr</code> 。请你将数组中的元素按照其二进制表示中数字 <strong>1</strong> 的数目升序排序。</p><p>如果存在多个数字二进制中 <strong>1</strong> 的数目相同，则必须将它们按照数值大小升序排列。</p><p>请你返回排序后的数组。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [0,1,2,3,4,5,6,7,8]</span><br><span class="line">输出：[0,1,2,4,8,3,5,6,7]</span><br><span class="line">解释：[0] 是唯一一个有 0 个 1 的数。</span><br><span class="line">[1,2,4,8] 都有 1 个 1 。</span><br><span class="line">[3,5,6] 有 2 个 1 。</span><br><span class="line">[7] 有 3 个 1 。</span><br><span class="line">按照 1 的个数排序得到的结果数组为 [0,1,2,4,8,3,5,6,7]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [1024,512,256,128,64,32,16,8,4,2,1]</span><br><span class="line">输出：[1,2,4,8,16,32,64,128,256,512,1024]</span><br><span class="line">解释：数组中所有整数二进制下都只有 1 个 1 ，所以你需要按照数值大小将它们排序。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [10000,10000]</span><br><span class="line">输出：[10000,10000]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [2,3,5,7,11,13,17,19]</span><br><span class="line">输出：[2,3,5,17,7,11,13,19]</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr = [10,100,1000,10000]</span><br><span class="line">输出：[10,100,10000,1000]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 500</code></li><li><code>0 &lt;= arr[i] &lt;= 10^4</code></li></ul></blockquote><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sortByBits</span>(<span class="params">self, arr: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">countOne</span>(<span class="params">num</span>):</span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">bin</span>(num).count(<span class="string">&#x27;1&#x27;</span>), num)</span><br><span class="line">        arr.sort(key = countOne)</span><br><span class="line">        <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h3 id="11-5">11.5</h3><p>抄作业了抄作业了</p><p>不使用优化的解法python直接超时了</p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201105105825.png" alt="image-20201105105825102" style="zoom:50%"><p><strong>题目</strong></p><blockquote><h4 id="127-单词接龙"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/word-ladder/">127. 单词接龙</a></h4><p>难度中等</p><p>给定两个单词（<em>beginWord</em> 和 <em>endWord</em>）和一个字典，找到从 <em>beginWord</em> 到 <em>endWord</em> 的最短转换序列的长度。转换需遵循如下规则：</p><ol><li>每次转换只能改变一个字母。</li><li>转换过程中的中间单词必须是字典中的单词。</li></ol><p><strong>说明:</strong></p><ul><li>如果不存在这样的转换序列，返回 0。</li><li>所有单词具有相同的长度。</li><li>所有单词只由小写字母组成。</li><li>字典中不存在重复的单词。</li><li>你可以假设 <em>beginWord</em> 和 <em>endWord</em> 是非空的，且二者不相同。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;,</span><br><span class="line">endWord = &quot;cog&quot;,</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line"></span><br><span class="line">输出: 5</span><br><span class="line"></span><br><span class="line">解释: 一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;,</span><br><span class="line">     返回它的长度 5。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">beginWord = &quot;hit&quot;</span><br><span class="line">endWord = &quot;cog&quot;</span><br><span class="line">wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line"></span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">解释: endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure></blockquote><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ladderLength</span>(<span class="params">self, beginWord: <span class="built_in">str</span>, endWord: <span class="built_in">str</span>, wordList: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        word_set = <span class="built_in">set</span>(wordList)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(word_set)==<span class="number">0</span> <span class="keyword">or</span> endWord <span class="keyword">not</span> <span class="keyword">in</span> word_set:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> beginWord <span class="keyword">in</span> word_set:</span><br><span class="line">            word_set.remove(beginWord)</span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        visited.add(beginWord)</span><br><span class="line">        visited.add(endWord)</span><br><span class="line">        begin_visited = <span class="built_in">set</span>()</span><br><span class="line">        begin_visited.add(beginWord)</span><br><span class="line">        end_visited = <span class="built_in">set</span>()</span><br><span class="line">        end_visited.add(endWord)</span><br><span class="line"></span><br><span class="line">        word_len = <span class="built_in">len</span>(beginWord)</span><br><span class="line">        step = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> begin_visited:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(begin_visited) &gt; <span class="built_in">len</span>(end_visited):</span><br><span class="line">                begin_visited, end_visited = end_visited, begin_visited</span><br><span class="line">            next_level_visited = <span class="built_in">set</span>()</span><br><span class="line">            <span class="keyword">for</span> word <span class="keyword">in</span> begin_visited:</span><br><span class="line">                word_list = <span class="built_in">list</span>(word)</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(word_len):</span><br><span class="line">                    origin_char = word_list[j]</span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">26</span>):</span><br><span class="line">                        word_list[j] = <span class="built_in">chr</span>(<span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)+k)</span><br><span class="line">                        next_word = <span class="string">&#x27;&#x27;</span>.join(word_list)</span><br><span class="line">                        <span class="keyword">if</span> next_word <span class="keyword">in</span> word_set:</span><br><span class="line">                            <span class="keyword">if</span> next_word <span class="keyword">in</span> end_visited:</span><br><span class="line">                                <span class="keyword">return</span> step+<span class="number">1</span></span><br><span class="line">                            <span class="keyword">if</span> next_word <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                                next_level_visited.add(next_word)</span><br><span class="line">                                visited.add(next_word)</span><br><span class="line">                    word_list[j] = origin_char</span><br><span class="line">            begin_visited = next_level_visited</span><br><span class="line">            step+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="11-4">11.4</h3><p>哎，今天考完了操作系统</p><p>虽然基本都是原题，但是有道15分的甘特图我估计🈚了</p><p><strong>题目</strong></p><blockquote><h4 id="57-插入区间"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/insert-interval/">57. 插入区间</a></h4><p>难度困难</p><p>给出一个*无重叠的 ，*按照区间起始端点排序的区间列表。</p><p>在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,3],[6,9]], newInterval = [2,5]</span><br><span class="line">输出：[[1,5],[6,9]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]</span><br><span class="line">输出：[[1,2],[3,10],[12,16]]</span><br><span class="line">解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。</span><br></pre></td></tr></table></figure></blockquote><p>困难题就这</p><p>不过是多写几个elif的事情</p><p>不说了，复习计算机网络去了</p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://gitee.com/ethanloo/markdownImage/raw/master/img/20201104135845.png" alt="image-20201104135845665" style="zoom:80%"><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]], newInterval: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(intervals)==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [newInterval]</span><br><span class="line">        tmp = []</span><br><span class="line">        new_left, new_right = newInterval[<span class="number">0</span>], newInterval[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> new_right&lt;intervals[<span class="number">0</span>][<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> [newInterval]+intervals</span><br><span class="line">        <span class="keyword">if</span> new_left&gt;intervals[-<span class="number">1</span>][<span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> intervals+[newInterval]</span><br><span class="line">        flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(intervals)):</span><br><span class="line">            left, right = intervals[i][<span class="number">0</span>], intervals[i][<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> new_left&lt;=left <span class="keyword">and</span> new_right&gt;=right:</span><br><span class="line">                <span class="comment"># 第一种情况newInterval包含了[left, right]</span></span><br><span class="line">                tmp.append(newInterval)</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> left&lt;=new_left <span class="keyword">and</span> right&gt;=new_right:</span><br><span class="line">                tmp.append(intervals[i])</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> new_left&lt;=right <span class="keyword">and</span> new_right&gt;=right:</span><br><span class="line">                tmp.append([left, new_right])</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">elif</span> new_left&lt;=left <span class="keyword">and</span> new_right&gt;=left:</span><br><span class="line">                tmp.append([new_left, right])</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp.append(intervals[i])</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            <span class="comment"># 说明没插入</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(tmp)-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> tmp[i+<span class="number">1</span>][<span class="number">0</span>]&gt;new_right:</span><br><span class="line">                    tmp = tmp[:i+<span class="number">1</span>]+[newInterval]+tmp[i+<span class="number">1</span>:]</span><br><span class="line">        <span class="comment"># 合并有重叠的数组</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(tmp) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> tmp</span><br><span class="line">        ans = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;<span class="built_in">len</span>(tmp)-<span class="number">1</span>:</span><br><span class="line">            left1, right1 = tmp[i]</span><br><span class="line">            left2, right2 = tmp[i+<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> right1&lt;left2:</span><br><span class="line">                ans.append(tmp[i])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> i&lt;<span class="built_in">len</span>(tmp)-<span class="number">1</span> <span class="keyword">and</span> tmp[i+<span class="number">1</span>][<span class="number">0</span>]&lt;=right1:</span><br><span class="line">                    i += <span class="number">1</span></span><br><span class="line">                <span class="comment"># 这个时候找到了需要合并的右边界</span></span><br><span class="line">                ans.append([left1,tmp[i][<span class="number">1</span>]])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i==<span class="built_in">len</span>(tmp)-<span class="number">1</span>:</span><br><span class="line">                ans.append(tmp[-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="11-3">11.3</h3><p><strong>题目</strong></p><blockquote><h4 id="941-有效的山脉数组"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/valid-mountain-array/">941. 有效的山脉数组</a></h4><p>难度简单</p><p>给定一个整数数组 <code>A</code>，如果它是有效的山脉数组就返回 <code>true</code>，否则返回 <code>false</code>。</p><p>让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：</p><ul><li><p><code>A.length &gt;= 3</code></p></li><li><p>在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &lt; i &lt; A.length - 1</span><br></pre></td></tr></table></figure><p>条件下，存在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i</span><br></pre></td></tr></table></figure><p>使得：</p><ul><li><code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</code></li><li><code>A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li></ul></li></ul><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://assets.leetcode.com/uploads/2019/10/20/hint_valid_mountain_array.png" alt="img" style="zoom:67%"><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,1]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,5,5]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[0,3,2,1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= A.length &lt;= 10000</code></li><li><code>0 &lt;= A[i] &lt;= 10000</code></li></ol></blockquote><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validMountainArray</span>(<span class="params">self, A: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(A)&lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        prev = A[<span class="number">0</span>]-<span class="number">1</span>  <span class="comment"># 用来记录经过的上一个数</span></span><br><span class="line">        flag = <span class="number">0</span>  <span class="comment"># 用来记录是否已经翻过山峰</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">            <span class="keyword">if</span> flag==<span class="number">0</span> <span class="keyword">and</span> i&gt;prev:</span><br><span class="line">                prev = i</span><br><span class="line">            <span class="keyword">elif</span> flag==<span class="number">0</span> <span class="keyword">and</span> i&lt;prev <span class="keyword">and</span> i!=A[<span class="number">0</span>]-<span class="number">1</span>:</span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line">                prev = i</span><br><span class="line">            <span class="keyword">elif</span> flag == <span class="number">1</span> <span class="keyword">and</span> i&lt;prev:</span><br><span class="line">                prev = i</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="11-2">11.2</h3><p>软件测试的期中考试有点崩，sad</p><p>近日只贴代码</p><p><strong>题目</strong></p><blockquote><h4 id="349-两个数组的交集"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/intersection-of-two-arrays/">349. 两个数组的交集</a></h4><p>难度简单</p><p>给定两个数组，编写一个函数来计算它们的交集。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">输出：[9,4]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>输出结果中的每个元素一定是唯一的。</li><li>我们可以不考虑输出结果的顺序。</li></ul></blockquote><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">intersection</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums1)&gt;<span class="built_in">len</span>(nums2):</span><br><span class="line">            nums1, nums2 = nums2, nums1</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">set</span>(nums1):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">                ans.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>赶紧复习操作系统和计网去了，想保住3.9好难TAT</p><h3 id="11-1">11.1</h3><p>刚刚竟然没注意把日期写成了10.32🙃</p><p>估计是学傻了</p><p>可惜了昨天的sn没能夺冠（dwg就nm强得离谱）</p><p><strong>题目</strong></p><blockquote><h4 id="140-单词拆分-II"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/word-break-ii/">140. 单词拆分 II</a></h4><p>难度困难</p><p>给定一个<strong>非空</strong>字符串 <em>s</em> 和一个包含<strong>非空</strong>单词列表的字典 <em>wordDict</em>，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。</p><p><strong>说明：</strong></p><ul><li>分隔时可以重复使用字典中的单词。</li><li>你可以假设字典中没有重复的单词。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;catsanddog&quot;</span><br><span class="line">wordDict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  &quot;cats and dog&quot;,</span><br><span class="line">  &quot;cat sand dog&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;pineapplepenapple&quot;</span><br><span class="line">wordDict = [&quot;apple&quot;, &quot;pen&quot;, &quot;applepen&quot;, &quot;pine&quot;, &quot;pineapple&quot;]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  &quot;pine apple pen apple&quot;,</span><br><span class="line">  &quot;pineapple pen apple&quot;,</span><br><span class="line">  &quot;pine applepen apple&quot;</span><br><span class="line">]</span><br><span class="line">解释: 注意你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">s = &quot;catsandog&quot;</span><br><span class="line">wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出:</span><br><span class="line">[]</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><p>我一开始看到这题目还很开心，因为在一节专选课刚做过<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.ethanloo.cn/post/2020-10-20-%E5%9F%BA%E4%BA%8E%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E7%9A%84%E5%8F%A5%E5%AD%90%E5%88%86%E8%AF%8D/">分词法的实验</a></p><p>可惜最大前向匹配法和最大后相匹配法并不能解决这个问题，因为从这里的示例二就能看出来，他的分词不是用“最大”这个规则能解决的</p><p>单纯地使用前向或后向并不能把<code>pineapple</code>拆解成<code>pine apple</code></p><p>咋办呢，看大佬题解呗</p><ul><li>动态规划+dfs</li><li>用动态规划求解字符的前n个字符能否拆解成若干字串<ul><li>用一个dp数组去记录</li></ul></li><li>用dfs，在dp数组的基础上，去找到所有可能性</li></ul><blockquote><p>就写个大概思路吧，还要准备三门专业必修课的期中考试😭</p></blockquote></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://blog.ethanloo.cn">EthanLoo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://blog.ethanloo.cn/post/2020-11-01-Algorithm/2020%E5%B9%B411%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/">https://blog.ethanloo.cn/post/2020-11-01-Algorithm/2020年11月刷题日志/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.ethanloo.cn" target="_blank">Ethanloo's</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/leetcode/">leetcode</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/2020-11-26-Algorithm/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%B9%98/" title="Java实现多线程矩阵相乘"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/20201216101954.webp" onerror='onerror=null,src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java实现多线程矩阵相乘</div></div></a></div><div class="next-post pull-right"><a href="/post/2020-10-24-Basic/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B4%A8%E9%87%8F%E4%BF%9D%E8%AF%81%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" title="软件测试与质量保证课程笔记"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="/img/cover/s.png" onerror='onerror=null,src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">软件测试与质量保证课程笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/2021-06-02-Algorithm/2021%E5%B9%B46%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/" title="2021年6月刷题日志"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/20210602143312.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-02</div><div class="title">2021年6月刷题日志</div></div></a></div><div><a href="/post/2021-05-05-Algorithm/2021%E5%B9%B45%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/" title="2021年5月刷题日志"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/image-20201204232217281.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-05</div><div class="title">2021年5月刷题日志</div></div></a></div><div><a href="/post/2021-04-01-Algorithm/2021%E5%B9%B44%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/" title="2021年4月刷题日志"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="/img/cover/l.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-01</div><div class="title">2021年4月刷题日志</div></div></a></div><div><a href="/post/2021-03-01-Algorithm/2021%E5%B9%B43%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/" title="2021年3月刷题日志"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="/img/cover/l.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-01</div><div class="title">2021年3月刷题日志</div></div></a></div><div><a href="/post/2021-02-01-Algorithm/2021%E5%B9%B42%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/" title="2021年2月刷题日志"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="/img/cover/l.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-01</div><div class="title">2021年2月刷题日志</div></div></a></div><div><a href="/post/2021-01-01-Algorithm/2021%E5%B9%B41%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/" title="2021年1月刷题日志"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="/img/cover/l.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-01</div><div class="title">2021年1月刷题日志</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/avatar.png" onerror='this.onerror=null,this.src="https://cdn.ethanloo.cn/img/20201202163407.gif"' alt="avatar"></div><div class="author-info__name">EthanLoo</div><div class="author-info__description">不过是用输出倒逼输入罢了👶</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/EthanLuu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/EthanLuu" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:ethanlooo@outlook.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=952792901&amp;site=qq&amp;menu=yes" rel="external nofollow noreferrer" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><span>公告</span></div><div class="announcement_content">好好吃饭🍣 好好睡觉💤<br>敲敲代码💻 谈谈恋爱💑</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-30"><span class="toc-text">11.30</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#767-%E9%87%8D%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">767. 重构字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-29"><span class="toc-text">11.29</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#976-%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E9%95%BF"><span class="toc-text">976. 三角形的最大周长</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-28"><span class="toc-text">11.28</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#493-%E7%BF%BB%E8%BD%AC%E5%AF%B9"><span class="toc-text">493. 翻转对</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-27"><span class="toc-text">11.27</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0-II"><span class="toc-text">454. 四数相加 II</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-26"><span class="toc-text">11.26</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#164-%E6%9C%80%E5%A4%A7%E9%97%B4%E8%B7%9D"><span class="toc-text">164. 最大间距</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-25"><span class="toc-text">11.25</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1370-%E4%B8%8A%E5%8D%87%E4%B8%8B%E9%99%8D%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">1370. 上升下降字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-24"><span class="toc-text">11.24</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-text">222. 完全二叉树的节点个数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-23"><span class="toc-text">11.23</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83"><span class="toc-text">452. 用最少数量的箭引爆气球</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-22"><span class="toc-text">11.22</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="toc-text">242. 有效的字母异位词</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-21"><span class="toc-text">11.21</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="toc-text">148. 排序链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-20"><span class="toc-text">11.20</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#147-%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">147. 对链表进行插入排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-19"><span class="toc-text">11.19</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#283-%E7%A7%BB%E5%8A%A8%E9%9B%B6"><span class="toc-text">283. 移动零</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-18"><span class="toc-text">11.18</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#134-%E5%8A%A0%E6%B2%B9%E7%AB%99"><span class="toc-text">134. 加油站</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-17"><span class="toc-text">11.17</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1030-%E8%B7%9D%E7%A6%BB%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E7%9F%A9%E9%98%B5%E5%8D%95%E5%85%83%E6%A0%BC"><span class="toc-text">1030. 距离顺序排列矩阵单元格</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-16"><span class="toc-text">11.16</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97"><span class="toc-text">406. 根据身高重建队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-15"><span class="toc-text">11.15</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#402-%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97"><span class="toc-text">402. 移掉K位数字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-14"><span class="toc-text">11.14</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1122-%E6%95%B0%E7%BB%84%E7%9A%84%E7%9B%B8%E5%AF%B9%E6%8E%92%E5%BA%8F"><span class="toc-text">1122. 数组的相对排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-13"><span class="toc-text">11.13</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#328-%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8"><span class="toc-text">328. 奇偶链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-12"><span class="toc-text">11.12</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#922-%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-II"><span class="toc-text">922. 按奇偶排序数组 II</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-11"><span class="toc-text">11.11</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#514-%E8%87%AA%E7%94%B1%E4%B9%8B%E8%B7%AF"><span class="toc-text">514. 自由之路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-10"><span class="toc-text">11.10</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="toc-text">31. 下一个排列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-9"><span class="toc-text">11.9</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#973-%E6%9C%80%E6%8E%A5%E8%BF%91%E5%8E%9F%E7%82%B9%E7%9A%84-K-%E4%B8%AA%E7%82%B9"><span class="toc-text">973. 最接近原点的 K 个点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-8"><span class="toc-text">11.8</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II"><span class="toc-text">122. 买卖股票的最佳时机 II</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-7"><span class="toc-text">11.7</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-6"><span class="toc-text">11.6</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1356-%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%AD%97%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%8B-1-%E7%9A%84%E6%95%B0%E7%9B%AE%E6%8E%92%E5%BA%8F"><span class="toc-text">1356. 根据数字二进制下 1 的数目排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5"><span class="toc-text">11.5</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#127-%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99"><span class="toc-text">127. 单词接龙</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4"><span class="toc-text">11.4</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#57-%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4"><span class="toc-text">57. 插入区间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3"><span class="toc-text">11.3</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#941-%E6%9C%89%E6%95%88%E7%9A%84%E5%B1%B1%E8%84%89%E6%95%B0%E7%BB%84"><span class="toc-text">941. 有效的山脉数组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2"><span class="toc-text">11.2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="toc-text">349. 两个数组的交集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1"><span class="toc-text">11.1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#140-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-II"><span class="toc-text">140. 单词拆分 II</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/2023-11-26-Weber/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%88%E4%BA%8C%EF%BC%89/" title="前端开发的十万个为什么（二）"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/Exploring-Different-Types-of-Landforms-_1_.webp" onerror='this.onerror=null,this.src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="前端开发的十万个为什么（二）"></a><div class="content"><a class="title" href="/post/2023-11-26-Weber/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%88%E4%BA%8C%EF%BC%89/" title="前端开发的十万个为什么（二）">前端开发的十万个为什么（二）</a><time datetime="2023-11-26T21:05:10.000Z" title="发表于 2023-11-26 21:05:10">2023-11-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2023-11-22-Vue/%E9%9D%A2%E5%90%91%20Vue%20%E4%B8%AD%20VNode%20%E7%9A%84%E4%B8%80%E6%AC%A1%20Deep%20Dive/" title="面向 Vue 中 VNode 的一次 Deep Dive"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/202311221935387.png" onerror='this.onerror=null,this.src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="面向 Vue 中 VNode 的一次 Deep Dive"></a><div class="content"><a class="title" href="/post/2023-11-22-Vue/%E9%9D%A2%E5%90%91%20Vue%20%E4%B8%AD%20VNode%20%E7%9A%84%E4%B8%80%E6%AC%A1%20Deep%20Dive/" title="面向 Vue 中 VNode 的一次 Deep Dive">面向 Vue 中 VNode 的一次 Deep Dive</a><time datetime="2023-11-22T15:41:10.000Z" title="发表于 2023-11-22 15:41:10">2023-11-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2023-07-24-Weber/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%88%E4%B8%80%EF%BC%89/" title="前端开发的十万个为什么（一）"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/Exploring-Different-Types-of-Landforms-_1_.webp" onerror='this.onerror=null,this.src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="前端开发的十万个为什么（一）"></a><div class="content"><a class="title" href="/post/2023-07-24-Weber/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%88%E4%B8%80%EF%BC%89/" title="前端开发的十万个为什么（一）">前端开发的十万个为什么（一）</a><time datetime="2023-07-24T15:41:10.000Z" title="发表于 2023-07-24 15:41:10">2023-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2022-11-24-Paper/YuZu%20-%20Neural-Enhanced%20Volumetric%20Video%20Streaming/" title="NSDI22 - YuZu：Neural-Enhanced Volumetric Video Streaming"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/202302041759590.webp" onerror='this.onerror=null,this.src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="NSDI22 - YuZu：Neural-Enhanced Volumetric Video Streaming"></a><div class="content"><a class="title" href="/post/2022-11-24-Paper/YuZu%20-%20Neural-Enhanced%20Volumetric%20Video%20Streaming/" title="NSDI22 - YuZu：Neural-Enhanced Volumetric Video Streaming">NSDI22 - YuZu：Neural-Enhanced Volumetric Video Streaming</a><time datetime="2022-11-24T11:33:08.000Z" title="发表于 2022-11-24 11:33:08">2022-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2022-11-10-Paper/Collaborative%20Service%20Placement%20for%20Edge%20Computing%20in%20Dense%20Small%20Cell%20Networks/" title="TMC21 - Collaborative Service Placement for Edge Computing in Dense Small Cell Networks"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/202302041758847.webp" onerror='this.onerror=null,this.src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="TMC21 - Collaborative Service Placement for Edge Computing in Dense Small Cell Networks"></a><div class="content"><a class="title" href="/post/2022-11-10-Paper/Collaborative%20Service%20Placement%20for%20Edge%20Computing%20in%20Dense%20Small%20Cell%20Networks/" title="TMC21 - Collaborative Service Placement for Edge Computing in Dense Small Cell Networks">TMC21 - Collaborative Service Placement for Edge Computing in Dense Small Cell Networks</a><time datetime="2022-11-10T11:47:01.000Z" title="发表于 2022-11-10 11:47:01">2022-11-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By EthanLoo</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">苏ICP备2020057383号</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://ethanloo-blog-waline.vercel.app',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  if (typeof Waline === 'object') initWaline()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css').then(() => {
      getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js').then(initWaline)
    })
  }
}

if ('Waline' === 'Waline' || !true) {
  if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><div async class="app-refresh" id="app-refresh"><div class="app-refresh-wrap"><label>✨ 网站更新啦 👉</label> <a href="javascript:void(0)" rel="external nofollow noreferrer" onclick="location.reload()">点击刷新</a></div></div><script>function showNotification(){if(GLOBAL_CONFIG.Snackbar){var t="light"===document.documentElement.getAttribute("data-theme")?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e=GLOBAL_CONFIG.Snackbar.position;Snackbar.show({text:"已更新最新版本",backgroundColor:t,duration:5e5,pos:e,actionText:"點擊刷新",actionTextColor:"#fff",onActionClick:function(t){location.reload()}})}else{var o=`top: 0; background: ${"light"===document.documentElement.getAttribute("data-theme")?"#49b1f5":"#1f1f1f"};`;document.getElementById("app-refresh").style.cssText=o}}"serviceWorker"in navigator&&(navigator.serviceWorker.controller&&navigator.serviceWorker.addEventListener("controllerchange",function(){showNotification()}),window.addEventListener("load",function(){navigator.serviceWorker.register("/sw.js")}));</script><script async src="./js/background.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>