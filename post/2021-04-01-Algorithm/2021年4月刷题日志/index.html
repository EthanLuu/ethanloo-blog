<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>2021年4月刷题日志 | Ethanloo's</title><meta name="author" content="EthanLoo"><meta name="copyright" content="EthanLoo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="仅用于记录 Leetcode 刷题过程，顺便锻炼一下自己的语言组织能力。"><link rel="shortcut icon" href="https://cdn.ethanloo.cn/img/favicon.png"><link rel="canonical" href="https://blog.ethanloo.cn/post/2021-04-01-Algorithm/2021%E5%B9%B44%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.clarity.ms"><link rel="manifest" href="/manifest.json"><link rel="apple-touch-icon" sizes="180x180" href="https://cdn.ethanloo.cn/img/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://cdn.ethanloo.cn/img/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="https://cdn.ethanloo.cn/img/favicon.png"><link rel="mask-icon" href="https://cdn.ethanloo.cn/img/favicon.png" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>!function(t,e,n,c,r,a,s){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/bjrte2qfwy",(s=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,s)}(window,document,"clarity","script")</script><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Noto+Sans+SC&amp;family=Noto+Serif+SC&amp;family=Roboto+Mono&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: EthanLoo","link":"链接: ","source":"来源: Ethanloo's","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"2021年4月刷题日志",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-11-26 23:46:29"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="./css/optimization.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/avatar.png" onerror='onerror=null,src="https://cdn.ethanloo.cn/img/20201202163407.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fab fa-readme"></i> <span>文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.ethanloo.cn/lab"><i class="fa-fw fas fa-meteor"></i> <span>实验室</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Ethanloo's"><span class="site-name">Ethanloo's</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fab fa-readme"></i> <span>文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.ethanloo.cn/lab"><i class="fa-fw fas fa-meteor"></i> <span>实验室</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">2021年4月刷题日志</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2021-04-01T09:33:01.000Z" title="发表于 2021-04-01 09:33:01">2021-04-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/">刷题日志</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>53分钟</span></span></div></div></div><article class="post-content" id="article-container"><p><strong>4.30</strong></p><p>刷完题复习一下软件项目管理就去考试了，考完起飞！</p><p><strong>题目</strong></p><blockquote><h4 id="137-只出现一次的数字-II"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/single-number-ii/">137. 只出现一次的数字 II</a></h4><p>难度中等580</p><p>给你一个整数数组 <code>nums</code> ，除某个元素仅出现 <strong>一次</strong> 外，其余每个元素都恰出现 **三次 。**请你找出并返回那个只出现了一次的元素。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,2,3,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,0,1,0,1,99]</span><br><span class="line">输出：99</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><p>不会位运算，直接哈希表计数，一次遍历数组，一次遍历哈希表。</p><p><strong>代码</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">singleNumber</span>(<span class="params">nums: <span class="built_in">number</span>[]</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    <span class="keyword">const</span> len = nums.<span class="property">length</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> num <span class="keyword">of</span> nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.<span class="title function_">has</span>(num)) &#123;</span><br><span class="line">            map.<span class="title function_">set</span>(num, <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map.<span class="title function_">set</span>(num, <span class="number">3</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> key</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.29</strong></p><p>单杀困难题，芜湖🛫！</p><p><strong>题目</strong></p><blockquote><h4 id="403-青蛙过河"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/frog-jump/">403. 青蛙过河</a></h4><p>难度困难</p><p>一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。</p><p>给你石子的位置列表 <code>stones</code>（用单元格序号 <strong>升序</strong> 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。</p><p>开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）。</p><p>如果青蛙上一步跳跃了 <code>k</code> 个单位，那么它接下来的跳跃距离只能选择为 <code>k - 1</code>、<code>k</code> 或 <code>k + 1</code> 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [0,1,3,5,6,8,12,17]</span><br><span class="line">输出：true</span><br><span class="line">解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [0,1,2,3,4,8,9,11]</span><br><span class="line">输出：false</span><br><span class="line">解释：这是因为第 5 和第 6 个石子之间的间距太大，没有可选的方案供青蛙跳跃过去。</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><p>很朴素的深搜，虽然题目中的数据规模是 2000，没想到记忆化一下就过了。</p><p>深搜过程：</p><ul><li>记录上一次的步长和位置，尝试找到可以跳到的所有位置</li><li>然后记录跳的步长，从下一个位置继续搜索</li></ul><p>记忆化：</p><ul><li>记录下从第 <code>i</code> 格出发且步长为 <code>j</code> 的可能</li><li>避免多次尝试无用解</li></ul><p><strong>代码</strong></p><blockquote><p>最近在试着用 TS 写项目，所以就用算法顺手练一下语法（不过似乎在这种函数里和 JS 区分不大）</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">canCross</span>(<span class="params">stones: <span class="built_in">number</span>[]</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> len = stones.<span class="property">length</span></span><br><span class="line">    <span class="comment">// reachables[i] = [3, 4] 表示到达第 i 格的前一步可能是 3 或 4 个单位</span></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">reachables</span>: <span class="title class_">Array</span>&lt;<span class="title class_">Array</span>&lt;<span class="built_in">number</span>&gt;&gt; = <span class="keyword">new</span> <span class="title class_">Array</span>(len).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>())</span><br><span class="line">    <span class="keyword">let</span> res = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">idx: <span class="built_in">number</span>, k: <span class="built_in">number</span></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx === len - <span class="number">1</span>) &#123;</span><br><span class="line">            res = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = idx + <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> step = stones[i] - stones[idx]</span><br><span class="line">            <span class="keyword">if</span> (step &gt;= k - <span class="number">1</span> &amp;&amp; step &lt;= k + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (reachables[i].<span class="title function_">indexOf</span>(step) !== -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// 说明深搜过当前可能</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                reachables[i].<span class="title function_">push</span>(step)</span><br><span class="line">                <span class="title function_">dfs</span>(i, step)</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (step &gt; k + <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">dfs</span>(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.28</strong></p><blockquote><h4 id="633-平方数之和"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/sum-of-square-numbers/">633. 平方数之和</a></h4><p>难度中等</p><p>给定一个非负整数 <code>c</code> ，你要判断是否存在两个整数 <code>a</code> 和 <code>b</code>，使得 <code>a2 + b2 = c</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：c = 5</span><br><span class="line">输出：true</span><br><span class="line">解释：1 * 1 + 2 * 2 = 5</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：c = 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：c = 4</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：c = 2</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：c = 1</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><p>两年前做过的第一到老题目了。</p><p>双指针，左指针初始值为 <code>0</code>，右指针为 <code>根号c</code>。</p><p>偏大右指针左移，偏小左指针右移，直到两个指针重合求出来的和还不满足，说明不存在。</p><p><strong>代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> judgeSquareSum = <span class="keyword">function</span>(<span class="params">c</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> left = <span class="number">0</span>, right = <span class="built_in">parseInt</span>(<span class="title class_">Math</span>.<span class="title function_">sqrt</span>(c))</span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="title class_">Math</span>.<span class="title function_">pow</span>(left, <span class="number">2</span>) + <span class="title class_">Math</span>.<span class="title function_">pow</span>(right, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> (res === c) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (res &gt; c) right--</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (res &lt; c) left++</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.27</strong></p><p><strong>题目</strong></p><blockquote><h4 id="938-二叉搜索树的范围和"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/range-sum-of-bst/">938. 二叉搜索树的范围和</a></h4><p>难度简单</p><p>给定二叉搜索树的根结点 <code>root</code>，返回值位于范围 <em><code>[low, high]</code></em> 之间的所有结点的值的和。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://assets.leetcode.com/uploads/2020/11/05/bst1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [10,5,15,3,7,null,18], low = 7, high = 15</span><br><span class="line">输出：32</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://assets.leetcode.com/uploads/2020/11/05/bst2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [10,5,15,3,7,13,18,1,null,6], low = 6, high = 10</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><p>利用二叉搜索树的性质：<code>左 &lt; 根 &lt; 右</code>，在求和的时候进行剪枝。</p><ul><li><p>如果根结点的值比题目给出的最小值 <code>low</code> 还要小，那么就只能往右子树里继续找。</p></li><li><p>如果根结点的值比题目给出的最大值 <code>high</code> 还要大，那么就只能往左子树里继续找。</p></li><li><p>否则，就需要向两边找。</p></li></ul><p>简单是简单，但是自己写完才发现官方题解代码真优雅。</p><p><strong>代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rangeSumBST = <span class="keyword">function</span>(<span class="params">root, low, high</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (root.<span class="property">val</span> &lt; low) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">rangeSumBST</span>(root.<span class="property">right</span>, low, high)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root.<span class="property">val</span> &gt; high) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">rangeSumBST</span>(root.<span class="property">left</span>, low, high)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root.<span class="property">val</span> + <span class="title function_">rangeSumBST</span>(root.<span class="property">left</span>, low, high) + <span class="title function_">rangeSumBST</span>(root.<span class="property">right</span>, low, high)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.26</strong></p><p><strong>题目</strong></p><blockquote><h4 id="1011-在-D-天内送达包裹的能力"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/">1011. 在 D 天内送达包裹的能力</a></h4><p>难度中等236</p><p>传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。</p><p>传送带上的第 <code>i</code> 个包裹的重量为 <code>weights[i]</code>。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p><p>返回能在 <code>D</code> 天内将传送带上的所有包裹送达的船的最低运载能力。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：weights = [1,2,3,4,5,6,7,8,9,10], D = 5</span><br><span class="line">输出：15</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：1, 2, 3, 4, 5</span><br><span class="line">第 2 天：6, 7</span><br><span class="line">第 3 天：8</span><br><span class="line">第 4 天：9</span><br><span class="line">第 5 天：10</span><br><span class="line"></span><br><span class="line">请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：weights = [3,2,2,4,1,4], D = 3</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：3, 2</span><br><span class="line">第 2 天：2, 4</span><br><span class="line">第 3 天：1, 4</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：weights = [1,2,3,1,1], D = 4</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">第 1 天：1</span><br><span class="line">第 2 天：2</span><br><span class="line">第 3 天：3</span><br><span class="line">第 4 天：1, 1</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><p>下意识看到 <code>在 * 天内 ** 的能力</code> 还以为是动态规划，看了一遍题目之后发现遍历就行。</p><p>遍历完发现超时了，超时完看题解发现要用二分 🤒</p><p>题目要返回的是最低运载能力，左边界设为最大包裹的重量，右边界设为所有包裹的总重量。</p><p>二分的依据是判断是按照当前的运载能力是否能在 D 天内完成：</p><ul><li>如果不能，说明运力偏小，左边界右移</li><li>如果能，说明运力偏大，右边界左移</li></ul><p>直到左边界超过右边界时，左边界就是所需的最小运力。</p><p><strong>代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shipWithinDays = <span class="keyword">function</span>(<span class="params">weights, D</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="title class_">Math</span>.<span class="title function_">max</span>(...weights), right = weights.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre + cur)</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((left + right)/ <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (<span class="title function_">canFinish</span>(weights, mid, D)) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">canFinish</span>(<span class="params">weights, ability, D</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> d = <span class="number">1</span>, cur = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> weight <span class="keyword">of</span> weights) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ability &lt; cur + weight) &#123;</span><br><span class="line">            cur = <span class="number">0</span></span><br><span class="line">            d++</span><br><span class="line">            <span class="keyword">if</span> (d &gt; D) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur += weight</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4.25</strong></p><p><strong>题目</strong></p><blockquote><h4 id="897-递增顺序搜索树"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/increasing-order-search-tree/">897. 递增顺序搜索树</a></h4><p>难度简单166</p><p>给你一棵二叉搜索树，请你 <strong>按中序遍历</strong> 将其重新排列为一棵递增顺序搜索树，使树中最左边的节点成为树的根节点，并且每个节点没有左子节点，只有一个右子节点。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://assets.leetcode.com/uploads/2020/11/17/ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,3,6,2,4,null,8,1,null,null,null,7,9]</span><br><span class="line">输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://assets.leetcode.com/uploads/2020/11/17/ex2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,1,7]</span><br><span class="line">输出：[1,null,5,null,7]</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><p>整体思路就是中序遍历，不过有两种建树方式。</p><ol><li>先中序遍历一遍原树，然后把遍历到的结点值逐个存入数组，最终遍历完一棵树的数组就是一个递增数列。根据该数组，逐个新建结点，生成新树。</li><li>在中序遍历的同时改变原树上结点的指向，原地修改。</li></ol><p><strong>代码</strong></p><p>两种思路都比较简单，这里就贴个第二种。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> increasingBST = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">inOrder</span> = (<span class="params">node</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">inOrder</span>(node.<span class="property">left</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历的同时直接修改结点指向</span></span><br><span class="line">        pre.<span class="property">right</span> = node</span><br><span class="line">        node.<span class="property">left</span> = <span class="literal">null</span></span><br><span class="line">        pre = node</span><br><span class="line"></span><br><span class="line">        <span class="title function_">inOrder</span>(node.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> dummy = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(-<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> pre = dummy    </span><br><span class="line">    <span class="title function_">inOrder</span>(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummy.<span class="property">right</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.24</strong></p><p><strong>题目</strong></p><blockquote><h4 id="377-组合总和-Ⅳ"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/combination-sum-iv/">377. 组合总和 Ⅳ</a></h4><p>难度中等</p><p>给你一个由 <strong>不同</strong> 整数组成的数组 <code>nums</code> ，和一个目标整数 <code>target</code> 。请你从 <code>nums</code> 中找出并返回总和为 <code>target</code> 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3], target = 4</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [9], target = 3</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 200</code></li><li><code>1 &lt;= nums[i] &lt;= 1000</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 1000</code></li></ul></blockquote><p><strong>思路1</strong></p><p>第一想法 DFS，写出来就超时了。</p><p>因为像是 <code>nums = [2, 1, 3], target = 35</code> 的情况，递归实在太久了。</p><p><strong>代码1</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> combinationSum4 = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">dfs</span> = (<span class="params">arr, sum</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> diff = target - sum</span><br><span class="line">        <span class="keyword">if</span> (diff === <span class="number">0</span>) &#123;</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        nums.<span class="title function_">map</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= diff) &#123;</span><br><span class="line">                arr.<span class="title function_">push</span>(num)</span><br><span class="line">                <span class="title function_">dfs</span>(arr, sum + num)</span><br><span class="line">                arr.<span class="title function_">pop</span>()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">dfs</span>([], <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>思路2</strong></p><p>又又又是动态规划，本质上是一个完全背包问题。</p><blockquote><p>这篇<a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/combination-sum-iv/solution/xi-wang-yong-yi-chong-gui-lu-gao-ding-bei-bao-wen-/">题解</a>针不戳。</p></blockquote><ul><li>DP table：开辟一个长度是 <code>target + 1</code> 的数组，<code>dp[i]</code> 表示的是和为 <code>i</code> 的组合数。</li><li>Base case：<code>dp[0] = 1</code>，表示和为 0 的组合只有一种，就是空数组。</li><li>动态转移方程<ul><li>从 <code>dp[1]</code> 求到 <code>dp[target]</code></li><li>每次算 <code>dp[i]</code> 的时候，遍历一遍我们手头的数组 <code>nums</code></li><li>若 <code>nums[j] &lt;= i</code>，说明当前的这个数可以与之前某个的组合相结合，因此令 <code>dp[i] += dp[nums[j] - i]</code></li></ul></li></ul><p><strong>代码2</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> combinationSum4 = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(target + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// 和为 1 的组合是 []</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= target; i++) &#123;</span><br><span class="line">        nums.<span class="title function_">map</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= i) &#123;</span><br><span class="line">                dp[i] += dp[i-num]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.23</strong></p><p><strong>题目</strong></p><blockquote><h4 id="368-最大整除子集"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/largest-divisible-subset/">368. 最大整除子集</a></h4><p>难度中等</p><p>给你一个由 <strong>无重复</strong> 正整数组成的集合 <code>nums</code> ，请你找出并返回其中最大的整除子集 <code>answer</code> ，子集中每一元素对 <code>(answer[i], answer[j])</code> 都应当满足：</p><ul><li><code>answer[i] % answer[j] == 0</code> ，或</li><li><code>answer[j] % answer[i] == 0</code></li></ul><p>如果存在多个有效解子集，返回其中任何一个均可。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[1,2]</span><br><span class="line">解释：[1,3] 也会被视为正确答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,4,8]</span><br><span class="line">输出：[1,2,4,8]</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><p>初看题目要求子集，下意识是想去用 DFS 的，但是发现数组规模是 1000，而且 DFS 似乎也不太好写，求助于官方题解后得知是用 DP。</p><p>之所以是 DP，是因为整除的性质：</p><ul><li>对于一个给定的整除子集而言，如果另外有一个数是该子集中最大数的整数倍，那么把这个数加入子集也是合法的。</li></ul><p>由于有这条性质，所以数字的大小和我们的遍历应该是关系的，先对数组排序可以简化后续步骤。</p><p>同时基于这条性质，也可以联想到 DP table 的定义和状态转移方程。</p><ul><li><p>假设 <code>dp[i]</code> 表示在 <code>nums[0:i]</code> 子数组中包含 <code>nums[i]</code> 在内的最大整除子集数。</p></li><li><p>我们需要遍历比当前数字小的所有数字，根据上面的整除性质，可以很容易得到 <code>dp[i]</code></p></li></ul><p>Base case：由于数字自身整除于自身，所以 <code>dp[i]</code> 应该初始化为 1。</p><p>在进行动规后，我们就获得了一个 <code>dp</code> 数组，例如题目中的 <code>nums = [1, 2, 3], dp = [1, 2, 2]</code>。</p><p>但是题目要求的并不是最大整除子集的规模，而是子集本身，所以我们现在可以根据子集数求子集。</p><p>首先确定最大子集的规模 <code>maxSize</code>，通过倒序遍历 <code>dp[i]</code> ，找到 <code>dp[i] = maxSize</code> 的 <code>nums[i]</code>，加入到结果自己。令 <code>maxSize--</code>，继续往前找，找到能整除上一个数且 <code>dp[i] = maxSize</code> 的数。</p><p><strong>代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> largestDivisibleSubset = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = nums.<span class="property">length</span></span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">x,y</span>) =&gt;</span> x-y)</span><br><span class="line">    <span class="comment">// dp[i] 表示在 nums[0:i] 子数组中包含 nums[i] 在内的最大整除子集数</span></span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">1</span>) </span><br><span class="line">    <span class="comment">// 动态规划求解整除子集数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] % nums[j] === <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 倒序遍历求有效解子集</span></span><br><span class="line">    res = []</span><br><span class="line">    maxSize = <span class="title class_">Math</span>.<span class="title function_">max</span>(...dp)</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] === maxSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre == <span class="literal">null</span> || nums[pre] % nums[i] === <span class="number">0</span>) &#123;</span><br><span class="line">                pre = i</span><br><span class="line">                res.<span class="title function_">push</span>(nums[i])</span><br><span class="line">                maxSize--</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.22</strong></p><p>今日没追求，暴力解困难</p><p><strong>题目</strong></p><blockquote><h4 id="363-矩形区域不超过-K-的最大数值和"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/max-sum-of-rectangle-no-larger-than-k/">363. 矩形区域不超过 K 的最大数值和</a></h4><p>难度困难</p><p>给你一个 <code>m x n</code> 的矩阵 <code>matrix</code> 和一个整数 <code>k</code> ，找出并返回矩阵内部矩形区域的不超过 <code>k</code> 的最大数值和。</p><p>题目数据保证总会存在一个数值和不超过 <code>k</code> 的矩形区域。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://assets.leetcode.com/uploads/2021/03/18/sum-grid.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,0,1],[0,-2,3]], k = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：蓝色边框圈出来的矩形区域 [[0, 1], [-2, 3]] 的数值和是 2，且 2 是不超过 k 的最大数字（k = 2）。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[2,2,-1]], k = 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><p>首先需要将一维前缀和数组扩展到二维，然后遍历整个二维数组的所有子数组，找出小于 <code>k</code> 的最大和。</p><p><strong>代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxSumSubmatrix = <span class="keyword">function</span>(<span class="params">matrix, k</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> m = matrix.<span class="property">length</span>, n = matrix[<span class="number">0</span>].<span class="property">length</span></span><br><span class="line">    <span class="keyword">const</span> sums = <span class="keyword">new</span> <span class="title class_">Array</span>(m + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>))</span><br><span class="line">    <span class="comment">// 先计算二维矩阵前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            sums[i + <span class="number">1</span>][j + <span class="number">1</span>] = sums[i][j + <span class="number">1</span>] + sums[i + <span class="number">1</span>][j] - sums[i][j] + matrix[i][j]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = -<span class="title class_">Infinity</span></span><br><span class="line">    <span class="comment">// 枚举所有子矩阵之和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> p = i; p &lt; m; p++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> q = j; q &lt; n; q++) &#123;</span><br><span class="line">                    <span class="comment">// (i,j) 是左上角，(p,q) 是右下角</span></span><br><span class="line">                    <span class="keyword">let</span> cur = sums[p+<span class="number">1</span>][q+<span class="number">1</span>] - sums[i][q+<span class="number">1</span>] - sums[p+<span class="number">1</span>][j] + sums[i][j]</span><br><span class="line">                    <span class="keyword">if</span> (cur &lt;= k) &#123;</span><br><span class="line">                        res = <span class="title class_">Math</span>.<span class="title function_">max</span>(res, cur)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.21</strong></p><p><strong>题目</strong></p><blockquote><h4 id="91-解码方法"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/decode-ways/">91. 解码方法</a></h4><p>难度中等</p><p>一条包含字母 <code>A-Z</code> 的消息通过以下映射进行了 <strong>编码</strong> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;A&#x27; -&gt; 1</span><br><span class="line">&#x27;B&#x27; -&gt; 2</span><br><span class="line">...</span><br><span class="line">&#x27;Z&#x27; -&gt; 26</span><br></pre></td></tr></table></figure><p>要 <strong>解码</strong> 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，<code>&quot;11106&quot;</code> 可以映射为：</p><ul><li><code>&quot;AAJF&quot;</code> ，将消息分组为 <code>(1 1 10 6)</code></li><li><code>&quot;KJF&quot;</code> ，将消息分组为 <code>(11 10 6)</code></li></ul><p>注意，消息不能分组为 <code>(1 11 06)</code> ，因为 <code>&quot;06&quot;</code> 不能映射为 <code>&quot;F&quot;</code> ，这是由于 <code>&quot;6&quot;</code> 和 <code>&quot;06&quot;</code> 在映射中并不等价。</p><p>给你一个只含数字的 <strong>非空</strong> 字符串 <code>s</code> ，请计算并返回 <strong>解码</strong> 方法的 <strong>总数</strong> 。</p><p>题目数据保证答案肯定是一个 <strong>32 位</strong> 的整数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;12&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：它可以解码为 &quot;AB&quot;（1 2）或者 &quot;L&quot;（12）。</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路1</strong></p><p>利用 BFS，尝试遍历进行所有可能性的。</p><p>每个位置可以有两种向下延申的情况：</p><ul><li>往后扩展一位</li><li>往后扩展两位</li></ul><blockquote><p>会进行大量的重复计算，导致这个解法超时</p></blockquote><p><strong>代码1</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numDecodings = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> n = s.<span class="property">length</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">bfs</span> = (<span class="params">index</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= n) &#123;</span><br><span class="line">            res += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">parseInt</span>(s[index]) &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="title function_">bfs</span>(index + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> num = <span class="built_in">parseInt</span>(s.<span class="title function_">slice</span>(index, index+<span class="number">2</span>))</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= <span class="number">10</span> &amp;&amp; num &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">                <span class="title function_">bfs</span>(index + <span class="number">2</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">bfs</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>思路2</strong></p><p>动态规划，利用当前数和前一个数的大小，迭代计算。</p><ul><li>DP table：<code>dp = new Array(n+1).fill(0)</code>，数组长度为 <code>字符串长度+1</code>，<code>dp[i]</code> 表示 <code>s[0:i]</code> 的解码方法数。</li><li>Base case：<code>dp[0] = 1</code>，表示我们假设空字符串有一种解码方式。</li><li>动态转移方程：从 <code>i = 1 to n</code>，当前的字符为 <code>s[i-1]</code>，前一个字符为 <code>s[i-2]</code><ul><li>如果当前的字符本身不为0，说明他自己就可以进行解码，因此 <code>s[0:i]</code> 的解码方式和 <code>s[0:i-1]</code> 的解码方式数相同。</li><li>如果当前的字符可以和前一个字符组成一个 <code>10-26</code> 的数，那么此时 <code>s[0:i]</code> 的解码方式和 <code>s[0:i-2]</code> 的解码方式数相同。</li></ul></li></ul><p><strong>代码2</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numDecodings = <span class="keyword">function</span>(<span class="params">s</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = s.<span class="property">length</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(n + <span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>) <span class="comment">// dp[i] 表示 s[0:i] 的解码方法</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span> <span class="comment">// 默认空字符串有一种编码方式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> cur = <span class="built_in">parseInt</span>(s[i-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">let</span> pre = <span class="built_in">parseInt</span>(s[i-<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">if</span> (cur &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dp[i] += dp[i-<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; pre !== <span class="number">0</span> &amp;&amp; cur + <span class="number">10</span> * pre &lt;= <span class="number">26</span>) &#123;</span><br><span class="line">            dp[i] += dp[i-<span class="number">2</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.20</strong></p><p>KMP？？？告辞</p><p><strong>题目</strong></p><blockquote><h4 id="28-实现-strStr"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/implement-strstr/">28. 实现 strStr()</a></h4><p>难度简单</p><p>实现 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://baike.baidu.com/item/strstr/811469">strStr()</a> 函数。</p><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 <code>-1</code> 。</p><p><strong>说明：</strong></p><p>当 <code>needle</code> 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</p><p>对于本题而言，当 <code>needle</code> 是空字符串时我们应当返回 0 。这与 C 语言的 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://baike.baidu.com/item/strstr/811469">strstr()</a> 以及 Java 的 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)">indexOf()</a> 定义相符。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;hello&quot;, needle = &quot;ll&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;&quot;, needle = &quot;&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><p>不搞竞赛，暴力就完事儿了。</p><p><strong>代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strStr = <span class="keyword">function</span>(<span class="params">haystack, needle</span>) &#123;</span><br><span class="line">    <span class="comment">// 滑动窗口</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> m = haystack.<span class="property">length</span></span><br><span class="line">    <span class="keyword">let</span> n = needle.<span class="property">length</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (j &lt; m &amp;&amp; i &lt;= j) &#123;</span><br><span class="line">        <span class="comment">// 根据两个指针的位置确定要对比的目标字符的位置</span></span><br><span class="line">        <span class="keyword">let</span> idx = j - i</span><br><span class="line">        <span class="keyword">if</span> (needle[idx] === haystack[j]) &#123;</span><br><span class="line">            j++</span><br><span class="line">            <span class="keyword">if</span> (needle[<span class="number">0</span>] !== haystack[i]) &#123;</span><br><span class="line">                i++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++</span><br><span class="line">            j = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j - i === n) &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.19</strong></p><p><strong>题目</strong></p><blockquote><h4 id="27-移除元素"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/remove-element/">27. 移除元素</a></h4><p>难度简单</p><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong><a target="_blank" rel="noopener external nofollow noreferrer" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a></strong> 移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并 <strong><a target="_blank" rel="noopener external nofollow noreferrer" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a> 修改输入数组</strong>。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2]</span><br><span class="line">解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3]</span><br><span class="line">解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><p>和昨天类似，也是双指针，直接上代码。</p><p><strong>代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeElement = <span class="keyword">function</span>(<span class="params">nums, val</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> idx = <span class="number">0</span></span><br><span class="line">    nums.<span class="title function_">forEach</span>(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num != val) &#123;</span><br><span class="line">            nums[idx++] = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> idx</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.18</strong></p><p>蓝桥杯考完了，10 道做出来 7 道 🤒 也不知道对不对。</p><p><strong>题目</strong></p><blockquote><h4 id="26-删除有序数组中的重复项"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></h4><p>难度简单</p><p>给你一个有序数组 <code>nums</code> ，请你** <a target="_blank" rel="noopener external nofollow noreferrer" href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><a target="_blank" rel="noopener external nofollow noreferrer" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a> 修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：2, nums = [1,2]</span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><p>经典老题了，双指针，把非重复的数字直接放到数组前部即可。</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeDuplicates</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != nums[i-<span class="number">1</span>]:</span><br><span class="line">                nums[cnt] = nums[i]</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><p><strong>4.17</strong></p><p><strong>题目</strong></p><blockquote><h4 id="220-存在重复元素-III"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/contains-duplicate-iii/">220. 存在重复元素 III</a></h4><p>难度中等</p><p>给你一个整数数组 <code>nums</code> 和两个整数 <code>k</code> 和 <code>t</code> 。请你判断是否存在两个下标 <code>i</code> 和 <code>j</code>，使得 <code>abs(nums[i] - nums[j]) &lt;= t</code> ，同时又满足 <code>abs(i - j) &lt;= k</code> 。</p><p>如果存在则返回 <code>true</code>，不存在返回 <code>false</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,1], k = 3, t = 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,0,1,1], k = 1, t = 2</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,5,9,1,5,9], k = 2, t = 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><p>因为题目中对两个数字的距离有规定，很容易想到的是双指针（滑动窗口）的思路。</p><ul><li>开辟一个长度为 <code>k + 1</code> 的滑动窗口，从数组左边滑到右边</li><li>滑动的过程中，维护一个有序集合来存储当前窗口内的数</li><li>边滑动，边判断这个有序集合中是否存在满足条件要求的差值 <code>&lt;= t</code> 的两个数</li></ul><blockquote><p>然而 Python 原生库不提供有序集合，于是放弃了这个方法</p></blockquote><p>另一种思路是参考的官方题解，利用桶排序的思想。</p><ul><li><p>设我们当前遍历的数为 <code>x</code>，题目中允许的最大差值 <code>t</code></p></li><li><p>所以我们的思想是每隔 <code>t+1</code> 的范围划分一个桶，把每个数放到对应的桶中</p></li><li><p>公式：<code>x = (t + 1) * a + b</code>，其中 <code>a</code> 就是 <code>x</code> 的桶序号</p></li><li><p>边遍历数组，边判断当前数字的前一个桶和后一个桶以及自己桶里有没有满足的数字</p></li><li><p>同时，保证桶的个数小于等于 <code>k</code></p></li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">containsNearbyAlmostDuplicate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span>, t: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># 要求两个数的差的绝对值&lt;=t，位置差&lt;=k</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 把每个数 x 存到对应的桶里</span></span><br><span class="line">        <span class="comment"># x = (t + 1) * a + b，这里的 a 表示的就是 x 应该放入的桶序号</span></span><br><span class="line">        dic = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getId</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> x // (t + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> (x + <span class="number">1</span>) // (t + <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            numId = getId(num)</span><br><span class="line">            <span class="keyword">if</span> (numId - <span class="number">1</span>) <span class="keyword">in</span> dic <span class="keyword">and</span> <span class="built_in">abs</span>(num - dic[numId - <span class="number">1</span>]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> (numId + <span class="number">1</span>) <span class="keyword">in</span> dic <span class="keyword">and</span> <span class="built_in">abs</span>(num - dic[numId + <span class="number">1</span>]) &lt;= t:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> numId <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            dic[numId] = num</span><br><span class="line">            <span class="keyword">if</span> i &gt;= k:</span><br><span class="line">                <span class="keyword">del</span> dic[getId(nums[i-k])]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><strong>4.16</strong></p><p>动规周他来了！</p><blockquote><p>因为周日要参加蓝桥杯，所以又换回 python 写代码了。</p></blockquote><p><strong>题目</strong></p><blockquote><h4 id="87-扰乱字符串"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/scramble-string/">87. 扰乱字符串</a></h4><p>难度困难</p><p>使用下面描述的算法可以扰乱字符串 <code>s</code> 得到字符串 <code>t</code> ：</p><ol><li>如果字符串的长度为 1 ，算法停止</li><li>如果字符串的长度 &gt; 1 ，执行下述步骤：<ul><li>在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 <code>s</code> ，则可以将其分成两个子字符串 <code>x</code> 和 <code>y</code> ，且满足 <code>s = x + y</code> 。</li><li><strong>随机</strong> 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，在执行这一步骤之后，<code>s</code> 可能是 <code>s = x + y</code> 或者 <code>s = y + x</code> 。</li><li>在 <code>x</code> 和 <code>y</code> 这两个子字符串上继续从步骤 1 开始递归执行此算法。</li></ul></li></ol><p>给你两个 <strong>长度相等</strong> 的字符串 <code>s1</code> 和 <code>s2</code>，判断 <code>s2</code> 是否是 <code>s1</code> 的扰乱字符串。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 = &quot;great&quot;, s2 = &quot;rgeat&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：s1 上可能发生的一种情形是：</span><br><span class="line">&quot;great&quot; --&gt; &quot;gr/eat&quot; // 在一个随机下标处分割得到两个子字符串</span><br><span class="line">&quot;gr/eat&quot; --&gt; &quot;gr/eat&quot; // 随机决定：「保持这两个子字符串的顺序不变」</span><br><span class="line">&quot;gr/eat&quot; --&gt; &quot;g/r / e/at&quot; // 在子字符串上递归执行此算法。两个子字符串分别在随机下标处进行一轮分割</span><br><span class="line">&quot;g/r / e/at&quot; --&gt; &quot;r/g / e/at&quot; // 随机决定：第一组「交换两个子字符串」，第二组「保持这两个子字符串的顺序不变」</span><br><span class="line">&quot;r/g / e/at&quot; --&gt; &quot;r/g / e/ a/t&quot; // 继续递归执行此算法，将 &quot;at&quot; 分割得到 &quot;a/t&quot;</span><br><span class="line">&quot;r/g / e/ a/t&quot; --&gt; &quot;r/g / e/ a/t&quot; // 随机决定：「保持这两个子字符串的顺序不变」</span><br><span class="line">算法终止，结果字符串和 s2 相同，都是 &quot;rgeat&quot;</span><br><span class="line">这是一种能够扰乱 s1 得到 s2 的情形，可以认为 s2 是 s1 的扰乱字符串，返回 true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 = &quot;abcde&quot;, s2 = &quot;caebd&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 = &quot;a&quot;, s2 = &quot;a&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>s1.length == s2.length</code></li><li><code>1 &lt;= s1.length &lt;= 30</code></li><li><code>s1</code> 和 <code>s2</code> 由小写英文字母组成</li></ul></blockquote><p><strong>思路</strong></p><p>动规困难题，最终还是参考了题解。</p><p>先确定动规的几个关键要素：</p><ul><li><p>DP table</p><ul><li>动规的核心思想就是 <code>大化小，小化了</code>，本题的最终目标是要知道 <code>s1</code> 能否被扰乱成 <code>s2</code>，在什么子条件下我们会知道最终答案呢？</li><li>如果我们把 <code>s1</code> 划分成 <code>s11 + s12</code>，<code>s2</code> 划分成 <code>s21 + s22</code> ，若满足以下条件之一，我们可以确定 <code>s1</code> 能被扰乱成 <code>s2</code><ul><li><code>s11</code> 可以被扰乱成 <code>s21</code>，<code>s12</code> 可以被扰乱成 <code>s22</code></li><li><code>s11</code> 可以被扰乱成 <code>s22</code>，<code>s12</code> 可以被扰乱成 <code>s21</code></li></ul></li><li>由于被扰乱的字符串必定是等长的，我们只需要确定起始位置和字符串长度来表示状态。</li><li><code>dp[i][j][l]</code> 的含义：<code>s1[i:i+l]</code> 能否扰乱获得 <code>s2[j:j+l]</code></li></ul></li><li><p>Base case</p><ul><li>每个相同的字符必定是可扰乱的</li></ul></li><li><p>状态转移方程</p><ul><li>在之前定义 DP table 的时候，其实就已经写出了状态转移的思想</li><li>枚举 <code>k in range(1, l)</code>，表示切割的位置，下面两者之一为真则 <code>dp[i][j][l]</code> 为真<ul><li><code>dp[i][j][k] and dp[i + k][j + k][l - k]</code></li><li><code>dp[i][j + l - k][k] and dp[i + k][j][l - k]</code></li></ul></li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">isScramble</span>(<span class="params">self, s1: <span class="built_in">str</span>, s2: <span class="built_in">str</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        <span class="comment"># dp[i][j][l]的含义：s1[i:i+l] 能否扰乱获得 s2[j:j+l]</span></span><br><span class="line">        n = <span class="built_in">len</span>(s1)</span><br><span class="line">        dp = [[[<span class="literal">False</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)] </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> s1[i] == s2[j]:</span><br><span class="line">                    dp[i][j][<span class="number">1</span>] = <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 枚举划分长度</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n - l + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># 枚举s1起始位置</span></span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n - l + <span class="number">1</span>):</span><br><span class="line">                    <span class="comment"># 枚举s2起始位置</span></span><br><span class="line">                    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, l):</span><br><span class="line">                        <span class="comment"># 枚举分割位置</span></span><br><span class="line">                        <span class="keyword">if</span> dp[i][j][k] <span class="keyword">and</span> dp[i + k][j + k][l - k]:</span><br><span class="line">                            <span class="comment"># 不交换 </span></span><br><span class="line">                            dp[i][j][l] = <span class="literal">True</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">                        <span class="keyword">if</span> dp[i][j + l - k][k] <span class="keyword">and</span> dp[i + k][j][l - k]:</span><br><span class="line">                            dp[i][j][l] = <span class="literal">True</span></span><br><span class="line">                            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>][n]</span><br></pre></td></tr></table></figure><p><strong>4.15</strong></p><p><strong>题目</strong></p><blockquote><h4 id="213-打家劫舍-II"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/house-robber-ii/">213. 打家劫舍 II</a></h4><p>难度中等</p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 <strong>围成一圈</strong> ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong> 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>在不触动警报装置的情况下</strong> ，能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li></ul></blockquote><p><strong>思路</strong></p><p>经典动规，和传统的打家劫舍的差别在于不能同时偷头尾两家，所以将头尾拆开考虑。</p><p>第一次遍历<code>[0, n-2]</code>，第二次遍历 <code>[1, n-1]</code>，找出最大值。</p><p>先定义 <code>dp table</code> : <code>dp[i]</code> 表示从第 <code>0</code> 家开始，打劫到第 <code>i</code> 家时，所获得的最大金额。</p><p>动态转移方程：<code>dp[i] = max(dp[i-2] + nums[i], dp[i-1])</code> ，<code>偷 i-2 和 i</code> 或者 <code>偷 i-1</code>，两者选最大值。</p><p><strong>代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rob = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n = nums.<span class="property">length</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="number">0</span>, cur = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 拆环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> tmp = <span class="title class_">Math</span>.<span class="title function_">max</span>(pre+nums[i], cur)</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = tmp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = cur</span><br><span class="line">    pre = <span class="number">0</span></span><br><span class="line">    cur = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> tmp = <span class="title class_">Math</span>.<span class="title function_">max</span>(pre+nums[i], cur)</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = tmp</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="title class_">Math</span>.<span class="title function_">max</span>(cur, res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.14</strong></p><p><strong>题目</strong></p><blockquote><h4 id="208-实现-Trie-前缀树"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h4><p>难度中等</p><p><strong><a target="_blank" rel="noopener external nofollow noreferrer" href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin">Trie</a></strong>（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。</p><p>请你实现 Trie 类：</p><ul><li><code>Trie()</code> 初始化前缀树对象。</li><li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li><li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li><li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class="line">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class="line">输出</span><br><span class="line">[null, null, true, false, true, null, true]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Trie trie = new Trie();</span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   // 返回 True</span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 False</span><br><span class="line">trie.startsWith(&quot;app&quot;); // 返回 True</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 True</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li><li><code>word</code> 和 <code>prefix</code> 仅由小写英文字母组成</li><li><code>insert</code>、<code>search</code> 和 <code>startsWith</code> 调用次数 <strong>总计</strong> 不超过 <code>3 * 104</code> 次</li></ul></blockquote><p><strong>思路</strong></p><p>数据结构题，能理解这棵树长什么样子就很容易画出来。</p><p>一般无非两种思路，一种是定义 <code>TrieNode(字典树节点)</code>，另一种是直接用哈希表（数组）。</p><p>JS 的语法就有点微妙，所以参考官方题解写的这个代码一开始有些费解。</p><p><strong>代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Trie</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">root</span> = &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Trie</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">insert</span> = <span class="keyword">function</span>(<span class="params">word</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">root</span></span><br><span class="line">    <span class="keyword">for</span> (ch <span class="keyword">of</span> word) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node[ch]) &#123;</span><br><span class="line">            node[ch] = &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node[ch]</span><br><span class="line">    &#125;</span><br><span class="line">    node.<span class="property">isEnd</span> = <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Trie</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">searchPrefix</span> = <span class="keyword">function</span>(<span class="params">preix</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="property">root</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> ch <span class="keyword">of</span> preix) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!node[ch])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        node = node[ch]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Trie</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">search</span> = <span class="keyword">function</span>(<span class="params">word</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> node = <span class="variable language_">this</span>.<span class="title function_">searchPrefix</span>(word)</span><br><span class="line">    <span class="keyword">return</span> node !== <span class="literal">undefined</span> &amp;&amp; node.<span class="property">isEnd</span> !== <span class="literal">undefined</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Trie</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">startsWith</span> = <span class="keyword">function</span>(<span class="params">prefix</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">searchPrefix</span>(prefix)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.13</strong></p><p><strong>题目</strong></p><blockquote><h4 id="783-二叉搜索树节点最小距离"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/">783. 二叉搜索树节点最小距离</a></h4><p>难度简单1</p><p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,6,1,3]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://assets.leetcode.com/uploads/2021/02/05/bst2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,0,48,null,null,12,49]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[2, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 105</code></li></ul></blockquote><p><strong>思路</strong></p><p>利用二叉搜索树的特性，<code>node.left.val &lt; node.val &lt; node.right.val</code>，通过中序遍历一棵二叉搜索树就可以得到一个递增的序列。</p><p>有了这个递增序列之后，就很容易寻找任意两个结点的最小差值了。</p><p><strong>代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minDiffInBST = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> nodes = []</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">inorder</span> = (<span class="params">node</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span></span><br><span class="line">        <span class="title function_">inorder</span>(node.<span class="property">left</span>)</span><br><span class="line">        nodes.<span class="title function_">push</span>(node.<span class="property">val</span>)</span><br><span class="line">        <span class="title function_">inorder</span>(node.<span class="property">right</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">inorder</span>(root)</span><br><span class="line">    <span class="keyword">let</span> res = <span class="title class_">Infinity</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nodes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        res = <span class="title class_">Math</span>.<span class="title function_">min</span>(res, nodes[i]-nodes[i-<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.12</strong></p><p><strong>题目</strong></p><blockquote><h4 id="179-最大数"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/largest-number/">179. 最大数</a></h4><p>难度中等</p><p>给定一组非负整数 <code>nums</code>，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。</p><p>**注意：**输出结果可能非常大，所以你需要返回一个字符串而不是整数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10,2]</span><br><span class="line">输出：&quot;210&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,30,34,5,9]</span><br><span class="line">输出：&quot;9534330&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：&quot;1&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [10]</span><br><span class="line">输出：&quot;10&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 109</code></li></ul></blockquote><p><strong>思路</strong></p><p>有脑筋急转弯内味了，参考了题解。</p><p>首先要知道肯定需要对 <code>nums</code> 排序，那么要确定 <code>x</code> 和 <code>y</code> 哪个应该放到更前面，我们可以直接通过以下两个字符串的值来确定</p><ul><li><code>x + y</code></li><li><code>y + x</code></li></ul><blockquote><p>注意，这边做的都是字符串的拼接，不是单纯加减</p></blockquote><p>如果前者大，那么 <code>x</code> 就放前面，否则放后面。</p><p>对排完序之后的数组进行拼接即可得到最终答案。</p><p>当然，也有可能出现数组全为 0 的情况，需要额外判断。</p><p><strong>代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> largestNumber = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> s1 = <span class="string">`<span class="subst">$&#123;x&#125;</span><span class="subst">$&#123;y&#125;</span>`</span></span><br><span class="line">        <span class="keyword">let</span> s2 = <span class="string">`<span class="subst">$&#123;y&#125;</span><span class="subst">$&#123;x&#125;</span>`</span></span><br><span class="line">        <span class="keyword">return</span> s2 - s1</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>] === <span class="number">0</span> ? <span class="string">&#x27;0&#x27;</span> : nums.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.11</strong></p><p><strong>题目</strong></p><blockquote><h4 id="264-丑数-II"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/ugly-number-ii/">264. 丑数 II</a></h4><p>难度中等</p><p>给你一个整数 <code>n</code> ，请你找出并返回第 <code>n</code> 个 <strong>丑数</strong> 。</p><p><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和/或 <code>5</code> 的正整数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 10</span><br><span class="line">输出：12</span><br><span class="line">解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：1</span><br><span class="line">解释：1 通常被视为丑数。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 1690</code></li></ul></blockquote><p><strong>思路</strong></p><ol><li><p>最小堆：先存后排序</p><p>一开始最小堆里存放的是 1，然后迭代 <code>n-1</code> 次，每次从最小堆中取出最小数，放回最小数的 2，3，5 倍。</p><p>迭代完之后，堆顶的数，就是第 <code>n</code> 小的数（因为前 <code>n-1</code> 个数已经被用掉了）</p></li><li><p>三指针：先排序后存</p><p>初始化一个 0 数组，长度为 <code>n</code>，第一个元素初始化为 <code>0</code></p><p>用三个指针 <code>idx1, idx2, idx3</code> 分别表示当前应该被乘 <code>2,3,5</code> 的基数的位置，一开始都初始为0</p><p>迭代 <code>n-1</code> 次，每次迭代中找到当前能添加的最小数，然后放到对应位置。</p></li></ol><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最小堆</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nthUglyNumber</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums = [<span class="number">1</span>]</span><br><span class="line">        nums_set = <span class="built_in">set</span>()</span><br><span class="line">        nums_set.add(<span class="number">1</span>)</span><br><span class="line">        factors = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">            cur = heapq.heappop(nums)</span><br><span class="line">            <span class="keyword">for</span> factor <span class="keyword">in</span> factors:</span><br><span class="line">                <span class="keyword">if</span> (nxt := cur * factor) <span class="keyword">not</span> <span class="keyword">in</span> nums_set:</span><br><span class="line">                    nums_set.add(nxt)</span><br><span class="line">                    heapq.heappush(nums, nxt)</span><br><span class="line">        <span class="keyword">return</span> heapq.heappop(nums)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三指针</span></span><br><span class="line"><span class="keyword">var</span> nthUglyNumber = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> nums = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">let</span> idx1 = <span class="number">0</span>, idx2 = <span class="number">0</span>, idx3 = <span class="number">0</span></span><br><span class="line">    nums[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> cur = <span class="title class_">Math</span>.<span class="title function_">min</span>(nums[idx1] * <span class="number">2</span>, nums[idx2] * <span class="number">3</span>, nums[idx3] * <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">if</span> (nums[idx1] * <span class="number">2</span> === cur) &#123;</span><br><span class="line">            idx1++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[idx2] * <span class="number">3</span> === cur) &#123;</span><br><span class="line">            idx2++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[idx3] * <span class="number">5</span> === cur) &#123;</span><br><span class="line">            idx3++</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i] = cur</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[n-<span class="number">1</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.10</strong></p><p>语法题</p><p><strong>题目</strong></p><blockquote><h4 id="263-丑数"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/ugly-number/">263. 丑数</a></h4><p>难度简单</p><p>给你一个整数 <code>n</code> ，请你判断 <code>n</code> 是否为 <strong>丑数</strong> 。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>丑数</strong> 就是只包含质因数 <code>2</code>、<code>3</code> 和/或 <code>5</code> 的正整数。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 6</span><br><span class="line">输出：true</span><br><span class="line">解释：6 = 2 × 3</span><br></pre></td></tr></table></figure></blockquote><p><strong>代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isUgly = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span> </span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">2</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">3</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            n /= <span class="number">5</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.8</strong></p><p>继续二分</p><p><strong>题目</strong></p><blockquote><h4 id="153-寻找旋转排序数组中的最小值"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></h4><p>难度中等</p><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p><ul><li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li><li>若旋转 <code>4</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li></ul><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p><p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2]</span><br><span class="line">输出：0</span><br><span class="line">解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [11,13,15,17]</span><br><span class="line">输出：11</span><br><span class="line">解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 5000</code></li><li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li><li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li></ul></blockquote><p><strong>思路</strong></p><p>通过二分来不断约束，找到最小数的位置。</p><p>之所以只需要判断 <code>nums[mid]</code> 和 <code>nums[right]</code> 的原因是：</p><ul><li><p>如果中间比右边大，说明最小数必定在右边数组中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">	中</span><br><span class="line">左</span><br><span class="line">    	右</span><br></pre></td></tr></table></figure></li><li><p>如果中间比右边小，那么最小数必定在左边数组中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">左</span><br><span class="line">		右</span><br><span class="line">	中</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>参考：<a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/er-fen-cha-zhao-wei-shi-yao-zuo-you-bu-dui-cheng-z/">leetcode 题解</a></p></blockquote><p><strong>代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findMin = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">const</span> mid = (left + right) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.7</strong></p><p><strong>题目</strong></p><blockquote><h4 id="81-搜索旋转排序数组-II"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/">81. 搜索旋转排序数组 II</a></h4><p>难度中等</p><p>已知存在一个按非降序排列的整数数组 <code>nums</code> ，数组中的值不必互不相同。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong> ，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,4,4,5,6,6,7]</code> 在下标 <code>5</code> 处经旋转后可能变为 <code>[4,5,6,6,7,0,1,2,4,4]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,5,6,0,0,1,2], target = 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,5,6,0,0,1,2], target = 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul></blockquote><p><strong>思路</strong></p><p>菜鸡写不出二分，只能官方题解了。</p><p>先说基础的思路：</p><ul><li>普通的二分可以直接搜索有序数组，但是题目中给的是翻转后的数组，所以只能保证数组部分有序</li><li>但是我们确实只需要部分有序就能够对二分的范围进行约束</li><li>假设当前的左指针为 <code>left</code>，右指针为 <code>right</code>，中指针 <code>mid = (left + right) // 2</code>，且此时的 <code>nums[mid] != target</code></li><li>此时 <code>nums[left:mid]</code> 和 <code>nums[mid:right]</code> 其中之一必定是有序的<ul><li>如果 <code>nums[left] &lt;= nums[mid]</code> ，就是左边有序</li><li>如果 <code>nums[mid] &lt;= nums[right]</code>，就是右边有序</li></ul></li><li>如果此时左边有序<ul><li>若 <code>nums[left] &lt;= target &lt; nums[mid]</code>，则区间向左约束 <code>right = mid - 1</code></li><li>否则区间向右约束 <code>left = mid + 1</code></li></ul></li><li>如果此时右边有序<ul><li>若 <code>nums[mid] &lt; target &lt;= nums[right]</code>，则区间向右约束</li><li>否则向左约束</li></ul></li></ul><p>在这个基础上，由于题目中给出的数组会重现重复数组，可能出现 <code>[1, 0, 1, 1, 1]</code>，无法正确约束区间</p><p>参考官方题解给出的思路是，在 <code>nums[left] == nums[mid] == nums[right]</code> 时，直接将左指针右移一格，右指针左移一格，向中心约束。</p><p><strong>代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="keyword">function</span>(<span class="params">nums, target</span>) &#123;</span><br><span class="line">    <span class="comment">// [mid-1, ...., right, left, ..., mid]</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = nums.<span class="property">length</span> - <span class="number">1</span>, mid = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>((right + left) / <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">const</span> cur = nums[mid]</span><br><span class="line">        <span class="keyword">if</span> (cur == target) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (nums[left] == cur &amp;&amp; cur == nums[right]) &#123;</span><br><span class="line">            left++</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] &lt;= cur) &#123;</span><br><span class="line">            <span class="comment">// 前半段有序</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; cur) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 后半段有序</span></span><br><span class="line">            <span class="keyword">if</span> (cur &lt; target &amp;&amp; target &lt;= nums[right]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.6</strong></p><p>收到 offer 啦 🤗</p><p><strong>题目</strong></p><blockquote><h4 id="80-删除有序数组中的重复项-II"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/">80. 删除有序数组中的重复项 II</a></h4><p>难度中等</p><p>给你一个有序数组 <code>nums</code> ，请你** <a target="_blank" rel="noopener external nofollow noreferrer" href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a>** 删除重复出现的元素，使每个元素 <strong>最多出现两次</strong> ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><a target="_blank" rel="noopener external nofollow noreferrer" href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地</a> 修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><p><strong>说明：</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢？</p><p>请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="line">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="line">for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    print(nums[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1,2,2,3]</span><br><span class="line">输出：5, nums = [1,1,2,2,3]</span><br><span class="line">解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,1,2,3,3]</span><br><span class="line">输出：7, nums = [0,0,1,1,2,3,3]</span><br><span class="line">解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按升序排列</li></ul></blockquote><p><strong>思路</strong></p><p>快慢指针，这个思路真的🐂。</p><p>用慢指针指向合法的数组尾部，用快指针指向已经遍历过的数组尾部。</p><p><strong>代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> slow = <span class="number">2</span>, fast = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> (fast &lt; nums.<span class="property">length</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != nums[slow-<span class="number">2</span>]) &#123;</span><br><span class="line">            nums[slow++] = nums[fast]</span><br><span class="line">        &#125;</span><br><span class="line">        fast++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.5</strong></p><p>简单题 😴</p><p><strong>题目</strong></p><blockquote><h4 id="88-合并两个有序数组"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/merge-sorted-array/">88. 合并两个有序数组</a></h4><p>难度简单</p><p>给你两个有序整数数组 <code>nums1</code> 和 <code>nums2</code>，请你将 <code>nums2</code> 合并到 <code>nums1</code> 中*，*使 <code>nums1</code> 成为一个有序数组。</p><p>初始化 <code>nums1</code> 和 <code>nums2</code> 的元素数量分别为 <code>m</code> 和 <code>n</code> 。你可以假设 <code>nums1</code> 的空间大小等于 <code>m + n</code>，这样它就有足够的空间保存来自 <code>nums2</code> 的元素。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3</span><br><span class="line">输出：[1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1], m = 1, nums2 = [], n = 0</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums1.length == m + n</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m, n &lt;= 200</code></li><li><code>1 &lt;= m + n &lt;= 200</code></li><li><code>-109 &lt;= nums1[i], nums2[i] &lt;= 109</code></li></ul></blockquote><p><strong>思路</strong></p><p>从 <code>nums1</code> 的尾部开始放数字，反向遍历数组，无需额外开辟数组。</p><p><strong>代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> merge = <span class="keyword">function</span>(<span class="params">nums1, m, nums2, n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> cur = m + n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1[i] &gt;= nums2[j]) &#123;</span><br><span class="line">            nums1[cur--] = nums1[i--]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[cur--] = nums2[j--]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        nums1[cur--] = nums1[i--]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        nums1[cur--] = nums2[j--]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.4</strong></p><p><strong>题目</strong></p><blockquote><h4 id="781-森林中的兔子"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/rabbits-in-forest/">781. 森林中的兔子</a></h4><p>难度中等</p><p>森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。我们将这些回答放在 <code>answers</code> 数组里。</p><p>返回森林中兔子的最少数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">输入: answers = [1, 1, 2]</span><br><span class="line">输出: 5</span><br><span class="line">解释:</span><br><span class="line">两只回答了 &quot;1&quot; 的兔子可能有相同的颜色，设为红色。</span><br><span class="line">之后回答了 &quot;2&quot; 的兔子不会是红色，否则他们的回答会相互矛盾。</span><br><span class="line">设回答了 &quot;2&quot; 的兔子为蓝色。</span><br><span class="line">此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。</span><br><span class="line">因此森林中兔子的最少数量是 5: 3 只回答的和 2 只没有回答的。</span><br><span class="line"></span><br><span class="line">输入: answers = [10, 10, 10]</span><br><span class="line">输出: 11</span><br><span class="line"></span><br><span class="line">输入: answers = []</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ol><li><code>answers</code> 的长度最大为<code>1000</code>。</li><li><code>answers[i]</code> 是在 <code>[0, 999]</code> 范围内的整数。</li></ol></blockquote><p><strong>思路</strong></p><p>哈希表 + 贪心，先按兔子回答的数字对兔子进行分组，再尽可能地把回答相同的数字分成一个颜色。</p><p><strong>代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numRabbits = <span class="keyword">function</span>(<span class="params">answers</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> m = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    answers.<span class="title function_">forEach</span>(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> key = val + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (!m.<span class="title function_">has</span>(key)) &#123;</span><br><span class="line">            m.<span class="title function_">set</span>(key, <span class="number">1</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            m.<span class="title function_">set</span>(key, m.<span class="title function_">get</span>(key) + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> [key, val] <span class="keyword">of</span> m) &#123;</span><br><span class="line">        <span class="keyword">const</span> k = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(val / key)</span><br><span class="line">        res += k * key</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.3</strong></p><p>字节不出所料，秒挂。</p><p>腾讯似乎有点希望？</p><p><strong>题目</strong></p><blockquote><h4 id="1143-最长公共子序列"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h4><p>难度中等472</p><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li><li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li></ul></blockquote><p><strong>思路</strong></p><p>动态规划：由于有两个变量，考虑使用二维的动态规划。</p><p>开辟一个二维数组 <code>dp</code> 记录 <code>dp[i][j]</code> 代表 <code>text1[0:i]</code> 和 <code>text[0:j]</code> 的最大公共子序列长度。</p><p>Base case：第一行和第一列全部初始化为 0</p><p>状态转移方程：如果 <code>text1[i] == text2[j]</code>，则 <code>dp[i][j] = dp[i-1][j-1] + 1</code>，否则 <code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code></p><p><strong>代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> longestCommonSubsequence = <span class="keyword">function</span>(<span class="params">text1, text2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> m = text1.<span class="property">length</span>, n = text2.<span class="property">length</span></span><br><span class="line">    <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="title class_">Array</span>(m+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n+<span class="number">1</span>).<span class="title function_">fill</span>(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">const</span> c = text1[i-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c === text2[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="title class_">Math</span>.<span class="title function_">max</span>(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.2</strong></p><p><strong>题目</strong></p><blockquote><h4 id="面试题-17-21-直方图的水量"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/volume-of-histogram-lcci/">面试题 17.21. 直方图的水量</a></h4><p>难度困难</p><p>给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为 1。</p><p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" alt="img"></p><p>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的直方图，在这种情况下，可以接 6 个单位的水（蓝色部分表示水）。 <strong>感谢 Marcos</strong> 贡献此图。</p><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><p>每个位置能储存的水的量，由它左侧的最高柱和右侧最高柱以及它本身的高度的决定。</p><p>例如，左侧最高 2，右侧最高 3，本身高度为 1，那么它能存的水就是 min(2, 3) - 1 = 1</p><p>有两种方式来统计每根柱子的左右最高情况</p><ul><li>开辟一个数组进行统计，时间复杂度 <code>O(N)</code>，空间复杂度 <code>O(N)</code></li><li>双指针，一边遍历统计，时间复杂度 <code>O(N)</code>，空间复杂度 <code>O(1)</code></li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># 每个位置能接到的水收到左侧最大高度和右侧最大高度的限制</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(height) &lt; <span class="number">3</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        height = [<span class="number">0</span>] + height + [<span class="number">0</span>]</span><br><span class="line">        left = []</span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> height:</span><br><span class="line">            cur = <span class="built_in">max</span>(cur, i)</span><br><span class="line">            left.append(cur)</span><br><span class="line">        n = <span class="built_in">len</span>(height)</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        cur = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> height[i] &lt; <span class="built_in">min</span>(cur, left[i]):</span><br><span class="line">                res += (<span class="built_in">min</span>(cur, left[i]) - height[i])</span><br><span class="line">            cur = <span class="built_in">max</span>(cur, height[i])</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">        </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trap = <span class="keyword">function</span>(<span class="params">height</span>) &#123;</span><br><span class="line">    <span class="comment">// 双指针</span></span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>, right = height.<span class="property">length</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        leftMax = <span class="title class_">Math</span>.<span class="title function_">max</span>(leftMax, height[left])</span><br><span class="line">        rightMax = <span class="title class_">Math</span>.<span class="title function_">max</span>(rightMax, height[right])</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">            res += leftMax - height[left]</span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res += rightMax - height[right]</span><br><span class="line">            right -= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>4.1</strong></p><p>🐟人节快乐嗷</p><p><strong>题目</strong></p><blockquote><h4 id="1006-笨阶乘"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/clumsy-factorial/">1006. 笨阶乘</a></h4><p>难度中等50</p><p>通常，正整数 <code>n</code> 的阶乘是所有小于或等于 <code>n</code> 的正整数的乘积。例如，<code>factorial(10) = 10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1</code>。</p><p>相反，我们设计了一个笨阶乘 <code>clumsy</code>：在整数的递减序列中，我们以一个固定顺序的操作符序列来依次替换原有的乘法操作符：乘法(*)，除法(/)，加法(+)和减法(-)。</p><p>例如，<code>clumsy(10) = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1</code>。然而，这些运算仍然使用通常的算术运算顺序：我们在任何加、减步骤之前执行所有的乘法和除法步骤，并且按从左到右处理乘法和除法步骤。</p><p>另外，我们使用的除法是地板除法（<em>floor division</em>），所以 <code>10 * 9 / 8</code> 等于 <code>11</code>。这保证结果是一个整数。</p><p>实现上面定义的笨函数：给定一个整数 <code>N</code>，它返回 <code>N</code> 的笨阶乘。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：4</span><br><span class="line">输出：7</span><br><span class="line">解释：7 = 4 * 3 / 2 + 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：10</span><br><span class="line">输出：12</span><br><span class="line">解释：12 = 10 * 9 / 8 + 7 - 6 * 5 / 4 + 3 - 2 * 1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= N &lt;= 10000</code></li><li><code>-2^31 &lt;= answer &lt;= 2^31 - 1</code> （答案保证符合 32 位整数。）</li></ol></blockquote><p><strong>代码</strong></p><p>标准栈解法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">N</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> clumsy = <span class="keyword">function</span>(<span class="params">N</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> stk = [N--]</span><br><span class="line">    <span class="keyword">let</span> idx = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(N)&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx % <span class="number">4</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            stk.<span class="title function_">push</span>(stk.<span class="title function_">pop</span>() * N)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idx % <span class="number">4</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> cur = stk.<span class="title function_">pop</span>();</span><br><span class="line">            stk.<span class="title function_">push</span>(cur &gt; <span class="number">0</span> ? <span class="title class_">Math</span>.<span class="title function_">floor</span>(cur / N) : <span class="title class_">Math</span>.<span class="title function_">ceil</span>(cur / N));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (idx % <span class="number">4</span> == <span class="number">2</span>) &#123;</span><br><span class="line">            stk.<span class="title function_">push</span>(N)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stk.<span class="title function_">push</span>(-N)</span><br><span class="line">        &#125;</span><br><span class="line">        N--</span><br><span class="line">        idx++</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> res = stk.<span class="title function_">reduce</span>(<span class="function">(<span class="params">pre, cur</span>)=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pre + cur</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>if else</code> 大法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">clumsy</span>(<span class="params">self, N: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> N == <span class="number">3</span>: <span class="keyword">return</span> <span class="number">6</span></span><br><span class="line">        <span class="keyword">elif</span> N == <span class="number">2</span>: <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">        <span class="keyword">elif</span> N == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> N &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> N &gt;= <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">                    res += N*(N-<span class="number">1</span>)//(N-<span class="number">2</span>)</span><br><span class="line">                    flag = <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res -= N*(N-<span class="number">1</span>)//(N-<span class="number">2</span>)</span><br><span class="line">                res += (N-<span class="number">3</span>)</span><br><span class="line">                N -= <span class="number">4</span></span><br><span class="line">            <span class="keyword">elif</span> N == <span class="number">3</span>:</span><br><span class="line">                res -= <span class="number">6</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> N == <span class="number">2</span>:</span><br><span class="line">                res -= <span class="number">2</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> N == <span class="number">1</span>:</span><br><span class="line">                res -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://blog.ethanloo.cn">EthanLoo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://blog.ethanloo.cn/post/2021-04-01-Algorithm/2021%E5%B9%B44%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/">https://blog.ethanloo.cn/post/2021-04-01-Algorithm/2021年4月刷题日志/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.ethanloo.cn" target="_blank">Ethanloo's</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/leetcode/">leetcode</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/2021-04-07-Weber/JS%E6%89%8B%E5%86%99%E9%A2%98/" title="JavaScript 手写题"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/20210420134832.jpg" onerror='onerror=null,src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JavaScript 手写题</div></div></a></div><div class="next-post pull-right"><a href="/post/2021-03-26-Weber/JS%20%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/" title="JS 基础面试题"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/20210327190958.jpg" onerror='onerror=null,src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JS 基础面试题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/2021-06-02-Algorithm/2021%E5%B9%B46%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/" title="2021年6月刷题日志"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/20210602143312.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-02</div><div class="title">2021年6月刷题日志</div></div></a></div><div><a href="/post/2021-05-05-Algorithm/2021%E5%B9%B45%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/" title="2021年5月刷题日志"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/image-20201204232217281.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-05</div><div class="title">2021年5月刷题日志</div></div></a></div><div><a href="/post/2021-03-01-Algorithm/2021%E5%B9%B43%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/" title="2021年3月刷题日志"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="/img/cover/l.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-01</div><div class="title">2021年3月刷题日志</div></div></a></div><div><a href="/post/2021-02-01-Algorithm/2021%E5%B9%B42%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/" title="2021年2月刷题日志"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="/img/cover/l.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-01</div><div class="title">2021年2月刷题日志</div></div></a></div><div><a href="/post/2021-01-01-Algorithm/2021%E5%B9%B41%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/" title="2021年1月刷题日志"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="/img/cover/l.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-01-01</div><div class="title">2021年1月刷题日志</div></div></a></div><div><a href="/post/2020-12-01-Algorithm/2020%E5%B9%B412%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/" title="2020年12月刷题日志"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="/img/cover/l.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-01</div><div class="title">2020年12月刷题日志</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/avatar.png" onerror='this.onerror=null,this.src="https://cdn.ethanloo.cn/img/20201202163407.gif"' alt="avatar"></div><div class="author-info__name">EthanLoo</div><div class="author-info__description">不过是用输出倒逼输入罢了👶</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/EthanLuu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/EthanLuu" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:ethanlooo@outlook.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=952792901&amp;site=qq&amp;menu=yes" rel="external nofollow noreferrer" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><span>公告</span></div><div class="announcement_content">好好吃饭🍣 好好睡觉💤<br>敲敲代码💻 谈谈恋爱💑</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#137-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-II"><span class="toc-text">137. 只出现一次的数字 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#403-%E9%9D%92%E8%9B%99%E8%BF%87%E6%B2%B3"><span class="toc-text">403. 青蛙过河</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#633-%E5%B9%B3%E6%96%B9%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">633. 平方数之和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#938-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E8%8C%83%E5%9B%B4%E5%92%8C"><span class="toc-text">938. 二叉搜索树的范围和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1011-%E5%9C%A8-D-%E5%A4%A9%E5%86%85%E9%80%81%E8%BE%BE%E5%8C%85%E8%A3%B9%E7%9A%84%E8%83%BD%E5%8A%9B"><span class="toc-text">1011. 在 D 天内送达包裹的能力</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#897-%E9%80%92%E5%A2%9E%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">897. 递增顺序搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%85%A3"><span class="toc-text">377. 组合总和 Ⅳ</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#368-%E6%9C%80%E5%A4%A7%E6%95%B4%E9%99%A4%E5%AD%90%E9%9B%86"><span class="toc-text">368. 最大整除子集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#363-%E7%9F%A9%E5%BD%A2%E5%8C%BA%E5%9F%9F%E4%B8%8D%E8%B6%85%E8%BF%87-K-%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%80%BC%E5%92%8C"><span class="toc-text">363. 矩形区域不超过 K 的最大数值和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#91-%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95"><span class="toc-text">91. 解码方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#28-%E5%AE%9E%E7%8E%B0-strStr"><span class="toc-text">28. 实现 strStr()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-text">27. 移除元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="toc-text">26. 删除有序数组中的重复项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#220-%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-III"><span class="toc-text">220. 存在重复元素 III</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#87-%E6%89%B0%E4%B9%B1%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">87. 扰乱字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#213-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-II"><span class="toc-text">213. 打家劫舍 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#208-%E5%AE%9E%E7%8E%B0-Trie-%E5%89%8D%E7%BC%80%E6%A0%91"><span class="toc-text">208. 实现 Trie (前缀树)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#783-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%8A%82%E7%82%B9%E6%9C%80%E5%B0%8F%E8%B7%9D%E7%A6%BB"><span class="toc-text">783. 二叉搜索树节点最小距离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#179-%E6%9C%80%E5%A4%A7%E6%95%B0"><span class="toc-text">179. 最大数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#264-%E4%B8%91%E6%95%B0-II"><span class="toc-text">264. 丑数 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#263-%E4%B8%91%E6%95%B0"><span class="toc-text">263. 丑数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-text">153. 寻找旋转排序数组中的最小值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#81-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-II"><span class="toc-text">81. 搜索旋转排序数组 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#80-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-II"><span class="toc-text">80. 删除有序数组中的重复项 II</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-text">88. 合并两个有序数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#781-%E6%A3%AE%E6%9E%97%E4%B8%AD%E7%9A%84%E5%85%94%E5%AD%90"><span class="toc-text">781. 森林中的兔子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1143-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">1143. 最长公共子序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98-17-21-%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E6%B0%B4%E9%87%8F"><span class="toc-text">面试题 17.21. 直方图的水量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1006-%E7%AC%A8%E9%98%B6%E4%B9%98"><span class="toc-text">1006. 笨阶乘</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/2023-11-26-Weber/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%88%E4%BA%8C%EF%BC%89/" title="前端开发的十万个为什么（二）"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/Exploring-Different-Types-of-Landforms-_1_.webp" onerror='this.onerror=null,this.src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="前端开发的十万个为什么（二）"></a><div class="content"><a class="title" href="/post/2023-11-26-Weber/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%88%E4%BA%8C%EF%BC%89/" title="前端开发的十万个为什么（二）">前端开发的十万个为什么（二）</a><time datetime="2023-11-26T21:05:10.000Z" title="发表于 2023-11-26 21:05:10">2023-11-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2023-11-22-Vue/%E9%9D%A2%E5%90%91%20Vue%20%E4%B8%AD%20VNode%20%E7%9A%84%E4%B8%80%E6%AC%A1%20Deep%20Dive/" title="面向 Vue 中 VNode 的一次 Deep Dive"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/202311221935387.png" onerror='this.onerror=null,this.src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="面向 Vue 中 VNode 的一次 Deep Dive"></a><div class="content"><a class="title" href="/post/2023-11-22-Vue/%E9%9D%A2%E5%90%91%20Vue%20%E4%B8%AD%20VNode%20%E7%9A%84%E4%B8%80%E6%AC%A1%20Deep%20Dive/" title="面向 Vue 中 VNode 的一次 Deep Dive">面向 Vue 中 VNode 的一次 Deep Dive</a><time datetime="2023-11-22T15:41:10.000Z" title="发表于 2023-11-22 15:41:10">2023-11-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2023-07-24-Weber/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%88%E4%B8%80%EF%BC%89/" title="前端开发的十万个为什么（一）"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/Exploring-Different-Types-of-Landforms-_1_.webp" onerror='this.onerror=null,this.src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="前端开发的十万个为什么（一）"></a><div class="content"><a class="title" href="/post/2023-07-24-Weber/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%88%E4%B8%80%EF%BC%89/" title="前端开发的十万个为什么（一）">前端开发的十万个为什么（一）</a><time datetime="2023-07-24T15:41:10.000Z" title="发表于 2023-07-24 15:41:10">2023-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2022-11-24-Paper/YuZu%20-%20Neural-Enhanced%20Volumetric%20Video%20Streaming/" title="NSDI22 - YuZu：Neural-Enhanced Volumetric Video Streaming"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/202302041759590.webp" onerror='this.onerror=null,this.src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="NSDI22 - YuZu：Neural-Enhanced Volumetric Video Streaming"></a><div class="content"><a class="title" href="/post/2022-11-24-Paper/YuZu%20-%20Neural-Enhanced%20Volumetric%20Video%20Streaming/" title="NSDI22 - YuZu：Neural-Enhanced Volumetric Video Streaming">NSDI22 - YuZu：Neural-Enhanced Volumetric Video Streaming</a><time datetime="2022-11-24T11:33:08.000Z" title="发表于 2022-11-24 11:33:08">2022-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2022-11-10-Paper/Collaborative%20Service%20Placement%20for%20Edge%20Computing%20in%20Dense%20Small%20Cell%20Networks/" title="TMC21 - Collaborative Service Placement for Edge Computing in Dense Small Cell Networks"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/202302041758847.webp" onerror='this.onerror=null,this.src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="TMC21 - Collaborative Service Placement for Edge Computing in Dense Small Cell Networks"></a><div class="content"><a class="title" href="/post/2022-11-10-Paper/Collaborative%20Service%20Placement%20for%20Edge%20Computing%20in%20Dense%20Small%20Cell%20Networks/" title="TMC21 - Collaborative Service Placement for Edge Computing in Dense Small Cell Networks">TMC21 - Collaborative Service Placement for Edge Computing in Dense Small Cell Networks</a><time datetime="2022-11-10T11:47:01.000Z" title="发表于 2022-11-10 11:47:01">2022-11-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By EthanLoo</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">苏ICP备2020057383号</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://ethanloo-blog-waline.vercel.app',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  if (typeof Waline === 'object') initWaline()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css').then(() => {
      getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js').then(initWaline)
    })
  }
}

if ('Waline' === 'Waline' || !true) {
  if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><div async class="app-refresh" id="app-refresh"><div class="app-refresh-wrap"><label>✨ 网站更新啦 👉</label> <a href="javascript:void(0)" rel="external nofollow noreferrer" onclick="location.reload()">点击刷新</a></div></div><script>function showNotification(){if(GLOBAL_CONFIG.Snackbar){var t="light"===document.documentElement.getAttribute("data-theme")?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e=GLOBAL_CONFIG.Snackbar.position;Snackbar.show({text:"已更新最新版本",backgroundColor:t,duration:5e5,pos:e,actionText:"點擊刷新",actionTextColor:"#fff",onActionClick:function(t){location.reload()}})}else{var o=`top: 0; background: ${"light"===document.documentElement.getAttribute("data-theme")?"#49b1f5":"#1f1f1f"};`;document.getElementById("app-refresh").style.cssText=o}}"serviceWorker"in navigator&&(navigator.serviceWorker.controller&&navigator.serviceWorker.addEventListener("controllerchange",function(){showNotification()}),window.addEventListener("load",function(){navigator.serviceWorker.register("/sw.js")}));</script><script async src="./js/background.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>