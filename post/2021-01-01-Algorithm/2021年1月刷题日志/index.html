<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>2021年1月刷题日志 | Ethanloo's</title><meta name="author" content="EthanLoo"><meta name="copyright" content="EthanLoo"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="文笔很烂，逻辑一般，单纯用来记录Leetcode刷题过程"><link rel="shortcut icon" href="https://cdn.ethanloo.cn/img/favicon.png"><link rel="canonical" href="https://blog.ethanloo.cn/post/2021-01-01-Algorithm/2021%E5%B9%B41%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.clarity.ms"><link rel="manifest" href="/manifest.json"><link rel="apple-touch-icon" sizes="180x180" href="https://cdn.ethanloo.cn/img/favicon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://cdn.ethanloo.cn/img/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="https://cdn.ethanloo.cn/img/favicon.png"><link rel="mask-icon" href="https://cdn.ethanloo.cn/img/favicon.png" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><script>!function(t,e,n,c,r,a,s){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(a=e.createElement(c)).async=1,a.src="https://www.clarity.ms/tag/bjrte2qfwy",(s=e.getElementsByTagName(c)[0]).parentNode.insertBefore(a,s)}(window,document,"clarity","script")</script><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Noto+Sans+SC&amp;family=Noto+Serif+SC&amp;family=Roboto+Mono&amp;display=swap" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: EthanLoo","link":"链接: ","source":"来源: Ethanloo's","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"2021年1月刷题日志",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-11-26 23:46:29"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="./css/optimization.css"><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/avatar.png" onerror='onerror=null,src="https://cdn.ethanloo.cn/img/20201202163407.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr class="custom-hr"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fab fa-readme"></i> <span>文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.ethanloo.cn/lab"><i class="fa-fw fas fa-meteor"></i> <span>实验室</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Ethanloo's"><span class="site-name">Ethanloo's</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fab fa-readme"></i> <span>文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://www.ethanloo.cn/lab"><i class="fa-fw fas fa-meteor"></i> <span>实验室</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">2021年1月刷题日志</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2021-01-01T09:33:01.000Z" title="发表于 2021-01-01 09:33:01">2021-01-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/">刷题日志</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>50分钟</span></span></div></div></div><article class="post-content" id="article-container"><p><strong>2.4</strong></p><p>美赛前的最后一天寒假了</p><p><strong>题目</strong></p><blockquote><h4 id="643-子数组最大平均数-I"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/maximum-average-subarray-i/">643. 子数组最大平均数 I</a></h4><p>难度简单</p><p>给定 <code>n</code> 个整数，找出平均数最大且长度为 <code>k</code> 的连续子数组，并输出该最大平均数。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,12,-5,-6,50,3], k = 4</span><br><span class="line">输出：12.75</span><br><span class="line">解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;= <code>k</code> &lt;= <code>n</code> &lt;= 30,000。</li><li>所给数据范围 [-10,000，10,000]。</li></ul></blockquote><p><strong>思路</strong></p><p>没啥花里胡哨的，用滑动窗口模拟就行</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findMaxAverage</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">float</span>: </span><br><span class="line">        cur_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>):</span><br><span class="line">            cur_sum += nums[i]</span><br><span class="line">        cur_max = -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k-<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">            cur_sum += nums[i]</span><br><span class="line">            cur_max = <span class="built_in">max</span>(cur_max, cur_sum)</span><br><span class="line">            cur_sum -= nums[i-k+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> cur_max/k</span><br></pre></td></tr></table></figure><p><strong>2.3</strong></p><p><strong>题目</strong></p><blockquote><h4 id="480-滑动窗口中位数"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/sliding-window-median/">480. 滑动窗口中位数</a></h4><p>难度困难</p><p>中位数是有序序列最中间的那个数。如果序列的大小是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。</p><p>例如：</p><ul><li><code>[2,3,4]</code>，中位数是 <code>3</code></li><li><code>[2,3]</code>，中位数是 <code>(2 + 3) / 2 = 2.5</code></li></ul><p>给你一个数组 <em>nums</em>，有一个大小为 <em>k</em> 的窗口从最左端滑动到最右端。窗口中有 <em>k</em> 个数，每次窗口向右移动 <em>1</em> 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。</p><p><strong>示例：</strong></p><p>给出 <em>nums</em> = <code>[1,3,-1,-3,5,3,6,7]</code>，以及 <em>k</em> = 3。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">窗口位置                      中位数</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       1</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7      -1</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7      -1</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       3</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       5</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      6</span><br></pre></td></tr></table></figure><p>因此，返回该滑动窗口的中位数数组 <code>[1,-1,-1,3,5,6]</code>。</p><p><strong>提示：</strong></p><ul><li>你可以假设 <code>k</code> 始终有效，即：<code>k</code> 始终小于输入的非空数组的元素个数。</li><li>与真实值误差在 <code>10 ^ -5</code> 以内的答案将被视作正确答案。</li></ul></blockquote><p><strong>思路</strong></p><p>暴力法</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">medianSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-k+<span class="number">1</span>):</span><br><span class="line">            tmp = nums[i:i+k]</span><br><span class="line">            tmp.sort()</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(tmp)%<span class="number">2</span> == <span class="number">1</span>:</span><br><span class="line">                res.append(tmp[k//<span class="number">2</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append((tmp[k//<span class="number">2</span>]+tmp[k//<span class="number">2</span>-<span class="number">1</span>])/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>2.2</strong></p><p><strong>题目</strong></p><blockquote><h4 id="424-替换后的最长重复字符"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/">424. 替换后的最长重复字符</a></h4><p>难度中等</p><p>给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 <em>k</em> 次。在执行上述操作后，找到包含重复字母的最长子串的长度。</p><p>**注意：**字符串长度 和 <em>k</em> 不会超过 104。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ABAB&quot;, k = 2</span><br><span class="line">输出：4</span><br><span class="line">解释：用两个&#x27;A&#x27;替换为两个&#x27;B&#x27;,反之亦然。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;AABABBA&quot;, k = 1</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">将中间的一个&#x27;A&#x27;替换为&#x27;B&#x27;,字符串变为 &quot;AABBBBA&quot;。</span><br><span class="line">子串 &quot;BBBB&quot; 有最长重复字母, 答案为 4。</span><br></pre></td></tr></table></figure></blockquote><p><strong>思路</strong></p><p>双指针，滑动窗口，遍历字符串，用一个数组来维护窗口中字母的出现次数</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">characterReplacement</span>(<span class="params">self, s: <span class="built_in">str</span>, k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cnts =  [<span class="number">0</span>]*<span class="number">26</span></span><br><span class="line">        left = right = maxn = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(s)</span><br><span class="line">        <span class="keyword">while</span> right &lt; n:</span><br><span class="line">            cnts[<span class="built_in">ord</span>(s[right]) - <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)] += <span class="number">1</span></span><br><span class="line">            maxn = <span class="built_in">max</span>(maxn, cnts[<span class="built_in">ord</span>(s[right]) - <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)])</span><br><span class="line">            <span class="keyword">if</span> right - left + <span class="number">1</span> - maxn &gt; k:</span><br><span class="line">                cnts[<span class="built_in">ord</span>(s[left]) - <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)] -= <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> right - left</span><br></pre></td></tr></table></figure><p><strong>2.1</strong></p><p>今日简单题，刷完吃寿喜烧去咯</p><p><strong>题目</strong></p><blockquote><h4 id="888-公平的糖果棒交换"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/fair-candy-swap/">888. 公平的糖果棒交换</a></h4><p>难度简单99</p><p>爱丽丝和鲍勃有不同大小的糖果棒：<code>A[i]</code> 是爱丽丝拥有的第 <code>i</code> 根糖果棒的大小，<code>B[j]</code> 是鲍勃拥有的第 <code>j</code> 根糖果棒的大小。</p><p>因为他们是朋友，所以他们想交换一根糖果棒，这样交换后，他们都有相同的糖果总量。<em>（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）</em></p><p>返回一个整数数组 <code>ans</code>，其中 <code>ans[0]</code> 是爱丽丝必须交换的糖果棒的大小，<code>ans[1]</code> 是 Bob 必须交换的糖果棒的大小。</p><p>如果有多个答案，你可以返回其中任何一个。保证答案存在。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [1,1], B = [2,2]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [1,2], B = [2,3]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [2], B = [1,3]</span><br><span class="line">输出：[2,3]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：A = [1,2,5], B = [2,4]</span><br><span class="line">输出：[5,4]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= A.length &lt;= 10000</code></li><li><code>1 &lt;= B.length &lt;= 10000</code></li><li><code>1 &lt;= A[i] &lt;= 100000</code></li><li><code>1 &lt;= B[i] &lt;= 100000</code></li><li>保证爱丽丝与鲍勃的糖果总量不同。</li><li>答案肯定存在。</li></ul></blockquote><p><strong>思路</strong></p><p>traversing and binary search.</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fairCandySwap</span>(<span class="params">self, A: <span class="type">List</span>[<span class="built_in">int</span>], B: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        sum_a = <span class="built_in">sum</span>(A)</span><br><span class="line">        sum_b = <span class="built_in">sum</span>(B)</span><br><span class="line">        diff = sum_a-sum_b</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">            j = <span class="built_in">int</span>(i-diff/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> j <span class="keyword">in</span> B:</span><br><span class="line">                <span class="keyword">return</span> [i,j]</span><br></pre></td></tr></table></figure><p><strong>1.31</strong></p><p>可恶啊，昨天看到是困难题，甚至CV都给忘了</p><p>今天又是并查集</p><p><strong>题目</strong></p><blockquote><h4 id="839-相似字符串组"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/similar-string-groups/">839. 相似字符串组</a></h4><p>难度困难</p><p>如果交换字符串 <code>X</code> 中的两个不同位置的字母，使得它和字符串 <code>Y</code> 相等，那么称 <code>X</code> 和 <code>Y</code> 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。</p><p>例如，<code>&quot;tars&quot;</code> 和 <code>&quot;rats&quot;</code> 是相似的 (交换 <code>0</code> 与 <code>2</code> 的位置)； <code>&quot;rats&quot;</code> 和 <code>&quot;arts&quot;</code> 也是相似的，但是 <code>&quot;star&quot;</code> 不与 <code>&quot;tars&quot;</code>，<code>&quot;rats&quot;</code>，或 <code>&quot;arts&quot;</code> 相似。</p><p>总之，它们通过相似性形成了两个关联组：<code>&#123;&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;&#125;</code> 和 <code>&#123;&quot;star&quot;&#125;</code>。注意，<code>&quot;tars&quot;</code> 和 <code>&quot;arts&quot;</code> 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。</p><p>给你一个字符串列表 <code>strs</code>。列表中的每个字符串都是 <code>strs</code> 中其它所有字符串的一个字母异位词。请问 <code>strs</code> 中有多少个相似字符串组？</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [&quot;tars&quot;,&quot;rats&quot;,&quot;arts&quot;,&quot;star&quot;]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [&quot;omv&quot;,&quot;ovm&quot;]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 100</code></li><li><code>1 &lt;= strs[i].length &lt;= 1000</code></li><li><code>sum(strs[i].length) &lt;= 2 * 104</code></li><li><code>strs[i]</code> 只包含小写字母。</li><li><code>strs</code> 中的所有单词都具有相同的长度，且是彼此的字母异位词。</li></ul></blockquote><p><strong>思路</strong></p><p>题目难度虽然是困难，但是其实具体的实现还是很简单的。</p><p>参考了官方题解之后豁然开朗，这道题目其实还是一个传统的并查集题目。</p><p>首先看到了我们的最终目标是求相似字符串组，其实就是抽象成并查集里的连通情况。</p><p>两个字符串相似，就说明是两个字符串相连（union）。</p><p>所以我们只需要维护一个并查集，遍历不同字符串组合确认是否连通，最后输出连通分量的个数即可。</p><p>维护并查集很简单，就是纯粹的最简单的模板。</p><p>确认字符串的相似性也不难，实现方法应该有很多，我这边就比较随意地写了一个。</p><ul><li>我们手上有两个字符串 <code>str1</code>, <code>str2</code></li><li>题目的条件是已知这两个字符串长度相等，因此我们直接按照位置来遍历字符串即可</li><li>新建一个数组 <code>diff_chars</code>，用来存放不同这两个字符串中的同一个位置上的不同的字符对 <code>(x_i, y_i)</code>，表示第 <code>i</code> 个位置上的两个不同字符。</li><li>同时遍历完两个字符串之后，我们去判断<code>diff_chars</code>的长度，只有当长度为的2 的时候，我们才能确认两个字符串有可能相似（在一开始的时候我们就提前判断字符串是否相等）</li><li>相似还需要确认字符对调之后是相同，因此对比一下数组中的两个字符对即可</li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">        self.parents = <span class="built_in">list</span>(<span class="built_in">range</span>(n))</span><br><span class="line">        self.cnt = n</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">if</span> self.parents[x] != x:</span><br><span class="line">            self.parents[x] = self.find(self.parents[x])</span><br><span class="line">        <span class="keyword">return</span> self.parents[x]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        f_x, f_y = self.find(x), self.find(y)</span><br><span class="line">        <span class="keyword">if</span> f_x != f_y:</span><br><span class="line">            self.parents[f_x] = f_y</span><br><span class="line">            self.cnt -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numSimilarGroups</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(strs)</span><br><span class="line">        uf = UnionFind(n)</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">is_similar</span>(<span class="params">str1, str2</span>):</span><br><span class="line">            <span class="comment"># 对比两个字符串是否相似</span></span><br><span class="line">            <span class="keyword">if</span> str1 == str2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            diff_chars = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(str1)):</span><br><span class="line">                <span class="keyword">if</span> str1[i] != str2[i]:</span><br><span class="line">                    diff_chars.append((str1[i], str2[i]))</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(diff_chars)!=<span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            a, b = diff_chars[<span class="number">0</span>]</span><br><span class="line">            c, d = diff_chars[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> a==d <span class="keyword">and</span> b==c:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, n):</span><br><span class="line">                <span class="comment"># 两两对比 确认相似</span></span><br><span class="line">                str1, str2 = strs[i], strs[j]</span><br><span class="line">                <span class="keyword">if</span> uf.find(i) != uf.find(j):</span><br><span class="line">                    <span class="keyword">if</span> is_similar(str1, str2):</span><br><span class="line">                        uf.union(i,j)</span><br><span class="line">        <span class="keyword">return</span> uf.cnt</span><br></pre></td></tr></table></figure><p><strong>1.29</strong></p><p><strong>题目</strong></p><blockquote><h4 id="1631-最小体力消耗路径"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/path-with-minimum-effort/">1631. 最小体力消耗路径</a></h4><p>难度中等</p><p>你准备参加一场远足活动。给你一个二维 <code>rows x columns</code> 的地图 <code>heights</code> ，其中 <code>heights[row][col]</code> 表示格子 <code>(row, col)</code> 的高度。一开始你在最左上角的格子 <code>(0, 0)</code> ，且你希望去最右下角的格子 <code>(rows-1, columns-1)</code> （注意下标从 <strong>0</strong> 开始编号）。你每次可以往 <strong>上</strong>，<strong>下</strong>，<strong>左</strong>，<strong>右</strong> 四个方向之一移动，你想要找到耗费 <strong>体力</strong> 最小的一条路径。</p><p>一条路径耗费的 <strong>体力值</strong> 是路径上相邻格子之间 <strong>高度差绝对值</strong> 的 <strong>最大值</strong> 决定的。</p><p>请你返回从左上角走到右下角的最小 <strong>体力消耗值</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex1.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [[1,2,2],[3,8,2],[5,3,5]]</span><br><span class="line">输出：2</span><br><span class="line">解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。</span><br><span class="line">这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [[1,2,3],[3,8,4],[5,3,5]]</span><br><span class="line">输出：1</span><br><span class="line">解释：路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex3.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [[1,2,1,1,1],[1,2,1,2,1],[1,2,1,2,1],[1,2,1,2,1],[1,1,1,2,1]]</span><br><span class="line">输出：0</span><br><span class="line">解释：上图所示路径不需要消耗任何体力。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>rows == heights.length</code></li><li><code>columns == heights[i].length</code></li><li><code>1 &lt;= rows, columns &lt;= 100</code></li><li><code>1 &lt;= heights[i][j] &lt;= 106</code></li></ul></blockquote><p><strong>思路</strong></p><p>需要抽象成图，每个格子代表一个结点，格子与格子之间的差值的绝对值就是边的权值。</p><p>题解中提供了三种思路</p><ul><li>二分法</li><li>并查集</li><li>Dijkstra 最短路径</li></ul><p>学习了一下 Dijkstra 最短路径算法，简单来说就是启发式搜索，一个利用启发函数的 BFS</p><p>维护一个小顶堆 <code>q</code>，维护一个遍历过的结点集合 <code>visited</code>，维护一个最短路径长度表 <code>dist</code>。</p><ul><li><p>每次遍历的时候找到当前小顶堆中代价最小的，即所需消耗体力最少的。</p></li><li><p>向四周遍历，假设从当前结点出发到达下一个结点的代价比<code>dist</code>的中的值小，则替换，并加入小顶堆，以便下一次可以遍历</p></li><li><p>遍历的时候需要确保当前结点未被遍历过</p></li><li><p>直到走到终点，即可退出遍历</p></li></ul><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minimumEffortPath</span>(<span class="params">self, heights: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="comment"># dijkstra</span></span><br><span class="line">        m, n = <span class="built_in">len</span>(heights), <span class="built_in">len</span>(heights[<span class="number">0</span>])</span><br><span class="line">        dist = [<span class="number">0</span>]+[<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)]*(m*n-<span class="number">1</span>)</span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        q = [(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            d, x, y = heapq.heappop(q)</span><br><span class="line">            node = x*n + y</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> visited:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> (x,y) == (m-<span class="number">1</span>,n-<span class="number">1</span>):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            visited.add(node)</span><br><span class="line">            <span class="keyword">for</span> nx, ny <span class="keyword">in</span> [(x-<span class="number">1</span>,y),(x+<span class="number">1</span>,y),(x,y-<span class="number">1</span>),(x,y+<span class="number">1</span>)]:</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span>&lt;=nx&lt;m <span class="keyword">and</span> <span class="number">0</span>&lt;=ny&lt;n <span class="keyword">and</span> <span class="built_in">max</span>(d, <span class="built_in">abs</span>(heights[x][y]-heights[nx][ny]))&lt;=dist[nx*n+ny]:</span><br><span class="line">                    dist[nx*n+ny] = <span class="built_in">max</span>(d, <span class="built_in">abs</span>(heights[x][y]-heights[nx][ny]))</span><br><span class="line">                    heapq.heappush(q, (dist[nx * n + ny], nx, ny))</span><br><span class="line">        <span class="keyword">return</span> dist[m*n - <span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>1.28</strong></p><p>昨日困难题又CV了，惭愧</p><p><strong>题目</strong></p><blockquote><h4 id="724-寻找数组的中心索引"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/find-pivot-index/">724. 寻找数组的中心索引</a></h4><p>难度简单</p><p>给定一个整数类型的数组 <code>nums</code>，请编写一个能够返回数组 <strong>“中心索引”</strong> 的方法。</p><p>我们是这样定义数组 <strong>中心索引</strong> 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">nums = [1, 7, 3, 6, 5, 6]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">索引 3 (nums[3] = 6) 的左侧数之和 (1 + 7 + 3 = 11)，与右侧数之和 (5 + 6 = 11) 相等。</span><br><span class="line">同时, 3 也是第一个符合要求的中心索引。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">nums = [1, 2, 3]</span><br><span class="line">输出：-1</span><br><span class="line">解释：</span><br><span class="line">数组中不存在满足此条件的中心索引。</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><code>nums</code> 的长度范围为 <code>[0, 10000]</code>。</li><li>任何一个 <code>nums[i]</code> 将会是一个范围在 <code>[-1000, 1000]</code>的整数。</li></ul></blockquote><p><strong>思路</strong></p><p>维护一个当前求得的和，遍历数组找中心索引</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pivotIndex</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        cur_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums)==<span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        tot = <span class="built_in">sum</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            target = tot-cur_sum-nums[i]</span><br><span class="line">            <span class="keyword">if</span> cur_sum == target:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            cur_sum += num</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>1.26</strong></p><p>简单题，好耶（然而我却WA了）</p><p><strong>题目</strong></p><blockquote><h4 id="1128-等价多米诺骨牌对的数量"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/number-of-equivalent-domino-pairs/">1128. 等价多米诺骨牌对的数量</a></h4><p>难度简单</p><p>给你一个由一些多米诺骨牌组成的列表 <code>dominoes</code>。</p><p>如果其中某一张多米诺骨牌可以通过旋转 <code>0</code> 度或 <code>180</code> 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。</p><p>形式上，<code>dominoes[i] = [a, b]</code> 和 <code>dominoes[j] = [c, d]</code> 等价的前提是 <code>a==c</code> 且 <code>b==d</code>，或是 <code>a==d</code> 且 <code>b==c</code>。</p><p>在 <code>0 &lt;= i &lt; j &lt; dominoes.length</code> 的前提下，找出满足 <code>dominoes[i]</code> 和 <code>dominoes[j]</code> 等价的骨牌对 <code>(i, j)</code> 的数量。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：dominoes = [[1,2],[2,1],[3,4],[5,6]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= dominoes.length &lt;= 40000</code></li><li><code>1 &lt;= dominoes[i][j] &lt;= 9</code></li></ul></blockquote><p><strong>思路</strong></p><p>用数组模拟哈希表进行计数</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numEquivDominoPairs</span>(<span class="params">self, dominoes: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums = [<span class="number">0</span>]*<span class="number">100</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> dominoes:</span><br><span class="line">            k = i*<span class="number">10</span>+j <span class="keyword">if</span> i&gt;j <span class="keyword">else</span> j*<span class="number">10</span>+i</span><br><span class="line">            cnt += nums[k]</span><br><span class="line">            nums[k] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure><p><strong>1.25</strong></p><p>我的天，原来我鸽了4天吗</p><p>新的建模题太折磨了🤕</p><p><strong>题目</strong></p><blockquote><h4 id="959-由斜杠划分区域"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/regions-cut-by-slashes/">959. 由斜杠划分区域</a></h4><p>难度中等</p><p>在由 1 x 1 方格组成的 N x N 网格 <code>grid</code> 中，每个 1 x 1 方块由 <code>/</code>、<code>\</code> 或空格构成。这些字符会将方块划分为一些共边的区域。</p><p>（请注意，反斜杠字符是转义的，因此 <code>\</code> 用 <code>&quot;\\&quot;</code> 表示。）。</p><p>返回区域的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  &quot; /&quot;,</span><br><span class="line">  &quot;/ &quot;</span><br><span class="line">]</span><br><span class="line">输出：2</span><br><span class="line">解释：2x2 网格如下：</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  &quot; /&quot;,</span><br><span class="line">  &quot;  &quot;</span><br><span class="line">]</span><br><span class="line">输出：1</span><br><span class="line">解释：2x2 网格如下：</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  &quot;\\/&quot;,</span><br><span class="line">  &quot;/\\&quot;</span><br><span class="line">]</span><br><span class="line">输出：4</span><br><span class="line">解释：（回想一下，因为 \ 字符是转义的，所以 &quot;\\/&quot; 表示 \/，而 &quot;/\\&quot; 表示 /\。）</span><br><span class="line">2x2 网格如下：</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  &quot;/\\&quot;,</span><br><span class="line">  &quot;\\/&quot;</span><br><span class="line">]</span><br><span class="line">输出：5</span><br><span class="line">解释：（回想一下，因为 \ 字符是转义的，所以 &quot;/\\&quot; 表示 /\，而 &quot;\\/&quot; 表示 \/。）</span><br><span class="line">2x2 网格如下：</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[</span><br><span class="line">  &quot;//&quot;,</span><br><span class="line">  &quot;/ &quot;</span><br><span class="line">]</span><br><span class="line">输出：3</span><br><span class="line">解释：2x2 网格如下：</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= grid.length == grid[0].length &lt;= 30</code></li><li><code>grid[i][j]</code> 是 <code>'/'</code>、<code>'\'</code>、或 <code>' '</code>。</li></ol></blockquote><p><strong>思路</strong></p><p>参考了官方题解，是很巧妙的并查集解法</p><p>本身用并查集求连通度不难，但是要发现怎么去划分区域就有点…</p><p>借用官方的图来说，每个格子划分成4块，分别对应0, 1, 2, 3</p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://pic.leetcode-cn.com/1611302894-vmBtyK-image.png" alt="image.png" style="zoom:50%"><p>我们可以把整个大的正方形抽象成一个<code>4*N*N</code>的数组，数组的每个元素代表的是四分之一个小正方形</p><p>因此，我们的并查集大小也是<code>4*N*N</code>，一开始假设都不是连通的</p><p>遍历<code>grid</code>的矩阵，相当于我们每次对一个小正方形内的四块进行操作</p><p>每次要进行的有两个操作</p><ol><li>小正方形内合并</li><li>小正方形间合并</li></ol><p>针对正方形内合并</p><ul><li>如果遍历到的是空格，即<code>‘ ’</code>，就把方块内四个格子全部连通</li><li>如果遍历到的是<code>/</code>，就把1和2连通，0和3连通</li><li>如果遍历到的是<code>\\</code>，就把0和1连通，2和3连通</li></ul><p>针对正方形间合并</p><ul><li>右侧合并<ul><li>将当前块的1和右侧块的3合并</li></ul></li><li>下侧合并<ul><li>将当前块的2和下侧块的0合并</li></ul></li></ul><p><strong>1.20</strong></p><p>不知不觉都20号了</p><p><strong>题目</strong></p><blockquote><h4 id="628-三个数的最大乘积"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/">628. 三个数的最大乘积</a></h4><p>难度简单242</p><p>给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: 24</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ol><li>给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。</li><li>输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。</li></ol></blockquote><p><strong>思路</strong></p><p>今天的题可太简单了，先排序，然后最大的乘积只可能是以下两个乘积之一</p><ol><li>最大的三个数的乘积</li><li>最小的两个数和最大的一个数的乘积</li></ol><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maximumProduct</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort()</span><br><span class="line">        res =[]</span><br><span class="line">        res.append(nums[<span class="number">0</span>]*nums[<span class="number">1</span>]*nums[-<span class="number">1</span>])</span><br><span class="line">        res.append(nums[-<span class="number">1</span>]*nums[-<span class="number">2</span>]*nums[-<span class="number">3</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res)</span><br></pre></td></tr></table></figure><p><strong>1.19</strong></p><p>龙妈的三条龙可太折磨了。</p><p><strong>题目</strong></p><blockquote><h4 id="1584-连接所有点的最小费用"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/min-cost-to-connect-all-points/">1584. 连接所有点的最小费用</a></h4><p>难度中等</p><p>给你一个<code>points</code> 数组，表示 2D 平面上的一些点，其中 <code>points[i] = [xi, yi]</code> 。</p><p>连接点 <code>[xi, yi]</code> 和点 <code>[xj, yj]</code> 的费用为它们之间的 <strong>曼哈顿距离</strong> ：<code>|xi - xj| + |yi - yj|</code> ，其中 <code>|val|</code> 表示 <code>val</code> 的绝对值。</p><p>请你返回将所有点连接的最小总费用。只有任意两点之间 <strong>有且仅有</strong> 一条简单路径时，才认为所有点都已连接。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://assets.leetcode.com/uploads/2020/08/26/d.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[0,0],[2,2],[3,10],[5,2],[7,0]]</span><br><span class="line">输出：20</span><br><span class="line">解释：</span><br><span class="line"></span><br><span class="line">我们可以按照上图所示连接所有点得到最小总费用，总费用为 20 。</span><br><span class="line">注意到任意两个点之间只有唯一一条路径互相到达。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[3,12],[-2,5],[-4,1]]</span><br><span class="line">输出：18</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[0,0],[1,1],[1,0],[-1,1]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[-1000000,-1000000],[1000000,1000000]]</span><br><span class="line">输出：4000000</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：points = [[0,0]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= points.length &lt;= 1000</code></li><li><code>-106 &lt;= xi, yi &lt;= 106</code></li><li>所有点 <code>(xi, yi)</code> 两两不同。</li></ul></blockquote><p><strong>思路</strong></p><p>关键词：并查集，Kruskal算法，最小生成树</p><ol><li>确定N个点之间所有可能的边</li><li>对所有边排序，升序排序</li><li>从最小的边开始遍历<ul><li>如果遍历到的边连接到的是两个未连通的结点，则生成该条边</li><li>直到所有的点都连通</li></ul></li></ol><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minCostConnectPoints</span>(<span class="params">self, points: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(points)</span><br><span class="line">        parents = <span class="built_in">list</span>(<span class="built_in">range</span>(n))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">if</span> x != parents[x]:</span><br><span class="line">                parents[x] = find(parents[x])</span><br><span class="line">            <span class="keyword">return</span> parents[x]</span><br><span class="line">        </span><br><span class="line">        dist = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>):</span><br><span class="line">            x1,y1 = points[i]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n):</span><br><span class="line">                x2,y2 = points[j]</span><br><span class="line">                dist.append([i,j,<span class="built_in">abs</span>(x2-x1)+<span class="built_in">abs</span>(y2-y1)])</span><br><span class="line">        dist.sort(key = <span class="keyword">lambda</span> x: x[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 构建最小生成树</span></span><br><span class="line">        edge, cost = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i,j,d <span class="keyword">in</span> dist:</span><br><span class="line">            a, b = find(i), find(j)</span><br><span class="line">            <span class="keyword">if</span> a != b:</span><br><span class="line">                <span class="comment"># 两个点不连通</span></span><br><span class="line">                edge += <span class="number">1</span></span><br><span class="line">                cost += d</span><br><span class="line">                parents[b] = a</span><br><span class="line">            <span class="keyword">if</span> edge == n-<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> cost</span><br><span class="line">        <span class="keyword">return</span> cost</span><br></pre></td></tr></table></figure><p><strong>1.18</strong></p><p>怎么寒假了还要这么头秃</p><p><strong>题目</strong></p><blockquote><h4 id="721-账户合并"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/accounts-merge/">721. 账户合并</a></h4><p>难度中等</p><p>给定一个列表 <code>accounts</code>，每个元素 <code>accounts[i]</code> 是一个字符串列表，其中第一个元素 <code>accounts[i][0]</code> 是 <em>名称 (name)</em>，其余元素是 <em>emails</em> 表示该账户的邮箱地址。</p><p>现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。</p><p>合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是按顺序排列的邮箱地址。账户本身可以以任意顺序返回。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">accounts = [[&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john00@mail.com&quot;], [&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;John&quot;, &quot;johnsmith@mail.com&quot;, &quot;john_newyork@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]</span><br><span class="line">输出：</span><br><span class="line">[[&quot;John&quot;, &#x27;john00@mail.com&#x27;, &#x27;john_newyork@mail.com&#x27;, &#x27;johnsmith@mail.com&#x27;],  [&quot;John&quot;, &quot;johnnybravo@mail.com&quot;], [&quot;Mary&quot;, &quot;mary@mail.com&quot;]]</span><br><span class="line">解释：</span><br><span class="line">第一个和第三个 John 是同一个人，因为他们有共同的邮箱地址 &quot;johnsmith@mail.com&quot;。 </span><br><span class="line">第二个 John 和 Mary 是不同的人，因为他们的邮箱地址没有被其他帐户使用。</span><br><span class="line">可以以任何顺序返回这些列表，例如答案 [[&#x27;Mary&#x27;，&#x27;mary@mail.com&#x27;]，[&#x27;John&#x27;，&#x27;johnnybravo@mail.com&#x27;]，</span><br><span class="line">[&#x27;John&#x27;，&#x27;john00@mail.com&#x27;，&#x27;john_newyork@mail.com&#x27;，&#x27;johnsmith@mail.com&#x27;]] 也是正确的。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>accounts</code>的长度将在<code>[1，1000]</code>的范围内。</li><li><code>accounts[i]</code>的长度将在<code>[1，10]</code>的范围内。</li><li><code>accounts[i][j]</code>的长度将在<code>[1，30]</code>的范围内。</li></ul></blockquote><p><strong>思路</strong></p><p>我以为是单纯的两个哈希表能解决，结果一看题解又是并查集</p><ul><li><p>一个哈希表存储：邮箱-&gt;index</p></li><li><p>另一个哈希表存储：邮箱-&gt;人名</p></li></ul><p>利用第一个哈希表，把同一个人的邮箱用并查集连通在一起</p><p>比如 <code>x@x.com</code> 如果和 <code>y@y.com</code> 是同一个人的，那么就连结到一个公共的父节点上去（这里用<code>index</code>表示父节点）</p><p>连接完之后，它们的<code>index</code>就相同了</p><p>最后利用第二个哈希表，把<code>index</code>相同的邮箱，放到同一个人名下，即可</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">accountsMerge</span>(<span class="params">self, accounts: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        email_to_index = <span class="built_in">dict</span>()</span><br><span class="line">        email_to_name = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> account <span class="keyword">in</span> accounts:</span><br><span class="line">            name = account[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> email <span class="keyword">in</span> account[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> email <span class="keyword">not</span> <span class="keyword">in</span> email_to_index:</span><br><span class="line">                    email_to_index[email] = <span class="built_in">len</span>(email_to_index)</span><br><span class="line">                    email_to_name[email] = name</span><br><span class="line">        n = <span class="built_in">len</span>(email_to_index)</span><br><span class="line">        parents = <span class="built_in">list</span>(<span class="built_in">range</span>(n))</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">x</span>):</span><br><span class="line">            <span class="keyword">if</span> parents[x] != x:</span><br><span class="line">                parents[x] = find(parents[x])</span><br><span class="line">            <span class="keyword">return</span> parents[x]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">x,y</span>):</span><br><span class="line">            f_x, f_y = find(x), find(y)</span><br><span class="line">            <span class="keyword">if</span> f_x != f_y:</span><br><span class="line">                parents[f_x] = f_y</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 开始合并同一个人的邮箱</span></span><br><span class="line">        <span class="keyword">for</span> account <span class="keyword">in</span> accounts:</span><br><span class="line">            first_index = email_to_index[account[<span class="number">1</span>]]</span><br><span class="line">            <span class="keyword">for</span> email <span class="keyword">in</span> account[<span class="number">2</span>:]:</span><br><span class="line">                union(first_index, email_to_index[email])</span><br><span class="line">        </span><br><span class="line">        index_to_emails = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> email, index <span class="keyword">in</span> email_to_index.items():</span><br><span class="line">            index = find(index)</span><br><span class="line">            index_to_emails[index].append(email)</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> emails <span class="keyword">in</span> index_to_emails.values(): </span><br><span class="line">            res.append([email_to_name[emails[<span class="number">0</span>]]] + <span class="built_in">sorted</span>(emails))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>1.17</strong></p><p>赶紧刷完题建模去了（这次培训竟然第一道就是对龙妈的三条🐉去建模）</p><p><strong>题目</strong></p><blockquote><h4 id="1232-缀点成线"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/check-if-it-is-a-straight-line/">1232. 缀点成线</a></h4><p>难度简单</p><p>在一个 XY 坐标系中有一些点，我们用数组 <code>coordinates</code> 来分别记录它们的坐标，其中 <code>coordinates[i] = [x, y]</code> 表示横坐标为 <code>x</code>、纵坐标为 <code>y</code> 的点。</p><p>请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 <code>true</code>，否则请返回 <code>false</code>。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/untitled-diagram-2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><strong><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/untitled-diagram-1.jpg" alt="img"></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= coordinates.length &lt;= 1000</code></li><li><code>coordinates[i].length == 2</code></li><li><code>-10^4 &lt;= coordinates[i][0], coordinates[i][1] &lt;= 10^4</code></li><li><code>coordinates</code> 中不含重复的点</li></ul></blockquote><p><strong>思路</strong></p><p>啥技巧都没用，就直接算斜率</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">checkStraightLine</span>(<span class="params">self, coordinates: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        x0, y0 = coordinates[<span class="number">0</span>]</span><br><span class="line">        x1, y1 = coordinates[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> x1 == x0:</span><br><span class="line">            <span class="keyword">for</span> x,y <span class="keyword">in</span> coordinates[<span class="number">1</span>:]:</span><br><span class="line">                <span class="keyword">if</span> x!=x0:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = (y1-y0)/(x1-x0)</span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> coordinates[<span class="number">2</span>:]:</span><br><span class="line">            <span class="keyword">if</span> x==x0: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> (y-y0)/(x-x0) != k:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>1.16</strong></p><p>打砖块，并查集，困难，放假，CV</p><p><strong>1.15</strong></p><p>放 假 啦！</p><p><strong>题目</strong></p><blockquote><h4 id="947-移除最多的同行或同列石头"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/most-stones-removed-with-same-row-or-column/">947. 移除最多的同行或同列石头</a></h4><p>难度中等</p><p><code>n</code> 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头。</p><p>如果一块石头的 <strong>同行或者同列</strong> 上有其他石头存在，那么就可以移除这块石头。</p><p>给你一个长度为 <code>n</code> 的数组 <code>stones</code> ，其中 <code>stones[i] = [xi, yi]</code> 表示第 <code>i</code> 块石头的位置，返回 <strong>可以移除的石子</strong> 的最大数量。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]</span><br><span class="line">输出：5</span><br><span class="line">解释：一种移除 5 块石头的方法如下所示：</span><br><span class="line">1. 移除石头 [2,2] ，因为它和 [2,1] 同行。</span><br><span class="line">2. 移除石头 [2,1] ，因为它和 [0,1] 同列。</span><br><span class="line">3. 移除石头 [1,2] ，因为它和 [1,0] 同行。</span><br><span class="line">4. 移除石头 [1,0] ，因为它和 [0,0] 同列。</span><br><span class="line">5. 移除石头 [0,1] ，因为它和 [0,0] 同行。</span><br><span class="line">石头 [0,0] 不能移除，因为它没有与另一块石头同行/列。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]</span><br><span class="line">输出：3</span><br><span class="line">解释：一种移除 3 块石头的方法如下所示：</span><br><span class="line">1. 移除石头 [2,2] ，因为它和 [2,0] 同行。</span><br><span class="line">2. 移除石头 [2,0] ，因为它和 [0,0] 同列。</span><br><span class="line">3. 移除石头 [0,2] ，因为它和 [0,0] 同行。</span><br><span class="line">石头 [0,0] 和 [1,1] 不能移除，因为它们没有与另一块石头同行/列。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：stones = [[0,0]]</span><br><span class="line">输出：0</span><br><span class="line">解释：[0,0] 是平面上唯一一块石头，所以不可以移除它。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= stones.length &lt;= 1000</code></li><li><code>0 &lt;= xi, yi &lt;= 104</code></li><li>不会有两块石头放在同一个坐标点上</li></ul></blockquote><p><strong>思路</strong></p><p>利用并查集，确定最后需要保留的点的个数</p><p>如果两个石头的行或者列相同，我们就可以认为它们是连通的</p><p>连通的石头意味着只需要留一块就够了</p><p>为了区分行和列，将行的值+10001</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n</span>):</span><br><span class="line">        self.dic = <span class="built_in">dict</span>()</span><br><span class="line">        self.cnt = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, i</span>):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> self.dic:</span><br><span class="line">            self.dic[i] = i</span><br><span class="line">            self.cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.dic[i] != i:</span><br><span class="line">            self.dic[i] = self.find(self.dic[i])</span><br><span class="line">        <span class="keyword">return</span> self.dic[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        f_x, f_y = self.find(x), self.find(y)</span><br><span class="line">        <span class="keyword">if</span> f_x == f_y:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.dic[f_x] = f_y</span><br><span class="line">        self.cnt -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">removeStones</span>(<span class="params">self, stones: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        n = <span class="built_in">len</span>(stones)</span><br><span class="line">        uf = UnionFind(n)</span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> stones:</span><br><span class="line">            uf.union(i+<span class="number">10001</span>, j)</span><br><span class="line">        <span class="keyword">return</span> n - uf.cnt</span><br></pre></td></tr></table></figure><p><strong>1.14</strong></p><p>最后一门OS，给爷🐛！</p><p><strong>题目</strong></p><blockquote><h4 id="1018-可被-5-整除的二进制前缀"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/binary-prefix-divisible-by-5/">1018. 可被 5 整除的二进制前缀</a></h4><p>难度简单</p><p>给定由若干 <code>0</code> 和 <code>1</code> 组成的数组 <code>A</code>。我们定义 <code>N_i</code>：从 <code>A[0]</code> 到 <code>A[i]</code> 的第 <code>i</code> 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。</p><p>返回布尔值列表 <code>answer</code>，只有当 <code>N_i</code> 可以被 <code>5</code> 整除时，答案 <code>answer[i]</code> 为 <code>true</code>，否则为 <code>false</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[0,1,1]</span><br><span class="line">输出：[true,false,false]</span><br><span class="line">解释：</span><br><span class="line">输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为真。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,1,1]</span><br><span class="line">输出：[false,false,false]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[0,1,1,1,1,1]</span><br><span class="line">输出：[true,false,false,false,true,false]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,1,1,0,1]</span><br><span class="line">输出：[false,false,false,false,false]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>1 &lt;= A.length &lt;= 30000</code></li><li><code>A[i]</code> 为 <code>0</code> 或 <code>1</code></li></ol></blockquote><p><strong>思路</strong></p><p>全程只算余数即可</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prefixesDivBy5</span>(<span class="params">self, A: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">bool</span>]:</span><br><span class="line">        res = []</span><br><span class="line">        tmp = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> A:</span><br><span class="line">            tmp *= <span class="number">2</span></span><br><span class="line">            tmp += i</span><br><span class="line">            tmp %= <span class="number">5</span></span><br><span class="line">            <span class="keyword">if</span> tmp == <span class="number">0</span>:</span><br><span class="line">                res.append(<span class="literal">True</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(<span class="literal">False</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>1.13</strong></p><p>又是并查集😓</p><p>明天考OS，紧张到起飞</p><p><strong>题目</strong></p><blockquote><h4 id="684-冗余连接"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/redundant-connection/">684. 冗余连接</a></h4><p>难度中等</p><p>在本问题中, 树指的是一个连通且无环的<strong>无向</strong>图。</p><p>输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, …, N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。</p><p>结果图是一个以<code>边</code>组成的二维数组。每一个<code>边</code>的元素是一对<code>[u, v]</code> ，满足 <code>u &lt; v</code>，表示连接顶点<code>u</code> 和<code>v</code>的<strong>无向</strong>图的边。</p><p>返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 <code>[u, v]</code> 应满足相同的格式 <code>u &lt; v</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,2], [1,3], [2,3]]</span><br><span class="line">输出: [2,3]</span><br><span class="line">解释: 给定的无向图为:</span><br><span class="line">  1</span><br><span class="line"> / \</span><br><span class="line">2 - 3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,2], [2,3], [3,4], [1,4], [1,5]]</span><br><span class="line">输出: [1,4]</span><br><span class="line">解释: 给定的无向图为:</span><br><span class="line">5 - 1 - 2</span><br><span class="line">    |   |</span><br><span class="line">    4 - 3</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li>输入的二维数组大小在 3 到 1000。</li><li>二维数组中的整数在1到N之间，其中N是输入数组的大小。</li></ul></blockquote><p><strong>思路</strong></p><p>用并查集确认两个结点是否连通（parent相同），如果在已经连通的情况下又有一条边将其相连，则说明产生了环路，返回这条边即可</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findRedundantConnection</span>(<span class="params">self, edges: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="comment"># 并查集</span></span><br><span class="line">        n = <span class="built_in">len</span>(edges)</span><br><span class="line">        parents = <span class="built_in">list</span>(<span class="built_in">range</span>(n+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">i</span>):</span><br><span class="line">            <span class="keyword">if</span> parents[i] != i:</span><br><span class="line">                parents[i] = find(parents[i])</span><br><span class="line">            <span class="keyword">return</span> parents[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">union</span>(<span class="params">x,y</span>):</span><br><span class="line">            fx, fy = find(x), find(y)</span><br><span class="line">            <span class="keyword">if</span> fx!=fy:</span><br><span class="line">                parents[fx] = fy</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> x,y <span class="keyword">in</span> edges:</span><br><span class="line">            <span class="keyword">if</span> find(x) == find(y):</span><br><span class="line">                <span class="keyword">return</span> [x,y]</span><br><span class="line">            union(x,y)</span><br><span class="line">        </span><br></pre></td></tr></table></figure><p><strong>1.12</strong></p><p>图论，拓扑排序，困难题，cv</p><p><strong>1.11</strong></p><p>a lovely Monday.</p><p><strong>题目</strong></p><blockquote><h4 id="1202-交换字符串中的元素"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/smallest-string-with-swaps/">1202. 交换字符串中的元素</a></h4><p>难度中等</p><p>给你一个字符串 <code>s</code>，以及该字符串中的一些「索引对」数组 <code>pairs</code>，其中 <code>pairs[i] = [a, b]</code> 表示字符串中的两个索引（编号从 0 开始）。</p><p>你可以 <strong>任意多次交换</strong> 在 <code>pairs</code> 中任意一对索引处的字符。</p><p>返回在经过若干次交换后，<code>s</code> 可以变成的按字典序最小的字符串。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;dcab&quot;, pairs = [[0,3],[1,2]]</span><br><span class="line">输出：&quot;bacd&quot;</span><br><span class="line">解释： </span><br><span class="line">交换 s[0] 和 s[3], s = &quot;bcad&quot;</span><br><span class="line">交换 s[1] 和 s[2], s = &quot;bacd&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;dcab&quot;, pairs = [[0,3],[1,2],[0,2]]</span><br><span class="line">输出：&quot;abcd&quot;</span><br><span class="line">解释：</span><br><span class="line">交换 s[0] 和 s[3], s = &quot;bcad&quot;</span><br><span class="line">交换 s[0] 和 s[2], s = &quot;acbd&quot;</span><br><span class="line">交换 s[1] 和 s[2], s = &quot;abcd&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;cba&quot;, pairs = [[0,1],[1,2]]</span><br><span class="line">输出：&quot;abc&quot;</span><br><span class="line">解释：</span><br><span class="line">交换 s[0] 和 s[1], s = &quot;bca&quot;</span><br><span class="line">交换 s[1] 和 s[2], s = &quot;bac&quot;</span><br><span class="line">交换 s[0] 和 s[1], s = &quot;abc&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 10^5</code></li><li><code>0 &lt;= pairs.length &lt;= 10^5</code></li><li><code>0 &lt;= pairs[i][0], pairs[i][1] &lt; s.length</code></li><li><code>s</code> 中只含有小写英文字母</li></ul></blockquote><p><strong>题目</strong></p><p>初步复习了一下并查集（没有跟官方题解一样用按秩优化）</p><p>根据题目要求可以很快发现有一个连通子集的问题，比如<code>[0,1]</code>和<code>[1,3]</code>可以理解为在一个连通集合里</p><p>因此考虑用并查集实现快速地查询哪些元素是在一个集合里的</p><p>具体思路见代码，以及<a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/number-of-provinces/solution/python-duo-tu-xiang-jie-bing-cha-ji-by-m-vjdr/">模板题解</a></p><p>代码实现使用的是递归的路径压缩（我还发现直接把并查集写在Solution里会报递归深度错误）</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DSU</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n:<span class="built_in">int</span></span>):</span><br><span class="line">        self.p = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">self, x: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="keyword">if</span> x != self.p[x]:</span><br><span class="line">            self.p[x] = self.find(self.p[x])</span><br><span class="line">        <span class="keyword">return</span> self.p[x]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">self, x:<span class="built_in">int</span> , y:<span class="built_in">int</span></span>):</span><br><span class="line">        fx, fy = self.find(x), self.find(y)</span><br><span class="line">        <span class="keyword">if</span> fx == fy: <span class="keyword">return</span></span><br><span class="line">        self.p[fx] = self.p[fy]</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">smallestStringWithSwaps</span>(<span class="params">self, s: <span class="built_in">str</span>, pairs: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="comment"># 构造并查集</span></span><br><span class="line">        length = <span class="built_in">len</span>(s)</span><br><span class="line">        dsu = DSU(length)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i,j <span class="keyword">in</span> pairs:</span><br><span class="line">            dsu.merge(i,j)</span><br><span class="line">        </span><br><span class="line">        dic = collections.defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            dic[dsu.find(i)].append(i)</span><br><span class="line">        res = <span class="built_in">list</span>(<span class="built_in">range</span>(length))</span><br><span class="line">        <span class="keyword">for</span> v <span class="keyword">in</span> dic.values():</span><br><span class="line">            words = [s[i] <span class="keyword">for</span> i <span class="keyword">in</span> v]</span><br><span class="line">            words.sort()</span><br><span class="line">            cnt = <span class="number">0</span> </span><br><span class="line">            v.sort()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> v:</span><br><span class="line">                res[i] = words[cnt]</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(res)</span><br></pre></td></tr></table></figure><p><strong>1.10</strong></p><blockquote><h4 id="228-汇总区间"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/summary-ranges/">228. 汇总区间</a></h4><p>难度简单</p><p>给定一个无重复元素的有序整数数组 <code>nums</code> 。</p><p>返回 <strong>恰好覆盖数组中所有数字</strong> 的 <strong>最小有序</strong> 区间范围列表。也就是说，<code>nums</code> 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 <code>nums</code> 的数字 <code>x</code> 。</p><p>列表中的每个区间范围 <code>[a,b]</code> 应该按如下格式输出：</p><ul><li><code>&quot;a-&gt;b&quot;</code> ，如果 <code>a != b</code></li><li><code>&quot;a&quot;</code> ，如果 <code>a == b</code></li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,4,5,7]</span><br><span class="line">输出：[&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,2] --&gt; &quot;0-&gt;2&quot;</span><br><span class="line">[4,5] --&gt; &quot;4-&gt;5&quot;</span><br><span class="line">[7,7] --&gt; &quot;7&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,2,3,4,6,8,9]</span><br><span class="line">输出：[&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]</span><br><span class="line">解释：区间范围是：</span><br><span class="line">[0,0] --&gt; &quot;0&quot;</span><br><span class="line">[2,4] --&gt; &quot;2-&gt;4&quot;</span><br><span class="line">[6,6] --&gt; &quot;6&quot;</span><br><span class="line">[8,9] --&gt; &quot;8-&gt;9&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1]</span><br><span class="line">输出：[&quot;-1&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[&quot;0&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 20</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li><li><code>nums</code> 中的所有值都 <strong>互不相同</strong></li><li><code>nums</code> 按升序排列</li></ul></blockquote><p><strong>思路</strong></p><p>没有技术可言，就是遍历一遍数组，把所有连续的子数组转换成<code>x-&gt;y</code>的字符串即可</p><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">summaryRanges</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">str</span>(nums[<span class="number">0</span>])]</span><br><span class="line">        first, last = nums[<span class="number">0</span>], nums[<span class="number">0</span>]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums[<span class="number">1</span>:]):</span><br><span class="line">            <span class="keyword">if</span> num != last + <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> first == last:</span><br><span class="line">                    res.append(<span class="built_in">str</span>(first))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append(<span class="built_in">str</span>(first)+<span class="string">&quot;-&gt;&quot;</span>+<span class="built_in">str</span>(last))</span><br><span class="line">                first = num</span><br><span class="line">            last = num</span><br><span class="line">            <span class="keyword">if</span> i == <span class="built_in">len</span>(nums)-<span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> first == last:</span><br><span class="line">                    res.append(<span class="built_in">str</span>(last))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append(<span class="built_in">str</span>(first)+<span class="string">&quot;-&gt;&quot;</span>+<span class="built_in">str</span>(last))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>1.9</strong></p><p>@labuladong！yyds！</p><p><strong>题解</strong></p><blockquote><h4 id="123-买卖股票的最佳时机-III"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/">123. 买卖股票的最佳时机 III</a></h4><p>难度困难</p><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p>**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [3,3,5,0,0,3,1,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。</span><br><span class="line">     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   </span><br><span class="line">     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   </span><br><span class="line">     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1] </span><br><span class="line">输出：0 </span><br><span class="line">解释：在这个情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：prices = [1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 105</code></li></ul></blockquote><p><strong>思路</strong></p><p>考完五门，还剩两门，计网和OS，还有四天，算是有空写题解了</p><p>看完东哥的算法小抄，真就直接秒杀动归呗。</p><p>一般来说，如果不限交易次数，只需要设置两个变量<code>dp0</code>和<code>dp1</code>分别表示当天未持有股票的状态和持有股票的状态。</p><p>这道题要求最多只能交易两次，所以我们的两个变量变成了两个数组</p><p><strong>DP Table</strong></p><ul><li><p><code>dp0[i]</code> 表示当天未持有股票的最大利润，且已进行了<code>i</code>次交易（卖出过<code>i</code>次股票）</p></li><li><p><code>dp1[i]</code> 表示当天持有股票的最大利润，且进行了<code>i</code>次交易</p></li></ul><p><strong>Base case</strong></p><ul><li><code>dp0 = [0,0,0]</code>，因为一开始未持有股票，所以第一天无论是交易了几次，最大利润都是0</li><li><code>dp1 = [-float('inf'),-float('inf')]</code>，因为一开始不可能持有股票，所以我们初始化最大利润为负无穷（避免第一天就能卖股票）</li></ul><p><strong>状态转移方程</strong></p><ul><li>针对<code>dp0</code>而言<ul><li>要么就是当天卖出了股票，要么就是本来就没有股票</li><li><code>dp0[0]</code>永远为0，因为交易次数为0且未持有股票，说明从未购入股票</li><li><code>dp0[1]</code> 为前一天未持有股票的最大收益，或者前一天持有股票且当天卖出股票的最大收益<ul><li>注意这里如果是保持未持有股票，则交易次数是不会变的</li><li>如果是卖出股票，那必定是根据<code>dp1[0]</code>去更新的，因为更新后才变成<code>dp0[1]</code>所表示的1次交易</li></ul></li><li><code>dp0[2]</code>和<code>dp0[1]</code>同理</li></ul></li><li>针对<code>dp1</code>而言<ul><li>要么就是当天买入了股票，要么就是之前就持有了股票，还没卖</li><li><code>dp1[0]</code> 就是根据前一天已经持有股票的最大利润<code>dp1[0]</code>，和当天买入股票的最大利润<code>dp0[0]-price</code></li><li><code>dp1[1]</code> 同理，需要考虑交易次数</li></ul></li></ul><blockquote><p>最后一天未持有股票，且交易次数为2的情况下必然是最大利益，即<code>dp0[2]</code></p></blockquote><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp0 = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>] <span class="comment"># 表示当天未持有股票的情况 </span></span><br><span class="line">        dp1 = [-<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>), -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)] <span class="comment"># 表示当天持有股票的情况</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            dp0[<span class="number">1</span>] = <span class="built_in">max</span>(dp1[<span class="number">0</span>]+price, dp0[<span class="number">1</span>])</span><br><span class="line">            dp0[<span class="number">2</span>] = <span class="built_in">max</span>(dp1[<span class="number">1</span>]+price, dp0[<span class="number">2</span>])</span><br><span class="line">            dp1[<span class="number">0</span>] = <span class="built_in">max</span>(dp0[<span class="number">0</span>]-price, dp1[<span class="number">0</span>])</span><br><span class="line">            dp1[<span class="number">1</span>] = <span class="built_in">max</span>(dp0[<span class="number">1</span>]-price, dp1[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> dp0[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><strong>1.8</strong></p><p>软测老师捞捞我</p><p><strong>题目</strong></p><blockquote><h4 id="189-旋转数组"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/rotate-array/">189. 旋转数组</a></h4><p>难度中等</p><p>给定一个数组，将数组中的元素向右移动 <em>k</em> 个位置，其中 <em>k</em> 是非负数。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [-1,-100,3,99] 和 k = 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li><li>要求使用空间复杂度为 O(1) 的 <strong>原地</strong> 算法。</li></ul></blockquote><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        k %= n</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">reverse</span>(<span class="params">i,j</span>):</span><br><span class="line">            <span class="comment"># 翻转数组的[i:j]</span></span><br><span class="line">            left, right = i, j-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left&lt;right:</span><br><span class="line">                nums[left], nums[right] = nums[right], nums[left]</span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">                right -= <span class="number">1</span></span><br><span class="line">        reverse(<span class="number">0</span>,n)</span><br><span class="line">        reverse(<span class="number">0</span>,k)</span><br><span class="line">        reverse(k,n)</span><br></pre></td></tr></table></figure><p><strong>1.7</strong></p><p>真的复习不完了兄弟萌</p><p><strong>题目</strong></p><blockquote><h4 id="547-省份数量"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/number-of-provinces/">547. 省份数量</a></h4><p>难度中等</p><p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市 <code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code> 与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市 <code>c</code> 间接相连。</p><p><strong>省份</strong> 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中 <code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第 <code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code> 表示二者不直接相连。</p><p>返回矩阵中 <strong>省份</strong> 的数量。</p><p><strong>示例 1：</strong></p><p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 200</code></li><li><code>n == isConnected.length</code></li><li><code>n == isConnected[i].length</code></li><li><code>isConnected[i][j]</code> 为 <code>1</code> 或 <code>0</code></li><li><code>isConnected[i][i] == 1</code></li><li><code>isConnected[i][j] == isConnected[j][i]</code></li></ul></blockquote><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findCircleNum</span>(<span class="params">self, isConnected: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">i</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> isConnected[i][j] == <span class="number">1</span> <span class="keyword">and</span> j <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    visited.add(j)</span><br><span class="line">                    dfs(j)</span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        circle = <span class="number">0</span></span><br><span class="line">        n = <span class="built_in">len</span>(isConnected)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                dfs(i)</span><br><span class="line">                circle += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> circle</span><br></pre></td></tr></table></figure><p><strong>题目</strong></p><p><strong>1.6</strong></p><p>cv的，没空复习并查集了</p><p><strong>题目</strong></p><blockquote><h4 id="399-除法求值"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/evaluate-division/">399. 除法求值</a></h4><p>难度中等293</p><p>给你一个变量对数组 <code>equations</code> 和一个实数值数组 <code>values</code> 作为已知条件，其中 <code>equations[i] = [Ai, Bi]</code> 和 <code>values[i]</code> 共同表示等式 <code>Ai / Bi = values[i]</code> 。每个 <code>Ai</code> 或 <code>Bi</code> 是一个表示单个变量的字符串。</p><p>另有一些以数组 <code>queries</code> 表示的问题，其中 <code>queries[j] = [Cj, Dj]</code> 表示第 <code>j</code> 个问题，请你根据已知条件找出 <code>Cj / Dj = ?</code> 的结果作为答案。</p><p>返回 <strong>所有问题的答案</strong> 。如果存在某个无法确定的答案，则用 <code>-1.0</code> 替代这个答案。</p><p>**注意：**输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;]], values = [2.0,3.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;e&quot;],[&quot;a&quot;,&quot;a&quot;],[&quot;x&quot;,&quot;x&quot;]]</span><br><span class="line">输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]</span><br><span class="line">解释：</span><br><span class="line">条件：a / b = 2.0, b / c = 3.0</span><br><span class="line">问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?</span><br><span class="line">结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：equations = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;c&quot;],[&quot;bc&quot;,&quot;cd&quot;]], values = [1.5,2.5,5.0], queries = [[&quot;a&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;b&quot;],[&quot;bc&quot;,&quot;cd&quot;],[&quot;cd&quot;,&quot;bc&quot;]]</span><br><span class="line">输出：[3.75000,0.40000,5.00000,0.20000]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：equations = [[&quot;a&quot;,&quot;b&quot;]], values = [0.5], queries = [[&quot;a&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;c&quot;],[&quot;x&quot;,&quot;y&quot;]]</span><br><span class="line">输出：[0.50000,2.00000,-1.00000,-1.00000]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= equations.length &lt;= 20</code></li><li><code>equations[i].length == 2</code></li><li><code>1 &lt;= Ai.length, Bi.length &lt;= 5</code></li><li><code>values.length == equations.length</code></li><li><code>0.0 &lt; values[i] &lt;= 20.0</code></li><li><code>1 &lt;= queries.length &lt;= 20</code></li><li><code>queries[i].length == 2</code></li><li><code>1 &lt;= Cj.length, Dj.length &lt;= 5</code></li><li><code>Ai, Bi, Cj, Dj</code> 由小写英文字母与数字组成</li></ul></blockquote><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calcEquation</span>(<span class="params">self, equations: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]], values: <span class="type">List</span>[<span class="built_in">float</span>], queries: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">        <span class="comment"># 构造图，equations的第一项除以第二项等于value里的对应值，第二项除以第一项等于其倒数</span></span><br><span class="line">        graph = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> (x, y), v <span class="keyword">in</span> <span class="built_in">zip</span>(equations, values):</span><br><span class="line">            <span class="keyword">if</span> x <span class="keyword">in</span> graph:</span><br><span class="line">                graph[x][y] = v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                graph[x] = &#123;y: v&#125;</span><br><span class="line">            <span class="keyword">if</span> y <span class="keyword">in</span> graph:</span><br><span class="line">                graph[y][x] = <span class="number">1</span>/v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                graph[y] = &#123;x: <span class="number">1</span>/v&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># dfs找寻从s到t的路径并返回结果叠乘后的边权重即结果</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">s, t</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">not</span> <span class="keyword">in</span> graph:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> t == s:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> graph[s].keys():</span><br><span class="line">                <span class="keyword">if</span> node == t:</span><br><span class="line">                    <span class="keyword">return</span> graph[s][node]</span><br><span class="line">                <span class="keyword">elif</span> node <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    visited.add(node)  <span class="comment"># 添加到已访问避免重复遍历</span></span><br><span class="line">                    v = dfs(node, t)</span><br><span class="line">                    <span class="keyword">if</span> v != -<span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">return</span> graph[s][node]*v</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 逐个计算query的值</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> qs, qt <span class="keyword">in</span> queries:</span><br><span class="line">            visited = <span class="built_in">set</span>()</span><br><span class="line">            res.append(dfs(qs, qt))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>1.5</strong></p><p>学校的课堂知识明明以后都用不上，却还是要为了绩点去复习</p><p>能直接快进到寒假不，我想快点开始学 JS 了</p><p><strong>题目</strong></p><blockquote><h4 id="830-较大分组的位置"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/positions-of-large-groups/">830. 较大分组的位置</a></h4><p>难度简单</p><p>在一个由小写字母构成的字符串 <code>s</code> 中，包含由一些连续的相同字符所构成的分组。</p><p>例如，在字符串 <code>s = &quot;abbxxxxzyy&quot;</code> 中，就含有 <code>&quot;a&quot;</code>, <code>&quot;bb&quot;</code>, <code>&quot;xxxx&quot;</code>, <code>&quot;z&quot;</code> 和 <code>&quot;yy&quot;</code> 这样的一些分组。</p><p>分组可以用区间 <code>[start, end]</code> 表示，其中 <code>start</code> 和 <code>end</code> 分别表示该分组的起始和终止位置的下标。上例中的 <code>&quot;xxxx&quot;</code> 分组用区间表示为 <code>[3,6]</code> 。</p><p>我们称所有包含大于或等于三个连续字符的分组为 <strong>较大分组</strong> 。</p><p>找到每一个 <strong>较大分组</strong> 的区间，<strong>按起始位置下标递增顺序排序后</strong>，返回结果。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abbxxxxzzy&quot;</span><br><span class="line">输出：[[3,6]]</span><br><span class="line">解释：&quot;xxxx&quot; 是一个起始于 3 且终止于 6 的较大分组。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：[]</span><br><span class="line">解释：&quot;a&quot;,&quot;b&quot; 和 &quot;c&quot; 均不是符合要求的较大分组。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abcdddeeeeaabbbcd&quot;</span><br><span class="line">输出：[[3,5],[6,9],[12,14]]</span><br><span class="line">解释：较大分组为 &quot;ddd&quot;, &quot;eeee&quot; 和 &quot;bbb&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aba&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅含小写英文字母</li></ul></blockquote><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">largeGroupPositions</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        last, cnt = <span class="string">&quot;&quot;</span>, <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i, word <span class="keyword">in</span> <span class="built_in">enumerate</span>(s):</span><br><span class="line">            <span class="keyword">if</span> word == last:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> cnt&gt;=<span class="number">3</span>:</span><br><span class="line">                    res.append([i-cnt,i-<span class="number">1</span>])</span><br><span class="line">                cnt = <span class="number">1</span></span><br><span class="line">                last = word</span><br><span class="line">        <span class="keyword">if</span> cnt&gt;=<span class="number">3</span>:</span><br><span class="line">            res.append([<span class="built_in">len</span>(s)-cnt,<span class="built_in">len</span>(s)-<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>1.4</strong></p><p>考试周开始了 🙌</p><p><strong>题目</strong></p><blockquote><h4 id="509-斐波那契数"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/fibonacci-number/">509. 斐波那契数</a></h4><p>难度简单</p><p><strong>斐波那契数</strong>，通常用 <code>F(n)</code> 表示，形成的序列称为 <strong>斐波那契数列</strong> 。该数列由 <code>0</code> 和 <code>1</code> 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">F(0) = 0，F(1) = 1</span><br><span class="line">F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span><br></pre></td></tr></table></figure><p>给你 <code>n</code> ，请计算 <code>F(n)</code> 。</p></blockquote><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">self, N: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N):</span><br><span class="line">            dp.append(dp[-<span class="number">1</span>]+dp[-<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> dp[N]</span><br></pre></td></tr></table></figure><p><strong>1.3</strong></p><p>还挺简单的，俺复习去了</p><p><strong>题目</strong></p><blockquote><h4 id="86-分隔链表"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/partition-list/">86. 分隔链表</a></h4><p>难度中等</p><p>给你一个链表和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有小于 <code>x</code> 的节点都出现在大于或等于 <code>x</code> 的节点之前。</p><p>你应当保留两个分区中每个节点的初始相对位置。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3</span><br><span class="line">输出：1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span><br></pre></td></tr></table></figure></blockquote><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, head: ListNode, x: <span class="built_in">int</span></span>) -&gt; ListNode:</span><br><span class="line">        node = head</span><br><span class="line">        dummy_small, dummy_large = ListNode(<span class="number">0</span>), ListNode(<span class="number">0</span>)</span><br><span class="line">        node_small, node_large = dummy_small, dummy_large</span><br><span class="line">        <span class="keyword">while</span> node:</span><br><span class="line">            nxt_node = node.<span class="built_in">next</span></span><br><span class="line">            <span class="keyword">if</span> node.val&lt;x:</span><br><span class="line">                <span class="keyword">if</span> node_small==dummy_small:</span><br><span class="line">                    node_small = node</span><br><span class="line">                    dummy_small.<span class="built_in">next</span> = node_small</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node_small.<span class="built_in">next</span> = node</span><br><span class="line">                    node_small = node</span><br><span class="line">                node_small.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> node_large == dummy_large:</span><br><span class="line">                    node_large = node</span><br><span class="line">                    dummy_large.<span class="built_in">next</span> = node_large</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node_large.<span class="built_in">next</span> = node</span><br><span class="line">                    node_large = node</span><br><span class="line">                node_large.<span class="built_in">next</span> = <span class="literal">None</span></span><br><span class="line">            node = nxt_node</span><br><span class="line">        node_small.<span class="built_in">next</span> = dummy_large.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> dummy_small.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p><strong>1.2</strong></p><p>好家伙，昨天做完题直接忘记写了</p><p><strong>题目</strong></p><blockquote><h4 id="239-滑动窗口最大值"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h4><p>难度困难</p><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">输出：[3,3,5,5,6,7]</span><br><span class="line">解释：</span><br><span class="line">滑动窗口的位置                最大值</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1], k = 1</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,-1], k = 1</span><br><span class="line">输出：[1,-1]</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [9,11], k = 2</span><br><span class="line">输出：[11]</span><br></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [4,-2], k = 2</span><br><span class="line">输出：[4]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul></blockquote><p><strong>代码</strong></p><p>堆栈：时间复杂度O(NlogN)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums, k</span>):</span><br><span class="line">        </span><br><span class="line">        heap = [(-nums[i], i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)]</span><br><span class="line">        heapq.heapify(heap)</span><br><span class="line">        res = [-heap[<span class="number">0</span>][<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k,<span class="built_in">len</span>(nums)):</span><br><span class="line">            heapq.heappush(heap, (-nums[i], i))</span><br><span class="line">            <span class="keyword">while</span> heap[<span class="number">0</span>][<span class="number">1</span>] &lt;= i - k:</span><br><span class="line">                heapq.heappop(heap)</span><br><span class="line">            res.append(-heap[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>双向队列：时间复杂度O(N)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums, k</span>):</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        q = deque()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k):</span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> nums[i] &gt;= nums[q[-<span class="number">1</span>]]:</span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(i)</span><br><span class="line">        res = [nums[q[<span class="number">0</span>]]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, n):</span><br><span class="line">            <span class="keyword">while</span> q <span class="keyword">and</span> nums[i] &gt;= nums[q[-<span class="number">1</span>]]:</span><br><span class="line">                q.pop()</span><br><span class="line">            q.append(i)</span><br><span class="line">            <span class="keyword">while</span> q[<span class="number">0</span>] &lt;= i - k:</span><br><span class="line">                q.popleft()</span><br><span class="line">            res.append(nums[q[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p><strong>1.1</strong></p><p>因为太简单而忘记更新 😓</p><p><strong>题目</strong></p><blockquote><h4 id="605-种花问题"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leetcode-cn.com/problems/can-place-flowers/">605. 种花问题</a></h4><p>难度简单</p><p>假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p><p>给你一个整数数组 <code>flowerbed</code> 表示花坛，由若干 <code>0</code> 和 <code>1</code> 组成，其中 <code>0</code> 表示没种植花，<code>1</code> 表示种植了花。另有一个数 <code>n</code> ，能否在不打破种植规则的情况下种入 <code>n</code> 朵花？能则返回 <code>true</code> ，不能则返回 <code>false</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：flowerbed = [1,0,0,0,1], n = 1</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：flowerbed = [1,0,0,0,1], n = 2</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= flowerbed.length &lt;= 2 * 104</code></li><li><code>flowerbed[i]</code> 为 <code>0</code> 或 <code>1</code></li><li><code>flowerbed</code> 中不存在相邻的两朵花</li><li><code>0 &lt;= n &lt;= flowerbed.length</code></li></ul></blockquote><p><strong>代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">canPlaceFlowers</span>(<span class="params">self, flowerbed: <span class="type">List</span>[<span class="built_in">int</span>], n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        index = <span class="number">0</span></span><br><span class="line">        size = <span class="built_in">len</span>(flowerbed)</span><br><span class="line">        <span class="keyword">while</span> index&lt;size:</span><br><span class="line">            <span class="keyword">if</span> flowerbed[index] == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 该位置有花</span></span><br><span class="line">                index += <span class="number">2</span></span><br><span class="line">            <span class="keyword">elif</span> index+<span class="number">1</span>&lt;size <span class="keyword">and</span> flowerbed[index+<span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 后一个位置有花</span></span><br><span class="line">                index += <span class="number">3</span></span><br><span class="line">            <span class="keyword">elif</span> index-<span class="number">1</span>&gt;=<span class="number">0</span> <span class="keyword">and</span> flowerbed[index-<span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># 前一个位置有花</span></span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 前中后均无花</span></span><br><span class="line">                flowerbed[index] = <span class="number">1</span></span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                index += <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> cnt&gt;=n</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://blog.ethanloo.cn">EthanLoo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://blog.ethanloo.cn/post/2021-01-01-Algorithm/2021%E5%B9%B41%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/">https://blog.ethanloo.cn/post/2021-01-01-Algorithm/2021年1月刷题日志/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.ethanloo.cn" target="_blank">Ethanloo's</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/leetcode/">leetcode</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/2021-01-10-Weber/CSS%20%E5%9F%BA%E7%A1%80/" title="CSS 知识点总结"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/20210110114324.webp" onerror='onerror=null,src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">CSS 知识点总结</div></div></a></div><div class="next-post pull-right"><a href="/post/2020-12-24-Weber/HTML5/" title="HTML5 知识点总结"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/20201224234538.webp" onerror='onerror=null,src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">HTML5 知识点总结</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/post/2021-06-02-Algorithm/2021%E5%B9%B46%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/" title="2021年6月刷题日志"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/20210602143312.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-02</div><div class="title">2021年6月刷题日志</div></div></a></div><div><a href="/post/2021-05-05-Algorithm/2021%E5%B9%B45%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/" title="2021年5月刷题日志"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/image-20201204232217281.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-05</div><div class="title">2021年5月刷题日志</div></div></a></div><div><a href="/post/2021-04-01-Algorithm/2021%E5%B9%B44%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/" title="2021年4月刷题日志"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="/img/cover/l.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-01</div><div class="title">2021年4月刷题日志</div></div></a></div><div><a href="/post/2021-03-01-Algorithm/2021%E5%B9%B43%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/" title="2021年3月刷题日志"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="/img/cover/l.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-01</div><div class="title">2021年3月刷题日志</div></div></a></div><div><a href="/post/2021-02-01-Algorithm/2021%E5%B9%B42%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/" title="2021年2月刷题日志"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="/img/cover/l.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-01</div><div class="title">2021年2月刷题日志</div></div></a></div><div><a href="/post/2020-12-01-Algorithm/2020%E5%B9%B412%E6%9C%88%E5%88%B7%E9%A2%98%E6%97%A5%E5%BF%97/" title="2020年12月刷题日志"><img class="cover" src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="/img/cover/l.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-01</div><div class="title">2020年12月刷题日志</div></div></a></div></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/avatar.png" onerror='this.onerror=null,this.src="https://cdn.ethanloo.cn/img/20201202163407.gif"' alt="avatar"></div><div class="author-info__name">EthanLoo</div><div class="author-info__description">不过是用输出倒逼输入罢了👶</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">55</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/EthanLuu"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/EthanLuu" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:ethanlooo@outlook.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=952792901&amp;site=qq&amp;menu=yes" rel="external nofollow noreferrer" target="_blank" title="QQ"><i class="fab fa-qq"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><span>公告</span></div><div class="announcement_content">好好吃饭🍣 好好睡觉💤<br>敲敲代码💻 谈谈恋爱💑</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#643-%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0-I"><span class="toc-text">643. 子数组最大平均数 I</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#480-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="toc-text">480. 滑动窗口中位数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#424-%E6%9B%BF%E6%8D%A2%E5%90%8E%E7%9A%84%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6"><span class="toc-text">424. 替换后的最长重复字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#888-%E5%85%AC%E5%B9%B3%E7%9A%84%E7%B3%96%E6%9E%9C%E6%A3%92%E4%BA%A4%E6%8D%A2"><span class="toc-text">888. 公平的糖果棒交换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#839-%E7%9B%B8%E4%BC%BC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BB%84"><span class="toc-text">839. 相似字符串组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1631-%E6%9C%80%E5%B0%8F%E4%BD%93%E5%8A%9B%E6%B6%88%E8%80%97%E8%B7%AF%E5%BE%84"><span class="toc-text">1631. 最小体力消耗路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#724-%E5%AF%BB%E6%89%BE%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E5%BF%83%E7%B4%A2%E5%BC%95"><span class="toc-text">724. 寻找数组的中心索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1128-%E7%AD%89%E4%BB%B7%E5%A4%9A%E7%B1%B3%E8%AF%BA%E9%AA%A8%E7%89%8C%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-text">1128. 等价多米诺骨牌对的数量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#959-%E7%94%B1%E6%96%9C%E6%9D%A0%E5%88%92%E5%88%86%E5%8C%BA%E5%9F%9F"><span class="toc-text">959. 由斜杠划分区域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#628-%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF"><span class="toc-text">628. 三个数的最大乘积</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1584-%E8%BF%9E%E6%8E%A5%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8"><span class="toc-text">1584. 连接所有点的最小费用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#721-%E8%B4%A6%E6%88%B7%E5%90%88%E5%B9%B6"><span class="toc-text">721. 账户合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1232-%E7%BC%80%E7%82%B9%E6%88%90%E7%BA%BF"><span class="toc-text">1232. 缀点成线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#947-%E7%A7%BB%E9%99%A4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%90%8C%E8%A1%8C%E6%88%96%E5%90%8C%E5%88%97%E7%9F%B3%E5%A4%B4"><span class="toc-text">947. 移除最多的同行或同列石头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1018-%E5%8F%AF%E8%A2%AB-5-%E6%95%B4%E9%99%A4%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%89%8D%E7%BC%80"><span class="toc-text">1018. 可被 5 整除的二进制前缀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#684-%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5"><span class="toc-text">684. 冗余连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1202-%E4%BA%A4%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">1202. 交换字符串中的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#228-%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4"><span class="toc-text">228. 汇总区间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#123-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-III"><span class="toc-text">123. 买卖股票的最佳时机 III</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#189-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84"><span class="toc-text">189. 旋转数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#547-%E7%9C%81%E4%BB%BD%E6%95%B0%E9%87%8F"><span class="toc-text">547. 省份数量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#399-%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC"><span class="toc-text">399. 除法求值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#830-%E8%BE%83%E5%A4%A7%E5%88%86%E7%BB%84%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-text">830. 较大分组的位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#509-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0"><span class="toc-text">509. 斐波那契数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#86-%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8"><span class="toc-text">86. 分隔链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-text">239. 滑动窗口最大值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#605-%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98"><span class="toc-text">605. 种花问题</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/2023-11-26-Weber/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%88%E4%BA%8C%EF%BC%89/" title="前端开发的十万个为什么（二）"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/Exploring-Different-Types-of-Landforms-_1_.webp" onerror='this.onerror=null,this.src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="前端开发的十万个为什么（二）"></a><div class="content"><a class="title" href="/post/2023-11-26-Weber/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%88%E4%BA%8C%EF%BC%89/" title="前端开发的十万个为什么（二）">前端开发的十万个为什么（二）</a><time datetime="2023-11-26T21:05:10.000Z" title="发表于 2023-11-26 21:05:10">2023-11-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2023-11-22-Vue/%E9%9D%A2%E5%90%91%20Vue%20%E4%B8%AD%20VNode%20%E7%9A%84%E4%B8%80%E6%AC%A1%20Deep%20Dive/" title="面向 Vue 中 VNode 的一次 Deep Dive"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/202311221935387.png" onerror='this.onerror=null,this.src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="面向 Vue 中 VNode 的一次 Deep Dive"></a><div class="content"><a class="title" href="/post/2023-11-22-Vue/%E9%9D%A2%E5%90%91%20Vue%20%E4%B8%AD%20VNode%20%E7%9A%84%E4%B8%80%E6%AC%A1%20Deep%20Dive/" title="面向 Vue 中 VNode 的一次 Deep Dive">面向 Vue 中 VNode 的一次 Deep Dive</a><time datetime="2023-11-22T15:41:10.000Z" title="发表于 2023-11-22 15:41:10">2023-11-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2023-07-24-Weber/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%88%E4%B8%80%EF%BC%89/" title="前端开发的十万个为什么（一）"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/Exploring-Different-Types-of-Landforms-_1_.webp" onerror='this.onerror=null,this.src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="前端开发的十万个为什么（一）"></a><div class="content"><a class="title" href="/post/2023-07-24-Weber/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E7%9A%84%E5%8D%81%E4%B8%87%E4%B8%AA%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%88%E4%B8%80%EF%BC%89/" title="前端开发的十万个为什么（一）">前端开发的十万个为什么（一）</a><time datetime="2023-07-24T15:41:10.000Z" title="发表于 2023-07-24 15:41:10">2023-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2022-11-24-Paper/YuZu%20-%20Neural-Enhanced%20Volumetric%20Video%20Streaming/" title="NSDI22 - YuZu：Neural-Enhanced Volumetric Video Streaming"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/202302041759590.webp" onerror='this.onerror=null,this.src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="NSDI22 - YuZu：Neural-Enhanced Volumetric Video Streaming"></a><div class="content"><a class="title" href="/post/2022-11-24-Paper/YuZu%20-%20Neural-Enhanced%20Volumetric%20Video%20Streaming/" title="NSDI22 - YuZu：Neural-Enhanced Volumetric Video Streaming">NSDI22 - YuZu：Neural-Enhanced Volumetric Video Streaming</a><time datetime="2022-11-24T11:33:08.000Z" title="发表于 2022-11-24 11:33:08">2022-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/2022-11-10-Paper/Collaborative%20Service%20Placement%20for%20Edge%20Computing%20in%20Dense%20Small%20Cell%20Networks/" title="TMC21 - Collaborative Service Placement for Edge Computing in Dense Small Cell Networks"><img src="https://cdn.ethanloo.cn/img/20201202165029.gif" data-lazy-src="https://cdn.ethanloo.cn/img/202302041758847.webp" onerror='this.onerror=null,this.src="https://cdn.ethanloo.cn/img/20201202164458.png"' alt="TMC21 - Collaborative Service Placement for Edge Computing in Dense Small Cell Networks"></a><div class="content"><a class="title" href="/post/2022-11-10-Paper/Collaborative%20Service%20Placement%20for%20Edge%20Computing%20in%20Dense%20Small%20Cell%20Networks/" title="TMC21 - Collaborative Service Placement for Edge Computing in Dense Small Cell Networks">TMC21 - Collaborative Service Placement for Edge Computing in Dense Small Cell Networks</a><time datetime="2022-11-10T11:47:01.000Z" title="发表于 2022-11-10 11:47:01">2022-11-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By EthanLoo</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">苏ICP备2020057383号</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://ethanloo-blog-waline.vercel.app',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  if (typeof Waline === 'object') initWaline()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css').then(() => {
      getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js').then(initWaline)
    })
  }
}

if ('Waline' === 'Waline' || !true) {
  if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><div async class="app-refresh" id="app-refresh"><div class="app-refresh-wrap"><label>✨ 网站更新啦 👉</label> <a href="javascript:void(0)" rel="external nofollow noreferrer" onclick="location.reload()">点击刷新</a></div></div><script>function showNotification(){if(GLOBAL_CONFIG.Snackbar){var t="light"===document.documentElement.getAttribute("data-theme")?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e=GLOBAL_CONFIG.Snackbar.position;Snackbar.show({text:"已更新最新版本",backgroundColor:t,duration:5e5,pos:e,actionText:"點擊刷新",actionTextColor:"#fff",onActionClick:function(t){location.reload()}})}else{var o=`top: 0; background: ${"light"===document.documentElement.getAttribute("data-theme")?"#49b1f5":"#1f1f1f"};`;document.getElementById("app-refresh").style.cssText=o}}"serviceWorker"in navigator&&(navigator.serviceWorker.controller&&navigator.serviceWorker.addEventListener("controllerchange",function(){showNotification()}),window.addEventListener("load",function(){navigator.serviceWorker.register("/sw.js")}));</script><script async src="./js/background.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>